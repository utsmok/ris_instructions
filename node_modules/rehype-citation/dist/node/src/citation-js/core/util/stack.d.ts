export default TokenStack;
/**
 * :@citation-js/core.util.TokenStack~pattern
 */
export type module = string | RegExp | module;
/**
 * TokenStack pattern
 *
 * @typedef module:@citation-js/core.util.TokenStack~pattern
 * @type {String|RegExp|module:@citation-js/core.util.TokenStack~match|Array<module:@citation-js/core.util.TokenStack~pattern>}
 */
/**
 * TokenStack pattern sequence
 *
 * @typedef module:@citation-js/core.util.TokenStack~sequence
 * @type {String|Array<module:@citation-js/core.util.TokenStack~pattern>}
 */
/**
 * @callback module:@citation-js/core.util.TokenStack~match
 * @param {String} token - token
 * @param {Number} index - token index
 * @param {Array<String>} stack - token stack
 * @return {Boolean} match or not
 */
/**
 * @callback module:@citation-js/core.util.TokenStack~tokenMap
 * @param {String} token - token
 * @return {String} new token
 */
/**
 * @callback module:@citation-js/core.util.TokenStack~tokenFilter
 * @param {String} token - token
 * @return {Boolean} keep or not
 */
/**
 * Create a TokenStack for parsing strings with complex escape sequences.
 *
 * @memberof module:@citation-js/core.util
 *
 * @param {Array<String>} array - list of tokens
 */
declare class TokenStack {
    /**
     * Get string representation of pattern.
     *
     * @access protected
     *
     * @param {String|RegExp} pattern - pattern
     *
     * @return {String} string representation
     */
    static getPatternText(pattern: string | RegExp): string;
    /**
     * Get a single callback to match a token against one or several patterns.
     *
     * @access protected
     *
     * @param {module:@citation-js/core.util.TokenStack~pattern} pattern - pattern
     *
     * @return {module:@citation-js/core.util.TokenStack~match} Match callback
     */
    static getMatchCallback(pattern: any): any;
    constructor(array: any);
    stack: any;
    index: number;
    current: any;
    /**
     * Get a number representing the number of tokens that are left.
     *
     * @access protected
     *
     * @return {Number} tokens left
     */
    tokensLeft(): number;
    /**
     * Match current token against pattern.
     *
     * @access protected
     *
     * @param {module:@citation-js/core.util.TokenStack~pattern} pattern - pattern
     *
     * @return {Boolean} match
     */
    matches(pattern: any): boolean;
    /**
     * Match current token against pattern.
     *
     * @access protected
     *
     * @param {module:@citation-js/core.util.TokenStack~sequence} pattern - pattern
     *
     * @return {Boolean} match
     */
    matchesSequence(sequence: any): boolean;
    /**
     * Consume a single token if possible, and throw if not.
     *
     * @access protected
     *
     * @param {module:@citation-js/core.util.TokenStack~pattern} [pattern=/^[\s\S]$/] - pattern
     * @param {Object} options
     * @param {Boolean} [options.inverse=false] - invert pattern
     * @param {Boolean} [options.spaced=true] - allow leading and trailing whitespace
     *
     * @return {String} token
     * @throws {SyntaxError} Unexpected token at index: Expected pattern, got token
     */
    consumeToken(pattern?: any, { inverse, spaced }?: {
        inverse?: boolean;
        spaced?: boolean;
    }): string;
    /**
     * Consume a single token if possible, and throw if not.
     *
     * @access protected
     *
     * @param {module:@citation-js/core.util.TokenStack~pattern} [pattern=/^\s$/] - whitespace pattern
     * @param {Object} options
     * @param {Boolean} [options.optional=true] - allow having no whitespace
     *
     * @return {String} matched whitespace
     * @throws {SyntaxError} Unexpected token at index: Expected whitespace, got token
     */
    consumeWhitespace(pattern?: any, { optional }?: {
        optional?: boolean;
    }): string;
    /**
     * Consume n tokens. Throws if not enough tokens left
     *
     * @access protected
     *
     * @param {Number} length - number of tokens
     *
     * @return {String} consumed tokens
     * @throws {SyntaxError} Not enough tokens left
     */
    consumeN(length: number): string;
    /**
     * Consume a pattern spanning multiple tokens ('sequence').
     *
     * @access protected
     *
     * @param {module:@citation-js/core.util.TokenStack~sequence} sequence - sequence
     *
     * @return {String} consumed tokens
     * @throws {SyntaxError} Expected sequence, got tokens
     */
    consumeSequence(sequence: any): string;
    /**
     * Consumes all consecutive tokens matching pattern. Throws if number of matched tokens not within range min-max.
     *
     * @access protected
     *
     * @param {module:@citation-js/core.util.TokenStack~pattern} [pattern=/^[\s\S]$/] - pattern
     * @param {Object} options
     * @param {Boolean} [options.inverse=false] - invert pattern
     * @param {Number} [options.min=0] - mininum number of consumed tokens
     * @param {Number} [options.max=Infinity] - maximum number of matched tokens
     * @param {module:@citation-js/core.util.TokenStack~tokenMap} [options.tokenMap] - map tokens before returning
     * @param {module:@citation-js/core.util.TokenStack~tokenFilter} [options.tokenFilter] - filter tokens before returning
     *
     * @return {String} consumed tokens
     * @throws {SyntaxError} Not enough tokens
     * @throws {SyntaxError} Too many tokens
     */
    consume(pattern?: any, { min, max, inverse, tokenMap, tokenFilter }?: {
        inverse?: boolean;
        min?: number;
        max?: number;
        tokenMap?: any;
        tokenFilter?: any;
    }): string;
}
