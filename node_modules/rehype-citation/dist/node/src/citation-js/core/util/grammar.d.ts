/**
 * :@citation-js/core.util.Grammar~ruleName
 */
export type module = string;
/**
 * @typedef module:@citation-js/core.util.Grammar~ruleName
 * @type {String}
 */
/**
 * @callback module:@citation-js/core.util.Grammar~rule
 * @this module:@citation-js/core.util.Grammar
 */
/**
 * @memberof module:@citation-js/core.util
 *
 * @param {Object<module:@citation-js/core.util.Grammar~ruleName,module:@citation-js/core.util.Grammar~rule>} rules
 * @param {Object} state
 */
export class Grammar {
    constructor(rules: any, state: any);
    rules: any;
    defaultState: any;
    mainRule: string;
    log: any[];
    /**
     * @param iterator - lexer supporting formatError() and next()
     * @param [mainRule] - defaults to the first rule
     * @return result of the main rule
     */
    parse(iterator: any, mainRule?: any): any;
    lexer: any;
    token: any;
    state: any;
    /**
     * @return {Boolean} true if there are no more tokens
     */
    matchEndOfFile(): boolean;
    /**
     * @param {String} type - a token type
     * @return {Boolean} true if the current token has the given type
     */
    matchToken(type: string): boolean;
    /**
     * @param {String} [type] - a token type
     * @param {Boolean} [optional=false] - false if it should throw an error if the type does not match
     * @return {Object} token information
     * @throws {SyntaxError} detailed syntax error if the current token is not the expected type or if there are no tokens left
     */
    consumeToken(type?: string, optional?: boolean): any;
    /**
     * @param {String} rule - a rule name
     * @return whatever the rule function returns
     */
    consumeRule(rule: string): any;
}
