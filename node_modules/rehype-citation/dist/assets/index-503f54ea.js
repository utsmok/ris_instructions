var Dy = Object.defineProperty
var Ry = (e, t, r) =>
  t in e ? Dy(e, t, { enumerable: !0, configurable: !0, writable: !0, value: r }) : (e[t] = r)
var Bp = (e, t, r) => (Ry(e, typeof t != 'symbol' ? t + '' : t, r), r)
;(function () {
  const t = document.createElement('link').relList
  if (t && t.supports && t.supports('modulepreload')) return
  for (const n of document.querySelectorAll('link[rel="modulepreload"]')) i(n)
  new MutationObserver((n) => {
    for (const s of n)
      if (s.type === 'childList')
        for (const a of s.addedNodes) a.tagName === 'LINK' && a.rel === 'modulepreload' && i(a)
  }).observe(document, { childList: !0, subtree: !0 })
  function r(n) {
    const s = {}
    return (
      n.integrity && (s.integrity = n.integrity),
      n.referrerPolicy && (s.referrerPolicy = n.referrerPolicy),
      n.crossOrigin === 'use-credentials'
        ? (s.credentials = 'include')
        : n.crossOrigin === 'anonymous'
        ? (s.credentials = 'omit')
        : (s.credentials = 'same-origin'),
      s
    )
  }
  function i(n) {
    if (n.ep) return
    n.ep = !0
    const s = r(n)
    fetch(n.href, s)
  }
})()
var mn =
  typeof globalThis < 'u'
    ? globalThis
    : typeof window < 'u'
    ? window
    : typeof global < 'u'
    ? global
    : typeof self < 'u'
    ? self
    : {}
function ci(e) {
  return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, 'default') ? e.default : e
}
var wd = { exports: {} },
  qo = {},
  Nd = { exports: {} },
  Se = {}
/**
 * @license React
 * react.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ var Zs = Symbol.for('react.element'),
  Ly = Symbol.for('react.portal'),
  Py = Symbol.for('react.fragment'),
  By = Symbol.for('react.strict_mode'),
  Fy = Symbol.for('react.profiler'),
  My = Symbol.for('react.provider'),
  Uy = Symbol.for('react.context'),
  Hy = Symbol.for('react.forward_ref'),
  zy = Symbol.for('react.suspense'),
  jy = Symbol.for('react.memo'),
  qy = Symbol.for('react.lazy'),
  Fp = Symbol.iterator
function $y(e) {
  return e === null || typeof e != 'object'
    ? null
    : ((e = (Fp && e[Fp]) || e['@@iterator']), typeof e == 'function' ? e : null)
}
var Od = {
    isMounted: function () {
      return !1
    },
    enqueueForceUpdate: function () {},
    enqueueReplaceState: function () {},
    enqueueSetState: function () {},
  },
  Id = Object.assign,
  Dd = {}
function Pn(e, t, r) {
  ;(this.props = e), (this.context = t), (this.refs = Dd), (this.updater = r || Od)
}
Pn.prototype.isReactComponent = {}
Pn.prototype.setState = function (e, t) {
  if (typeof e != 'object' && typeof e != 'function' && e != null)
    throw Error(
      'setState(...): takes an object of state variables to update or a function which returns an object of state variables.'
    )
  this.updater.enqueueSetState(this, e, t, 'setState')
}
Pn.prototype.forceUpdate = function (e) {
  this.updater.enqueueForceUpdate(this, e, 'forceUpdate')
}
function Rd() {}
Rd.prototype = Pn.prototype
function sf(e, t, r) {
  ;(this.props = e), (this.context = t), (this.refs = Dd), (this.updater = r || Od)
}
var af = (sf.prototype = new Rd())
af.constructor = sf
Id(af, Pn.prototype)
af.isPureReactComponent = !0
var Mp = Array.isArray,
  Ld = Object.prototype.hasOwnProperty,
  of = { current: null },
  Pd = { key: !0, ref: !0, __self: !0, __source: !0 }
function Bd(e, t, r) {
  var i,
    n = {},
    s = null,
    a = null
  if (t != null)
    for (i in (t.ref !== void 0 && (a = t.ref), t.key !== void 0 && (s = '' + t.key), t))
      Ld.call(t, i) && !Pd.hasOwnProperty(i) && (n[i] = t[i])
  var o = arguments.length - 2
  if (o === 1) n.children = r
  else if (1 < o) {
    for (var u = Array(o), c = 0; c < o; c++) u[c] = arguments[c + 2]
    n.children = u
  }
  if (e && e.defaultProps) for (i in ((o = e.defaultProps), o)) n[i] === void 0 && (n[i] = o[i])
  return { $$typeof: Zs, type: e, key: s, ref: a, props: n, _owner: of.current }
}
function Vy(e, t) {
  return { $$typeof: Zs, type: e.type, key: t, ref: e.ref, props: e.props, _owner: e._owner }
}
function uf(e) {
  return typeof e == 'object' && e !== null && e.$$typeof === Zs
}
function Gy(e) {
  var t = { '=': '=0', ':': '=2' }
  return (
    '$' +
    e.replace(/[=:]/g, function (r) {
      return t[r]
    })
  )
}
var Up = /\/+/g
function Ou(e, t) {
  return typeof e == 'object' && e !== null && e.key != null ? Gy('' + e.key) : t.toString(36)
}
function qa(e, t, r, i, n) {
  var s = typeof e
  ;(s === 'undefined' || s === 'boolean') && (e = null)
  var a = !1
  if (e === null) a = !0
  else
    switch (s) {
      case 'string':
      case 'number':
        a = !0
        break
      case 'object':
        switch (e.$$typeof) {
          case Zs:
          case Ly:
            a = !0
        }
    }
  if (a)
    return (
      (a = e),
      (n = n(a)),
      (e = i === '' ? '.' + Ou(a, 0) : i),
      Mp(n)
        ? ((r = ''),
          e != null && (r = e.replace(Up, '$&/') + '/'),
          qa(n, t, r, '', function (c) {
            return c
          }))
        : n != null &&
          (uf(n) &&
            (n = Vy(
              n,
              r +
                (!n.key || (a && a.key === n.key) ? '' : ('' + n.key).replace(Up, '$&/') + '/') +
                e
            )),
          t.push(n)),
      1
    )
  if (((a = 0), (i = i === '' ? '.' : i + ':'), Mp(e)))
    for (var o = 0; o < e.length; o++) {
      s = e[o]
      var u = i + Ou(s, o)
      a += qa(s, t, r, u, n)
    }
  else if (((u = $y(e)), typeof u == 'function'))
    for (e = u.call(e), o = 0; !(s = e.next()).done; )
      (s = s.value), (u = i + Ou(s, o++)), (a += qa(s, t, r, u, n))
  else if (s === 'object')
    throw (
      ((t = String(e)),
      Error(
        'Objects are not valid as a React child (found: ' +
          (t === '[object Object]' ? 'object with keys {' + Object.keys(e).join(', ') + '}' : t) +
          '). If you meant to render a collection of children, use an array instead.'
      ))
    )
  return a
}
function ga(e, t, r) {
  if (e == null) return e
  var i = [],
    n = 0
  return (
    qa(e, i, '', '', function (s) {
      return t.call(r, s, n++)
    }),
    i
  )
}
function Xy(e) {
  if (e._status === -1) {
    var t = e._result
    ;(t = t()),
      t.then(
        function (r) {
          ;(e._status === 0 || e._status === -1) && ((e._status = 1), (e._result = r))
        },
        function (r) {
          ;(e._status === 0 || e._status === -1) && ((e._status = 2), (e._result = r))
        }
      ),
      e._status === -1 && ((e._status = 0), (e._result = t))
  }
  if (e._status === 1) return e._result.default
  throw e._result
}
var _t = { current: null },
  $a = { transition: null },
  Yy = { ReactCurrentDispatcher: _t, ReactCurrentBatchConfig: $a, ReactCurrentOwner: of }
Se.Children = {
  map: ga,
  forEach: function (e, t, r) {
    ga(
      e,
      function () {
        t.apply(this, arguments)
      },
      r
    )
  },
  count: function (e) {
    var t = 0
    return (
      ga(e, function () {
        t++
      }),
      t
    )
  },
  toArray: function (e) {
    return (
      ga(e, function (t) {
        return t
      }) || []
    )
  },
  only: function (e) {
    if (!uf(e)) throw Error('React.Children.only expected to receive a single React element child.')
    return e
  },
}
Se.Component = Pn
Se.Fragment = Py
Se.Profiler = Fy
Se.PureComponent = sf
Se.StrictMode = By
Se.Suspense = zy
Se.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = Yy
Se.cloneElement = function (e, t, r) {
  if (e == null)
    throw Error(
      'React.cloneElement(...): The argument must be a React element, but you passed ' + e + '.'
    )
  var i = Id({}, e.props),
    n = e.key,
    s = e.ref,
    a = e._owner
  if (t != null) {
    if (
      (t.ref !== void 0 && ((s = t.ref), (a = of.current)),
      t.key !== void 0 && (n = '' + t.key),
      e.type && e.type.defaultProps)
    )
      var o = e.type.defaultProps
    for (u in t)
      Ld.call(t, u) &&
        !Pd.hasOwnProperty(u) &&
        (i[u] = t[u] === void 0 && o !== void 0 ? o[u] : t[u])
  }
  var u = arguments.length - 2
  if (u === 1) i.children = r
  else if (1 < u) {
    o = Array(u)
    for (var c = 0; c < u; c++) o[c] = arguments[c + 2]
    i.children = o
  }
  return { $$typeof: Zs, type: e.type, key: n, ref: s, props: i, _owner: a }
}
Se.createContext = function (e) {
  return (
    (e = {
      $$typeof: Uy,
      _currentValue: e,
      _currentValue2: e,
      _threadCount: 0,
      Provider: null,
      Consumer: null,
      _defaultValue: null,
      _globalName: null,
    }),
    (e.Provider = { $$typeof: My, _context: e }),
    (e.Consumer = e)
  )
}
Se.createElement = Bd
Se.createFactory = function (e) {
  var t = Bd.bind(null, e)
  return (t.type = e), t
}
Se.createRef = function () {
  return { current: null }
}
Se.forwardRef = function (e) {
  return { $$typeof: Hy, render: e }
}
Se.isValidElement = uf
Se.lazy = function (e) {
  return { $$typeof: qy, _payload: { _status: -1, _result: e }, _init: Xy }
}
Se.memo = function (e, t) {
  return { $$typeof: jy, type: e, compare: t === void 0 ? null : t }
}
Se.startTransition = function (e) {
  var t = $a.transition
  $a.transition = {}
  try {
    e()
  } finally {
    $a.transition = t
  }
}
Se.unstable_act = function () {
  throw Error('act(...) is not supported in production builds of React.')
}
Se.useCallback = function (e, t) {
  return _t.current.useCallback(e, t)
}
Se.useContext = function (e) {
  return _t.current.useContext(e)
}
Se.useDebugValue = function () {}
Se.useDeferredValue = function (e) {
  return _t.current.useDeferredValue(e)
}
Se.useEffect = function (e, t) {
  return _t.current.useEffect(e, t)
}
Se.useId = function () {
  return _t.current.useId()
}
Se.useImperativeHandle = function (e, t, r) {
  return _t.current.useImperativeHandle(e, t, r)
}
Se.useInsertionEffect = function (e, t) {
  return _t.current.useInsertionEffect(e, t)
}
Se.useLayoutEffect = function (e, t) {
  return _t.current.useLayoutEffect(e, t)
}
Se.useMemo = function (e, t) {
  return _t.current.useMemo(e, t)
}
Se.useReducer = function (e, t, r) {
  return _t.current.useReducer(e, t, r)
}
Se.useRef = function (e) {
  return _t.current.useRef(e)
}
Se.useState = function (e) {
  return _t.current.useState(e)
}
Se.useSyncExternalStore = function (e, t, r) {
  return _t.current.useSyncExternalStore(e, t, r)
}
Se.useTransition = function () {
  return _t.current.useTransition()
}
Se.version = '18.2.0'
Nd.exports = Se
var Tn = Nd.exports
const Wy = ci(Tn)
/**
 * @license React
 * react-jsx-runtime.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ var Qy = Tn,
  Ky = Symbol.for('react.element'),
  Jy = Symbol.for('react.fragment'),
  Zy = Object.prototype.hasOwnProperty,
  e_ = Qy.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner,
  t_ = { key: !0, ref: !0, __self: !0, __source: !0 }
function Fd(e, t, r) {
  var i,
    n = {},
    s = null,
    a = null
  r !== void 0 && (s = '' + r),
    t.key !== void 0 && (s = '' + t.key),
    t.ref !== void 0 && (a = t.ref)
  for (i in t) Zy.call(t, i) && !t_.hasOwnProperty(i) && (n[i] = t[i])
  if (e && e.defaultProps) for (i in ((t = e.defaultProps), t)) n[i] === void 0 && (n[i] = t[i])
  return { $$typeof: Ky, type: e, key: s, ref: a, props: n, _owner: e_.current }
}
qo.Fragment = Jy
qo.jsx = Fd
qo.jsxs = Fd
wd.exports = qo
var $e = wd.exports,
  Md = { exports: {} },
  Ut = {},
  Ud = { exports: {} },
  Hd = {}
/**
 * @license React
 * scheduler.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ ;(function (e) {
  function t(P, Y) {
    var w = P.length
    P.push(Y)
    e: for (; 0 < w; ) {
      var q = (w - 1) >>> 1,
        X = P[q]
      if (0 < n(X, Y)) (P[q] = Y), (P[w] = X), (w = q)
      else break e
    }
  }
  function r(P) {
    return P.length === 0 ? null : P[0]
  }
  function i(P) {
    if (P.length === 0) return null
    var Y = P[0],
      w = P.pop()
    if (w !== Y) {
      P[0] = w
      e: for (var q = 0, X = P.length, I = X >>> 1; q < I; ) {
        var re = 2 * (q + 1) - 1,
          ie = P[re],
          Z = re + 1,
          oe = P[Z]
        if (0 > n(ie, w))
          Z < X && 0 > n(oe, ie)
            ? ((P[q] = oe), (P[Z] = w), (q = Z))
            : ((P[q] = ie), (P[re] = w), (q = re))
        else if (Z < X && 0 > n(oe, w)) (P[q] = oe), (P[Z] = w), (q = Z)
        else break e
      }
    }
    return Y
  }
  function n(P, Y) {
    var w = P.sortIndex - Y.sortIndex
    return w !== 0 ? w : P.id - Y.id
  }
  if (typeof performance == 'object' && typeof performance.now == 'function') {
    var s = performance
    e.unstable_now = function () {
      return s.now()
    }
  } else {
    var a = Date,
      o = a.now()
    e.unstable_now = function () {
      return a.now() - o
    }
  }
  var u = [],
    c = [],
    f = 1,
    h = null,
    p = 3,
    m = !1,
    v = !1,
    b = !1,
    S = typeof setTimeout == 'function' ? setTimeout : null,
    g = typeof clearTimeout == 'function' ? clearTimeout : null,
    _ = typeof setImmediate < 'u' ? setImmediate : null
  typeof navigator < 'u' &&
    navigator.scheduling !== void 0 &&
    navigator.scheduling.isInputPending !== void 0 &&
    navigator.scheduling.isInputPending.bind(navigator.scheduling)
  function y(P) {
    for (var Y = r(c); Y !== null; ) {
      if (Y.callback === null) i(c)
      else if (Y.startTime <= P) i(c), (Y.sortIndex = Y.expirationTime), t(u, Y)
      else break
      Y = r(c)
    }
  }
  function x(P) {
    if (((b = !1), y(P), !v))
      if (r(u) !== null) (v = !0), $(D)
      else {
        var Y = r(c)
        Y !== null && L(x, Y.startTime - P)
      }
  }
  function D(P, Y) {
    ;(v = !1), b && ((b = !1), g(T), (T = -1)), (m = !0)
    var w = p
    try {
      for (y(Y), h = r(u); h !== null && (!(h.expirationTime > Y) || (P && !N())); ) {
        var q = h.callback
        if (typeof q == 'function') {
          ;(h.callback = null), (p = h.priorityLevel)
          var X = q(h.expirationTime <= Y)
          ;(Y = e.unstable_now()),
            typeof X == 'function' ? (h.callback = X) : h === r(u) && i(u),
            y(Y)
        } else i(u)
        h = r(u)
      }
      if (h !== null) var I = !0
      else {
        var re = r(c)
        re !== null && L(x, re.startTime - Y), (I = !1)
      }
      return I
    } finally {
      ;(h = null), (p = w), (m = !1)
    }
  }
  var C = !1,
    H = null,
    T = -1,
    k = 5,
    O = -1
  function N() {
    return !(e.unstable_now() - O < k)
  }
  function M() {
    if (H !== null) {
      var P = e.unstable_now()
      O = P
      var Y = !0
      try {
        Y = H(!0, P)
      } finally {
        Y ? V() : ((C = !1), (H = null))
      }
    } else C = !1
  }
  var V
  if (typeof _ == 'function')
    V = function () {
      _(M)
    }
  else if (typeof MessageChannel < 'u') {
    var j = new MessageChannel(),
      R = j.port2
    ;(j.port1.onmessage = M),
      (V = function () {
        R.postMessage(null)
      })
  } else
    V = function () {
      S(M, 0)
    }
  function $(P) {
    ;(H = P), C || ((C = !0), V())
  }
  function L(P, Y) {
    T = S(function () {
      P(e.unstable_now())
    }, Y)
  }
  ;(e.unstable_IdlePriority = 5),
    (e.unstable_ImmediatePriority = 1),
    (e.unstable_LowPriority = 4),
    (e.unstable_NormalPriority = 3),
    (e.unstable_Profiling = null),
    (e.unstable_UserBlockingPriority = 2),
    (e.unstable_cancelCallback = function (P) {
      P.callback = null
    }),
    (e.unstable_continueExecution = function () {
      v || m || ((v = !0), $(D))
    }),
    (e.unstable_forceFrameRate = function (P) {
      0 > P || 125 < P
        ? console.error(
            'forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported'
          )
        : (k = 0 < P ? Math.floor(1e3 / P) : 5)
    }),
    (e.unstable_getCurrentPriorityLevel = function () {
      return p
    }),
    (e.unstable_getFirstCallbackNode = function () {
      return r(u)
    }),
    (e.unstable_next = function (P) {
      switch (p) {
        case 1:
        case 2:
        case 3:
          var Y = 3
          break
        default:
          Y = p
      }
      var w = p
      p = Y
      try {
        return P()
      } finally {
        p = w
      }
    }),
    (e.unstable_pauseExecution = function () {}),
    (e.unstable_requestPaint = function () {}),
    (e.unstable_runWithPriority = function (P, Y) {
      switch (P) {
        case 1:
        case 2:
        case 3:
        case 4:
        case 5:
          break
        default:
          P = 3
      }
      var w = p
      p = P
      try {
        return Y()
      } finally {
        p = w
      }
    }),
    (e.unstable_scheduleCallback = function (P, Y, w) {
      var q = e.unstable_now()
      switch (
        (typeof w == 'object' && w !== null
          ? ((w = w.delay), (w = typeof w == 'number' && 0 < w ? q + w : q))
          : (w = q),
        P)
      ) {
        case 1:
          var X = -1
          break
        case 2:
          X = 250
          break
        case 5:
          X = 1073741823
          break
        case 4:
          X = 1e4
          break
        default:
          X = 5e3
      }
      return (
        (X = w + X),
        (P = {
          id: f++,
          callback: Y,
          priorityLevel: P,
          startTime: w,
          expirationTime: X,
          sortIndex: -1,
        }),
        w > q
          ? ((P.sortIndex = w),
            t(c, P),
            r(u) === null && P === r(c) && (b ? (g(T), (T = -1)) : (b = !0), L(x, w - q)))
          : ((P.sortIndex = X), t(u, P), v || m || ((v = !0), $(D))),
        P
      )
    }),
    (e.unstable_shouldYield = N),
    (e.unstable_wrapCallback = function (P) {
      var Y = p
      return function () {
        var w = p
        p = Y
        try {
          return P.apply(this, arguments)
        } finally {
          p = w
        }
      }
    })
})(Hd)
Ud.exports = Hd
var r_ = Ud.exports
/**
 * @license React
 * react-dom.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ var zd = Tn,
  Mt = r_
function ue(e) {
  for (
    var t = 'https://reactjs.org/docs/error-decoder.html?invariant=' + e, r = 1;
    r < arguments.length;
    r++
  )
    t += '&args[]=' + encodeURIComponent(arguments[r])
  return (
    'Minified React error #' +
    e +
    '; visit ' +
    t +
    ' for the full message or use the non-minified dev environment for full errors and additional helpful warnings.'
  )
}
var jd = new Set(),
  As = {}
function Hi(e, t) {
  An(e, t), An(e + 'Capture', t)
}
function An(e, t) {
  for (As[e] = t, e = 0; e < t.length; e++) jd.add(t[e])
}
var Or = !(
    typeof window > 'u' ||
    typeof window.document > 'u' ||
    typeof window.document.createElement > 'u'
  ),
  Dl = Object.prototype.hasOwnProperty,
  i_ =
    /^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/,
  Hp = {},
  zp = {}
function n_(e) {
  return Dl.call(zp, e) ? !0 : Dl.call(Hp, e) ? !1 : i_.test(e) ? (zp[e] = !0) : ((Hp[e] = !0), !1)
}
function s_(e, t, r, i) {
  if (r !== null && r.type === 0) return !1
  switch (typeof t) {
    case 'function':
    case 'symbol':
      return !0
    case 'boolean':
      return i
        ? !1
        : r !== null
        ? !r.acceptsBooleans
        : ((e = e.toLowerCase().slice(0, 5)), e !== 'data-' && e !== 'aria-')
    default:
      return !1
  }
}
function a_(e, t, r, i) {
  if (t === null || typeof t > 'u' || s_(e, t, r, i)) return !0
  if (i) return !1
  if (r !== null)
    switch (r.type) {
      case 3:
        return !t
      case 4:
        return t === !1
      case 5:
        return isNaN(t)
      case 6:
        return isNaN(t) || 1 > t
    }
  return !1
}
function vt(e, t, r, i, n, s, a) {
  ;(this.acceptsBooleans = t === 2 || t === 3 || t === 4),
    (this.attributeName = i),
    (this.attributeNamespace = n),
    (this.mustUseProperty = r),
    (this.propertyName = e),
    (this.type = t),
    (this.sanitizeURL = s),
    (this.removeEmptyString = a)
}
var ut = {}
'children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style'
  .split(' ')
  .forEach(function (e) {
    ut[e] = new vt(e, 0, !1, e, null, !1, !1)
  })
;[
  ['acceptCharset', 'accept-charset'],
  ['className', 'class'],
  ['htmlFor', 'for'],
  ['httpEquiv', 'http-equiv'],
].forEach(function (e) {
  var t = e[0]
  ut[t] = new vt(t, 1, !1, e[1], null, !1, !1)
})
;['contentEditable', 'draggable', 'spellCheck', 'value'].forEach(function (e) {
  ut[e] = new vt(e, 2, !1, e.toLowerCase(), null, !1, !1)
})
;['autoReverse', 'externalResourcesRequired', 'focusable', 'preserveAlpha'].forEach(function (e) {
  ut[e] = new vt(e, 2, !1, e, null, !1, !1)
})
'allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture disableRemotePlayback formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope'
  .split(' ')
  .forEach(function (e) {
    ut[e] = new vt(e, 3, !1, e.toLowerCase(), null, !1, !1)
  })
;['checked', 'multiple', 'muted', 'selected'].forEach(function (e) {
  ut[e] = new vt(e, 3, !0, e, null, !1, !1)
})
;['capture', 'download'].forEach(function (e) {
  ut[e] = new vt(e, 4, !1, e, null, !1, !1)
})
;['cols', 'rows', 'size', 'span'].forEach(function (e) {
  ut[e] = new vt(e, 6, !1, e, null, !1, !1)
})
;['rowSpan', 'start'].forEach(function (e) {
  ut[e] = new vt(e, 5, !1, e.toLowerCase(), null, !1, !1)
})
var lf = /[\-:]([a-z])/g
function cf(e) {
  return e[1].toUpperCase()
}
'accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height'
  .split(' ')
  .forEach(function (e) {
    var t = e.replace(lf, cf)
    ut[t] = new vt(t, 1, !1, e, null, !1, !1)
  })
'xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type'
  .split(' ')
  .forEach(function (e) {
    var t = e.replace(lf, cf)
    ut[t] = new vt(t, 1, !1, e, 'http://www.w3.org/1999/xlink', !1, !1)
  })
;['xml:base', 'xml:lang', 'xml:space'].forEach(function (e) {
  var t = e.replace(lf, cf)
  ut[t] = new vt(t, 1, !1, e, 'http://www.w3.org/XML/1998/namespace', !1, !1)
})
;['tabIndex', 'crossOrigin'].forEach(function (e) {
  ut[e] = new vt(e, 1, !1, e.toLowerCase(), null, !1, !1)
})
ut.xlinkHref = new vt('xlinkHref', 1, !1, 'xlink:href', 'http://www.w3.org/1999/xlink', !0, !1)
;['src', 'href', 'action', 'formAction'].forEach(function (e) {
  ut[e] = new vt(e, 1, !1, e.toLowerCase(), null, !0, !0)
})
function ff(e, t, r, i) {
  var n = ut.hasOwnProperty(t) ? ut[t] : null
  ;(n !== null
    ? n.type !== 0
    : i || !(2 < t.length) || (t[0] !== 'o' && t[0] !== 'O') || (t[1] !== 'n' && t[1] !== 'N')) &&
    (a_(t, r, n, i) && (r = null),
    i || n === null
      ? n_(t) && (r === null ? e.removeAttribute(t) : e.setAttribute(t, '' + r))
      : n.mustUseProperty
      ? (e[n.propertyName] = r === null ? (n.type === 3 ? !1 : '') : r)
      : ((t = n.attributeName),
        (i = n.attributeNamespace),
        r === null
          ? e.removeAttribute(t)
          : ((n = n.type),
            (r = n === 3 || (n === 4 && r === !0) ? '' : '' + r),
            i ? e.setAttributeNS(i, t, r) : e.setAttribute(t, r))))
}
var Br = zd.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED,
  ba = Symbol.for('react.element'),
  Ji = Symbol.for('react.portal'),
  Zi = Symbol.for('react.fragment'),
  pf = Symbol.for('react.strict_mode'),
  Rl = Symbol.for('react.profiler'),
  qd = Symbol.for('react.provider'),
  $d = Symbol.for('react.context'),
  hf = Symbol.for('react.forward_ref'),
  Ll = Symbol.for('react.suspense'),
  Pl = Symbol.for('react.suspense_list'),
  mf = Symbol.for('react.memo'),
  $r = Symbol.for('react.lazy'),
  Vd = Symbol.for('react.offscreen'),
  jp = Symbol.iterator
function zn(e) {
  return e === null || typeof e != 'object'
    ? null
    : ((e = (jp && e[jp]) || e['@@iterator']), typeof e == 'function' ? e : null)
}
var Xe = Object.assign,
  Iu
function rs(e) {
  if (Iu === void 0)
    try {
      throw Error()
    } catch (r) {
      var t = r.stack.trim().match(/\n( *(at )?)/)
      Iu = (t && t[1]) || ''
    }
  return (
    `
` +
    Iu +
    e
  )
}
var Du = !1
function Ru(e, t) {
  if (!e || Du) return ''
  Du = !0
  var r = Error.prepareStackTrace
  Error.prepareStackTrace = void 0
  try {
    if (t)
      if (
        ((t = function () {
          throw Error()
        }),
        Object.defineProperty(t.prototype, 'props', {
          set: function () {
            throw Error()
          },
        }),
        typeof Reflect == 'object' && Reflect.construct)
      ) {
        try {
          Reflect.construct(t, [])
        } catch (c) {
          var i = c
        }
        Reflect.construct(e, [], t)
      } else {
        try {
          t.call()
        } catch (c) {
          i = c
        }
        e.call(t.prototype)
      }
    else {
      try {
        throw Error()
      } catch (c) {
        i = c
      }
      e()
    }
  } catch (c) {
    if (c && i && typeof c.stack == 'string') {
      for (
        var n = c.stack.split(`
`),
          s = i.stack.split(`
`),
          a = n.length - 1,
          o = s.length - 1;
        1 <= a && 0 <= o && n[a] !== s[o];

      )
        o--
      for (; 1 <= a && 0 <= o; a--, o--)
        if (n[a] !== s[o]) {
          if (a !== 1 || o !== 1)
            do
              if ((a--, o--, 0 > o || n[a] !== s[o])) {
                var u =
                  `
` + n[a].replace(' at new ', ' at ')
                return (
                  e.displayName &&
                    u.includes('<anonymous>') &&
                    (u = u.replace('<anonymous>', e.displayName)),
                  u
                )
              }
            while (1 <= a && 0 <= o)
          break
        }
    }
  } finally {
    ;(Du = !1), (Error.prepareStackTrace = r)
  }
  return (e = e ? e.displayName || e.name : '') ? rs(e) : ''
}
function o_(e) {
  switch (e.tag) {
    case 5:
      return rs(e.type)
    case 16:
      return rs('Lazy')
    case 13:
      return rs('Suspense')
    case 19:
      return rs('SuspenseList')
    case 0:
    case 2:
    case 15:
      return (e = Ru(e.type, !1)), e
    case 11:
      return (e = Ru(e.type.render, !1)), e
    case 1:
      return (e = Ru(e.type, !0)), e
    default:
      return ''
  }
}
function Bl(e) {
  if (e == null) return null
  if (typeof e == 'function') return e.displayName || e.name || null
  if (typeof e == 'string') return e
  switch (e) {
    case Zi:
      return 'Fragment'
    case Ji:
      return 'Portal'
    case Rl:
      return 'Profiler'
    case pf:
      return 'StrictMode'
    case Ll:
      return 'Suspense'
    case Pl:
      return 'SuspenseList'
  }
  if (typeof e == 'object')
    switch (e.$$typeof) {
      case $d:
        return (e.displayName || 'Context') + '.Consumer'
      case qd:
        return (e._context.displayName || 'Context') + '.Provider'
      case hf:
        var t = e.render
        return (
          (e = e.displayName),
          e ||
            ((e = t.displayName || t.name || ''),
            (e = e !== '' ? 'ForwardRef(' + e + ')' : 'ForwardRef')),
          e
        )
      case mf:
        return (t = e.displayName || null), t !== null ? t : Bl(e.type) || 'Memo'
      case $r:
        ;(t = e._payload), (e = e._init)
        try {
          return Bl(e(t))
        } catch {}
    }
  return null
}
function u_(e) {
  var t = e.type
  switch (e.tag) {
    case 24:
      return 'Cache'
    case 9:
      return (t.displayName || 'Context') + '.Consumer'
    case 10:
      return (t._context.displayName || 'Context') + '.Provider'
    case 18:
      return 'DehydratedFragment'
    case 11:
      return (
        (e = t.render),
        (e = e.displayName || e.name || ''),
        t.displayName || (e !== '' ? 'ForwardRef(' + e + ')' : 'ForwardRef')
      )
    case 7:
      return 'Fragment'
    case 5:
      return t
    case 4:
      return 'Portal'
    case 3:
      return 'Root'
    case 6:
      return 'Text'
    case 16:
      return Bl(t)
    case 8:
      return t === pf ? 'StrictMode' : 'Mode'
    case 22:
      return 'Offscreen'
    case 12:
      return 'Profiler'
    case 21:
      return 'Scope'
    case 13:
      return 'Suspense'
    case 19:
      return 'SuspenseList'
    case 25:
      return 'TracingMarker'
    case 1:
    case 0:
    case 17:
    case 2:
    case 14:
    case 15:
      if (typeof t == 'function') return t.displayName || t.name || null
      if (typeof t == 'string') return t
  }
  return null
}
function oi(e) {
  switch (typeof e) {
    case 'boolean':
    case 'number':
    case 'string':
    case 'undefined':
      return e
    case 'object':
      return e
    default:
      return ''
  }
}
function Gd(e) {
  var t = e.type
  return (e = e.nodeName) && e.toLowerCase() === 'input' && (t === 'checkbox' || t === 'radio')
}
function l_(e) {
  var t = Gd(e) ? 'checked' : 'value',
    r = Object.getOwnPropertyDescriptor(e.constructor.prototype, t),
    i = '' + e[t]
  if (
    !e.hasOwnProperty(t) &&
    typeof r < 'u' &&
    typeof r.get == 'function' &&
    typeof r.set == 'function'
  ) {
    var n = r.get,
      s = r.set
    return (
      Object.defineProperty(e, t, {
        configurable: !0,
        get: function () {
          return n.call(this)
        },
        set: function (a) {
          ;(i = '' + a), s.call(this, a)
        },
      }),
      Object.defineProperty(e, t, { enumerable: r.enumerable }),
      {
        getValue: function () {
          return i
        },
        setValue: function (a) {
          i = '' + a
        },
        stopTracking: function () {
          ;(e._valueTracker = null), delete e[t]
        },
      }
    )
  }
}
function ya(e) {
  e._valueTracker || (e._valueTracker = l_(e))
}
function Xd(e) {
  if (!e) return !1
  var t = e._valueTracker
  if (!t) return !0
  var r = t.getValue(),
    i = ''
  return (
    e && (i = Gd(e) ? (e.checked ? 'true' : 'false') : e.value),
    (e = i),
    e !== r ? (t.setValue(e), !0) : !1
  )
}
function uo(e) {
  if (((e = e || (typeof document < 'u' ? document : void 0)), typeof e > 'u')) return null
  try {
    return e.activeElement || e.body
  } catch {
    return e.body
  }
}
function Fl(e, t) {
  var r = t.checked
  return Xe({}, t, {
    defaultChecked: void 0,
    defaultValue: void 0,
    value: void 0,
    checked: r ?? e._wrapperState.initialChecked,
  })
}
function qp(e, t) {
  var r = t.defaultValue == null ? '' : t.defaultValue,
    i = t.checked != null ? t.checked : t.defaultChecked
  ;(r = oi(t.value != null ? t.value : r)),
    (e._wrapperState = {
      initialChecked: i,
      initialValue: r,
      controlled: t.type === 'checkbox' || t.type === 'radio' ? t.checked != null : t.value != null,
    })
}
function Yd(e, t) {
  ;(t = t.checked), t != null && ff(e, 'checked', t, !1)
}
function Ml(e, t) {
  Yd(e, t)
  var r = oi(t.value),
    i = t.type
  if (r != null)
    i === 'number'
      ? ((r === 0 && e.value === '') || e.value != r) && (e.value = '' + r)
      : e.value !== '' + r && (e.value = '' + r)
  else if (i === 'submit' || i === 'reset') {
    e.removeAttribute('value')
    return
  }
  t.hasOwnProperty('value')
    ? Ul(e, t.type, r)
    : t.hasOwnProperty('defaultValue') && Ul(e, t.type, oi(t.defaultValue)),
    t.checked == null && t.defaultChecked != null && (e.defaultChecked = !!t.defaultChecked)
}
function $p(e, t, r) {
  if (t.hasOwnProperty('value') || t.hasOwnProperty('defaultValue')) {
    var i = t.type
    if (!((i !== 'submit' && i !== 'reset') || (t.value !== void 0 && t.value !== null))) return
    ;(t = '' + e._wrapperState.initialValue),
      r || t === e.value || (e.value = t),
      (e.defaultValue = t)
  }
  ;(r = e.name),
    r !== '' && (e.name = ''),
    (e.defaultChecked = !!e._wrapperState.initialChecked),
    r !== '' && (e.name = r)
}
function Ul(e, t, r) {
  ;(t !== 'number' || uo(e.ownerDocument) !== e) &&
    (r == null
      ? (e.defaultValue = '' + e._wrapperState.initialValue)
      : e.defaultValue !== '' + r && (e.defaultValue = '' + r))
}
var is = Array.isArray
function dn(e, t, r, i) {
  if (((e = e.options), t)) {
    t = {}
    for (var n = 0; n < r.length; n++) t['$' + r[n]] = !0
    for (r = 0; r < e.length; r++)
      (n = t.hasOwnProperty('$' + e[r].value)),
        e[r].selected !== n && (e[r].selected = n),
        n && i && (e[r].defaultSelected = !0)
  } else {
    for (r = '' + oi(r), t = null, n = 0; n < e.length; n++) {
      if (e[n].value === r) {
        ;(e[n].selected = !0), i && (e[n].defaultSelected = !0)
        return
      }
      t !== null || e[n].disabled || (t = e[n])
    }
    t !== null && (t.selected = !0)
  }
}
function Hl(e, t) {
  if (t.dangerouslySetInnerHTML != null) throw Error(ue(91))
  return Xe({}, t, {
    value: void 0,
    defaultValue: void 0,
    children: '' + e._wrapperState.initialValue,
  })
}
function Vp(e, t) {
  var r = t.value
  if (r == null) {
    if (((r = t.children), (t = t.defaultValue), r != null)) {
      if (t != null) throw Error(ue(92))
      if (is(r)) {
        if (1 < r.length) throw Error(ue(93))
        r = r[0]
      }
      t = r
    }
    t == null && (t = ''), (r = t)
  }
  e._wrapperState = { initialValue: oi(r) }
}
function Wd(e, t) {
  var r = oi(t.value),
    i = oi(t.defaultValue)
  r != null &&
    ((r = '' + r),
    r !== e.value && (e.value = r),
    t.defaultValue == null && e.defaultValue !== r && (e.defaultValue = r)),
    i != null && (e.defaultValue = '' + i)
}
function Gp(e) {
  var t = e.textContent
  t === e._wrapperState.initialValue && t !== '' && t !== null && (e.value = t)
}
function Qd(e) {
  switch (e) {
    case 'svg':
      return 'http://www.w3.org/2000/svg'
    case 'math':
      return 'http://www.w3.org/1998/Math/MathML'
    default:
      return 'http://www.w3.org/1999/xhtml'
  }
}
function zl(e, t) {
  return e == null || e === 'http://www.w3.org/1999/xhtml'
    ? Qd(t)
    : e === 'http://www.w3.org/2000/svg' && t === 'foreignObject'
    ? 'http://www.w3.org/1999/xhtml'
    : e
}
var _a,
  Kd = (function (e) {
    return typeof MSApp < 'u' && MSApp.execUnsafeLocalFunction
      ? function (t, r, i, n) {
          MSApp.execUnsafeLocalFunction(function () {
            return e(t, r, i, n)
          })
        }
      : e
  })(function (e, t) {
    if (e.namespaceURI !== 'http://www.w3.org/2000/svg' || 'innerHTML' in e) e.innerHTML = t
    else {
      for (
        _a = _a || document.createElement('div'),
          _a.innerHTML = '<svg>' + t.valueOf().toString() + '</svg>',
          t = _a.firstChild;
        e.firstChild;

      )
        e.removeChild(e.firstChild)
      for (; t.firstChild; ) e.appendChild(t.firstChild)
    }
  })
function Ss(e, t) {
  if (t) {
    var r = e.firstChild
    if (r && r === e.lastChild && r.nodeType === 3) {
      r.nodeValue = t
      return
    }
  }
  e.textContent = t
}
var os = {
    animationIterationCount: !0,
    aspectRatio: !0,
    borderImageOutset: !0,
    borderImageSlice: !0,
    borderImageWidth: !0,
    boxFlex: !0,
    boxFlexGroup: !0,
    boxOrdinalGroup: !0,
    columnCount: !0,
    columns: !0,
    flex: !0,
    flexGrow: !0,
    flexPositive: !0,
    flexShrink: !0,
    flexNegative: !0,
    flexOrder: !0,
    gridArea: !0,
    gridRow: !0,
    gridRowEnd: !0,
    gridRowSpan: !0,
    gridRowStart: !0,
    gridColumn: !0,
    gridColumnEnd: !0,
    gridColumnSpan: !0,
    gridColumnStart: !0,
    fontWeight: !0,
    lineClamp: !0,
    lineHeight: !0,
    opacity: !0,
    order: !0,
    orphans: !0,
    tabSize: !0,
    widows: !0,
    zIndex: !0,
    zoom: !0,
    fillOpacity: !0,
    floodOpacity: !0,
    stopOpacity: !0,
    strokeDasharray: !0,
    strokeDashoffset: !0,
    strokeMiterlimit: !0,
    strokeOpacity: !0,
    strokeWidth: !0,
  },
  c_ = ['Webkit', 'ms', 'Moz', 'O']
Object.keys(os).forEach(function (e) {
  c_.forEach(function (t) {
    ;(t = t + e.charAt(0).toUpperCase() + e.substring(1)), (os[t] = os[e])
  })
})
function Jd(e, t, r) {
  return t == null || typeof t == 'boolean' || t === ''
    ? ''
    : r || typeof t != 'number' || t === 0 || (os.hasOwnProperty(e) && os[e])
    ? ('' + t).trim()
    : t + 'px'
}
function Zd(e, t) {
  e = e.style
  for (var r in t)
    if (t.hasOwnProperty(r)) {
      var i = r.indexOf('--') === 0,
        n = Jd(r, t[r], i)
      r === 'float' && (r = 'cssFloat'), i ? e.setProperty(r, n) : (e[r] = n)
    }
}
var f_ = Xe(
  { menuitem: !0 },
  {
    area: !0,
    base: !0,
    br: !0,
    col: !0,
    embed: !0,
    hr: !0,
    img: !0,
    input: !0,
    keygen: !0,
    link: !0,
    meta: !0,
    param: !0,
    source: !0,
    track: !0,
    wbr: !0,
  }
)
function jl(e, t) {
  if (t) {
    if (f_[e] && (t.children != null || t.dangerouslySetInnerHTML != null)) throw Error(ue(137, e))
    if (t.dangerouslySetInnerHTML != null) {
      if (t.children != null) throw Error(ue(60))
      if (typeof t.dangerouslySetInnerHTML != 'object' || !('__html' in t.dangerouslySetInnerHTML))
        throw Error(ue(61))
    }
    if (t.style != null && typeof t.style != 'object') throw Error(ue(62))
  }
}
function ql(e, t) {
  if (e.indexOf('-') === -1) return typeof t.is == 'string'
  switch (e) {
    case 'annotation-xml':
    case 'color-profile':
    case 'font-face':
    case 'font-face-src':
    case 'font-face-uri':
    case 'font-face-format':
    case 'font-face-name':
    case 'missing-glyph':
      return !1
    default:
      return !0
  }
}
var $l = null
function df(e) {
  return (
    (e = e.target || e.srcElement || window),
    e.correspondingUseElement && (e = e.correspondingUseElement),
    e.nodeType === 3 ? e.parentNode : e
  )
}
var Vl = null,
  gn = null,
  bn = null
function Xp(e) {
  if ((e = ra(e))) {
    if (typeof Vl != 'function') throw Error(ue(280))
    var t = e.stateNode
    t && ((t = Yo(t)), Vl(e.stateNode, e.type, t))
  }
}
function e0(e) {
  gn ? (bn ? bn.push(e) : (bn = [e])) : (gn = e)
}
function t0() {
  if (gn) {
    var e = gn,
      t = bn
    if (((bn = gn = null), Xp(e), t)) for (e = 0; e < t.length; e++) Xp(t[e])
  }
}
function r0(e, t) {
  return e(t)
}
function i0() {}
var Lu = !1
function n0(e, t, r) {
  if (Lu) return e(t, r)
  Lu = !0
  try {
    return r0(e, t, r)
  } finally {
    ;(Lu = !1), (gn !== null || bn !== null) && (i0(), t0())
  }
}
function Cs(e, t) {
  var r = e.stateNode
  if (r === null) return null
  var i = Yo(r)
  if (i === null) return null
  r = i[t]
  e: switch (t) {
    case 'onClick':
    case 'onClickCapture':
    case 'onDoubleClick':
    case 'onDoubleClickCapture':
    case 'onMouseDown':
    case 'onMouseDownCapture':
    case 'onMouseMove':
    case 'onMouseMoveCapture':
    case 'onMouseUp':
    case 'onMouseUpCapture':
    case 'onMouseEnter':
      ;(i = !i.disabled) ||
        ((e = e.type),
        (i = !(e === 'button' || e === 'input' || e === 'select' || e === 'textarea'))),
        (e = !i)
      break e
    default:
      e = !1
  }
  if (e) return null
  if (r && typeof r != 'function') throw Error(ue(231, t, typeof r))
  return r
}
var Gl = !1
if (Or)
  try {
    var jn = {}
    Object.defineProperty(jn, 'passive', {
      get: function () {
        Gl = !0
      },
    }),
      window.addEventListener('test', jn, jn),
      window.removeEventListener('test', jn, jn)
  } catch {
    Gl = !1
  }
function p_(e, t, r, i, n, s, a, o, u) {
  var c = Array.prototype.slice.call(arguments, 3)
  try {
    t.apply(r, c)
  } catch (f) {
    this.onError(f)
  }
}
var us = !1,
  lo = null,
  co = !1,
  Xl = null,
  h_ = {
    onError: function (e) {
      ;(us = !0), (lo = e)
    },
  }
function m_(e, t, r, i, n, s, a, o, u) {
  ;(us = !1), (lo = null), p_.apply(h_, arguments)
}
function d_(e, t, r, i, n, s, a, o, u) {
  if ((m_.apply(this, arguments), us)) {
    if (us) {
      var c = lo
      ;(us = !1), (lo = null)
    } else throw Error(ue(198))
    co || ((co = !0), (Xl = c))
  }
}
function zi(e) {
  var t = e,
    r = e
  if (e.alternate) for (; t.return; ) t = t.return
  else {
    e = t
    do (t = e), t.flags & 4098 && (r = t.return), (e = t.return)
    while (e)
  }
  return t.tag === 3 ? r : null
}
function s0(e) {
  if (e.tag === 13) {
    var t = e.memoizedState
    if ((t === null && ((e = e.alternate), e !== null && (t = e.memoizedState)), t !== null))
      return t.dehydrated
  }
  return null
}
function Yp(e) {
  if (zi(e) !== e) throw Error(ue(188))
}
function g_(e) {
  var t = e.alternate
  if (!t) {
    if (((t = zi(e)), t === null)) throw Error(ue(188))
    return t !== e ? null : e
  }
  for (var r = e, i = t; ; ) {
    var n = r.return
    if (n === null) break
    var s = n.alternate
    if (s === null) {
      if (((i = n.return), i !== null)) {
        r = i
        continue
      }
      break
    }
    if (n.child === s.child) {
      for (s = n.child; s; ) {
        if (s === r) return Yp(n), e
        if (s === i) return Yp(n), t
        s = s.sibling
      }
      throw Error(ue(188))
    }
    if (r.return !== i.return) (r = n), (i = s)
    else {
      for (var a = !1, o = n.child; o; ) {
        if (o === r) {
          ;(a = !0), (r = n), (i = s)
          break
        }
        if (o === i) {
          ;(a = !0), (i = n), (r = s)
          break
        }
        o = o.sibling
      }
      if (!a) {
        for (o = s.child; o; ) {
          if (o === r) {
            ;(a = !0), (r = s), (i = n)
            break
          }
          if (o === i) {
            ;(a = !0), (i = s), (r = n)
            break
          }
          o = o.sibling
        }
        if (!a) throw Error(ue(189))
      }
    }
    if (r.alternate !== i) throw Error(ue(190))
  }
  if (r.tag !== 3) throw Error(ue(188))
  return r.stateNode.current === r ? e : t
}
function a0(e) {
  return (e = g_(e)), e !== null ? o0(e) : null
}
function o0(e) {
  if (e.tag === 5 || e.tag === 6) return e
  for (e = e.child; e !== null; ) {
    var t = o0(e)
    if (t !== null) return t
    e = e.sibling
  }
  return null
}
var u0 = Mt.unstable_scheduleCallback,
  Wp = Mt.unstable_cancelCallback,
  b_ = Mt.unstable_shouldYield,
  y_ = Mt.unstable_requestPaint,
  We = Mt.unstable_now,
  __ = Mt.unstable_getCurrentPriorityLevel,
  gf = Mt.unstable_ImmediatePriority,
  l0 = Mt.unstable_UserBlockingPriority,
  fo = Mt.unstable_NormalPriority,
  v_ = Mt.unstable_LowPriority,
  c0 = Mt.unstable_IdlePriority,
  $o = null,
  br = null
function E_(e) {
  if (br && typeof br.onCommitFiberRoot == 'function')
    try {
      br.onCommitFiberRoot($o, e, void 0, (e.current.flags & 128) === 128)
    } catch {}
}
var ir = Math.clz32 ? Math.clz32 : A_,
  x_ = Math.log,
  T_ = Math.LN2
function A_(e) {
  return (e >>>= 0), e === 0 ? 32 : (31 - ((x_(e) / T_) | 0)) | 0
}
var va = 64,
  Ea = 4194304
function ns(e) {
  switch (e & -e) {
    case 1:
      return 1
    case 2:
      return 2
    case 4:
      return 4
    case 8:
      return 8
    case 16:
      return 16
    case 32:
      return 32
    case 64:
    case 128:
    case 256:
    case 512:
    case 1024:
    case 2048:
    case 4096:
    case 8192:
    case 16384:
    case 32768:
    case 65536:
    case 131072:
    case 262144:
    case 524288:
    case 1048576:
    case 2097152:
      return e & 4194240
    case 4194304:
    case 8388608:
    case 16777216:
    case 33554432:
    case 67108864:
      return e & 130023424
    case 134217728:
      return 134217728
    case 268435456:
      return 268435456
    case 536870912:
      return 536870912
    case 1073741824:
      return 1073741824
    default:
      return e
  }
}
function po(e, t) {
  var r = e.pendingLanes
  if (r === 0) return 0
  var i = 0,
    n = e.suspendedLanes,
    s = e.pingedLanes,
    a = r & 268435455
  if (a !== 0) {
    var o = a & ~n
    o !== 0 ? (i = ns(o)) : ((s &= a), s !== 0 && (i = ns(s)))
  } else (a = r & ~n), a !== 0 ? (i = ns(a)) : s !== 0 && (i = ns(s))
  if (i === 0) return 0
  if (
    t !== 0 &&
    t !== i &&
    !(t & n) &&
    ((n = i & -i), (s = t & -t), n >= s || (n === 16 && (s & 4194240) !== 0))
  )
    return t
  if ((i & 4 && (i |= r & 16), (t = e.entangledLanes), t !== 0))
    for (e = e.entanglements, t &= i; 0 < t; )
      (r = 31 - ir(t)), (n = 1 << r), (i |= e[r]), (t &= ~n)
  return i
}
function S_(e, t) {
  switch (e) {
    case 1:
    case 2:
    case 4:
      return t + 250
    case 8:
    case 16:
    case 32:
    case 64:
    case 128:
    case 256:
    case 512:
    case 1024:
    case 2048:
    case 4096:
    case 8192:
    case 16384:
    case 32768:
    case 65536:
    case 131072:
    case 262144:
    case 524288:
    case 1048576:
    case 2097152:
      return t + 5e3
    case 4194304:
    case 8388608:
    case 16777216:
    case 33554432:
    case 67108864:
      return -1
    case 134217728:
    case 268435456:
    case 536870912:
    case 1073741824:
      return -1
    default:
      return -1
  }
}
function C_(e, t) {
  for (
    var r = e.suspendedLanes, i = e.pingedLanes, n = e.expirationTimes, s = e.pendingLanes;
    0 < s;

  ) {
    var a = 31 - ir(s),
      o = 1 << a,
      u = n[a]
    u === -1 ? (!(o & r) || o & i) && (n[a] = S_(o, t)) : u <= t && (e.expiredLanes |= o), (s &= ~o)
  }
}
function Yl(e) {
  return (e = e.pendingLanes & -1073741825), e !== 0 ? e : e & 1073741824 ? 1073741824 : 0
}
function f0() {
  var e = va
  return (va <<= 1), !(va & 4194240) && (va = 64), e
}
function Pu(e) {
  for (var t = [], r = 0; 31 > r; r++) t.push(e)
  return t
}
function ea(e, t, r) {
  ;(e.pendingLanes |= t),
    t !== 536870912 && ((e.suspendedLanes = 0), (e.pingedLanes = 0)),
    (e = e.eventTimes),
    (t = 31 - ir(t)),
    (e[t] = r)
}
function k_(e, t) {
  var r = e.pendingLanes & ~t
  ;(e.pendingLanes = t),
    (e.suspendedLanes = 0),
    (e.pingedLanes = 0),
    (e.expiredLanes &= t),
    (e.mutableReadLanes &= t),
    (e.entangledLanes &= t),
    (t = e.entanglements)
  var i = e.eventTimes
  for (e = e.expirationTimes; 0 < r; ) {
    var n = 31 - ir(r),
      s = 1 << n
    ;(t[n] = 0), (i[n] = -1), (e[n] = -1), (r &= ~s)
  }
}
function bf(e, t) {
  var r = (e.entangledLanes |= t)
  for (e = e.entanglements; r; ) {
    var i = 31 - ir(r),
      n = 1 << i
    ;(n & t) | (e[i] & t) && (e[i] |= t), (r &= ~n)
  }
}
var Re = 0
function p0(e) {
  return (e &= -e), 1 < e ? (4 < e ? (e & 268435455 ? 16 : 536870912) : 4) : 1
}
var h0,
  yf,
  m0,
  d0,
  g0,
  Wl = !1,
  xa = [],
  Kr = null,
  Jr = null,
  Zr = null,
  ks = new Map(),
  ws = new Map(),
  Gr = [],
  w_ =
    'mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset submit'.split(
      ' '
    )
function Qp(e, t) {
  switch (e) {
    case 'focusin':
    case 'focusout':
      Kr = null
      break
    case 'dragenter':
    case 'dragleave':
      Jr = null
      break
    case 'mouseover':
    case 'mouseout':
      Zr = null
      break
    case 'pointerover':
    case 'pointerout':
      ks.delete(t.pointerId)
      break
    case 'gotpointercapture':
    case 'lostpointercapture':
      ws.delete(t.pointerId)
  }
}
function qn(e, t, r, i, n, s) {
  return e === null || e.nativeEvent !== s
    ? ((e = {
        blockedOn: t,
        domEventName: r,
        eventSystemFlags: i,
        nativeEvent: s,
        targetContainers: [n],
      }),
      t !== null && ((t = ra(t)), t !== null && yf(t)),
      e)
    : ((e.eventSystemFlags |= i),
      (t = e.targetContainers),
      n !== null && t.indexOf(n) === -1 && t.push(n),
      e)
}
function N_(e, t, r, i, n) {
  switch (t) {
    case 'focusin':
      return (Kr = qn(Kr, e, t, r, i, n)), !0
    case 'dragenter':
      return (Jr = qn(Jr, e, t, r, i, n)), !0
    case 'mouseover':
      return (Zr = qn(Zr, e, t, r, i, n)), !0
    case 'pointerover':
      var s = n.pointerId
      return ks.set(s, qn(ks.get(s) || null, e, t, r, i, n)), !0
    case 'gotpointercapture':
      return (s = n.pointerId), ws.set(s, qn(ws.get(s) || null, e, t, r, i, n)), !0
  }
  return !1
}
function b0(e) {
  var t = Ei(e.target)
  if (t !== null) {
    var r = zi(t)
    if (r !== null) {
      if (((t = r.tag), t === 13)) {
        if (((t = s0(r)), t !== null)) {
          ;(e.blockedOn = t),
            g0(e.priority, function () {
              m0(r)
            })
          return
        }
      } else if (t === 3 && r.stateNode.current.memoizedState.isDehydrated) {
        e.blockedOn = r.tag === 3 ? r.stateNode.containerInfo : null
        return
      }
    }
  }
  e.blockedOn = null
}
function Va(e) {
  if (e.blockedOn !== null) return !1
  for (var t = e.targetContainers; 0 < t.length; ) {
    var r = Ql(e.domEventName, e.eventSystemFlags, t[0], e.nativeEvent)
    if (r === null) {
      r = e.nativeEvent
      var i = new r.constructor(r.type, r)
      ;($l = i), r.target.dispatchEvent(i), ($l = null)
    } else return (t = ra(r)), t !== null && yf(t), (e.blockedOn = r), !1
    t.shift()
  }
  return !0
}
function Kp(e, t, r) {
  Va(e) && r.delete(t)
}
function O_() {
  ;(Wl = !1),
    Kr !== null && Va(Kr) && (Kr = null),
    Jr !== null && Va(Jr) && (Jr = null),
    Zr !== null && Va(Zr) && (Zr = null),
    ks.forEach(Kp),
    ws.forEach(Kp)
}
function $n(e, t) {
  e.blockedOn === t &&
    ((e.blockedOn = null),
    Wl || ((Wl = !0), Mt.unstable_scheduleCallback(Mt.unstable_NormalPriority, O_)))
}
function Ns(e) {
  function t(n) {
    return $n(n, e)
  }
  if (0 < xa.length) {
    $n(xa[0], e)
    for (var r = 1; r < xa.length; r++) {
      var i = xa[r]
      i.blockedOn === e && (i.blockedOn = null)
    }
  }
  for (
    Kr !== null && $n(Kr, e),
      Jr !== null && $n(Jr, e),
      Zr !== null && $n(Zr, e),
      ks.forEach(t),
      ws.forEach(t),
      r = 0;
    r < Gr.length;
    r++
  )
    (i = Gr[r]), i.blockedOn === e && (i.blockedOn = null)
  for (; 0 < Gr.length && ((r = Gr[0]), r.blockedOn === null); )
    b0(r), r.blockedOn === null && Gr.shift()
}
var yn = Br.ReactCurrentBatchConfig,
  ho = !0
function I_(e, t, r, i) {
  var n = Re,
    s = yn.transition
  yn.transition = null
  try {
    ;(Re = 1), _f(e, t, r, i)
  } finally {
    ;(Re = n), (yn.transition = s)
  }
}
function D_(e, t, r, i) {
  var n = Re,
    s = yn.transition
  yn.transition = null
  try {
    ;(Re = 4), _f(e, t, r, i)
  } finally {
    ;(Re = n), (yn.transition = s)
  }
}
function _f(e, t, r, i) {
  if (ho) {
    var n = Ql(e, t, r, i)
    if (n === null) Vu(e, t, i, mo, r), Qp(e, i)
    else if (N_(n, e, t, r, i)) i.stopPropagation()
    else if ((Qp(e, i), t & 4 && -1 < w_.indexOf(e))) {
      for (; n !== null; ) {
        var s = ra(n)
        if ((s !== null && h0(s), (s = Ql(e, t, r, i)), s === null && Vu(e, t, i, mo, r), s === n))
          break
        n = s
      }
      n !== null && i.stopPropagation()
    } else Vu(e, t, i, null, r)
  }
}
var mo = null
function Ql(e, t, r, i) {
  if (((mo = null), (e = df(i)), (e = Ei(e)), e !== null))
    if (((t = zi(e)), t === null)) e = null
    else if (((r = t.tag), r === 13)) {
      if (((e = s0(t)), e !== null)) return e
      e = null
    } else if (r === 3) {
      if (t.stateNode.current.memoizedState.isDehydrated)
        return t.tag === 3 ? t.stateNode.containerInfo : null
      e = null
    } else t !== e && (e = null)
  return (mo = e), null
}
function y0(e) {
  switch (e) {
    case 'cancel':
    case 'click':
    case 'close':
    case 'contextmenu':
    case 'copy':
    case 'cut':
    case 'auxclick':
    case 'dblclick':
    case 'dragend':
    case 'dragstart':
    case 'drop':
    case 'focusin':
    case 'focusout':
    case 'input':
    case 'invalid':
    case 'keydown':
    case 'keypress':
    case 'keyup':
    case 'mousedown':
    case 'mouseup':
    case 'paste':
    case 'pause':
    case 'play':
    case 'pointercancel':
    case 'pointerdown':
    case 'pointerup':
    case 'ratechange':
    case 'reset':
    case 'resize':
    case 'seeked':
    case 'submit':
    case 'touchcancel':
    case 'touchend':
    case 'touchstart':
    case 'volumechange':
    case 'change':
    case 'selectionchange':
    case 'textInput':
    case 'compositionstart':
    case 'compositionend':
    case 'compositionupdate':
    case 'beforeblur':
    case 'afterblur':
    case 'beforeinput':
    case 'blur':
    case 'fullscreenchange':
    case 'focus':
    case 'hashchange':
    case 'popstate':
    case 'select':
    case 'selectstart':
      return 1
    case 'drag':
    case 'dragenter':
    case 'dragexit':
    case 'dragleave':
    case 'dragover':
    case 'mousemove':
    case 'mouseout':
    case 'mouseover':
    case 'pointermove':
    case 'pointerout':
    case 'pointerover':
    case 'scroll':
    case 'toggle':
    case 'touchmove':
    case 'wheel':
    case 'mouseenter':
    case 'mouseleave':
    case 'pointerenter':
    case 'pointerleave':
      return 4
    case 'message':
      switch (__()) {
        case gf:
          return 1
        case l0:
          return 4
        case fo:
        case v_:
          return 16
        case c0:
          return 536870912
        default:
          return 16
      }
    default:
      return 16
  }
}
var Wr = null,
  vf = null,
  Ga = null
function _0() {
  if (Ga) return Ga
  var e,
    t = vf,
    r = t.length,
    i,
    n = 'value' in Wr ? Wr.value : Wr.textContent,
    s = n.length
  for (e = 0; e < r && t[e] === n[e]; e++);
  var a = r - e
  for (i = 1; i <= a && t[r - i] === n[s - i]; i++);
  return (Ga = n.slice(e, 1 < i ? 1 - i : void 0))
}
function Xa(e) {
  var t = e.keyCode
  return (
    'charCode' in e ? ((e = e.charCode), e === 0 && t === 13 && (e = 13)) : (e = t),
    e === 10 && (e = 13),
    32 <= e || e === 13 ? e : 0
  )
}
function Ta() {
  return !0
}
function Jp() {
  return !1
}
function Ht(e) {
  function t(r, i, n, s, a) {
    ;(this._reactName = r),
      (this._targetInst = n),
      (this.type = i),
      (this.nativeEvent = s),
      (this.target = a),
      (this.currentTarget = null)
    for (var o in e) e.hasOwnProperty(o) && ((r = e[o]), (this[o] = r ? r(s) : s[o]))
    return (
      (this.isDefaultPrevented = (
        s.defaultPrevented != null ? s.defaultPrevented : s.returnValue === !1
      )
        ? Ta
        : Jp),
      (this.isPropagationStopped = Jp),
      this
    )
  }
  return (
    Xe(t.prototype, {
      preventDefault: function () {
        this.defaultPrevented = !0
        var r = this.nativeEvent
        r &&
          (r.preventDefault
            ? r.preventDefault()
            : typeof r.returnValue != 'unknown' && (r.returnValue = !1),
          (this.isDefaultPrevented = Ta))
      },
      stopPropagation: function () {
        var r = this.nativeEvent
        r &&
          (r.stopPropagation
            ? r.stopPropagation()
            : typeof r.cancelBubble != 'unknown' && (r.cancelBubble = !0),
          (this.isPropagationStopped = Ta))
      },
      persist: function () {},
      isPersistent: Ta,
    }),
    t
  )
}
var Bn = {
    eventPhase: 0,
    bubbles: 0,
    cancelable: 0,
    timeStamp: function (e) {
      return e.timeStamp || Date.now()
    },
    defaultPrevented: 0,
    isTrusted: 0,
  },
  Ef = Ht(Bn),
  ta = Xe({}, Bn, { view: 0, detail: 0 }),
  R_ = Ht(ta),
  Bu,
  Fu,
  Vn,
  Vo = Xe({}, ta, {
    screenX: 0,
    screenY: 0,
    clientX: 0,
    clientY: 0,
    pageX: 0,
    pageY: 0,
    ctrlKey: 0,
    shiftKey: 0,
    altKey: 0,
    metaKey: 0,
    getModifierState: xf,
    button: 0,
    buttons: 0,
    relatedTarget: function (e) {
      return e.relatedTarget === void 0
        ? e.fromElement === e.srcElement
          ? e.toElement
          : e.fromElement
        : e.relatedTarget
    },
    movementX: function (e) {
      return 'movementX' in e
        ? e.movementX
        : (e !== Vn &&
            (Vn && e.type === 'mousemove'
              ? ((Bu = e.screenX - Vn.screenX), (Fu = e.screenY - Vn.screenY))
              : (Fu = Bu = 0),
            (Vn = e)),
          Bu)
    },
    movementY: function (e) {
      return 'movementY' in e ? e.movementY : Fu
    },
  }),
  Zp = Ht(Vo),
  L_ = Xe({}, Vo, { dataTransfer: 0 }),
  P_ = Ht(L_),
  B_ = Xe({}, ta, { relatedTarget: 0 }),
  Mu = Ht(B_),
  F_ = Xe({}, Bn, { animationName: 0, elapsedTime: 0, pseudoElement: 0 }),
  M_ = Ht(F_),
  U_ = Xe({}, Bn, {
    clipboardData: function (e) {
      return 'clipboardData' in e ? e.clipboardData : window.clipboardData
    },
  }),
  H_ = Ht(U_),
  z_ = Xe({}, Bn, { data: 0 }),
  eh = Ht(z_),
  j_ = {
    Esc: 'Escape',
    Spacebar: ' ',
    Left: 'ArrowLeft',
    Up: 'ArrowUp',
    Right: 'ArrowRight',
    Down: 'ArrowDown',
    Del: 'Delete',
    Win: 'OS',
    Menu: 'ContextMenu',
    Apps: 'ContextMenu',
    Scroll: 'ScrollLock',
    MozPrintableKey: 'Unidentified',
  },
  q_ = {
    8: 'Backspace',
    9: 'Tab',
    12: 'Clear',
    13: 'Enter',
    16: 'Shift',
    17: 'Control',
    18: 'Alt',
    19: 'Pause',
    20: 'CapsLock',
    27: 'Escape',
    32: ' ',
    33: 'PageUp',
    34: 'PageDown',
    35: 'End',
    36: 'Home',
    37: 'ArrowLeft',
    38: 'ArrowUp',
    39: 'ArrowRight',
    40: 'ArrowDown',
    45: 'Insert',
    46: 'Delete',
    112: 'F1',
    113: 'F2',
    114: 'F3',
    115: 'F4',
    116: 'F5',
    117: 'F6',
    118: 'F7',
    119: 'F8',
    120: 'F9',
    121: 'F10',
    122: 'F11',
    123: 'F12',
    144: 'NumLock',
    145: 'ScrollLock',
    224: 'Meta',
  },
  $_ = { Alt: 'altKey', Control: 'ctrlKey', Meta: 'metaKey', Shift: 'shiftKey' }
function V_(e) {
  var t = this.nativeEvent
  return t.getModifierState ? t.getModifierState(e) : (e = $_[e]) ? !!t[e] : !1
}
function xf() {
  return V_
}
var G_ = Xe({}, ta, {
    key: function (e) {
      if (e.key) {
        var t = j_[e.key] || e.key
        if (t !== 'Unidentified') return t
      }
      return e.type === 'keypress'
        ? ((e = Xa(e)), e === 13 ? 'Enter' : String.fromCharCode(e))
        : e.type === 'keydown' || e.type === 'keyup'
        ? q_[e.keyCode] || 'Unidentified'
        : ''
    },
    code: 0,
    location: 0,
    ctrlKey: 0,
    shiftKey: 0,
    altKey: 0,
    metaKey: 0,
    repeat: 0,
    locale: 0,
    getModifierState: xf,
    charCode: function (e) {
      return e.type === 'keypress' ? Xa(e) : 0
    },
    keyCode: function (e) {
      return e.type === 'keydown' || e.type === 'keyup' ? e.keyCode : 0
    },
    which: function (e) {
      return e.type === 'keypress'
        ? Xa(e)
        : e.type === 'keydown' || e.type === 'keyup'
        ? e.keyCode
        : 0
    },
  }),
  X_ = Ht(G_),
  Y_ = Xe({}, Vo, {
    pointerId: 0,
    width: 0,
    height: 0,
    pressure: 0,
    tangentialPressure: 0,
    tiltX: 0,
    tiltY: 0,
    twist: 0,
    pointerType: 0,
    isPrimary: 0,
  }),
  th = Ht(Y_),
  W_ = Xe({}, ta, {
    touches: 0,
    targetTouches: 0,
    changedTouches: 0,
    altKey: 0,
    metaKey: 0,
    ctrlKey: 0,
    shiftKey: 0,
    getModifierState: xf,
  }),
  Q_ = Ht(W_),
  K_ = Xe({}, Bn, { propertyName: 0, elapsedTime: 0, pseudoElement: 0 }),
  J_ = Ht(K_),
  Z_ = Xe({}, Vo, {
    deltaX: function (e) {
      return 'deltaX' in e ? e.deltaX : 'wheelDeltaX' in e ? -e.wheelDeltaX : 0
    },
    deltaY: function (e) {
      return 'deltaY' in e
        ? e.deltaY
        : 'wheelDeltaY' in e
        ? -e.wheelDeltaY
        : 'wheelDelta' in e
        ? -e.wheelDelta
        : 0
    },
    deltaZ: 0,
    deltaMode: 0,
  }),
  ev = Ht(Z_),
  tv = [9, 13, 27, 32],
  Tf = Or && 'CompositionEvent' in window,
  ls = null
Or && 'documentMode' in document && (ls = document.documentMode)
var rv = Or && 'TextEvent' in window && !ls,
  v0 = Or && (!Tf || (ls && 8 < ls && 11 >= ls)),
  rh = String.fromCharCode(32),
  ih = !1
function E0(e, t) {
  switch (e) {
    case 'keyup':
      return tv.indexOf(t.keyCode) !== -1
    case 'keydown':
      return t.keyCode !== 229
    case 'keypress':
    case 'mousedown':
    case 'focusout':
      return !0
    default:
      return !1
  }
}
function x0(e) {
  return (e = e.detail), typeof e == 'object' && 'data' in e ? e.data : null
}
var en = !1
function iv(e, t) {
  switch (e) {
    case 'compositionend':
      return x0(t)
    case 'keypress':
      return t.which !== 32 ? null : ((ih = !0), rh)
    case 'textInput':
      return (e = t.data), e === rh && ih ? null : e
    default:
      return null
  }
}
function nv(e, t) {
  if (en)
    return e === 'compositionend' || (!Tf && E0(e, t))
      ? ((e = _0()), (Ga = vf = Wr = null), (en = !1), e)
      : null
  switch (e) {
    case 'paste':
      return null
    case 'keypress':
      if (!(t.ctrlKey || t.altKey || t.metaKey) || (t.ctrlKey && t.altKey)) {
        if (t.char && 1 < t.char.length) return t.char
        if (t.which) return String.fromCharCode(t.which)
      }
      return null
    case 'compositionend':
      return v0 && t.locale !== 'ko' ? null : t.data
    default:
      return null
  }
}
var sv = {
  color: !0,
  date: !0,
  datetime: !0,
  'datetime-local': !0,
  email: !0,
  month: !0,
  number: !0,
  password: !0,
  range: !0,
  search: !0,
  tel: !0,
  text: !0,
  time: !0,
  url: !0,
  week: !0,
}
function nh(e) {
  var t = e && e.nodeName && e.nodeName.toLowerCase()
  return t === 'input' ? !!sv[e.type] : t === 'textarea'
}
function T0(e, t, r, i) {
  e0(i),
    (t = go(t, 'onChange')),
    0 < t.length &&
      ((r = new Ef('onChange', 'change', null, r, i)), e.push({ event: r, listeners: t }))
}
var cs = null,
  Os = null
function av(e) {
  L0(e, 0)
}
function Go(e) {
  var t = nn(e)
  if (Xd(t)) return e
}
function ov(e, t) {
  if (e === 'change') return t
}
var A0 = !1
if (Or) {
  var Uu
  if (Or) {
    var Hu = 'oninput' in document
    if (!Hu) {
      var sh = document.createElement('div')
      sh.setAttribute('oninput', 'return;'), (Hu = typeof sh.oninput == 'function')
    }
    Uu = Hu
  } else Uu = !1
  A0 = Uu && (!document.documentMode || 9 < document.documentMode)
}
function ah() {
  cs && (cs.detachEvent('onpropertychange', S0), (Os = cs = null))
}
function S0(e) {
  if (e.propertyName === 'value' && Go(Os)) {
    var t = []
    T0(t, Os, e, df(e)), n0(av, t)
  }
}
function uv(e, t, r) {
  e === 'focusin'
    ? (ah(), (cs = t), (Os = r), cs.attachEvent('onpropertychange', S0))
    : e === 'focusout' && ah()
}
function lv(e) {
  if (e === 'selectionchange' || e === 'keyup' || e === 'keydown') return Go(Os)
}
function cv(e, t) {
  if (e === 'click') return Go(t)
}
function fv(e, t) {
  if (e === 'input' || e === 'change') return Go(t)
}
function pv(e, t) {
  return (e === t && (e !== 0 || 1 / e === 1 / t)) || (e !== e && t !== t)
}
var ar = typeof Object.is == 'function' ? Object.is : pv
function Is(e, t) {
  if (ar(e, t)) return !0
  if (typeof e != 'object' || e === null || typeof t != 'object' || t === null) return !1
  var r = Object.keys(e),
    i = Object.keys(t)
  if (r.length !== i.length) return !1
  for (i = 0; i < r.length; i++) {
    var n = r[i]
    if (!Dl.call(t, n) || !ar(e[n], t[n])) return !1
  }
  return !0
}
function oh(e) {
  for (; e && e.firstChild; ) e = e.firstChild
  return e
}
function uh(e, t) {
  var r = oh(e)
  e = 0
  for (var i; r; ) {
    if (r.nodeType === 3) {
      if (((i = e + r.textContent.length), e <= t && i >= t)) return { node: r, offset: t - e }
      e = i
    }
    e: {
      for (; r; ) {
        if (r.nextSibling) {
          r = r.nextSibling
          break e
        }
        r = r.parentNode
      }
      r = void 0
    }
    r = oh(r)
  }
}
function C0(e, t) {
  return e && t
    ? e === t
      ? !0
      : e && e.nodeType === 3
      ? !1
      : t && t.nodeType === 3
      ? C0(e, t.parentNode)
      : 'contains' in e
      ? e.contains(t)
      : e.compareDocumentPosition
      ? !!(e.compareDocumentPosition(t) & 16)
      : !1
    : !1
}
function k0() {
  for (var e = window, t = uo(); t instanceof e.HTMLIFrameElement; ) {
    try {
      var r = typeof t.contentWindow.location.href == 'string'
    } catch {
      r = !1
    }
    if (r) e = t.contentWindow
    else break
    t = uo(e.document)
  }
  return t
}
function Af(e) {
  var t = e && e.nodeName && e.nodeName.toLowerCase()
  return (
    t &&
    ((t === 'input' &&
      (e.type === 'text' ||
        e.type === 'search' ||
        e.type === 'tel' ||
        e.type === 'url' ||
        e.type === 'password')) ||
      t === 'textarea' ||
      e.contentEditable === 'true')
  )
}
function hv(e) {
  var t = k0(),
    r = e.focusedElem,
    i = e.selectionRange
  if (t !== r && r && r.ownerDocument && C0(r.ownerDocument.documentElement, r)) {
    if (i !== null && Af(r)) {
      if (((t = i.start), (e = i.end), e === void 0 && (e = t), 'selectionStart' in r))
        (r.selectionStart = t), (r.selectionEnd = Math.min(e, r.value.length))
      else if (
        ((e = ((t = r.ownerDocument || document) && t.defaultView) || window), e.getSelection)
      ) {
        e = e.getSelection()
        var n = r.textContent.length,
          s = Math.min(i.start, n)
        ;(i = i.end === void 0 ? s : Math.min(i.end, n)),
          !e.extend && s > i && ((n = i), (i = s), (s = n)),
          (n = uh(r, s))
        var a = uh(r, i)
        n &&
          a &&
          (e.rangeCount !== 1 ||
            e.anchorNode !== n.node ||
            e.anchorOffset !== n.offset ||
            e.focusNode !== a.node ||
            e.focusOffset !== a.offset) &&
          ((t = t.createRange()),
          t.setStart(n.node, n.offset),
          e.removeAllRanges(),
          s > i
            ? (e.addRange(t), e.extend(a.node, a.offset))
            : (t.setEnd(a.node, a.offset), e.addRange(t)))
      }
    }
    for (t = [], e = r; (e = e.parentNode); )
      e.nodeType === 1 && t.push({ element: e, left: e.scrollLeft, top: e.scrollTop })
    for (typeof r.focus == 'function' && r.focus(), r = 0; r < t.length; r++)
      (e = t[r]), (e.element.scrollLeft = e.left), (e.element.scrollTop = e.top)
  }
}
var mv = Or && 'documentMode' in document && 11 >= document.documentMode,
  tn = null,
  Kl = null,
  fs = null,
  Jl = !1
function lh(e, t, r) {
  var i = r.window === r ? r.document : r.nodeType === 9 ? r : r.ownerDocument
  Jl ||
    tn == null ||
    tn !== uo(i) ||
    ((i = tn),
    'selectionStart' in i && Af(i)
      ? (i = { start: i.selectionStart, end: i.selectionEnd })
      : ((i = ((i.ownerDocument && i.ownerDocument.defaultView) || window).getSelection()),
        (i = {
          anchorNode: i.anchorNode,
          anchorOffset: i.anchorOffset,
          focusNode: i.focusNode,
          focusOffset: i.focusOffset,
        })),
    (fs && Is(fs, i)) ||
      ((fs = i),
      (i = go(Kl, 'onSelect')),
      0 < i.length &&
        ((t = new Ef('onSelect', 'select', null, t, r)),
        e.push({ event: t, listeners: i }),
        (t.target = tn))))
}
function Aa(e, t) {
  var r = {}
  return (
    (r[e.toLowerCase()] = t.toLowerCase()),
    (r['Webkit' + e] = 'webkit' + t),
    (r['Moz' + e] = 'moz' + t),
    r
  )
}
var rn = {
    animationend: Aa('Animation', 'AnimationEnd'),
    animationiteration: Aa('Animation', 'AnimationIteration'),
    animationstart: Aa('Animation', 'AnimationStart'),
    transitionend: Aa('Transition', 'TransitionEnd'),
  },
  zu = {},
  w0 = {}
Or &&
  ((w0 = document.createElement('div').style),
  'AnimationEvent' in window ||
    (delete rn.animationend.animation,
    delete rn.animationiteration.animation,
    delete rn.animationstart.animation),
  'TransitionEvent' in window || delete rn.transitionend.transition)
function Xo(e) {
  if (zu[e]) return zu[e]
  if (!rn[e]) return e
  var t = rn[e],
    r
  for (r in t) if (t.hasOwnProperty(r) && r in w0) return (zu[e] = t[r])
  return e
}
var N0 = Xo('animationend'),
  O0 = Xo('animationiteration'),
  I0 = Xo('animationstart'),
  D0 = Xo('transitionend'),
  R0 = new Map(),
  ch =
    'abort auxClick cancel canPlay canPlayThrough click close contextMenu copy cut drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error gotPointerCapture input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart lostPointerCapture mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing pointerCancel pointerDown pointerMove pointerOut pointerOver pointerUp progress rateChange reset resize seeked seeking stalled submit suspend timeUpdate touchCancel touchEnd touchStart volumeChange scroll toggle touchMove waiting wheel'.split(
      ' '
    )
function fi(e, t) {
  R0.set(e, t), Hi(t, [e])
}
for (var ju = 0; ju < ch.length; ju++) {
  var qu = ch[ju],
    dv = qu.toLowerCase(),
    gv = qu[0].toUpperCase() + qu.slice(1)
  fi(dv, 'on' + gv)
}
fi(N0, 'onAnimationEnd')
fi(O0, 'onAnimationIteration')
fi(I0, 'onAnimationStart')
fi('dblclick', 'onDoubleClick')
fi('focusin', 'onFocus')
fi('focusout', 'onBlur')
fi(D0, 'onTransitionEnd')
An('onMouseEnter', ['mouseout', 'mouseover'])
An('onMouseLeave', ['mouseout', 'mouseover'])
An('onPointerEnter', ['pointerout', 'pointerover'])
An('onPointerLeave', ['pointerout', 'pointerover'])
Hi('onChange', 'change click focusin focusout input keydown keyup selectionchange'.split(' '))
Hi(
  'onSelect',
  'focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange'.split(' ')
)
Hi('onBeforeInput', ['compositionend', 'keypress', 'textInput', 'paste'])
Hi('onCompositionEnd', 'compositionend focusout keydown keypress keyup mousedown'.split(' '))
Hi('onCompositionStart', 'compositionstart focusout keydown keypress keyup mousedown'.split(' '))
Hi('onCompositionUpdate', 'compositionupdate focusout keydown keypress keyup mousedown'.split(' '))
var ss =
    'abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange resize seeked seeking stalled suspend timeupdate volumechange waiting'.split(
      ' '
    ),
  bv = new Set('cancel close invalid load scroll toggle'.split(' ').concat(ss))
function fh(e, t, r) {
  var i = e.type || 'unknown-event'
  ;(e.currentTarget = r), d_(i, t, void 0, e), (e.currentTarget = null)
}
function L0(e, t) {
  t = (t & 4) !== 0
  for (var r = 0; r < e.length; r++) {
    var i = e[r],
      n = i.event
    i = i.listeners
    e: {
      var s = void 0
      if (t)
        for (var a = i.length - 1; 0 <= a; a--) {
          var o = i[a],
            u = o.instance,
            c = o.currentTarget
          if (((o = o.listener), u !== s && n.isPropagationStopped())) break e
          fh(n, o, c), (s = u)
        }
      else
        for (a = 0; a < i.length; a++) {
          if (
            ((o = i[a]),
            (u = o.instance),
            (c = o.currentTarget),
            (o = o.listener),
            u !== s && n.isPropagationStopped())
          )
            break e
          fh(n, o, c), (s = u)
        }
    }
  }
  if (co) throw ((e = Xl), (co = !1), (Xl = null), e)
}
function Ue(e, t) {
  var r = t[ic]
  r === void 0 && (r = t[ic] = new Set())
  var i = e + '__bubble'
  r.has(i) || (P0(t, e, 2, !1), r.add(i))
}
function $u(e, t, r) {
  var i = 0
  t && (i |= 4), P0(r, e, i, t)
}
var Sa = '_reactListening' + Math.random().toString(36).slice(2)
function Ds(e) {
  if (!e[Sa]) {
    ;(e[Sa] = !0),
      jd.forEach(function (r) {
        r !== 'selectionchange' && (bv.has(r) || $u(r, !1, e), $u(r, !0, e))
      })
    var t = e.nodeType === 9 ? e : e.ownerDocument
    t === null || t[Sa] || ((t[Sa] = !0), $u('selectionchange', !1, t))
  }
}
function P0(e, t, r, i) {
  switch (y0(t)) {
    case 1:
      var n = I_
      break
    case 4:
      n = D_
      break
    default:
      n = _f
  }
  ;(r = n.bind(null, t, r, e)),
    (n = void 0),
    !Gl || (t !== 'touchstart' && t !== 'touchmove' && t !== 'wheel') || (n = !0),
    i
      ? n !== void 0
        ? e.addEventListener(t, r, { capture: !0, passive: n })
        : e.addEventListener(t, r, !0)
      : n !== void 0
      ? e.addEventListener(t, r, { passive: n })
      : e.addEventListener(t, r, !1)
}
function Vu(e, t, r, i, n) {
  var s = i
  if (!(t & 1) && !(t & 2) && i !== null)
    e: for (;;) {
      if (i === null) return
      var a = i.tag
      if (a === 3 || a === 4) {
        var o = i.stateNode.containerInfo
        if (o === n || (o.nodeType === 8 && o.parentNode === n)) break
        if (a === 4)
          for (a = i.return; a !== null; ) {
            var u = a.tag
            if (
              (u === 3 || u === 4) &&
              ((u = a.stateNode.containerInfo), u === n || (u.nodeType === 8 && u.parentNode === n))
            )
              return
            a = a.return
          }
        for (; o !== null; ) {
          if (((a = Ei(o)), a === null)) return
          if (((u = a.tag), u === 5 || u === 6)) {
            i = s = a
            continue e
          }
          o = o.parentNode
        }
      }
      i = i.return
    }
  n0(function () {
    var c = s,
      f = df(r),
      h = []
    e: {
      var p = R0.get(e)
      if (p !== void 0) {
        var m = Ef,
          v = e
        switch (e) {
          case 'keypress':
            if (Xa(r) === 0) break e
          case 'keydown':
          case 'keyup':
            m = X_
            break
          case 'focusin':
            ;(v = 'focus'), (m = Mu)
            break
          case 'focusout':
            ;(v = 'blur'), (m = Mu)
            break
          case 'beforeblur':
          case 'afterblur':
            m = Mu
            break
          case 'click':
            if (r.button === 2) break e
          case 'auxclick':
          case 'dblclick':
          case 'mousedown':
          case 'mousemove':
          case 'mouseup':
          case 'mouseout':
          case 'mouseover':
          case 'contextmenu':
            m = Zp
            break
          case 'drag':
          case 'dragend':
          case 'dragenter':
          case 'dragexit':
          case 'dragleave':
          case 'dragover':
          case 'dragstart':
          case 'drop':
            m = P_
            break
          case 'touchcancel':
          case 'touchend':
          case 'touchmove':
          case 'touchstart':
            m = Q_
            break
          case N0:
          case O0:
          case I0:
            m = M_
            break
          case D0:
            m = J_
            break
          case 'scroll':
            m = R_
            break
          case 'wheel':
            m = ev
            break
          case 'copy':
          case 'cut':
          case 'paste':
            m = H_
            break
          case 'gotpointercapture':
          case 'lostpointercapture':
          case 'pointercancel':
          case 'pointerdown':
          case 'pointermove':
          case 'pointerout':
          case 'pointerover':
          case 'pointerup':
            m = th
        }
        var b = (t & 4) !== 0,
          S = !b && e === 'scroll',
          g = b ? (p !== null ? p + 'Capture' : null) : p
        b = []
        for (var _ = c, y; _ !== null; ) {
          y = _
          var x = y.stateNode
          if (
            (y.tag === 5 &&
              x !== null &&
              ((y = x), g !== null && ((x = Cs(_, g)), x != null && b.push(Rs(_, x, y)))),
            S)
          )
            break
          _ = _.return
        }
        0 < b.length && ((p = new m(p, v, null, r, f)), h.push({ event: p, listeners: b }))
      }
    }
    if (!(t & 7)) {
      e: {
        if (
          ((p = e === 'mouseover' || e === 'pointerover'),
          (m = e === 'mouseout' || e === 'pointerout'),
          p && r !== $l && (v = r.relatedTarget || r.fromElement) && (Ei(v) || v[Ir]))
        )
          break e
        if (
          (m || p) &&
          ((p =
            f.window === f ? f : (p = f.ownerDocument) ? p.defaultView || p.parentWindow : window),
          m
            ? ((v = r.relatedTarget || r.toElement),
              (m = c),
              (v = v ? Ei(v) : null),
              v !== null && ((S = zi(v)), v !== S || (v.tag !== 5 && v.tag !== 6)) && (v = null))
            : ((m = null), (v = c)),
          m !== v)
        ) {
          if (
            ((b = Zp),
            (x = 'onMouseLeave'),
            (g = 'onMouseEnter'),
            (_ = 'mouse'),
            (e === 'pointerout' || e === 'pointerover') &&
              ((b = th), (x = 'onPointerLeave'), (g = 'onPointerEnter'), (_ = 'pointer')),
            (S = m == null ? p : nn(m)),
            (y = v == null ? p : nn(v)),
            (p = new b(x, _ + 'leave', m, r, f)),
            (p.target = S),
            (p.relatedTarget = y),
            (x = null),
            Ei(f) === c &&
              ((b = new b(g, _ + 'enter', v, r, f)),
              (b.target = y),
              (b.relatedTarget = S),
              (x = b)),
            (S = x),
            m && v)
          )
            t: {
              for (b = m, g = v, _ = 0, y = b; y; y = $i(y)) _++
              for (y = 0, x = g; x; x = $i(x)) y++
              for (; 0 < _ - y; ) (b = $i(b)), _--
              for (; 0 < y - _; ) (g = $i(g)), y--
              for (; _--; ) {
                if (b === g || (g !== null && b === g.alternate)) break t
                ;(b = $i(b)), (g = $i(g))
              }
              b = null
            }
          else b = null
          m !== null && ph(h, p, m, b, !1), v !== null && S !== null && ph(h, S, v, b, !0)
        }
      }
      e: {
        if (
          ((p = c ? nn(c) : window),
          (m = p.nodeName && p.nodeName.toLowerCase()),
          m === 'select' || (m === 'input' && p.type === 'file'))
        )
          var D = ov
        else if (nh(p))
          if (A0) D = fv
          else {
            D = lv
            var C = uv
          }
        else
          (m = p.nodeName) &&
            m.toLowerCase() === 'input' &&
            (p.type === 'checkbox' || p.type === 'radio') &&
            (D = cv)
        if (D && (D = D(e, c))) {
          T0(h, D, r, f)
          break e
        }
        C && C(e, p, c),
          e === 'focusout' &&
            (C = p._wrapperState) &&
            C.controlled &&
            p.type === 'number' &&
            Ul(p, 'number', p.value)
      }
      switch (((C = c ? nn(c) : window), e)) {
        case 'focusin':
          ;(nh(C) || C.contentEditable === 'true') && ((tn = C), (Kl = c), (fs = null))
          break
        case 'focusout':
          fs = Kl = tn = null
          break
        case 'mousedown':
          Jl = !0
          break
        case 'contextmenu':
        case 'mouseup':
        case 'dragend':
          ;(Jl = !1), lh(h, r, f)
          break
        case 'selectionchange':
          if (mv) break
        case 'keydown':
        case 'keyup':
          lh(h, r, f)
      }
      var H
      if (Tf)
        e: {
          switch (e) {
            case 'compositionstart':
              var T = 'onCompositionStart'
              break e
            case 'compositionend':
              T = 'onCompositionEnd'
              break e
            case 'compositionupdate':
              T = 'onCompositionUpdate'
              break e
          }
          T = void 0
        }
      else
        en
          ? E0(e, r) && (T = 'onCompositionEnd')
          : e === 'keydown' && r.keyCode === 229 && (T = 'onCompositionStart')
      T &&
        (v0 &&
          r.locale !== 'ko' &&
          (en || T !== 'onCompositionStart'
            ? T === 'onCompositionEnd' && en && (H = _0())
            : ((Wr = f), (vf = 'value' in Wr ? Wr.value : Wr.textContent), (en = !0))),
        (C = go(c, T)),
        0 < C.length &&
          ((T = new eh(T, e, null, r, f)),
          h.push({ event: T, listeners: C }),
          H ? (T.data = H) : ((H = x0(r)), H !== null && (T.data = H)))),
        (H = rv ? iv(e, r) : nv(e, r)) &&
          ((c = go(c, 'onBeforeInput')),
          0 < c.length &&
            ((f = new eh('onBeforeInput', 'beforeinput', null, r, f)),
            h.push({ event: f, listeners: c }),
            (f.data = H)))
    }
    L0(h, t)
  })
}
function Rs(e, t, r) {
  return { instance: e, listener: t, currentTarget: r }
}
function go(e, t) {
  for (var r = t + 'Capture', i = []; e !== null; ) {
    var n = e,
      s = n.stateNode
    n.tag === 5 &&
      s !== null &&
      ((n = s),
      (s = Cs(e, r)),
      s != null && i.unshift(Rs(e, s, n)),
      (s = Cs(e, t)),
      s != null && i.push(Rs(e, s, n))),
      (e = e.return)
  }
  return i
}
function $i(e) {
  if (e === null) return null
  do e = e.return
  while (e && e.tag !== 5)
  return e || null
}
function ph(e, t, r, i, n) {
  for (var s = t._reactName, a = []; r !== null && r !== i; ) {
    var o = r,
      u = o.alternate,
      c = o.stateNode
    if (u !== null && u === i) break
    o.tag === 5 &&
      c !== null &&
      ((o = c),
      n
        ? ((u = Cs(r, s)), u != null && a.unshift(Rs(r, u, o)))
        : n || ((u = Cs(r, s)), u != null && a.push(Rs(r, u, o)))),
      (r = r.return)
  }
  a.length !== 0 && e.push({ event: t, listeners: a })
}
var yv = /\r\n?/g,
  _v = /\u0000|\uFFFD/g
function hh(e) {
  return (typeof e == 'string' ? e : '' + e)
    .replace(
      yv,
      `
`
    )
    .replace(_v, '')
}
function Ca(e, t, r) {
  if (((t = hh(t)), hh(e) !== t && r)) throw Error(ue(425))
}
function bo() {}
var Zl = null,
  ec = null
function tc(e, t) {
  return (
    e === 'textarea' ||
    e === 'noscript' ||
    typeof t.children == 'string' ||
    typeof t.children == 'number' ||
    (typeof t.dangerouslySetInnerHTML == 'object' &&
      t.dangerouslySetInnerHTML !== null &&
      t.dangerouslySetInnerHTML.__html != null)
  )
}
var rc = typeof setTimeout == 'function' ? setTimeout : void 0,
  vv = typeof clearTimeout == 'function' ? clearTimeout : void 0,
  mh = typeof Promise == 'function' ? Promise : void 0,
  Ev =
    typeof queueMicrotask == 'function'
      ? queueMicrotask
      : typeof mh < 'u'
      ? function (e) {
          return mh.resolve(null).then(e).catch(xv)
        }
      : rc
function xv(e) {
  setTimeout(function () {
    throw e
  })
}
function Gu(e, t) {
  var r = t,
    i = 0
  do {
    var n = r.nextSibling
    if ((e.removeChild(r), n && n.nodeType === 8))
      if (((r = n.data), r === '/$')) {
        if (i === 0) {
          e.removeChild(n), Ns(t)
          return
        }
        i--
      } else (r !== '$' && r !== '$?' && r !== '$!') || i++
    r = n
  } while (r)
  Ns(t)
}
function ei(e) {
  for (; e != null; e = e.nextSibling) {
    var t = e.nodeType
    if (t === 1 || t === 3) break
    if (t === 8) {
      if (((t = e.data), t === '$' || t === '$!' || t === '$?')) break
      if (t === '/$') return null
    }
  }
  return e
}
function dh(e) {
  e = e.previousSibling
  for (var t = 0; e; ) {
    if (e.nodeType === 8) {
      var r = e.data
      if (r === '$' || r === '$!' || r === '$?') {
        if (t === 0) return e
        t--
      } else r === '/$' && t++
    }
    e = e.previousSibling
  }
  return null
}
var Fn = Math.random().toString(36).slice(2),
  hr = '__reactFiber$' + Fn,
  Ls = '__reactProps$' + Fn,
  Ir = '__reactContainer$' + Fn,
  ic = '__reactEvents$' + Fn,
  Tv = '__reactListeners$' + Fn,
  Av = '__reactHandles$' + Fn
function Ei(e) {
  var t = e[hr]
  if (t) return t
  for (var r = e.parentNode; r; ) {
    if ((t = r[Ir] || r[hr])) {
      if (((r = t.alternate), t.child !== null || (r !== null && r.child !== null)))
        for (e = dh(e); e !== null; ) {
          if ((r = e[hr])) return r
          e = dh(e)
        }
      return t
    }
    ;(e = r), (r = e.parentNode)
  }
  return null
}
function ra(e) {
  return (
    (e = e[hr] || e[Ir]),
    !e || (e.tag !== 5 && e.tag !== 6 && e.tag !== 13 && e.tag !== 3) ? null : e
  )
}
function nn(e) {
  if (e.tag === 5 || e.tag === 6) return e.stateNode
  throw Error(ue(33))
}
function Yo(e) {
  return e[Ls] || null
}
var nc = [],
  sn = -1
function pi(e) {
  return { current: e }
}
function He(e) {
  0 > sn || ((e.current = nc[sn]), (nc[sn] = null), sn--)
}
function Fe(e, t) {
  sn++, (nc[sn] = e.current), (e.current = t)
}
var ui = {},
  mt = pi(ui),
  kt = pi(!1),
  wi = ui
function Sn(e, t) {
  var r = e.type.contextTypes
  if (!r) return ui
  var i = e.stateNode
  if (i && i.__reactInternalMemoizedUnmaskedChildContext === t)
    return i.__reactInternalMemoizedMaskedChildContext
  var n = {},
    s
  for (s in r) n[s] = t[s]
  return (
    i &&
      ((e = e.stateNode),
      (e.__reactInternalMemoizedUnmaskedChildContext = t),
      (e.__reactInternalMemoizedMaskedChildContext = n)),
    n
  )
}
function wt(e) {
  return (e = e.childContextTypes), e != null
}
function yo() {
  He(kt), He(mt)
}
function gh(e, t, r) {
  if (mt.current !== ui) throw Error(ue(168))
  Fe(mt, t), Fe(kt, r)
}
function B0(e, t, r) {
  var i = e.stateNode
  if (((t = t.childContextTypes), typeof i.getChildContext != 'function')) return r
  i = i.getChildContext()
  for (var n in i) if (!(n in t)) throw Error(ue(108, u_(e) || 'Unknown', n))
  return Xe({}, r, i)
}
function _o(e) {
  return (
    (e = ((e = e.stateNode) && e.__reactInternalMemoizedMergedChildContext) || ui),
    (wi = mt.current),
    Fe(mt, e),
    Fe(kt, kt.current),
    !0
  )
}
function bh(e, t, r) {
  var i = e.stateNode
  if (!i) throw Error(ue(169))
  r
    ? ((e = B0(e, t, wi)),
      (i.__reactInternalMemoizedMergedChildContext = e),
      He(kt),
      He(mt),
      Fe(mt, e))
    : He(kt),
    Fe(kt, r)
}
var Cr = null,
  Wo = !1,
  Xu = !1
function F0(e) {
  Cr === null ? (Cr = [e]) : Cr.push(e)
}
function Sv(e) {
  ;(Wo = !0), F0(e)
}
function hi() {
  if (!Xu && Cr !== null) {
    Xu = !0
    var e = 0,
      t = Re
    try {
      var r = Cr
      for (Re = 1; e < r.length; e++) {
        var i = r[e]
        do i = i(!0)
        while (i !== null)
      }
      ;(Cr = null), (Wo = !1)
    } catch (n) {
      throw (Cr !== null && (Cr = Cr.slice(e + 1)), u0(gf, hi), n)
    } finally {
      ;(Re = t), (Xu = !1)
    }
  }
  return null
}
var an = [],
  on = 0,
  vo = null,
  Eo = 0,
  $t = [],
  Vt = 0,
  Ni = null,
  kr = 1,
  wr = ''
function bi(e, t) {
  ;(an[on++] = Eo), (an[on++] = vo), (vo = e), (Eo = t)
}
function M0(e, t, r) {
  ;($t[Vt++] = kr), ($t[Vt++] = wr), ($t[Vt++] = Ni), (Ni = e)
  var i = kr
  e = wr
  var n = 32 - ir(i) - 1
  ;(i &= ~(1 << n)), (r += 1)
  var s = 32 - ir(t) + n
  if (30 < s) {
    var a = n - (n % 5)
    ;(s = (i & ((1 << a) - 1)).toString(32)),
      (i >>= a),
      (n -= a),
      (kr = (1 << (32 - ir(t) + n)) | (r << n) | i),
      (wr = s + e)
  } else (kr = (1 << s) | (r << n) | i), (wr = e)
}
function Sf(e) {
  e.return !== null && (bi(e, 1), M0(e, 1, 0))
}
function Cf(e) {
  for (; e === vo; ) (vo = an[--on]), (an[on] = null), (Eo = an[--on]), (an[on] = null)
  for (; e === Ni; )
    (Ni = $t[--Vt]),
      ($t[Vt] = null),
      (wr = $t[--Vt]),
      ($t[Vt] = null),
      (kr = $t[--Vt]),
      ($t[Vt] = null)
}
var Pt = null,
  Lt = null,
  qe = !1,
  tr = null
function U0(e, t) {
  var r = Xt(5, null, null, 0)
  ;(r.elementType = 'DELETED'),
    (r.stateNode = t),
    (r.return = e),
    (t = e.deletions),
    t === null ? ((e.deletions = [r]), (e.flags |= 16)) : t.push(r)
}
function yh(e, t) {
  switch (e.tag) {
    case 5:
      var r = e.type
      return (
        (t = t.nodeType !== 1 || r.toLowerCase() !== t.nodeName.toLowerCase() ? null : t),
        t !== null ? ((e.stateNode = t), (Pt = e), (Lt = ei(t.firstChild)), !0) : !1
      )
    case 6:
      return (
        (t = e.pendingProps === '' || t.nodeType !== 3 ? null : t),
        t !== null ? ((e.stateNode = t), (Pt = e), (Lt = null), !0) : !1
      )
    case 13:
      return (
        (t = t.nodeType !== 8 ? null : t),
        t !== null
          ? ((r = Ni !== null ? { id: kr, overflow: wr } : null),
            (e.memoizedState = { dehydrated: t, treeContext: r, retryLane: 1073741824 }),
            (r = Xt(18, null, null, 0)),
            (r.stateNode = t),
            (r.return = e),
            (e.child = r),
            (Pt = e),
            (Lt = null),
            !0)
          : !1
      )
    default:
      return !1
  }
}
function sc(e) {
  return (e.mode & 1) !== 0 && (e.flags & 128) === 0
}
function ac(e) {
  if (qe) {
    var t = Lt
    if (t) {
      var r = t
      if (!yh(e, t)) {
        if (sc(e)) throw Error(ue(418))
        t = ei(r.nextSibling)
        var i = Pt
        t && yh(e, t) ? U0(i, r) : ((e.flags = (e.flags & -4097) | 2), (qe = !1), (Pt = e))
      }
    } else {
      if (sc(e)) throw Error(ue(418))
      ;(e.flags = (e.flags & -4097) | 2), (qe = !1), (Pt = e)
    }
  }
}
function _h(e) {
  for (e = e.return; e !== null && e.tag !== 5 && e.tag !== 3 && e.tag !== 13; ) e = e.return
  Pt = e
}
function ka(e) {
  if (e !== Pt) return !1
  if (!qe) return _h(e), (qe = !0), !1
  var t
  if (
    ((t = e.tag !== 3) &&
      !(t = e.tag !== 5) &&
      ((t = e.type), (t = t !== 'head' && t !== 'body' && !tc(e.type, e.memoizedProps))),
    t && (t = Lt))
  ) {
    if (sc(e)) throw (H0(), Error(ue(418)))
    for (; t; ) U0(e, t), (t = ei(t.nextSibling))
  }
  if ((_h(e), e.tag === 13)) {
    if (((e = e.memoizedState), (e = e !== null ? e.dehydrated : null), !e)) throw Error(ue(317))
    e: {
      for (e = e.nextSibling, t = 0; e; ) {
        if (e.nodeType === 8) {
          var r = e.data
          if (r === '/$') {
            if (t === 0) {
              Lt = ei(e.nextSibling)
              break e
            }
            t--
          } else (r !== '$' && r !== '$!' && r !== '$?') || t++
        }
        e = e.nextSibling
      }
      Lt = null
    }
  } else Lt = Pt ? ei(e.stateNode.nextSibling) : null
  return !0
}
function H0() {
  for (var e = Lt; e; ) e = ei(e.nextSibling)
}
function Cn() {
  ;(Lt = Pt = null), (qe = !1)
}
function kf(e) {
  tr === null ? (tr = [e]) : tr.push(e)
}
var Cv = Br.ReactCurrentBatchConfig
function Zt(e, t) {
  if (e && e.defaultProps) {
    ;(t = Xe({}, t)), (e = e.defaultProps)
    for (var r in e) t[r] === void 0 && (t[r] = e[r])
    return t
  }
  return t
}
var xo = pi(null),
  To = null,
  un = null,
  wf = null
function Nf() {
  wf = un = To = null
}
function Of(e) {
  var t = xo.current
  He(xo), (e._currentValue = t)
}
function oc(e, t, r) {
  for (; e !== null; ) {
    var i = e.alternate
    if (
      ((e.childLanes & t) !== t
        ? ((e.childLanes |= t), i !== null && (i.childLanes |= t))
        : i !== null && (i.childLanes & t) !== t && (i.childLanes |= t),
      e === r)
    )
      break
    e = e.return
  }
}
function _n(e, t) {
  ;(To = e),
    (wf = un = null),
    (e = e.dependencies),
    e !== null && e.firstContext !== null && (e.lanes & t && (Ct = !0), (e.firstContext = null))
}
function Wt(e) {
  var t = e._currentValue
  if (wf !== e)
    if (((e = { context: e, memoizedValue: t, next: null }), un === null)) {
      if (To === null) throw Error(ue(308))
      ;(un = e), (To.dependencies = { lanes: 0, firstContext: e })
    } else un = un.next = e
  return t
}
var xi = null
function If(e) {
  xi === null ? (xi = [e]) : xi.push(e)
}
function z0(e, t, r, i) {
  var n = t.interleaved
  return (
    n === null ? ((r.next = r), If(t)) : ((r.next = n.next), (n.next = r)),
    (t.interleaved = r),
    Dr(e, i)
  )
}
function Dr(e, t) {
  e.lanes |= t
  var r = e.alternate
  for (r !== null && (r.lanes |= t), r = e, e = e.return; e !== null; )
    (e.childLanes |= t),
      (r = e.alternate),
      r !== null && (r.childLanes |= t),
      (r = e),
      (e = e.return)
  return r.tag === 3 ? r.stateNode : null
}
var Vr = !1
function Df(e) {
  e.updateQueue = {
    baseState: e.memoizedState,
    firstBaseUpdate: null,
    lastBaseUpdate: null,
    shared: { pending: null, interleaved: null, lanes: 0 },
    effects: null,
  }
}
function j0(e, t) {
  ;(e = e.updateQueue),
    t.updateQueue === e &&
      (t.updateQueue = {
        baseState: e.baseState,
        firstBaseUpdate: e.firstBaseUpdate,
        lastBaseUpdate: e.lastBaseUpdate,
        shared: e.shared,
        effects: e.effects,
      })
}
function Nr(e, t) {
  return { eventTime: e, lane: t, tag: 0, payload: null, callback: null, next: null }
}
function ti(e, t, r) {
  var i = e.updateQueue
  if (i === null) return null
  if (((i = i.shared), Ie & 2)) {
    var n = i.pending
    return n === null ? (t.next = t) : ((t.next = n.next), (n.next = t)), (i.pending = t), Dr(e, r)
  }
  return (
    (n = i.interleaved),
    n === null ? ((t.next = t), If(i)) : ((t.next = n.next), (n.next = t)),
    (i.interleaved = t),
    Dr(e, r)
  )
}
function Ya(e, t, r) {
  if (((t = t.updateQueue), t !== null && ((t = t.shared), (r & 4194240) !== 0))) {
    var i = t.lanes
    ;(i &= e.pendingLanes), (r |= i), (t.lanes = r), bf(e, r)
  }
}
function vh(e, t) {
  var r = e.updateQueue,
    i = e.alternate
  if (i !== null && ((i = i.updateQueue), r === i)) {
    var n = null,
      s = null
    if (((r = r.firstBaseUpdate), r !== null)) {
      do {
        var a = {
          eventTime: r.eventTime,
          lane: r.lane,
          tag: r.tag,
          payload: r.payload,
          callback: r.callback,
          next: null,
        }
        s === null ? (n = s = a) : (s = s.next = a), (r = r.next)
      } while (r !== null)
      s === null ? (n = s = t) : (s = s.next = t)
    } else n = s = t
    ;(r = {
      baseState: i.baseState,
      firstBaseUpdate: n,
      lastBaseUpdate: s,
      shared: i.shared,
      effects: i.effects,
    }),
      (e.updateQueue = r)
    return
  }
  ;(e = r.lastBaseUpdate),
    e === null ? (r.firstBaseUpdate = t) : (e.next = t),
    (r.lastBaseUpdate = t)
}
function Ao(e, t, r, i) {
  var n = e.updateQueue
  Vr = !1
  var s = n.firstBaseUpdate,
    a = n.lastBaseUpdate,
    o = n.shared.pending
  if (o !== null) {
    n.shared.pending = null
    var u = o,
      c = u.next
    ;(u.next = null), a === null ? (s = c) : (a.next = c), (a = u)
    var f = e.alternate
    f !== null &&
      ((f = f.updateQueue),
      (o = f.lastBaseUpdate),
      o !== a && (o === null ? (f.firstBaseUpdate = c) : (o.next = c), (f.lastBaseUpdate = u)))
  }
  if (s !== null) {
    var h = n.baseState
    ;(a = 0), (f = c = u = null), (o = s)
    do {
      var p = o.lane,
        m = o.eventTime
      if ((i & p) === p) {
        f !== null &&
          (f = f.next =
            {
              eventTime: m,
              lane: 0,
              tag: o.tag,
              payload: o.payload,
              callback: o.callback,
              next: null,
            })
        e: {
          var v = e,
            b = o
          switch (((p = t), (m = r), b.tag)) {
            case 1:
              if (((v = b.payload), typeof v == 'function')) {
                h = v.call(m, h, p)
                break e
              }
              h = v
              break e
            case 3:
              v.flags = (v.flags & -65537) | 128
            case 0:
              if (((v = b.payload), (p = typeof v == 'function' ? v.call(m, h, p) : v), p == null))
                break e
              h = Xe({}, h, p)
              break e
            case 2:
              Vr = !0
          }
        }
        o.callback !== null &&
          o.lane !== 0 &&
          ((e.flags |= 64), (p = n.effects), p === null ? (n.effects = [o]) : p.push(o))
      } else
        (m = {
          eventTime: m,
          lane: p,
          tag: o.tag,
          payload: o.payload,
          callback: o.callback,
          next: null,
        }),
          f === null ? ((c = f = m), (u = h)) : (f = f.next = m),
          (a |= p)
      if (((o = o.next), o === null)) {
        if (((o = n.shared.pending), o === null)) break
        ;(p = o), (o = p.next), (p.next = null), (n.lastBaseUpdate = p), (n.shared.pending = null)
      }
    } while (1)
    if (
      (f === null && (u = h),
      (n.baseState = u),
      (n.firstBaseUpdate = c),
      (n.lastBaseUpdate = f),
      (t = n.shared.interleaved),
      t !== null)
    ) {
      n = t
      do (a |= n.lane), (n = n.next)
      while (n !== t)
    } else s === null && (n.shared.lanes = 0)
    ;(Ii |= a), (e.lanes = a), (e.memoizedState = h)
  }
}
function Eh(e, t, r) {
  if (((e = t.effects), (t.effects = null), e !== null))
    for (t = 0; t < e.length; t++) {
      var i = e[t],
        n = i.callback
      if (n !== null) {
        if (((i.callback = null), (i = r), typeof n != 'function')) throw Error(ue(191, n))
        n.call(i)
      }
    }
}
var q0 = new zd.Component().refs
function uc(e, t, r, i) {
  ;(t = e.memoizedState),
    (r = r(i, t)),
    (r = r == null ? t : Xe({}, t, r)),
    (e.memoizedState = r),
    e.lanes === 0 && (e.updateQueue.baseState = r)
}
var Qo = {
  isMounted: function (e) {
    return (e = e._reactInternals) ? zi(e) === e : !1
  },
  enqueueSetState: function (e, t, r) {
    e = e._reactInternals
    var i = yt(),
      n = ii(e),
      s = Nr(i, n)
    ;(s.payload = t),
      r != null && (s.callback = r),
      (t = ti(e, s, n)),
      t !== null && (nr(t, e, n, i), Ya(t, e, n))
  },
  enqueueReplaceState: function (e, t, r) {
    e = e._reactInternals
    var i = yt(),
      n = ii(e),
      s = Nr(i, n)
    ;(s.tag = 1),
      (s.payload = t),
      r != null && (s.callback = r),
      (t = ti(e, s, n)),
      t !== null && (nr(t, e, n, i), Ya(t, e, n))
  },
  enqueueForceUpdate: function (e, t) {
    e = e._reactInternals
    var r = yt(),
      i = ii(e),
      n = Nr(r, i)
    ;(n.tag = 2),
      t != null && (n.callback = t),
      (t = ti(e, n, i)),
      t !== null && (nr(t, e, i, r), Ya(t, e, i))
  },
}
function xh(e, t, r, i, n, s, a) {
  return (
    (e = e.stateNode),
    typeof e.shouldComponentUpdate == 'function'
      ? e.shouldComponentUpdate(i, s, a)
      : t.prototype && t.prototype.isPureReactComponent
      ? !Is(r, i) || !Is(n, s)
      : !0
  )
}
function $0(e, t, r) {
  var i = !1,
    n = ui,
    s = t.contextType
  return (
    typeof s == 'object' && s !== null
      ? (s = Wt(s))
      : ((n = wt(t) ? wi : mt.current),
        (i = t.contextTypes),
        (s = (i = i != null) ? Sn(e, n) : ui)),
    (t = new t(r, s)),
    (e.memoizedState = t.state !== null && t.state !== void 0 ? t.state : null),
    (t.updater = Qo),
    (e.stateNode = t),
    (t._reactInternals = e),
    i &&
      ((e = e.stateNode),
      (e.__reactInternalMemoizedUnmaskedChildContext = n),
      (e.__reactInternalMemoizedMaskedChildContext = s)),
    t
  )
}
function Th(e, t, r, i) {
  ;(e = t.state),
    typeof t.componentWillReceiveProps == 'function' && t.componentWillReceiveProps(r, i),
    typeof t.UNSAFE_componentWillReceiveProps == 'function' &&
      t.UNSAFE_componentWillReceiveProps(r, i),
    t.state !== e && Qo.enqueueReplaceState(t, t.state, null)
}
function lc(e, t, r, i) {
  var n = e.stateNode
  ;(n.props = r), (n.state = e.memoizedState), (n.refs = q0), Df(e)
  var s = t.contextType
  typeof s == 'object' && s !== null
    ? (n.context = Wt(s))
    : ((s = wt(t) ? wi : mt.current), (n.context = Sn(e, s))),
    (n.state = e.memoizedState),
    (s = t.getDerivedStateFromProps),
    typeof s == 'function' && (uc(e, t, s, r), (n.state = e.memoizedState)),
    typeof t.getDerivedStateFromProps == 'function' ||
      typeof n.getSnapshotBeforeUpdate == 'function' ||
      (typeof n.UNSAFE_componentWillMount != 'function' &&
        typeof n.componentWillMount != 'function') ||
      ((t = n.state),
      typeof n.componentWillMount == 'function' && n.componentWillMount(),
      typeof n.UNSAFE_componentWillMount == 'function' && n.UNSAFE_componentWillMount(),
      t !== n.state && Qo.enqueueReplaceState(n, n.state, null),
      Ao(e, r, n, i),
      (n.state = e.memoizedState)),
    typeof n.componentDidMount == 'function' && (e.flags |= 4194308)
}
function Gn(e, t, r) {
  if (((e = r.ref), e !== null && typeof e != 'function' && typeof e != 'object')) {
    if (r._owner) {
      if (((r = r._owner), r)) {
        if (r.tag !== 1) throw Error(ue(309))
        var i = r.stateNode
      }
      if (!i) throw Error(ue(147, e))
      var n = i,
        s = '' + e
      return t !== null && t.ref !== null && typeof t.ref == 'function' && t.ref._stringRef === s
        ? t.ref
        : ((t = function (a) {
            var o = n.refs
            o === q0 && (o = n.refs = {}), a === null ? delete o[s] : (o[s] = a)
          }),
          (t._stringRef = s),
          t)
    }
    if (typeof e != 'string') throw Error(ue(284))
    if (!r._owner) throw Error(ue(290, e))
  }
  return e
}
function wa(e, t) {
  throw (
    ((e = Object.prototype.toString.call(t)),
    Error(
      ue(31, e === '[object Object]' ? 'object with keys {' + Object.keys(t).join(', ') + '}' : e)
    ))
  )
}
function Ah(e) {
  var t = e._init
  return t(e._payload)
}
function V0(e) {
  function t(g, _) {
    if (e) {
      var y = g.deletions
      y === null ? ((g.deletions = [_]), (g.flags |= 16)) : y.push(_)
    }
  }
  function r(g, _) {
    if (!e) return null
    for (; _ !== null; ) t(g, _), (_ = _.sibling)
    return null
  }
  function i(g, _) {
    for (g = new Map(); _ !== null; )
      _.key !== null ? g.set(_.key, _) : g.set(_.index, _), (_ = _.sibling)
    return g
  }
  function n(g, _) {
    return (g = ni(g, _)), (g.index = 0), (g.sibling = null), g
  }
  function s(g, _, y) {
    return (
      (g.index = y),
      e
        ? ((y = g.alternate),
          y !== null ? ((y = y.index), y < _ ? ((g.flags |= 2), _) : y) : ((g.flags |= 2), _))
        : ((g.flags |= 1048576), _)
    )
  }
  function a(g) {
    return e && g.alternate === null && (g.flags |= 2), g
  }
  function o(g, _, y, x) {
    return _ === null || _.tag !== 6
      ? ((_ = el(y, g.mode, x)), (_.return = g), _)
      : ((_ = n(_, y)), (_.return = g), _)
  }
  function u(g, _, y, x) {
    var D = y.type
    return D === Zi
      ? f(g, _, y.props.children, x, y.key)
      : _ !== null &&
        (_.elementType === D ||
          (typeof D == 'object' && D !== null && D.$$typeof === $r && Ah(D) === _.type))
      ? ((x = n(_, y.props)), (x.ref = Gn(g, _, y)), (x.return = g), x)
      : ((x = eo(y.type, y.key, y.props, null, g.mode, x)),
        (x.ref = Gn(g, _, y)),
        (x.return = g),
        x)
  }
  function c(g, _, y, x) {
    return _ === null ||
      _.tag !== 4 ||
      _.stateNode.containerInfo !== y.containerInfo ||
      _.stateNode.implementation !== y.implementation
      ? ((_ = tl(y, g.mode, x)), (_.return = g), _)
      : ((_ = n(_, y.children || [])), (_.return = g), _)
  }
  function f(g, _, y, x, D) {
    return _ === null || _.tag !== 7
      ? ((_ = Ci(y, g.mode, x, D)), (_.return = g), _)
      : ((_ = n(_, y)), (_.return = g), _)
  }
  function h(g, _, y) {
    if ((typeof _ == 'string' && _ !== '') || typeof _ == 'number')
      return (_ = el('' + _, g.mode, y)), (_.return = g), _
    if (typeof _ == 'object' && _ !== null) {
      switch (_.$$typeof) {
        case ba:
          return (
            (y = eo(_.type, _.key, _.props, null, g.mode, y)),
            (y.ref = Gn(g, null, _)),
            (y.return = g),
            y
          )
        case Ji:
          return (_ = tl(_, g.mode, y)), (_.return = g), _
        case $r:
          var x = _._init
          return h(g, x(_._payload), y)
      }
      if (is(_) || zn(_)) return (_ = Ci(_, g.mode, y, null)), (_.return = g), _
      wa(g, _)
    }
    return null
  }
  function p(g, _, y, x) {
    var D = _ !== null ? _.key : null
    if ((typeof y == 'string' && y !== '') || typeof y == 'number')
      return D !== null ? null : o(g, _, '' + y, x)
    if (typeof y == 'object' && y !== null) {
      switch (y.$$typeof) {
        case ba:
          return y.key === D ? u(g, _, y, x) : null
        case Ji:
          return y.key === D ? c(g, _, y, x) : null
        case $r:
          return (D = y._init), p(g, _, D(y._payload), x)
      }
      if (is(y) || zn(y)) return D !== null ? null : f(g, _, y, x, null)
      wa(g, y)
    }
    return null
  }
  function m(g, _, y, x, D) {
    if ((typeof x == 'string' && x !== '') || typeof x == 'number')
      return (g = g.get(y) || null), o(_, g, '' + x, D)
    if (typeof x == 'object' && x !== null) {
      switch (x.$$typeof) {
        case ba:
          return (g = g.get(x.key === null ? y : x.key) || null), u(_, g, x, D)
        case Ji:
          return (g = g.get(x.key === null ? y : x.key) || null), c(_, g, x, D)
        case $r:
          var C = x._init
          return m(g, _, y, C(x._payload), D)
      }
      if (is(x) || zn(x)) return (g = g.get(y) || null), f(_, g, x, D, null)
      wa(_, x)
    }
    return null
  }
  function v(g, _, y, x) {
    for (var D = null, C = null, H = _, T = (_ = 0), k = null; H !== null && T < y.length; T++) {
      H.index > T ? ((k = H), (H = null)) : (k = H.sibling)
      var O = p(g, H, y[T], x)
      if (O === null) {
        H === null && (H = k)
        break
      }
      e && H && O.alternate === null && t(g, H),
        (_ = s(O, _, T)),
        C === null ? (D = O) : (C.sibling = O),
        (C = O),
        (H = k)
    }
    if (T === y.length) return r(g, H), qe && bi(g, T), D
    if (H === null) {
      for (; T < y.length; T++)
        (H = h(g, y[T], x)),
          H !== null && ((_ = s(H, _, T)), C === null ? (D = H) : (C.sibling = H), (C = H))
      return qe && bi(g, T), D
    }
    for (H = i(g, H); T < y.length; T++)
      (k = m(H, g, T, y[T], x)),
        k !== null &&
          (e && k.alternate !== null && H.delete(k.key === null ? T : k.key),
          (_ = s(k, _, T)),
          C === null ? (D = k) : (C.sibling = k),
          (C = k))
    return (
      e &&
        H.forEach(function (N) {
          return t(g, N)
        }),
      qe && bi(g, T),
      D
    )
  }
  function b(g, _, y, x) {
    var D = zn(y)
    if (typeof D != 'function') throw Error(ue(150))
    if (((y = D.call(y)), y == null)) throw Error(ue(151))
    for (
      var C = (D = null), H = _, T = (_ = 0), k = null, O = y.next();
      H !== null && !O.done;
      T++, O = y.next()
    ) {
      H.index > T ? ((k = H), (H = null)) : (k = H.sibling)
      var N = p(g, H, O.value, x)
      if (N === null) {
        H === null && (H = k)
        break
      }
      e && H && N.alternate === null && t(g, H),
        (_ = s(N, _, T)),
        C === null ? (D = N) : (C.sibling = N),
        (C = N),
        (H = k)
    }
    if (O.done) return r(g, H), qe && bi(g, T), D
    if (H === null) {
      for (; !O.done; T++, O = y.next())
        (O = h(g, O.value, x)),
          O !== null && ((_ = s(O, _, T)), C === null ? (D = O) : (C.sibling = O), (C = O))
      return qe && bi(g, T), D
    }
    for (H = i(g, H); !O.done; T++, O = y.next())
      (O = m(H, g, T, O.value, x)),
        O !== null &&
          (e && O.alternate !== null && H.delete(O.key === null ? T : O.key),
          (_ = s(O, _, T)),
          C === null ? (D = O) : (C.sibling = O),
          (C = O))
    return (
      e &&
        H.forEach(function (M) {
          return t(g, M)
        }),
      qe && bi(g, T),
      D
    )
  }
  function S(g, _, y, x) {
    if (
      (typeof y == 'object' &&
        y !== null &&
        y.type === Zi &&
        y.key === null &&
        (y = y.props.children),
      typeof y == 'object' && y !== null)
    ) {
      switch (y.$$typeof) {
        case ba:
          e: {
            for (var D = y.key, C = _; C !== null; ) {
              if (C.key === D) {
                if (((D = y.type), D === Zi)) {
                  if (C.tag === 7) {
                    r(g, C.sibling), (_ = n(C, y.props.children)), (_.return = g), (g = _)
                    break e
                  }
                } else if (
                  C.elementType === D ||
                  (typeof D == 'object' && D !== null && D.$$typeof === $r && Ah(D) === C.type)
                ) {
                  r(g, C.sibling),
                    (_ = n(C, y.props)),
                    (_.ref = Gn(g, C, y)),
                    (_.return = g),
                    (g = _)
                  break e
                }
                r(g, C)
                break
              } else t(g, C)
              C = C.sibling
            }
            y.type === Zi
              ? ((_ = Ci(y.props.children, g.mode, x, y.key)), (_.return = g), (g = _))
              : ((x = eo(y.type, y.key, y.props, null, g.mode, x)),
                (x.ref = Gn(g, _, y)),
                (x.return = g),
                (g = x))
          }
          return a(g)
        case Ji:
          e: {
            for (C = y.key; _ !== null; ) {
              if (_.key === C)
                if (
                  _.tag === 4 &&
                  _.stateNode.containerInfo === y.containerInfo &&
                  _.stateNode.implementation === y.implementation
                ) {
                  r(g, _.sibling), (_ = n(_, y.children || [])), (_.return = g), (g = _)
                  break e
                } else {
                  r(g, _)
                  break
                }
              else t(g, _)
              _ = _.sibling
            }
            ;(_ = tl(y, g.mode, x)), (_.return = g), (g = _)
          }
          return a(g)
        case $r:
          return (C = y._init), S(g, _, C(y._payload), x)
      }
      if (is(y)) return v(g, _, y, x)
      if (zn(y)) return b(g, _, y, x)
      wa(g, y)
    }
    return (typeof y == 'string' && y !== '') || typeof y == 'number'
      ? ((y = '' + y),
        _ !== null && _.tag === 6
          ? (r(g, _.sibling), (_ = n(_, y)), (_.return = g), (g = _))
          : (r(g, _), (_ = el(y, g.mode, x)), (_.return = g), (g = _)),
        a(g))
      : r(g, _)
  }
  return S
}
var kn = V0(!0),
  G0 = V0(!1),
  ia = {},
  yr = pi(ia),
  Ps = pi(ia),
  Bs = pi(ia)
function Ti(e) {
  if (e === ia) throw Error(ue(174))
  return e
}
function Rf(e, t) {
  switch ((Fe(Bs, t), Fe(Ps, e), Fe(yr, ia), (e = t.nodeType), e)) {
    case 9:
    case 11:
      t = (t = t.documentElement) ? t.namespaceURI : zl(null, '')
      break
    default:
      ;(e = e === 8 ? t.parentNode : t),
        (t = e.namespaceURI || null),
        (e = e.tagName),
        (t = zl(t, e))
  }
  He(yr), Fe(yr, t)
}
function wn() {
  He(yr), He(Ps), He(Bs)
}
function X0(e) {
  Ti(Bs.current)
  var t = Ti(yr.current),
    r = zl(t, e.type)
  t !== r && (Fe(Ps, e), Fe(yr, r))
}
function Lf(e) {
  Ps.current === e && (He(yr), He(Ps))
}
var Ve = pi(0)
function So(e) {
  for (var t = e; t !== null; ) {
    if (t.tag === 13) {
      var r = t.memoizedState
      if (r !== null && ((r = r.dehydrated), r === null || r.data === '$?' || r.data === '$!'))
        return t
    } else if (t.tag === 19 && t.memoizedProps.revealOrder !== void 0) {
      if (t.flags & 128) return t
    } else if (t.child !== null) {
      ;(t.child.return = t), (t = t.child)
      continue
    }
    if (t === e) break
    for (; t.sibling === null; ) {
      if (t.return === null || t.return === e) return null
      t = t.return
    }
    ;(t.sibling.return = t.return), (t = t.sibling)
  }
  return null
}
var Yu = []
function Pf() {
  for (var e = 0; e < Yu.length; e++) Yu[e]._workInProgressVersionPrimary = null
  Yu.length = 0
}
var Wa = Br.ReactCurrentDispatcher,
  Wu = Br.ReactCurrentBatchConfig,
  Oi = 0,
  Ge = null,
  Je = null,
  it = null,
  Co = !1,
  ps = !1,
  Fs = 0,
  kv = 0
function ct() {
  throw Error(ue(321))
}
function Bf(e, t) {
  if (t === null) return !1
  for (var r = 0; r < t.length && r < e.length; r++) if (!ar(e[r], t[r])) return !1
  return !0
}
function Ff(e, t, r, i, n, s) {
  if (
    ((Oi = s),
    (Ge = t),
    (t.memoizedState = null),
    (t.updateQueue = null),
    (t.lanes = 0),
    (Wa.current = e === null || e.memoizedState === null ? Iv : Dv),
    (e = r(i, n)),
    ps)
  ) {
    s = 0
    do {
      if (((ps = !1), (Fs = 0), 25 <= s)) throw Error(ue(301))
      ;(s += 1), (it = Je = null), (t.updateQueue = null), (Wa.current = Rv), (e = r(i, n))
    } while (ps)
  }
  if (
    ((Wa.current = ko),
    (t = Je !== null && Je.next !== null),
    (Oi = 0),
    (it = Je = Ge = null),
    (Co = !1),
    t)
  )
    throw Error(ue(300))
  return e
}
function Mf() {
  var e = Fs !== 0
  return (Fs = 0), e
}
function fr() {
  var e = { memoizedState: null, baseState: null, baseQueue: null, queue: null, next: null }
  return it === null ? (Ge.memoizedState = it = e) : (it = it.next = e), it
}
function Qt() {
  if (Je === null) {
    var e = Ge.alternate
    e = e !== null ? e.memoizedState : null
  } else e = Je.next
  var t = it === null ? Ge.memoizedState : it.next
  if (t !== null) (it = t), (Je = e)
  else {
    if (e === null) throw Error(ue(310))
    ;(Je = e),
      (e = {
        memoizedState: Je.memoizedState,
        baseState: Je.baseState,
        baseQueue: Je.baseQueue,
        queue: Je.queue,
        next: null,
      }),
      it === null ? (Ge.memoizedState = it = e) : (it = it.next = e)
  }
  return it
}
function Ms(e, t) {
  return typeof t == 'function' ? t(e) : t
}
function Qu(e) {
  var t = Qt(),
    r = t.queue
  if (r === null) throw Error(ue(311))
  r.lastRenderedReducer = e
  var i = Je,
    n = i.baseQueue,
    s = r.pending
  if (s !== null) {
    if (n !== null) {
      var a = n.next
      ;(n.next = s.next), (s.next = a)
    }
    ;(i.baseQueue = n = s), (r.pending = null)
  }
  if (n !== null) {
    ;(s = n.next), (i = i.baseState)
    var o = (a = null),
      u = null,
      c = s
    do {
      var f = c.lane
      if ((Oi & f) === f)
        u !== null &&
          (u = u.next =
            {
              lane: 0,
              action: c.action,
              hasEagerState: c.hasEagerState,
              eagerState: c.eagerState,
              next: null,
            }),
          (i = c.hasEagerState ? c.eagerState : e(i, c.action))
      else {
        var h = {
          lane: f,
          action: c.action,
          hasEagerState: c.hasEagerState,
          eagerState: c.eagerState,
          next: null,
        }
        u === null ? ((o = u = h), (a = i)) : (u = u.next = h), (Ge.lanes |= f), (Ii |= f)
      }
      c = c.next
    } while (c !== null && c !== s)
    u === null ? (a = i) : (u.next = o),
      ar(i, t.memoizedState) || (Ct = !0),
      (t.memoizedState = i),
      (t.baseState = a),
      (t.baseQueue = u),
      (r.lastRenderedState = i)
  }
  if (((e = r.interleaved), e !== null)) {
    n = e
    do (s = n.lane), (Ge.lanes |= s), (Ii |= s), (n = n.next)
    while (n !== e)
  } else n === null && (r.lanes = 0)
  return [t.memoizedState, r.dispatch]
}
function Ku(e) {
  var t = Qt(),
    r = t.queue
  if (r === null) throw Error(ue(311))
  r.lastRenderedReducer = e
  var i = r.dispatch,
    n = r.pending,
    s = t.memoizedState
  if (n !== null) {
    r.pending = null
    var a = (n = n.next)
    do (s = e(s, a.action)), (a = a.next)
    while (a !== n)
    ar(s, t.memoizedState) || (Ct = !0),
      (t.memoizedState = s),
      t.baseQueue === null && (t.baseState = s),
      (r.lastRenderedState = s)
  }
  return [s, i]
}
function Y0() {}
function W0(e, t) {
  var r = Ge,
    i = Qt(),
    n = t(),
    s = !ar(i.memoizedState, n)
  if (
    (s && ((i.memoizedState = n), (Ct = !0)),
    (i = i.queue),
    Uf(J0.bind(null, r, i, e), [e]),
    i.getSnapshot !== t || s || (it !== null && it.memoizedState.tag & 1))
  ) {
    if (((r.flags |= 2048), Us(9, K0.bind(null, r, i, n, t), void 0, null), st === null))
      throw Error(ue(349))
    Oi & 30 || Q0(r, t, n)
  }
  return n
}
function Q0(e, t, r) {
  ;(e.flags |= 16384),
    (e = { getSnapshot: t, value: r }),
    (t = Ge.updateQueue),
    t === null
      ? ((t = { lastEffect: null, stores: null }), (Ge.updateQueue = t), (t.stores = [e]))
      : ((r = t.stores), r === null ? (t.stores = [e]) : r.push(e))
}
function K0(e, t, r, i) {
  ;(t.value = r), (t.getSnapshot = i), Z0(t) && eg(e)
}
function J0(e, t, r) {
  return r(function () {
    Z0(t) && eg(e)
  })
}
function Z0(e) {
  var t = e.getSnapshot
  e = e.value
  try {
    var r = t()
    return !ar(e, r)
  } catch {
    return !0
  }
}
function eg(e) {
  var t = Dr(e, 1)
  t !== null && nr(t, e, 1, -1)
}
function Sh(e) {
  var t = fr()
  return (
    typeof e == 'function' && (e = e()),
    (t.memoizedState = t.baseState = e),
    (e = {
      pending: null,
      interleaved: null,
      lanes: 0,
      dispatch: null,
      lastRenderedReducer: Ms,
      lastRenderedState: e,
    }),
    (t.queue = e),
    (e = e.dispatch = Ov.bind(null, Ge, e)),
    [t.memoizedState, e]
  )
}
function Us(e, t, r, i) {
  return (
    (e = { tag: e, create: t, destroy: r, deps: i, next: null }),
    (t = Ge.updateQueue),
    t === null
      ? ((t = { lastEffect: null, stores: null }),
        (Ge.updateQueue = t),
        (t.lastEffect = e.next = e))
      : ((r = t.lastEffect),
        r === null
          ? (t.lastEffect = e.next = e)
          : ((i = r.next), (r.next = e), (e.next = i), (t.lastEffect = e))),
    e
  )
}
function tg() {
  return Qt().memoizedState
}
function Qa(e, t, r, i) {
  var n = fr()
  ;(Ge.flags |= e), (n.memoizedState = Us(1 | t, r, void 0, i === void 0 ? null : i))
}
function Ko(e, t, r, i) {
  var n = Qt()
  i = i === void 0 ? null : i
  var s = void 0
  if (Je !== null) {
    var a = Je.memoizedState
    if (((s = a.destroy), i !== null && Bf(i, a.deps))) {
      n.memoizedState = Us(t, r, s, i)
      return
    }
  }
  ;(Ge.flags |= e), (n.memoizedState = Us(1 | t, r, s, i))
}
function Ch(e, t) {
  return Qa(8390656, 8, e, t)
}
function Uf(e, t) {
  return Ko(2048, 8, e, t)
}
function rg(e, t) {
  return Ko(4, 2, e, t)
}
function ig(e, t) {
  return Ko(4, 4, e, t)
}
function ng(e, t) {
  if (typeof t == 'function')
    return (
      (e = e()),
      t(e),
      function () {
        t(null)
      }
    )
  if (t != null)
    return (
      (e = e()),
      (t.current = e),
      function () {
        t.current = null
      }
    )
}
function sg(e, t, r) {
  return (r = r != null ? r.concat([e]) : null), Ko(4, 4, ng.bind(null, t, e), r)
}
function Hf() {}
function ag(e, t) {
  var r = Qt()
  t = t === void 0 ? null : t
  var i = r.memoizedState
  return i !== null && t !== null && Bf(t, i[1]) ? i[0] : ((r.memoizedState = [e, t]), e)
}
function og(e, t) {
  var r = Qt()
  t = t === void 0 ? null : t
  var i = r.memoizedState
  return i !== null && t !== null && Bf(t, i[1]) ? i[0] : ((e = e()), (r.memoizedState = [e, t]), e)
}
function ug(e, t, r) {
  return Oi & 21
    ? (ar(r, t) || ((r = f0()), (Ge.lanes |= r), (Ii |= r), (e.baseState = !0)), t)
    : (e.baseState && ((e.baseState = !1), (Ct = !0)), (e.memoizedState = r))
}
function wv(e, t) {
  var r = Re
  ;(Re = r !== 0 && 4 > r ? r : 4), e(!0)
  var i = Wu.transition
  Wu.transition = {}
  try {
    e(!1), t()
  } finally {
    ;(Re = r), (Wu.transition = i)
  }
}
function lg() {
  return Qt().memoizedState
}
function Nv(e, t, r) {
  var i = ii(e)
  if (((r = { lane: i, action: r, hasEagerState: !1, eagerState: null, next: null }), cg(e)))
    fg(t, r)
  else if (((r = z0(e, t, r, i)), r !== null)) {
    var n = yt()
    nr(r, e, i, n), pg(r, t, i)
  }
}
function Ov(e, t, r) {
  var i = ii(e),
    n = { lane: i, action: r, hasEagerState: !1, eagerState: null, next: null }
  if (cg(e)) fg(t, n)
  else {
    var s = e.alternate
    if (e.lanes === 0 && (s === null || s.lanes === 0) && ((s = t.lastRenderedReducer), s !== null))
      try {
        var a = t.lastRenderedState,
          o = s(a, r)
        if (((n.hasEagerState = !0), (n.eagerState = o), ar(o, a))) {
          var u = t.interleaved
          u === null ? ((n.next = n), If(t)) : ((n.next = u.next), (u.next = n)),
            (t.interleaved = n)
          return
        }
      } catch {
      } finally {
      }
    ;(r = z0(e, t, n, i)), r !== null && ((n = yt()), nr(r, e, i, n), pg(r, t, i))
  }
}
function cg(e) {
  var t = e.alternate
  return e === Ge || (t !== null && t === Ge)
}
function fg(e, t) {
  ps = Co = !0
  var r = e.pending
  r === null ? (t.next = t) : ((t.next = r.next), (r.next = t)), (e.pending = t)
}
function pg(e, t, r) {
  if (r & 4194240) {
    var i = t.lanes
    ;(i &= e.pendingLanes), (r |= i), (t.lanes = r), bf(e, r)
  }
}
var ko = {
    readContext: Wt,
    useCallback: ct,
    useContext: ct,
    useEffect: ct,
    useImperativeHandle: ct,
    useInsertionEffect: ct,
    useLayoutEffect: ct,
    useMemo: ct,
    useReducer: ct,
    useRef: ct,
    useState: ct,
    useDebugValue: ct,
    useDeferredValue: ct,
    useTransition: ct,
    useMutableSource: ct,
    useSyncExternalStore: ct,
    useId: ct,
    unstable_isNewReconciler: !1,
  },
  Iv = {
    readContext: Wt,
    useCallback: function (e, t) {
      return (fr().memoizedState = [e, t === void 0 ? null : t]), e
    },
    useContext: Wt,
    useEffect: Ch,
    useImperativeHandle: function (e, t, r) {
      return (r = r != null ? r.concat([e]) : null), Qa(4194308, 4, ng.bind(null, t, e), r)
    },
    useLayoutEffect: function (e, t) {
      return Qa(4194308, 4, e, t)
    },
    useInsertionEffect: function (e, t) {
      return Qa(4, 2, e, t)
    },
    useMemo: function (e, t) {
      var r = fr()
      return (t = t === void 0 ? null : t), (e = e()), (r.memoizedState = [e, t]), e
    },
    useReducer: function (e, t, r) {
      var i = fr()
      return (
        (t = r !== void 0 ? r(t) : t),
        (i.memoizedState = i.baseState = t),
        (e = {
          pending: null,
          interleaved: null,
          lanes: 0,
          dispatch: null,
          lastRenderedReducer: e,
          lastRenderedState: t,
        }),
        (i.queue = e),
        (e = e.dispatch = Nv.bind(null, Ge, e)),
        [i.memoizedState, e]
      )
    },
    useRef: function (e) {
      var t = fr()
      return (e = { current: e }), (t.memoizedState = e)
    },
    useState: Sh,
    useDebugValue: Hf,
    useDeferredValue: function (e) {
      return (fr().memoizedState = e)
    },
    useTransition: function () {
      var e = Sh(!1),
        t = e[0]
      return (e = wv.bind(null, e[1])), (fr().memoizedState = e), [t, e]
    },
    useMutableSource: function () {},
    useSyncExternalStore: function (e, t, r) {
      var i = Ge,
        n = fr()
      if (qe) {
        if (r === void 0) throw Error(ue(407))
        r = r()
      } else {
        if (((r = t()), st === null)) throw Error(ue(349))
        Oi & 30 || Q0(i, t, r)
      }
      n.memoizedState = r
      var s = { value: r, getSnapshot: t }
      return (
        (n.queue = s),
        Ch(J0.bind(null, i, s, e), [e]),
        (i.flags |= 2048),
        Us(9, K0.bind(null, i, s, r, t), void 0, null),
        r
      )
    },
    useId: function () {
      var e = fr(),
        t = st.identifierPrefix
      if (qe) {
        var r = wr,
          i = kr
        ;(r = (i & ~(1 << (32 - ir(i) - 1))).toString(32) + r),
          (t = ':' + t + 'R' + r),
          (r = Fs++),
          0 < r && (t += 'H' + r.toString(32)),
          (t += ':')
      } else (r = kv++), (t = ':' + t + 'r' + r.toString(32) + ':')
      return (e.memoizedState = t)
    },
    unstable_isNewReconciler: !1,
  },
  Dv = {
    readContext: Wt,
    useCallback: ag,
    useContext: Wt,
    useEffect: Uf,
    useImperativeHandle: sg,
    useInsertionEffect: rg,
    useLayoutEffect: ig,
    useMemo: og,
    useReducer: Qu,
    useRef: tg,
    useState: function () {
      return Qu(Ms)
    },
    useDebugValue: Hf,
    useDeferredValue: function (e) {
      var t = Qt()
      return ug(t, Je.memoizedState, e)
    },
    useTransition: function () {
      var e = Qu(Ms)[0],
        t = Qt().memoizedState
      return [e, t]
    },
    useMutableSource: Y0,
    useSyncExternalStore: W0,
    useId: lg,
    unstable_isNewReconciler: !1,
  },
  Rv = {
    readContext: Wt,
    useCallback: ag,
    useContext: Wt,
    useEffect: Uf,
    useImperativeHandle: sg,
    useInsertionEffect: rg,
    useLayoutEffect: ig,
    useMemo: og,
    useReducer: Ku,
    useRef: tg,
    useState: function () {
      return Ku(Ms)
    },
    useDebugValue: Hf,
    useDeferredValue: function (e) {
      var t = Qt()
      return Je === null ? (t.memoizedState = e) : ug(t, Je.memoizedState, e)
    },
    useTransition: function () {
      var e = Ku(Ms)[0],
        t = Qt().memoizedState
      return [e, t]
    },
    useMutableSource: Y0,
    useSyncExternalStore: W0,
    useId: lg,
    unstable_isNewReconciler: !1,
  }
function Nn(e, t) {
  try {
    var r = '',
      i = t
    do (r += o_(i)), (i = i.return)
    while (i)
    var n = r
  } catch (s) {
    n =
      `
Error generating stack: ` +
      s.message +
      `
` +
      s.stack
  }
  return { value: e, source: t, stack: n, digest: null }
}
function Ju(e, t, r) {
  return { value: e, source: null, stack: r ?? null, digest: t ?? null }
}
function cc(e, t) {
  try {
    console.error(t.value)
  } catch (r) {
    setTimeout(function () {
      throw r
    })
  }
}
var Lv = typeof WeakMap == 'function' ? WeakMap : Map
function hg(e, t, r) {
  ;(r = Nr(-1, r)), (r.tag = 3), (r.payload = { element: null })
  var i = t.value
  return (
    (r.callback = function () {
      No || ((No = !0), (vc = i)), cc(e, t)
    }),
    r
  )
}
function mg(e, t, r) {
  ;(r = Nr(-1, r)), (r.tag = 3)
  var i = e.type.getDerivedStateFromError
  if (typeof i == 'function') {
    var n = t.value
    ;(r.payload = function () {
      return i(n)
    }),
      (r.callback = function () {
        cc(e, t)
      })
  }
  var s = e.stateNode
  return (
    s !== null &&
      typeof s.componentDidCatch == 'function' &&
      (r.callback = function () {
        cc(e, t), typeof i != 'function' && (ri === null ? (ri = new Set([this])) : ri.add(this))
        var a = t.stack
        this.componentDidCatch(t.value, { componentStack: a !== null ? a : '' })
      }),
    r
  )
}
function kh(e, t, r) {
  var i = e.pingCache
  if (i === null) {
    i = e.pingCache = new Lv()
    var n = new Set()
    i.set(t, n)
  } else (n = i.get(t)), n === void 0 && ((n = new Set()), i.set(t, n))
  n.has(r) || (n.add(r), (e = Yv.bind(null, e, t, r)), t.then(e, e))
}
function wh(e) {
  do {
    var t
    if (
      ((t = e.tag === 13) && ((t = e.memoizedState), (t = t !== null ? t.dehydrated !== null : !0)),
      t)
    )
      return e
    e = e.return
  } while (e !== null)
  return null
}
function Nh(e, t, r, i, n) {
  return e.mode & 1
    ? ((e.flags |= 65536), (e.lanes = n), e)
    : (e === t
        ? (e.flags |= 65536)
        : ((e.flags |= 128),
          (r.flags |= 131072),
          (r.flags &= -52805),
          r.tag === 1 &&
            (r.alternate === null ? (r.tag = 17) : ((t = Nr(-1, 1)), (t.tag = 2), ti(r, t, 1))),
          (r.lanes |= 1)),
      e)
}
var Pv = Br.ReactCurrentOwner,
  Ct = !1
function gt(e, t, r, i) {
  t.child = e === null ? G0(t, null, r, i) : kn(t, e.child, r, i)
}
function Oh(e, t, r, i, n) {
  r = r.render
  var s = t.ref
  return (
    _n(t, n),
    (i = Ff(e, t, r, i, s, n)),
    (r = Mf()),
    e !== null && !Ct
      ? ((t.updateQueue = e.updateQueue), (t.flags &= -2053), (e.lanes &= ~n), Rr(e, t, n))
      : (qe && r && Sf(t), (t.flags |= 1), gt(e, t, i, n), t.child)
  )
}
function Ih(e, t, r, i, n) {
  if (e === null) {
    var s = r.type
    return typeof s == 'function' &&
      !Yf(s) &&
      s.defaultProps === void 0 &&
      r.compare === null &&
      r.defaultProps === void 0
      ? ((t.tag = 15), (t.type = s), dg(e, t, s, i, n))
      : ((e = eo(r.type, null, i, t, t.mode, n)), (e.ref = t.ref), (e.return = t), (t.child = e))
  }
  if (((s = e.child), !(e.lanes & n))) {
    var a = s.memoizedProps
    if (((r = r.compare), (r = r !== null ? r : Is), r(a, i) && e.ref === t.ref)) return Rr(e, t, n)
  }
  return (t.flags |= 1), (e = ni(s, i)), (e.ref = t.ref), (e.return = t), (t.child = e)
}
function dg(e, t, r, i, n) {
  if (e !== null) {
    var s = e.memoizedProps
    if (Is(s, i) && e.ref === t.ref)
      if (((Ct = !1), (t.pendingProps = i = s), (e.lanes & n) !== 0)) e.flags & 131072 && (Ct = !0)
      else return (t.lanes = e.lanes), Rr(e, t, n)
  }
  return fc(e, t, r, i, n)
}
function gg(e, t, r) {
  var i = t.pendingProps,
    n = i.children,
    s = e !== null ? e.memoizedState : null
  if (i.mode === 'hidden')
    if (!(t.mode & 1))
      (t.memoizedState = { baseLanes: 0, cachePool: null, transitions: null }),
        Fe(cn, Dt),
        (Dt |= r)
    else {
      if (!(r & 1073741824))
        return (
          (e = s !== null ? s.baseLanes | r : r),
          (t.lanes = t.childLanes = 1073741824),
          (t.memoizedState = { baseLanes: e, cachePool: null, transitions: null }),
          (t.updateQueue = null),
          Fe(cn, Dt),
          (Dt |= e),
          null
        )
      ;(t.memoizedState = { baseLanes: 0, cachePool: null, transitions: null }),
        (i = s !== null ? s.baseLanes : r),
        Fe(cn, Dt),
        (Dt |= i)
    }
  else
    s !== null ? ((i = s.baseLanes | r), (t.memoizedState = null)) : (i = r), Fe(cn, Dt), (Dt |= i)
  return gt(e, t, n, r), t.child
}
function bg(e, t) {
  var r = t.ref
  ;((e === null && r !== null) || (e !== null && e.ref !== r)) &&
    ((t.flags |= 512), (t.flags |= 2097152))
}
function fc(e, t, r, i, n) {
  var s = wt(r) ? wi : mt.current
  return (
    (s = Sn(t, s)),
    _n(t, n),
    (r = Ff(e, t, r, i, s, n)),
    (i = Mf()),
    e !== null && !Ct
      ? ((t.updateQueue = e.updateQueue), (t.flags &= -2053), (e.lanes &= ~n), Rr(e, t, n))
      : (qe && i && Sf(t), (t.flags |= 1), gt(e, t, r, n), t.child)
  )
}
function Dh(e, t, r, i, n) {
  if (wt(r)) {
    var s = !0
    _o(t)
  } else s = !1
  if ((_n(t, n), t.stateNode === null)) Ka(e, t), $0(t, r, i), lc(t, r, i, n), (i = !0)
  else if (e === null) {
    var a = t.stateNode,
      o = t.memoizedProps
    a.props = o
    var u = a.context,
      c = r.contextType
    typeof c == 'object' && c !== null
      ? (c = Wt(c))
      : ((c = wt(r) ? wi : mt.current), (c = Sn(t, c)))
    var f = r.getDerivedStateFromProps,
      h = typeof f == 'function' || typeof a.getSnapshotBeforeUpdate == 'function'
    h ||
      (typeof a.UNSAFE_componentWillReceiveProps != 'function' &&
        typeof a.componentWillReceiveProps != 'function') ||
      ((o !== i || u !== c) && Th(t, a, i, c)),
      (Vr = !1)
    var p = t.memoizedState
    ;(a.state = p),
      Ao(t, i, a, n),
      (u = t.memoizedState),
      o !== i || p !== u || kt.current || Vr
        ? (typeof f == 'function' && (uc(t, r, f, i), (u = t.memoizedState)),
          (o = Vr || xh(t, r, o, i, p, u, c))
            ? (h ||
                (typeof a.UNSAFE_componentWillMount != 'function' &&
                  typeof a.componentWillMount != 'function') ||
                (typeof a.componentWillMount == 'function' && a.componentWillMount(),
                typeof a.UNSAFE_componentWillMount == 'function' && a.UNSAFE_componentWillMount()),
              typeof a.componentDidMount == 'function' && (t.flags |= 4194308))
            : (typeof a.componentDidMount == 'function' && (t.flags |= 4194308),
              (t.memoizedProps = i),
              (t.memoizedState = u)),
          (a.props = i),
          (a.state = u),
          (a.context = c),
          (i = o))
        : (typeof a.componentDidMount == 'function' && (t.flags |= 4194308), (i = !1))
  } else {
    ;(a = t.stateNode),
      j0(e, t),
      (o = t.memoizedProps),
      (c = t.type === t.elementType ? o : Zt(t.type, o)),
      (a.props = c),
      (h = t.pendingProps),
      (p = a.context),
      (u = r.contextType),
      typeof u == 'object' && u !== null
        ? (u = Wt(u))
        : ((u = wt(r) ? wi : mt.current), (u = Sn(t, u)))
    var m = r.getDerivedStateFromProps
    ;(f = typeof m == 'function' || typeof a.getSnapshotBeforeUpdate == 'function') ||
      (typeof a.UNSAFE_componentWillReceiveProps != 'function' &&
        typeof a.componentWillReceiveProps != 'function') ||
      ((o !== h || p !== u) && Th(t, a, i, u)),
      (Vr = !1),
      (p = t.memoizedState),
      (a.state = p),
      Ao(t, i, a, n)
    var v = t.memoizedState
    o !== h || p !== v || kt.current || Vr
      ? (typeof m == 'function' && (uc(t, r, m, i), (v = t.memoizedState)),
        (c = Vr || xh(t, r, c, i, p, v, u) || !1)
          ? (f ||
              (typeof a.UNSAFE_componentWillUpdate != 'function' &&
                typeof a.componentWillUpdate != 'function') ||
              (typeof a.componentWillUpdate == 'function' && a.componentWillUpdate(i, v, u),
              typeof a.UNSAFE_componentWillUpdate == 'function' &&
                a.UNSAFE_componentWillUpdate(i, v, u)),
            typeof a.componentDidUpdate == 'function' && (t.flags |= 4),
            typeof a.getSnapshotBeforeUpdate == 'function' && (t.flags |= 1024))
          : (typeof a.componentDidUpdate != 'function' ||
              (o === e.memoizedProps && p === e.memoizedState) ||
              (t.flags |= 4),
            typeof a.getSnapshotBeforeUpdate != 'function' ||
              (o === e.memoizedProps && p === e.memoizedState) ||
              (t.flags |= 1024),
            (t.memoizedProps = i),
            (t.memoizedState = v)),
        (a.props = i),
        (a.state = v),
        (a.context = u),
        (i = c))
      : (typeof a.componentDidUpdate != 'function' ||
          (o === e.memoizedProps && p === e.memoizedState) ||
          (t.flags |= 4),
        typeof a.getSnapshotBeforeUpdate != 'function' ||
          (o === e.memoizedProps && p === e.memoizedState) ||
          (t.flags |= 1024),
        (i = !1))
  }
  return pc(e, t, r, i, s, n)
}
function pc(e, t, r, i, n, s) {
  bg(e, t)
  var a = (t.flags & 128) !== 0
  if (!i && !a) return n && bh(t, r, !1), Rr(e, t, s)
  ;(i = t.stateNode), (Pv.current = t)
  var o = a && typeof r.getDerivedStateFromError != 'function' ? null : i.render()
  return (
    (t.flags |= 1),
    e !== null && a
      ? ((t.child = kn(t, e.child, null, s)), (t.child = kn(t, null, o, s)))
      : gt(e, t, o, s),
    (t.memoizedState = i.state),
    n && bh(t, r, !0),
    t.child
  )
}
function yg(e) {
  var t = e.stateNode
  t.pendingContext
    ? gh(e, t.pendingContext, t.pendingContext !== t.context)
    : t.context && gh(e, t.context, !1),
    Rf(e, t.containerInfo)
}
function Rh(e, t, r, i, n) {
  return Cn(), kf(n), (t.flags |= 256), gt(e, t, r, i), t.child
}
var hc = { dehydrated: null, treeContext: null, retryLane: 0 }
function mc(e) {
  return { baseLanes: e, cachePool: null, transitions: null }
}
function _g(e, t, r) {
  var i = t.pendingProps,
    n = Ve.current,
    s = !1,
    a = (t.flags & 128) !== 0,
    o
  if (
    ((o = a) || (o = e !== null && e.memoizedState === null ? !1 : (n & 2) !== 0),
    o ? ((s = !0), (t.flags &= -129)) : (e === null || e.memoizedState !== null) && (n |= 1),
    Fe(Ve, n & 1),
    e === null)
  )
    return (
      ac(t),
      (e = t.memoizedState),
      e !== null && ((e = e.dehydrated), e !== null)
        ? (t.mode & 1 ? (e.data === '$!' ? (t.lanes = 8) : (t.lanes = 1073741824)) : (t.lanes = 1),
          null)
        : ((a = i.children),
          (e = i.fallback),
          s
            ? ((i = t.mode),
              (s = t.child),
              (a = { mode: 'hidden', children: a }),
              !(i & 1) && s !== null
                ? ((s.childLanes = 0), (s.pendingProps = a))
                : (s = eu(a, i, 0, null)),
              (e = Ci(e, i, r, null)),
              (s.return = t),
              (e.return = t),
              (s.sibling = e),
              (t.child = s),
              (t.child.memoizedState = mc(r)),
              (t.memoizedState = hc),
              e)
            : zf(t, a))
    )
  if (((n = e.memoizedState), n !== null && ((o = n.dehydrated), o !== null)))
    return Bv(e, t, a, i, o, n, r)
  if (s) {
    ;(s = i.fallback), (a = t.mode), (n = e.child), (o = n.sibling)
    var u = { mode: 'hidden', children: i.children }
    return (
      !(a & 1) && t.child !== n
        ? ((i = t.child), (i.childLanes = 0), (i.pendingProps = u), (t.deletions = null))
        : ((i = ni(n, u)), (i.subtreeFlags = n.subtreeFlags & 14680064)),
      o !== null ? (s = ni(o, s)) : ((s = Ci(s, a, r, null)), (s.flags |= 2)),
      (s.return = t),
      (i.return = t),
      (i.sibling = s),
      (t.child = i),
      (i = s),
      (s = t.child),
      (a = e.child.memoizedState),
      (a =
        a === null
          ? mc(r)
          : { baseLanes: a.baseLanes | r, cachePool: null, transitions: a.transitions }),
      (s.memoizedState = a),
      (s.childLanes = e.childLanes & ~r),
      (t.memoizedState = hc),
      i
    )
  }
  return (
    (s = e.child),
    (e = s.sibling),
    (i = ni(s, { mode: 'visible', children: i.children })),
    !(t.mode & 1) && (i.lanes = r),
    (i.return = t),
    (i.sibling = null),
    e !== null &&
      ((r = t.deletions), r === null ? ((t.deletions = [e]), (t.flags |= 16)) : r.push(e)),
    (t.child = i),
    (t.memoizedState = null),
    i
  )
}
function zf(e, t) {
  return (t = eu({ mode: 'visible', children: t }, e.mode, 0, null)), (t.return = e), (e.child = t)
}
function Na(e, t, r, i) {
  return (
    i !== null && kf(i),
    kn(t, e.child, null, r),
    (e = zf(t, t.pendingProps.children)),
    (e.flags |= 2),
    (t.memoizedState = null),
    e
  )
}
function Bv(e, t, r, i, n, s, a) {
  if (r)
    return t.flags & 256
      ? ((t.flags &= -257), (i = Ju(Error(ue(422)))), Na(e, t, a, i))
      : t.memoizedState !== null
      ? ((t.child = e.child), (t.flags |= 128), null)
      : ((s = i.fallback),
        (n = t.mode),
        (i = eu({ mode: 'visible', children: i.children }, n, 0, null)),
        (s = Ci(s, n, a, null)),
        (s.flags |= 2),
        (i.return = t),
        (s.return = t),
        (i.sibling = s),
        (t.child = i),
        t.mode & 1 && kn(t, e.child, null, a),
        (t.child.memoizedState = mc(a)),
        (t.memoizedState = hc),
        s)
  if (!(t.mode & 1)) return Na(e, t, a, null)
  if (n.data === '$!') {
    if (((i = n.nextSibling && n.nextSibling.dataset), i)) var o = i.dgst
    return (i = o), (s = Error(ue(419))), (i = Ju(s, i, void 0)), Na(e, t, a, i)
  }
  if (((o = (a & e.childLanes) !== 0), Ct || o)) {
    if (((i = st), i !== null)) {
      switch (a & -a) {
        case 4:
          n = 2
          break
        case 16:
          n = 8
          break
        case 64:
        case 128:
        case 256:
        case 512:
        case 1024:
        case 2048:
        case 4096:
        case 8192:
        case 16384:
        case 32768:
        case 65536:
        case 131072:
        case 262144:
        case 524288:
        case 1048576:
        case 2097152:
        case 4194304:
        case 8388608:
        case 16777216:
        case 33554432:
        case 67108864:
          n = 32
          break
        case 536870912:
          n = 268435456
          break
        default:
          n = 0
      }
      ;(n = n & (i.suspendedLanes | a) ? 0 : n),
        n !== 0 && n !== s.retryLane && ((s.retryLane = n), Dr(e, n), nr(i, e, n, -1))
    }
    return Xf(), (i = Ju(Error(ue(421)))), Na(e, t, a, i)
  }
  return n.data === '$?'
    ? ((t.flags |= 128), (t.child = e.child), (t = Wv.bind(null, e)), (n._reactRetry = t), null)
    : ((e = s.treeContext),
      (Lt = ei(n.nextSibling)),
      (Pt = t),
      (qe = !0),
      (tr = null),
      e !== null &&
        (($t[Vt++] = kr),
        ($t[Vt++] = wr),
        ($t[Vt++] = Ni),
        (kr = e.id),
        (wr = e.overflow),
        (Ni = t)),
      (t = zf(t, i.children)),
      (t.flags |= 4096),
      t)
}
function Lh(e, t, r) {
  e.lanes |= t
  var i = e.alternate
  i !== null && (i.lanes |= t), oc(e.return, t, r)
}
function Zu(e, t, r, i, n) {
  var s = e.memoizedState
  s === null
    ? (e.memoizedState = {
        isBackwards: t,
        rendering: null,
        renderingStartTime: 0,
        last: i,
        tail: r,
        tailMode: n,
      })
    : ((s.isBackwards = t),
      (s.rendering = null),
      (s.renderingStartTime = 0),
      (s.last = i),
      (s.tail = r),
      (s.tailMode = n))
}
function vg(e, t, r) {
  var i = t.pendingProps,
    n = i.revealOrder,
    s = i.tail
  if ((gt(e, t, i.children, r), (i = Ve.current), i & 2)) (i = (i & 1) | 2), (t.flags |= 128)
  else {
    if (e !== null && e.flags & 128)
      e: for (e = t.child; e !== null; ) {
        if (e.tag === 13) e.memoizedState !== null && Lh(e, r, t)
        else if (e.tag === 19) Lh(e, r, t)
        else if (e.child !== null) {
          ;(e.child.return = e), (e = e.child)
          continue
        }
        if (e === t) break e
        for (; e.sibling === null; ) {
          if (e.return === null || e.return === t) break e
          e = e.return
        }
        ;(e.sibling.return = e.return), (e = e.sibling)
      }
    i &= 1
  }
  if ((Fe(Ve, i), !(t.mode & 1))) t.memoizedState = null
  else
    switch (n) {
      case 'forwards':
        for (r = t.child, n = null; r !== null; )
          (e = r.alternate), e !== null && So(e) === null && (n = r), (r = r.sibling)
        ;(r = n),
          r === null ? ((n = t.child), (t.child = null)) : ((n = r.sibling), (r.sibling = null)),
          Zu(t, !1, n, r, s)
        break
      case 'backwards':
        for (r = null, n = t.child, t.child = null; n !== null; ) {
          if (((e = n.alternate), e !== null && So(e) === null)) {
            t.child = n
            break
          }
          ;(e = n.sibling), (n.sibling = r), (r = n), (n = e)
        }
        Zu(t, !0, r, null, s)
        break
      case 'together':
        Zu(t, !1, null, null, void 0)
        break
      default:
        t.memoizedState = null
    }
  return t.child
}
function Ka(e, t) {
  !(t.mode & 1) && e !== null && ((e.alternate = null), (t.alternate = null), (t.flags |= 2))
}
function Rr(e, t, r) {
  if ((e !== null && (t.dependencies = e.dependencies), (Ii |= t.lanes), !(r & t.childLanes)))
    return null
  if (e !== null && t.child !== e.child) throw Error(ue(153))
  if (t.child !== null) {
    for (e = t.child, r = ni(e, e.pendingProps), t.child = r, r.return = t; e.sibling !== null; )
      (e = e.sibling), (r = r.sibling = ni(e, e.pendingProps)), (r.return = t)
    r.sibling = null
  }
  return t.child
}
function Fv(e, t, r) {
  switch (t.tag) {
    case 3:
      yg(t), Cn()
      break
    case 5:
      X0(t)
      break
    case 1:
      wt(t.type) && _o(t)
      break
    case 4:
      Rf(t, t.stateNode.containerInfo)
      break
    case 10:
      var i = t.type._context,
        n = t.memoizedProps.value
      Fe(xo, i._currentValue), (i._currentValue = n)
      break
    case 13:
      if (((i = t.memoizedState), i !== null))
        return i.dehydrated !== null
          ? (Fe(Ve, Ve.current & 1), (t.flags |= 128), null)
          : r & t.child.childLanes
          ? _g(e, t, r)
          : (Fe(Ve, Ve.current & 1), (e = Rr(e, t, r)), e !== null ? e.sibling : null)
      Fe(Ve, Ve.current & 1)
      break
    case 19:
      if (((i = (r & t.childLanes) !== 0), e.flags & 128)) {
        if (i) return vg(e, t, r)
        t.flags |= 128
      }
      if (
        ((n = t.memoizedState),
        n !== null && ((n.rendering = null), (n.tail = null), (n.lastEffect = null)),
        Fe(Ve, Ve.current),
        i)
      )
        break
      return null
    case 22:
    case 23:
      return (t.lanes = 0), gg(e, t, r)
  }
  return Rr(e, t, r)
}
var Eg, dc, xg, Tg
Eg = function (e, t) {
  for (var r = t.child; r !== null; ) {
    if (r.tag === 5 || r.tag === 6) e.appendChild(r.stateNode)
    else if (r.tag !== 4 && r.child !== null) {
      ;(r.child.return = r), (r = r.child)
      continue
    }
    if (r === t) break
    for (; r.sibling === null; ) {
      if (r.return === null || r.return === t) return
      r = r.return
    }
    ;(r.sibling.return = r.return), (r = r.sibling)
  }
}
dc = function () {}
xg = function (e, t, r, i) {
  var n = e.memoizedProps
  if (n !== i) {
    ;(e = t.stateNode), Ti(yr.current)
    var s = null
    switch (r) {
      case 'input':
        ;(n = Fl(e, n)), (i = Fl(e, i)), (s = [])
        break
      case 'select':
        ;(n = Xe({}, n, { value: void 0 })), (i = Xe({}, i, { value: void 0 })), (s = [])
        break
      case 'textarea':
        ;(n = Hl(e, n)), (i = Hl(e, i)), (s = [])
        break
      default:
        typeof n.onClick != 'function' && typeof i.onClick == 'function' && (e.onclick = bo)
    }
    jl(r, i)
    var a
    r = null
    for (c in n)
      if (!i.hasOwnProperty(c) && n.hasOwnProperty(c) && n[c] != null)
        if (c === 'style') {
          var o = n[c]
          for (a in o) o.hasOwnProperty(a) && (r || (r = {}), (r[a] = ''))
        } else
          c !== 'dangerouslySetInnerHTML' &&
            c !== 'children' &&
            c !== 'suppressContentEditableWarning' &&
            c !== 'suppressHydrationWarning' &&
            c !== 'autoFocus' &&
            (As.hasOwnProperty(c) ? s || (s = []) : (s = s || []).push(c, null))
    for (c in i) {
      var u = i[c]
      if (
        ((o = n != null ? n[c] : void 0),
        i.hasOwnProperty(c) && u !== o && (u != null || o != null))
      )
        if (c === 'style')
          if (o) {
            for (a in o)
              !o.hasOwnProperty(a) || (u && u.hasOwnProperty(a)) || (r || (r = {}), (r[a] = ''))
            for (a in u) u.hasOwnProperty(a) && o[a] !== u[a] && (r || (r = {}), (r[a] = u[a]))
          } else r || (s || (s = []), s.push(c, r)), (r = u)
        else
          c === 'dangerouslySetInnerHTML'
            ? ((u = u ? u.__html : void 0),
              (o = o ? o.__html : void 0),
              u != null && o !== u && (s = s || []).push(c, u))
            : c === 'children'
            ? (typeof u != 'string' && typeof u != 'number') || (s = s || []).push(c, '' + u)
            : c !== 'suppressContentEditableWarning' &&
              c !== 'suppressHydrationWarning' &&
              (As.hasOwnProperty(c)
                ? (u != null && c === 'onScroll' && Ue('scroll', e), s || o === u || (s = []))
                : (s = s || []).push(c, u))
    }
    r && (s = s || []).push('style', r)
    var c = s
    ;(t.updateQueue = c) && (t.flags |= 4)
  }
}
Tg = function (e, t, r, i) {
  r !== i && (t.flags |= 4)
}
function Xn(e, t) {
  if (!qe)
    switch (e.tailMode) {
      case 'hidden':
        t = e.tail
        for (var r = null; t !== null; ) t.alternate !== null && (r = t), (t = t.sibling)
        r === null ? (e.tail = null) : (r.sibling = null)
        break
      case 'collapsed':
        r = e.tail
        for (var i = null; r !== null; ) r.alternate !== null && (i = r), (r = r.sibling)
        i === null
          ? t || e.tail === null
            ? (e.tail = null)
            : (e.tail.sibling = null)
          : (i.sibling = null)
    }
}
function ft(e) {
  var t = e.alternate !== null && e.alternate.child === e.child,
    r = 0,
    i = 0
  if (t)
    for (var n = e.child; n !== null; )
      (r |= n.lanes | n.childLanes),
        (i |= n.subtreeFlags & 14680064),
        (i |= n.flags & 14680064),
        (n.return = e),
        (n = n.sibling)
  else
    for (n = e.child; n !== null; )
      (r |= n.lanes | n.childLanes),
        (i |= n.subtreeFlags),
        (i |= n.flags),
        (n.return = e),
        (n = n.sibling)
  return (e.subtreeFlags |= i), (e.childLanes = r), t
}
function Mv(e, t, r) {
  var i = t.pendingProps
  switch ((Cf(t), t.tag)) {
    case 2:
    case 16:
    case 15:
    case 0:
    case 11:
    case 7:
    case 8:
    case 12:
    case 9:
    case 14:
      return ft(t), null
    case 1:
      return wt(t.type) && yo(), ft(t), null
    case 3:
      return (
        (i = t.stateNode),
        wn(),
        He(kt),
        He(mt),
        Pf(),
        i.pendingContext && ((i.context = i.pendingContext), (i.pendingContext = null)),
        (e === null || e.child === null) &&
          (ka(t)
            ? (t.flags |= 4)
            : e === null ||
              (e.memoizedState.isDehydrated && !(t.flags & 256)) ||
              ((t.flags |= 1024), tr !== null && (Tc(tr), (tr = null)))),
        dc(e, t),
        ft(t),
        null
      )
    case 5:
      Lf(t)
      var n = Ti(Bs.current)
      if (((r = t.type), e !== null && t.stateNode != null))
        xg(e, t, r, i, n), e.ref !== t.ref && ((t.flags |= 512), (t.flags |= 2097152))
      else {
        if (!i) {
          if (t.stateNode === null) throw Error(ue(166))
          return ft(t), null
        }
        if (((e = Ti(yr.current)), ka(t))) {
          ;(i = t.stateNode), (r = t.type)
          var s = t.memoizedProps
          switch (((i[hr] = t), (i[Ls] = s), (e = (t.mode & 1) !== 0), r)) {
            case 'dialog':
              Ue('cancel', i), Ue('close', i)
              break
            case 'iframe':
            case 'object':
            case 'embed':
              Ue('load', i)
              break
            case 'video':
            case 'audio':
              for (n = 0; n < ss.length; n++) Ue(ss[n], i)
              break
            case 'source':
              Ue('error', i)
              break
            case 'img':
            case 'image':
            case 'link':
              Ue('error', i), Ue('load', i)
              break
            case 'details':
              Ue('toggle', i)
              break
            case 'input':
              qp(i, s), Ue('invalid', i)
              break
            case 'select':
              ;(i._wrapperState = { wasMultiple: !!s.multiple }), Ue('invalid', i)
              break
            case 'textarea':
              Vp(i, s), Ue('invalid', i)
          }
          jl(r, s), (n = null)
          for (var a in s)
            if (s.hasOwnProperty(a)) {
              var o = s[a]
              a === 'children'
                ? typeof o == 'string'
                  ? i.textContent !== o &&
                    (s.suppressHydrationWarning !== !0 && Ca(i.textContent, o, e),
                    (n = ['children', o]))
                  : typeof o == 'number' &&
                    i.textContent !== '' + o &&
                    (s.suppressHydrationWarning !== !0 && Ca(i.textContent, o, e),
                    (n = ['children', '' + o]))
                : As.hasOwnProperty(a) && o != null && a === 'onScroll' && Ue('scroll', i)
            }
          switch (r) {
            case 'input':
              ya(i), $p(i, s, !0)
              break
            case 'textarea':
              ya(i), Gp(i)
              break
            case 'select':
            case 'option':
              break
            default:
              typeof s.onClick == 'function' && (i.onclick = bo)
          }
          ;(i = n), (t.updateQueue = i), i !== null && (t.flags |= 4)
        } else {
          ;(a = n.nodeType === 9 ? n : n.ownerDocument),
            e === 'http://www.w3.org/1999/xhtml' && (e = Qd(r)),
            e === 'http://www.w3.org/1999/xhtml'
              ? r === 'script'
                ? ((e = a.createElement('div')),
                  (e.innerHTML = '<script></script>'),
                  (e = e.removeChild(e.firstChild)))
                : typeof i.is == 'string'
                ? (e = a.createElement(r, { is: i.is }))
                : ((e = a.createElement(r)),
                  r === 'select' &&
                    ((a = e), i.multiple ? (a.multiple = !0) : i.size && (a.size = i.size)))
              : (e = a.createElementNS(e, r)),
            (e[hr] = t),
            (e[Ls] = i),
            Eg(e, t, !1, !1),
            (t.stateNode = e)
          e: {
            switch (((a = ql(r, i)), r)) {
              case 'dialog':
                Ue('cancel', e), Ue('close', e), (n = i)
                break
              case 'iframe':
              case 'object':
              case 'embed':
                Ue('load', e), (n = i)
                break
              case 'video':
              case 'audio':
                for (n = 0; n < ss.length; n++) Ue(ss[n], e)
                n = i
                break
              case 'source':
                Ue('error', e), (n = i)
                break
              case 'img':
              case 'image':
              case 'link':
                Ue('error', e), Ue('load', e), (n = i)
                break
              case 'details':
                Ue('toggle', e), (n = i)
                break
              case 'input':
                qp(e, i), (n = Fl(e, i)), Ue('invalid', e)
                break
              case 'option':
                n = i
                break
              case 'select':
                ;(e._wrapperState = { wasMultiple: !!i.multiple }),
                  (n = Xe({}, i, { value: void 0 })),
                  Ue('invalid', e)
                break
              case 'textarea':
                Vp(e, i), (n = Hl(e, i)), Ue('invalid', e)
                break
              default:
                n = i
            }
            jl(r, n), (o = n)
            for (s in o)
              if (o.hasOwnProperty(s)) {
                var u = o[s]
                s === 'style'
                  ? Zd(e, u)
                  : s === 'dangerouslySetInnerHTML'
                  ? ((u = u ? u.__html : void 0), u != null && Kd(e, u))
                  : s === 'children'
                  ? typeof u == 'string'
                    ? (r !== 'textarea' || u !== '') && Ss(e, u)
                    : typeof u == 'number' && Ss(e, '' + u)
                  : s !== 'suppressContentEditableWarning' &&
                    s !== 'suppressHydrationWarning' &&
                    s !== 'autoFocus' &&
                    (As.hasOwnProperty(s)
                      ? u != null && s === 'onScroll' && Ue('scroll', e)
                      : u != null && ff(e, s, u, a))
              }
            switch (r) {
              case 'input':
                ya(e), $p(e, i, !1)
                break
              case 'textarea':
                ya(e), Gp(e)
                break
              case 'option':
                i.value != null && e.setAttribute('value', '' + oi(i.value))
                break
              case 'select':
                ;(e.multiple = !!i.multiple),
                  (s = i.value),
                  s != null
                    ? dn(e, !!i.multiple, s, !1)
                    : i.defaultValue != null && dn(e, !!i.multiple, i.defaultValue, !0)
                break
              default:
                typeof n.onClick == 'function' && (e.onclick = bo)
            }
            switch (r) {
              case 'button':
              case 'input':
              case 'select':
              case 'textarea':
                i = !!i.autoFocus
                break e
              case 'img':
                i = !0
                break e
              default:
                i = !1
            }
          }
          i && (t.flags |= 4)
        }
        t.ref !== null && ((t.flags |= 512), (t.flags |= 2097152))
      }
      return ft(t), null
    case 6:
      if (e && t.stateNode != null) Tg(e, t, e.memoizedProps, i)
      else {
        if (typeof i != 'string' && t.stateNode === null) throw Error(ue(166))
        if (((r = Ti(Bs.current)), Ti(yr.current), ka(t))) {
          if (
            ((i = t.stateNode),
            (r = t.memoizedProps),
            (i[hr] = t),
            (s = i.nodeValue !== r) && ((e = Pt), e !== null))
          )
            switch (e.tag) {
              case 3:
                Ca(i.nodeValue, r, (e.mode & 1) !== 0)
                break
              case 5:
                e.memoizedProps.suppressHydrationWarning !== !0 &&
                  Ca(i.nodeValue, r, (e.mode & 1) !== 0)
            }
          s && (t.flags |= 4)
        } else
          (i = (r.nodeType === 9 ? r : r.ownerDocument).createTextNode(i)),
            (i[hr] = t),
            (t.stateNode = i)
      }
      return ft(t), null
    case 13:
      if (
        (He(Ve),
        (i = t.memoizedState),
        e === null || (e.memoizedState !== null && e.memoizedState.dehydrated !== null))
      ) {
        if (qe && Lt !== null && t.mode & 1 && !(t.flags & 128))
          H0(), Cn(), (t.flags |= 98560), (s = !1)
        else if (((s = ka(t)), i !== null && i.dehydrated !== null)) {
          if (e === null) {
            if (!s) throw Error(ue(318))
            if (((s = t.memoizedState), (s = s !== null ? s.dehydrated : null), !s))
              throw Error(ue(317))
            s[hr] = t
          } else Cn(), !(t.flags & 128) && (t.memoizedState = null), (t.flags |= 4)
          ft(t), (s = !1)
        } else tr !== null && (Tc(tr), (tr = null)), (s = !0)
        if (!s) return t.flags & 65536 ? t : null
      }
      return t.flags & 128
        ? ((t.lanes = r), t)
        : ((i = i !== null),
          i !== (e !== null && e.memoizedState !== null) &&
            i &&
            ((t.child.flags |= 8192),
            t.mode & 1 && (e === null || Ve.current & 1 ? Ze === 0 && (Ze = 3) : Xf())),
          t.updateQueue !== null && (t.flags |= 4),
          ft(t),
          null)
    case 4:
      return wn(), dc(e, t), e === null && Ds(t.stateNode.containerInfo), ft(t), null
    case 10:
      return Of(t.type._context), ft(t), null
    case 17:
      return wt(t.type) && yo(), ft(t), null
    case 19:
      if ((He(Ve), (s = t.memoizedState), s === null)) return ft(t), null
      if (((i = (t.flags & 128) !== 0), (a = s.rendering), a === null))
        if (i) Xn(s, !1)
        else {
          if (Ze !== 0 || (e !== null && e.flags & 128))
            for (e = t.child; e !== null; ) {
              if (((a = So(e)), a !== null)) {
                for (
                  t.flags |= 128,
                    Xn(s, !1),
                    i = a.updateQueue,
                    i !== null && ((t.updateQueue = i), (t.flags |= 4)),
                    t.subtreeFlags = 0,
                    i = r,
                    r = t.child;
                  r !== null;

                )
                  (s = r),
                    (e = i),
                    (s.flags &= 14680066),
                    (a = s.alternate),
                    a === null
                      ? ((s.childLanes = 0),
                        (s.lanes = e),
                        (s.child = null),
                        (s.subtreeFlags = 0),
                        (s.memoizedProps = null),
                        (s.memoizedState = null),
                        (s.updateQueue = null),
                        (s.dependencies = null),
                        (s.stateNode = null))
                      : ((s.childLanes = a.childLanes),
                        (s.lanes = a.lanes),
                        (s.child = a.child),
                        (s.subtreeFlags = 0),
                        (s.deletions = null),
                        (s.memoizedProps = a.memoizedProps),
                        (s.memoizedState = a.memoizedState),
                        (s.updateQueue = a.updateQueue),
                        (s.type = a.type),
                        (e = a.dependencies),
                        (s.dependencies =
                          e === null ? null : { lanes: e.lanes, firstContext: e.firstContext })),
                    (r = r.sibling)
                return Fe(Ve, (Ve.current & 1) | 2), t.child
              }
              e = e.sibling
            }
          s.tail !== null &&
            We() > On &&
            ((t.flags |= 128), (i = !0), Xn(s, !1), (t.lanes = 4194304))
        }
      else {
        if (!i)
          if (((e = So(a)), e !== null)) {
            if (
              ((t.flags |= 128),
              (i = !0),
              (r = e.updateQueue),
              r !== null && ((t.updateQueue = r), (t.flags |= 4)),
              Xn(s, !0),
              s.tail === null && s.tailMode === 'hidden' && !a.alternate && !qe)
            )
              return ft(t), null
          } else
            2 * We() - s.renderingStartTime > On &&
              r !== 1073741824 &&
              ((t.flags |= 128), (i = !0), Xn(s, !1), (t.lanes = 4194304))
        s.isBackwards
          ? ((a.sibling = t.child), (t.child = a))
          : ((r = s.last), r !== null ? (r.sibling = a) : (t.child = a), (s.last = a))
      }
      return s.tail !== null
        ? ((t = s.tail),
          (s.rendering = t),
          (s.tail = t.sibling),
          (s.renderingStartTime = We()),
          (t.sibling = null),
          (r = Ve.current),
          Fe(Ve, i ? (r & 1) | 2 : r & 1),
          t)
        : (ft(t), null)
    case 22:
    case 23:
      return (
        Gf(),
        (i = t.memoizedState !== null),
        e !== null && (e.memoizedState !== null) !== i && (t.flags |= 8192),
        i && t.mode & 1
          ? Dt & 1073741824 && (ft(t), t.subtreeFlags & 6 && (t.flags |= 8192))
          : ft(t),
        null
      )
    case 24:
      return null
    case 25:
      return null
  }
  throw Error(ue(156, t.tag))
}
function Uv(e, t) {
  switch ((Cf(t), t.tag)) {
    case 1:
      return (
        wt(t.type) && yo(), (e = t.flags), e & 65536 ? ((t.flags = (e & -65537) | 128), t) : null
      )
    case 3:
      return (
        wn(),
        He(kt),
        He(mt),
        Pf(),
        (e = t.flags),
        e & 65536 && !(e & 128) ? ((t.flags = (e & -65537) | 128), t) : null
      )
    case 5:
      return Lf(t), null
    case 13:
      if ((He(Ve), (e = t.memoizedState), e !== null && e.dehydrated !== null)) {
        if (t.alternate === null) throw Error(ue(340))
        Cn()
      }
      return (e = t.flags), e & 65536 ? ((t.flags = (e & -65537) | 128), t) : null
    case 19:
      return He(Ve), null
    case 4:
      return wn(), null
    case 10:
      return Of(t.type._context), null
    case 22:
    case 23:
      return Gf(), null
    case 24:
      return null
    default:
      return null
  }
}
var Oa = !1,
  pt = !1,
  Hv = typeof WeakSet == 'function' ? WeakSet : Set,
  he = null
function ln(e, t) {
  var r = e.ref
  if (r !== null)
    if (typeof r == 'function')
      try {
        r(null)
      } catch (i) {
        Ye(e, t, i)
      }
    else r.current = null
}
function gc(e, t, r) {
  try {
    r()
  } catch (i) {
    Ye(e, t, i)
  }
}
var Ph = !1
function zv(e, t) {
  if (((Zl = ho), (e = k0()), Af(e))) {
    if ('selectionStart' in e) var r = { start: e.selectionStart, end: e.selectionEnd }
    else
      e: {
        r = ((r = e.ownerDocument) && r.defaultView) || window
        var i = r.getSelection && r.getSelection()
        if (i && i.rangeCount !== 0) {
          r = i.anchorNode
          var n = i.anchorOffset,
            s = i.focusNode
          i = i.focusOffset
          try {
            r.nodeType, s.nodeType
          } catch {
            r = null
            break e
          }
          var a = 0,
            o = -1,
            u = -1,
            c = 0,
            f = 0,
            h = e,
            p = null
          t: for (;;) {
            for (
              var m;
              h !== r || (n !== 0 && h.nodeType !== 3) || (o = a + n),
                h !== s || (i !== 0 && h.nodeType !== 3) || (u = a + i),
                h.nodeType === 3 && (a += h.nodeValue.length),
                (m = h.firstChild) !== null;

            )
              (p = h), (h = m)
            for (;;) {
              if (h === e) break t
              if (
                (p === r && ++c === n && (o = a),
                p === s && ++f === i && (u = a),
                (m = h.nextSibling) !== null)
              )
                break
              ;(h = p), (p = h.parentNode)
            }
            h = m
          }
          r = o === -1 || u === -1 ? null : { start: o, end: u }
        } else r = null
      }
    r = r || { start: 0, end: 0 }
  } else r = null
  for (ec = { focusedElem: e, selectionRange: r }, ho = !1, he = t; he !== null; )
    if (((t = he), (e = t.child), (t.subtreeFlags & 1028) !== 0 && e !== null))
      (e.return = t), (he = e)
    else
      for (; he !== null; ) {
        t = he
        try {
          var v = t.alternate
          if (t.flags & 1024)
            switch (t.tag) {
              case 0:
              case 11:
              case 15:
                break
              case 1:
                if (v !== null) {
                  var b = v.memoizedProps,
                    S = v.memoizedState,
                    g = t.stateNode,
                    _ = g.getSnapshotBeforeUpdate(t.elementType === t.type ? b : Zt(t.type, b), S)
                  g.__reactInternalSnapshotBeforeUpdate = _
                }
                break
              case 3:
                var y = t.stateNode.containerInfo
                y.nodeType === 1
                  ? (y.textContent = '')
                  : y.nodeType === 9 && y.documentElement && y.removeChild(y.documentElement)
                break
              case 5:
              case 6:
              case 4:
              case 17:
                break
              default:
                throw Error(ue(163))
            }
        } catch (x) {
          Ye(t, t.return, x)
        }
        if (((e = t.sibling), e !== null)) {
          ;(e.return = t.return), (he = e)
          break
        }
        he = t.return
      }
  return (v = Ph), (Ph = !1), v
}
function hs(e, t, r) {
  var i = t.updateQueue
  if (((i = i !== null ? i.lastEffect : null), i !== null)) {
    var n = (i = i.next)
    do {
      if ((n.tag & e) === e) {
        var s = n.destroy
        ;(n.destroy = void 0), s !== void 0 && gc(t, r, s)
      }
      n = n.next
    } while (n !== i)
  }
}
function Jo(e, t) {
  if (((t = t.updateQueue), (t = t !== null ? t.lastEffect : null), t !== null)) {
    var r = (t = t.next)
    do {
      if ((r.tag & e) === e) {
        var i = r.create
        r.destroy = i()
      }
      r = r.next
    } while (r !== t)
  }
}
function bc(e) {
  var t = e.ref
  if (t !== null) {
    var r = e.stateNode
    switch (e.tag) {
      case 5:
        e = r
        break
      default:
        e = r
    }
    typeof t == 'function' ? t(e) : (t.current = e)
  }
}
function Ag(e) {
  var t = e.alternate
  t !== null && ((e.alternate = null), Ag(t)),
    (e.child = null),
    (e.deletions = null),
    (e.sibling = null),
    e.tag === 5 &&
      ((t = e.stateNode),
      t !== null && (delete t[hr], delete t[Ls], delete t[ic], delete t[Tv], delete t[Av])),
    (e.stateNode = null),
    (e.return = null),
    (e.dependencies = null),
    (e.memoizedProps = null),
    (e.memoizedState = null),
    (e.pendingProps = null),
    (e.stateNode = null),
    (e.updateQueue = null)
}
function Sg(e) {
  return e.tag === 5 || e.tag === 3 || e.tag === 4
}
function Bh(e) {
  e: for (;;) {
    for (; e.sibling === null; ) {
      if (e.return === null || Sg(e.return)) return null
      e = e.return
    }
    for (e.sibling.return = e.return, e = e.sibling; e.tag !== 5 && e.tag !== 6 && e.tag !== 18; ) {
      if (e.flags & 2 || e.child === null || e.tag === 4) continue e
      ;(e.child.return = e), (e = e.child)
    }
    if (!(e.flags & 2)) return e.stateNode
  }
}
function yc(e, t, r) {
  var i = e.tag
  if (i === 5 || i === 6)
    (e = e.stateNode),
      t
        ? r.nodeType === 8
          ? r.parentNode.insertBefore(e, t)
          : r.insertBefore(e, t)
        : (r.nodeType === 8
            ? ((t = r.parentNode), t.insertBefore(e, r))
            : ((t = r), t.appendChild(e)),
          (r = r._reactRootContainer),
          r != null || t.onclick !== null || (t.onclick = bo))
  else if (i !== 4 && ((e = e.child), e !== null))
    for (yc(e, t, r), e = e.sibling; e !== null; ) yc(e, t, r), (e = e.sibling)
}
function _c(e, t, r) {
  var i = e.tag
  if (i === 5 || i === 6) (e = e.stateNode), t ? r.insertBefore(e, t) : r.appendChild(e)
  else if (i !== 4 && ((e = e.child), e !== null))
    for (_c(e, t, r), e = e.sibling; e !== null; ) _c(e, t, r), (e = e.sibling)
}
var at = null,
  er = !1
function Ur(e, t, r) {
  for (r = r.child; r !== null; ) Cg(e, t, r), (r = r.sibling)
}
function Cg(e, t, r) {
  if (br && typeof br.onCommitFiberUnmount == 'function')
    try {
      br.onCommitFiberUnmount($o, r)
    } catch {}
  switch (r.tag) {
    case 5:
      pt || ln(r, t)
    case 6:
      var i = at,
        n = er
      ;(at = null),
        Ur(e, t, r),
        (at = i),
        (er = n),
        at !== null &&
          (er
            ? ((e = at),
              (r = r.stateNode),
              e.nodeType === 8 ? e.parentNode.removeChild(r) : e.removeChild(r))
            : at.removeChild(r.stateNode))
      break
    case 18:
      at !== null &&
        (er
          ? ((e = at),
            (r = r.stateNode),
            e.nodeType === 8 ? Gu(e.parentNode, r) : e.nodeType === 1 && Gu(e, r),
            Ns(e))
          : Gu(at, r.stateNode))
      break
    case 4:
      ;(i = at),
        (n = er),
        (at = r.stateNode.containerInfo),
        (er = !0),
        Ur(e, t, r),
        (at = i),
        (er = n)
      break
    case 0:
    case 11:
    case 14:
    case 15:
      if (!pt && ((i = r.updateQueue), i !== null && ((i = i.lastEffect), i !== null))) {
        n = i = i.next
        do {
          var s = n,
            a = s.destroy
          ;(s = s.tag), a !== void 0 && (s & 2 || s & 4) && gc(r, t, a), (n = n.next)
        } while (n !== i)
      }
      Ur(e, t, r)
      break
    case 1:
      if (!pt && (ln(r, t), (i = r.stateNode), typeof i.componentWillUnmount == 'function'))
        try {
          ;(i.props = r.memoizedProps), (i.state = r.memoizedState), i.componentWillUnmount()
        } catch (o) {
          Ye(r, t, o)
        }
      Ur(e, t, r)
      break
    case 21:
      Ur(e, t, r)
      break
    case 22:
      r.mode & 1
        ? ((pt = (i = pt) || r.memoizedState !== null), Ur(e, t, r), (pt = i))
        : Ur(e, t, r)
      break
    default:
      Ur(e, t, r)
  }
}
function Fh(e) {
  var t = e.updateQueue
  if (t !== null) {
    e.updateQueue = null
    var r = e.stateNode
    r === null && (r = e.stateNode = new Hv()),
      t.forEach(function (i) {
        var n = Qv.bind(null, e, i)
        r.has(i) || (r.add(i), i.then(n, n))
      })
  }
}
function Jt(e, t) {
  var r = t.deletions
  if (r !== null)
    for (var i = 0; i < r.length; i++) {
      var n = r[i]
      try {
        var s = e,
          a = t,
          o = a
        e: for (; o !== null; ) {
          switch (o.tag) {
            case 5:
              ;(at = o.stateNode), (er = !1)
              break e
            case 3:
              ;(at = o.stateNode.containerInfo), (er = !0)
              break e
            case 4:
              ;(at = o.stateNode.containerInfo), (er = !0)
              break e
          }
          o = o.return
        }
        if (at === null) throw Error(ue(160))
        Cg(s, a, n), (at = null), (er = !1)
        var u = n.alternate
        u !== null && (u.return = null), (n.return = null)
      } catch (c) {
        Ye(n, t, c)
      }
    }
  if (t.subtreeFlags & 12854) for (t = t.child; t !== null; ) kg(t, e), (t = t.sibling)
}
function kg(e, t) {
  var r = e.alternate,
    i = e.flags
  switch (e.tag) {
    case 0:
    case 11:
    case 14:
    case 15:
      if ((Jt(t, e), cr(e), i & 4)) {
        try {
          hs(3, e, e.return), Jo(3, e)
        } catch (b) {
          Ye(e, e.return, b)
        }
        try {
          hs(5, e, e.return)
        } catch (b) {
          Ye(e, e.return, b)
        }
      }
      break
    case 1:
      Jt(t, e), cr(e), i & 512 && r !== null && ln(r, r.return)
      break
    case 5:
      if ((Jt(t, e), cr(e), i & 512 && r !== null && ln(r, r.return), e.flags & 32)) {
        var n = e.stateNode
        try {
          Ss(n, '')
        } catch (b) {
          Ye(e, e.return, b)
        }
      }
      if (i & 4 && ((n = e.stateNode), n != null)) {
        var s = e.memoizedProps,
          a = r !== null ? r.memoizedProps : s,
          o = e.type,
          u = e.updateQueue
        if (((e.updateQueue = null), u !== null))
          try {
            o === 'input' && s.type === 'radio' && s.name != null && Yd(n, s), ql(o, a)
            var c = ql(o, s)
            for (a = 0; a < u.length; a += 2) {
              var f = u[a],
                h = u[a + 1]
              f === 'style'
                ? Zd(n, h)
                : f === 'dangerouslySetInnerHTML'
                ? Kd(n, h)
                : f === 'children'
                ? Ss(n, h)
                : ff(n, f, h, c)
            }
            switch (o) {
              case 'input':
                Ml(n, s)
                break
              case 'textarea':
                Wd(n, s)
                break
              case 'select':
                var p = n._wrapperState.wasMultiple
                n._wrapperState.wasMultiple = !!s.multiple
                var m = s.value
                m != null
                  ? dn(n, !!s.multiple, m, !1)
                  : p !== !!s.multiple &&
                    (s.defaultValue != null
                      ? dn(n, !!s.multiple, s.defaultValue, !0)
                      : dn(n, !!s.multiple, s.multiple ? [] : '', !1))
            }
            n[Ls] = s
          } catch (b) {
            Ye(e, e.return, b)
          }
      }
      break
    case 6:
      if ((Jt(t, e), cr(e), i & 4)) {
        if (e.stateNode === null) throw Error(ue(162))
        ;(n = e.stateNode), (s = e.memoizedProps)
        try {
          n.nodeValue = s
        } catch (b) {
          Ye(e, e.return, b)
        }
      }
      break
    case 3:
      if ((Jt(t, e), cr(e), i & 4 && r !== null && r.memoizedState.isDehydrated))
        try {
          Ns(t.containerInfo)
        } catch (b) {
          Ye(e, e.return, b)
        }
      break
    case 4:
      Jt(t, e), cr(e)
      break
    case 13:
      Jt(t, e),
        cr(e),
        (n = e.child),
        n.flags & 8192 &&
          ((s = n.memoizedState !== null),
          (n.stateNode.isHidden = s),
          !s || (n.alternate !== null && n.alternate.memoizedState !== null) || ($f = We())),
        i & 4 && Fh(e)
      break
    case 22:
      if (
        ((f = r !== null && r.memoizedState !== null),
        e.mode & 1 ? ((pt = (c = pt) || f), Jt(t, e), (pt = c)) : Jt(t, e),
        cr(e),
        i & 8192)
      ) {
        if (((c = e.memoizedState !== null), (e.stateNode.isHidden = c) && !f && e.mode & 1))
          for (he = e, f = e.child; f !== null; ) {
            for (h = he = f; he !== null; ) {
              switch (((p = he), (m = p.child), p.tag)) {
                case 0:
                case 11:
                case 14:
                case 15:
                  hs(4, p, p.return)
                  break
                case 1:
                  ln(p, p.return)
                  var v = p.stateNode
                  if (typeof v.componentWillUnmount == 'function') {
                    ;(i = p), (r = p.return)
                    try {
                      ;(t = i),
                        (v.props = t.memoizedProps),
                        (v.state = t.memoizedState),
                        v.componentWillUnmount()
                    } catch (b) {
                      Ye(i, r, b)
                    }
                  }
                  break
                case 5:
                  ln(p, p.return)
                  break
                case 22:
                  if (p.memoizedState !== null) {
                    Uh(h)
                    continue
                  }
              }
              m !== null ? ((m.return = p), (he = m)) : Uh(h)
            }
            f = f.sibling
          }
        e: for (f = null, h = e; ; ) {
          if (h.tag === 5) {
            if (f === null) {
              f = h
              try {
                ;(n = h.stateNode),
                  c
                    ? ((s = n.style),
                      typeof s.setProperty == 'function'
                        ? s.setProperty('display', 'none', 'important')
                        : (s.display = 'none'))
                    : ((o = h.stateNode),
                      (u = h.memoizedProps.style),
                      (a = u != null && u.hasOwnProperty('display') ? u.display : null),
                      (o.style.display = Jd('display', a)))
              } catch (b) {
                Ye(e, e.return, b)
              }
            }
          } else if (h.tag === 6) {
            if (f === null)
              try {
                h.stateNode.nodeValue = c ? '' : h.memoizedProps
              } catch (b) {
                Ye(e, e.return, b)
              }
          } else if (
            ((h.tag !== 22 && h.tag !== 23) || h.memoizedState === null || h === e) &&
            h.child !== null
          ) {
            ;(h.child.return = h), (h = h.child)
            continue
          }
          if (h === e) break e
          for (; h.sibling === null; ) {
            if (h.return === null || h.return === e) break e
            f === h && (f = null), (h = h.return)
          }
          f === h && (f = null), (h.sibling.return = h.return), (h = h.sibling)
        }
      }
      break
    case 19:
      Jt(t, e), cr(e), i & 4 && Fh(e)
      break
    case 21:
      break
    default:
      Jt(t, e), cr(e)
  }
}
function cr(e) {
  var t = e.flags
  if (t & 2) {
    try {
      e: {
        for (var r = e.return; r !== null; ) {
          if (Sg(r)) {
            var i = r
            break e
          }
          r = r.return
        }
        throw Error(ue(160))
      }
      switch (i.tag) {
        case 5:
          var n = i.stateNode
          i.flags & 32 && (Ss(n, ''), (i.flags &= -33))
          var s = Bh(e)
          _c(e, s, n)
          break
        case 3:
        case 4:
          var a = i.stateNode.containerInfo,
            o = Bh(e)
          yc(e, o, a)
          break
        default:
          throw Error(ue(161))
      }
    } catch (u) {
      Ye(e, e.return, u)
    }
    e.flags &= -3
  }
  t & 4096 && (e.flags &= -4097)
}
function jv(e, t, r) {
  ;(he = e), wg(e)
}
function wg(e, t, r) {
  for (var i = (e.mode & 1) !== 0; he !== null; ) {
    var n = he,
      s = n.child
    if (n.tag === 22 && i) {
      var a = n.memoizedState !== null || Oa
      if (!a) {
        var o = n.alternate,
          u = (o !== null && o.memoizedState !== null) || pt
        o = Oa
        var c = pt
        if (((Oa = a), (pt = u) && !c))
          for (he = n; he !== null; )
            (a = he),
              (u = a.child),
              a.tag === 22 && a.memoizedState !== null
                ? Hh(n)
                : u !== null
                ? ((u.return = a), (he = u))
                : Hh(n)
        for (; s !== null; ) (he = s), wg(s), (s = s.sibling)
        ;(he = n), (Oa = o), (pt = c)
      }
      Mh(e)
    } else n.subtreeFlags & 8772 && s !== null ? ((s.return = n), (he = s)) : Mh(e)
  }
}
function Mh(e) {
  for (; he !== null; ) {
    var t = he
    if (t.flags & 8772) {
      var r = t.alternate
      try {
        if (t.flags & 8772)
          switch (t.tag) {
            case 0:
            case 11:
            case 15:
              pt || Jo(5, t)
              break
            case 1:
              var i = t.stateNode
              if (t.flags & 4 && !pt)
                if (r === null) i.componentDidMount()
                else {
                  var n = t.elementType === t.type ? r.memoizedProps : Zt(t.type, r.memoizedProps)
                  i.componentDidUpdate(n, r.memoizedState, i.__reactInternalSnapshotBeforeUpdate)
                }
              var s = t.updateQueue
              s !== null && Eh(t, s, i)
              break
            case 3:
              var a = t.updateQueue
              if (a !== null) {
                if (((r = null), t.child !== null))
                  switch (t.child.tag) {
                    case 5:
                      r = t.child.stateNode
                      break
                    case 1:
                      r = t.child.stateNode
                  }
                Eh(t, a, r)
              }
              break
            case 5:
              var o = t.stateNode
              if (r === null && t.flags & 4) {
                r = o
                var u = t.memoizedProps
                switch (t.type) {
                  case 'button':
                  case 'input':
                  case 'select':
                  case 'textarea':
                    u.autoFocus && r.focus()
                    break
                  case 'img':
                    u.src && (r.src = u.src)
                }
              }
              break
            case 6:
              break
            case 4:
              break
            case 12:
              break
            case 13:
              if (t.memoizedState === null) {
                var c = t.alternate
                if (c !== null) {
                  var f = c.memoizedState
                  if (f !== null) {
                    var h = f.dehydrated
                    h !== null && Ns(h)
                  }
                }
              }
              break
            case 19:
            case 17:
            case 21:
            case 22:
            case 23:
            case 25:
              break
            default:
              throw Error(ue(163))
          }
        pt || (t.flags & 512 && bc(t))
      } catch (p) {
        Ye(t, t.return, p)
      }
    }
    if (t === e) {
      he = null
      break
    }
    if (((r = t.sibling), r !== null)) {
      ;(r.return = t.return), (he = r)
      break
    }
    he = t.return
  }
}
function Uh(e) {
  for (; he !== null; ) {
    var t = he
    if (t === e) {
      he = null
      break
    }
    var r = t.sibling
    if (r !== null) {
      ;(r.return = t.return), (he = r)
      break
    }
    he = t.return
  }
}
function Hh(e) {
  for (; he !== null; ) {
    var t = he
    try {
      switch (t.tag) {
        case 0:
        case 11:
        case 15:
          var r = t.return
          try {
            Jo(4, t)
          } catch (u) {
            Ye(t, r, u)
          }
          break
        case 1:
          var i = t.stateNode
          if (typeof i.componentDidMount == 'function') {
            var n = t.return
            try {
              i.componentDidMount()
            } catch (u) {
              Ye(t, n, u)
            }
          }
          var s = t.return
          try {
            bc(t)
          } catch (u) {
            Ye(t, s, u)
          }
          break
        case 5:
          var a = t.return
          try {
            bc(t)
          } catch (u) {
            Ye(t, a, u)
          }
      }
    } catch (u) {
      Ye(t, t.return, u)
    }
    if (t === e) {
      he = null
      break
    }
    var o = t.sibling
    if (o !== null) {
      ;(o.return = t.return), (he = o)
      break
    }
    he = t.return
  }
}
var qv = Math.ceil,
  wo = Br.ReactCurrentDispatcher,
  jf = Br.ReactCurrentOwner,
  Yt = Br.ReactCurrentBatchConfig,
  Ie = 0,
  st = null,
  Ke = null,
  ot = 0,
  Dt = 0,
  cn = pi(0),
  Ze = 0,
  Hs = null,
  Ii = 0,
  Zo = 0,
  qf = 0,
  ms = null,
  At = null,
  $f = 0,
  On = 1 / 0,
  Sr = null,
  No = !1,
  vc = null,
  ri = null,
  Ia = !1,
  Qr = null,
  Oo = 0,
  ds = 0,
  Ec = null,
  Ja = -1,
  Za = 0
function yt() {
  return Ie & 6 ? We() : Ja !== -1 ? Ja : (Ja = We())
}
function ii(e) {
  return e.mode & 1
    ? Ie & 2 && ot !== 0
      ? ot & -ot
      : Cv.transition !== null
      ? (Za === 0 && (Za = f0()), Za)
      : ((e = Re), e !== 0 || ((e = window.event), (e = e === void 0 ? 16 : y0(e.type))), e)
    : 1
}
function nr(e, t, r, i) {
  if (50 < ds) throw ((ds = 0), (Ec = null), Error(ue(185)))
  ea(e, r, i),
    (!(Ie & 2) || e !== st) &&
      (e === st && (!(Ie & 2) && (Zo |= r), Ze === 4 && Xr(e, ot)),
      Nt(e, i),
      r === 1 && Ie === 0 && !(t.mode & 1) && ((On = We() + 500), Wo && hi()))
}
function Nt(e, t) {
  var r = e.callbackNode
  C_(e, t)
  var i = po(e, e === st ? ot : 0)
  if (i === 0) r !== null && Wp(r), (e.callbackNode = null), (e.callbackPriority = 0)
  else if (((t = i & -i), e.callbackPriority !== t)) {
    if ((r != null && Wp(r), t === 1))
      e.tag === 0 ? Sv(zh.bind(null, e)) : F0(zh.bind(null, e)),
        Ev(function () {
          !(Ie & 6) && hi()
        }),
        (r = null)
    else {
      switch (p0(i)) {
        case 1:
          r = gf
          break
        case 4:
          r = l0
          break
        case 16:
          r = fo
          break
        case 536870912:
          r = c0
          break
        default:
          r = fo
      }
      r = Bg(r, Ng.bind(null, e))
    }
    ;(e.callbackPriority = t), (e.callbackNode = r)
  }
}
function Ng(e, t) {
  if (((Ja = -1), (Za = 0), Ie & 6)) throw Error(ue(327))
  var r = e.callbackNode
  if (vn() && e.callbackNode !== r) return null
  var i = po(e, e === st ? ot : 0)
  if (i === 0) return null
  if (i & 30 || i & e.expiredLanes || t) t = Io(e, i)
  else {
    t = i
    var n = Ie
    Ie |= 2
    var s = Ig()
    ;(st !== e || ot !== t) && ((Sr = null), (On = We() + 500), Si(e, t))
    do
      try {
        Gv()
        break
      } catch (o) {
        Og(e, o)
      }
    while (1)
    Nf(), (wo.current = s), (Ie = n), Ke !== null ? (t = 0) : ((st = null), (ot = 0), (t = Ze))
  }
  if (t !== 0) {
    if ((t === 2 && ((n = Yl(e)), n !== 0 && ((i = n), (t = xc(e, n)))), t === 1))
      throw ((r = Hs), Si(e, 0), Xr(e, i), Nt(e, We()), r)
    if (t === 6) Xr(e, i)
    else {
      if (
        ((n = e.current.alternate),
        !(i & 30) &&
          !$v(n) &&
          ((t = Io(e, i)), t === 2 && ((s = Yl(e)), s !== 0 && ((i = s), (t = xc(e, s)))), t === 1))
      )
        throw ((r = Hs), Si(e, 0), Xr(e, i), Nt(e, We()), r)
      switch (((e.finishedWork = n), (e.finishedLanes = i), t)) {
        case 0:
        case 1:
          throw Error(ue(345))
        case 2:
          yi(e, At, Sr)
          break
        case 3:
          if ((Xr(e, i), (i & 130023424) === i && ((t = $f + 500 - We()), 10 < t))) {
            if (po(e, 0) !== 0) break
            if (((n = e.suspendedLanes), (n & i) !== i)) {
              yt(), (e.pingedLanes |= e.suspendedLanes & n)
              break
            }
            e.timeoutHandle = rc(yi.bind(null, e, At, Sr), t)
            break
          }
          yi(e, At, Sr)
          break
        case 4:
          if ((Xr(e, i), (i & 4194240) === i)) break
          for (t = e.eventTimes, n = -1; 0 < i; ) {
            var a = 31 - ir(i)
            ;(s = 1 << a), (a = t[a]), a > n && (n = a), (i &= ~s)
          }
          if (
            ((i = n),
            (i = We() - i),
            (i =
              (120 > i
                ? 120
                : 480 > i
                ? 480
                : 1080 > i
                ? 1080
                : 1920 > i
                ? 1920
                : 3e3 > i
                ? 3e3
                : 4320 > i
                ? 4320
                : 1960 * qv(i / 1960)) - i),
            10 < i)
          ) {
            e.timeoutHandle = rc(yi.bind(null, e, At, Sr), i)
            break
          }
          yi(e, At, Sr)
          break
        case 5:
          yi(e, At, Sr)
          break
        default:
          throw Error(ue(329))
      }
    }
  }
  return Nt(e, We()), e.callbackNode === r ? Ng.bind(null, e) : null
}
function xc(e, t) {
  var r = ms
  return (
    e.current.memoizedState.isDehydrated && (Si(e, t).flags |= 256),
    (e = Io(e, t)),
    e !== 2 && ((t = At), (At = r), t !== null && Tc(t)),
    e
  )
}
function Tc(e) {
  At === null ? (At = e) : At.push.apply(At, e)
}
function $v(e) {
  for (var t = e; ; ) {
    if (t.flags & 16384) {
      var r = t.updateQueue
      if (r !== null && ((r = r.stores), r !== null))
        for (var i = 0; i < r.length; i++) {
          var n = r[i],
            s = n.getSnapshot
          n = n.value
          try {
            if (!ar(s(), n)) return !1
          } catch {
            return !1
          }
        }
    }
    if (((r = t.child), t.subtreeFlags & 16384 && r !== null)) (r.return = t), (t = r)
    else {
      if (t === e) break
      for (; t.sibling === null; ) {
        if (t.return === null || t.return === e) return !0
        t = t.return
      }
      ;(t.sibling.return = t.return), (t = t.sibling)
    }
  }
  return !0
}
function Xr(e, t) {
  for (
    t &= ~qf, t &= ~Zo, e.suspendedLanes |= t, e.pingedLanes &= ~t, e = e.expirationTimes;
    0 < t;

  ) {
    var r = 31 - ir(t),
      i = 1 << r
    ;(e[r] = -1), (t &= ~i)
  }
}
function zh(e) {
  if (Ie & 6) throw Error(ue(327))
  vn()
  var t = po(e, 0)
  if (!(t & 1)) return Nt(e, We()), null
  var r = Io(e, t)
  if (e.tag !== 0 && r === 2) {
    var i = Yl(e)
    i !== 0 && ((t = i), (r = xc(e, i)))
  }
  if (r === 1) throw ((r = Hs), Si(e, 0), Xr(e, t), Nt(e, We()), r)
  if (r === 6) throw Error(ue(345))
  return (
    (e.finishedWork = e.current.alternate), (e.finishedLanes = t), yi(e, At, Sr), Nt(e, We()), null
  )
}
function Vf(e, t) {
  var r = Ie
  Ie |= 1
  try {
    return e(t)
  } finally {
    ;(Ie = r), Ie === 0 && ((On = We() + 500), Wo && hi())
  }
}
function Di(e) {
  Qr !== null && Qr.tag === 0 && !(Ie & 6) && vn()
  var t = Ie
  Ie |= 1
  var r = Yt.transition,
    i = Re
  try {
    if (((Yt.transition = null), (Re = 1), e)) return e()
  } finally {
    ;(Re = i), (Yt.transition = r), (Ie = t), !(Ie & 6) && hi()
  }
}
function Gf() {
  ;(Dt = cn.current), He(cn)
}
function Si(e, t) {
  ;(e.finishedWork = null), (e.finishedLanes = 0)
  var r = e.timeoutHandle
  if ((r !== -1 && ((e.timeoutHandle = -1), vv(r)), Ke !== null))
    for (r = Ke.return; r !== null; ) {
      var i = r
      switch ((Cf(i), i.tag)) {
        case 1:
          ;(i = i.type.childContextTypes), i != null && yo()
          break
        case 3:
          wn(), He(kt), He(mt), Pf()
          break
        case 5:
          Lf(i)
          break
        case 4:
          wn()
          break
        case 13:
          He(Ve)
          break
        case 19:
          He(Ve)
          break
        case 10:
          Of(i.type._context)
          break
        case 22:
        case 23:
          Gf()
      }
      r = r.return
    }
  if (
    ((st = e),
    (Ke = e = ni(e.current, null)),
    (ot = Dt = t),
    (Ze = 0),
    (Hs = null),
    (qf = Zo = Ii = 0),
    (At = ms = null),
    xi !== null)
  ) {
    for (t = 0; t < xi.length; t++)
      if (((r = xi[t]), (i = r.interleaved), i !== null)) {
        r.interleaved = null
        var n = i.next,
          s = r.pending
        if (s !== null) {
          var a = s.next
          ;(s.next = n), (i.next = a)
        }
        r.pending = i
      }
    xi = null
  }
  return e
}
function Og(e, t) {
  do {
    var r = Ke
    try {
      if ((Nf(), (Wa.current = ko), Co)) {
        for (var i = Ge.memoizedState; i !== null; ) {
          var n = i.queue
          n !== null && (n.pending = null), (i = i.next)
        }
        Co = !1
      }
      if (
        ((Oi = 0),
        (it = Je = Ge = null),
        (ps = !1),
        (Fs = 0),
        (jf.current = null),
        r === null || r.return === null)
      ) {
        ;(Ze = 1), (Hs = t), (Ke = null)
        break
      }
      e: {
        var s = e,
          a = r.return,
          o = r,
          u = t
        if (
          ((t = ot),
          (o.flags |= 32768),
          u !== null && typeof u == 'object' && typeof u.then == 'function')
        ) {
          var c = u,
            f = o,
            h = f.tag
          if (!(f.mode & 1) && (h === 0 || h === 11 || h === 15)) {
            var p = f.alternate
            p
              ? ((f.updateQueue = p.updateQueue),
                (f.memoizedState = p.memoizedState),
                (f.lanes = p.lanes))
              : ((f.updateQueue = null), (f.memoizedState = null))
          }
          var m = wh(a)
          if (m !== null) {
            ;(m.flags &= -257), Nh(m, a, o, s, t), m.mode & 1 && kh(s, c, t), (t = m), (u = c)
            var v = t.updateQueue
            if (v === null) {
              var b = new Set()
              b.add(u), (t.updateQueue = b)
            } else v.add(u)
            break e
          } else {
            if (!(t & 1)) {
              kh(s, c, t), Xf()
              break e
            }
            u = Error(ue(426))
          }
        } else if (qe && o.mode & 1) {
          var S = wh(a)
          if (S !== null) {
            !(S.flags & 65536) && (S.flags |= 256), Nh(S, a, o, s, t), kf(Nn(u, o))
            break e
          }
        }
        ;(s = u = Nn(u, o)), Ze !== 4 && (Ze = 2), ms === null ? (ms = [s]) : ms.push(s), (s = a)
        do {
          switch (s.tag) {
            case 3:
              ;(s.flags |= 65536), (t &= -t), (s.lanes |= t)
              var g = hg(s, u, t)
              vh(s, g)
              break e
            case 1:
              o = u
              var _ = s.type,
                y = s.stateNode
              if (
                !(s.flags & 128) &&
                (typeof _.getDerivedStateFromError == 'function' ||
                  (y !== null &&
                    typeof y.componentDidCatch == 'function' &&
                    (ri === null || !ri.has(y))))
              ) {
                ;(s.flags |= 65536), (t &= -t), (s.lanes |= t)
                var x = mg(s, o, t)
                vh(s, x)
                break e
              }
          }
          s = s.return
        } while (s !== null)
      }
      Rg(r)
    } catch (D) {
      ;(t = D), Ke === r && r !== null && (Ke = r = r.return)
      continue
    }
    break
  } while (1)
}
function Ig() {
  var e = wo.current
  return (wo.current = ko), e === null ? ko : e
}
function Xf() {
  ;(Ze === 0 || Ze === 3 || Ze === 2) && (Ze = 4),
    st === null || (!(Ii & 268435455) && !(Zo & 268435455)) || Xr(st, ot)
}
function Io(e, t) {
  var r = Ie
  Ie |= 2
  var i = Ig()
  ;(st !== e || ot !== t) && ((Sr = null), Si(e, t))
  do
    try {
      Vv()
      break
    } catch (n) {
      Og(e, n)
    }
  while (1)
  if ((Nf(), (Ie = r), (wo.current = i), Ke !== null)) throw Error(ue(261))
  return (st = null), (ot = 0), Ze
}
function Vv() {
  for (; Ke !== null; ) Dg(Ke)
}
function Gv() {
  for (; Ke !== null && !b_(); ) Dg(Ke)
}
function Dg(e) {
  var t = Pg(e.alternate, e, Dt)
  ;(e.memoizedProps = e.pendingProps), t === null ? Rg(e) : (Ke = t), (jf.current = null)
}
function Rg(e) {
  var t = e
  do {
    var r = t.alternate
    if (((e = t.return), t.flags & 32768)) {
      if (((r = Uv(r, t)), r !== null)) {
        ;(r.flags &= 32767), (Ke = r)
        return
      }
      if (e !== null) (e.flags |= 32768), (e.subtreeFlags = 0), (e.deletions = null)
      else {
        ;(Ze = 6), (Ke = null)
        return
      }
    } else if (((r = Mv(r, t, Dt)), r !== null)) {
      Ke = r
      return
    }
    if (((t = t.sibling), t !== null)) {
      Ke = t
      return
    }
    Ke = t = e
  } while (t !== null)
  Ze === 0 && (Ze = 5)
}
function yi(e, t, r) {
  var i = Re,
    n = Yt.transition
  try {
    ;(Yt.transition = null), (Re = 1), Xv(e, t, r, i)
  } finally {
    ;(Yt.transition = n), (Re = i)
  }
  return null
}
function Xv(e, t, r, i) {
  do vn()
  while (Qr !== null)
  if (Ie & 6) throw Error(ue(327))
  r = e.finishedWork
  var n = e.finishedLanes
  if (r === null) return null
  if (((e.finishedWork = null), (e.finishedLanes = 0), r === e.current)) throw Error(ue(177))
  ;(e.callbackNode = null), (e.callbackPriority = 0)
  var s = r.lanes | r.childLanes
  if (
    (k_(e, s),
    e === st && ((Ke = st = null), (ot = 0)),
    (!(r.subtreeFlags & 2064) && !(r.flags & 2064)) ||
      Ia ||
      ((Ia = !0),
      Bg(fo, function () {
        return vn(), null
      })),
    (s = (r.flags & 15990) !== 0),
    r.subtreeFlags & 15990 || s)
  ) {
    ;(s = Yt.transition), (Yt.transition = null)
    var a = Re
    Re = 1
    var o = Ie
    ;(Ie |= 4),
      (jf.current = null),
      zv(e, r),
      kg(r, e),
      hv(ec),
      (ho = !!Zl),
      (ec = Zl = null),
      (e.current = r),
      jv(r),
      y_(),
      (Ie = o),
      (Re = a),
      (Yt.transition = s)
  } else e.current = r
  if (
    (Ia && ((Ia = !1), (Qr = e), (Oo = n)),
    (s = e.pendingLanes),
    s === 0 && (ri = null),
    E_(r.stateNode),
    Nt(e, We()),
    t !== null)
  )
    for (i = e.onRecoverableError, r = 0; r < t.length; r++)
      (n = t[r]), i(n.value, { componentStack: n.stack, digest: n.digest })
  if (No) throw ((No = !1), (e = vc), (vc = null), e)
  return (
    Oo & 1 && e.tag !== 0 && vn(),
    (s = e.pendingLanes),
    s & 1 ? (e === Ec ? ds++ : ((ds = 0), (Ec = e))) : (ds = 0),
    hi(),
    null
  )
}
function vn() {
  if (Qr !== null) {
    var e = p0(Oo),
      t = Yt.transition,
      r = Re
    try {
      if (((Yt.transition = null), (Re = 16 > e ? 16 : e), Qr === null)) var i = !1
      else {
        if (((e = Qr), (Qr = null), (Oo = 0), Ie & 6)) throw Error(ue(331))
        var n = Ie
        for (Ie |= 4, he = e.current; he !== null; ) {
          var s = he,
            a = s.child
          if (he.flags & 16) {
            var o = s.deletions
            if (o !== null) {
              for (var u = 0; u < o.length; u++) {
                var c = o[u]
                for (he = c; he !== null; ) {
                  var f = he
                  switch (f.tag) {
                    case 0:
                    case 11:
                    case 15:
                      hs(8, f, s)
                  }
                  var h = f.child
                  if (h !== null) (h.return = f), (he = h)
                  else
                    for (; he !== null; ) {
                      f = he
                      var p = f.sibling,
                        m = f.return
                      if ((Ag(f), f === c)) {
                        he = null
                        break
                      }
                      if (p !== null) {
                        ;(p.return = m), (he = p)
                        break
                      }
                      he = m
                    }
                }
              }
              var v = s.alternate
              if (v !== null) {
                var b = v.child
                if (b !== null) {
                  v.child = null
                  do {
                    var S = b.sibling
                    ;(b.sibling = null), (b = S)
                  } while (b !== null)
                }
              }
              he = s
            }
          }
          if (s.subtreeFlags & 2064 && a !== null) (a.return = s), (he = a)
          else
            e: for (; he !== null; ) {
              if (((s = he), s.flags & 2048))
                switch (s.tag) {
                  case 0:
                  case 11:
                  case 15:
                    hs(9, s, s.return)
                }
              var g = s.sibling
              if (g !== null) {
                ;(g.return = s.return), (he = g)
                break e
              }
              he = s.return
            }
        }
        var _ = e.current
        for (he = _; he !== null; ) {
          a = he
          var y = a.child
          if (a.subtreeFlags & 2064 && y !== null) (y.return = a), (he = y)
          else
            e: for (a = _; he !== null; ) {
              if (((o = he), o.flags & 2048))
                try {
                  switch (o.tag) {
                    case 0:
                    case 11:
                    case 15:
                      Jo(9, o)
                  }
                } catch (D) {
                  Ye(o, o.return, D)
                }
              if (o === a) {
                he = null
                break e
              }
              var x = o.sibling
              if (x !== null) {
                ;(x.return = o.return), (he = x)
                break e
              }
              he = o.return
            }
        }
        if (((Ie = n), hi(), br && typeof br.onPostCommitFiberRoot == 'function'))
          try {
            br.onPostCommitFiberRoot($o, e)
          } catch {}
        i = !0
      }
      return i
    } finally {
      ;(Re = r), (Yt.transition = t)
    }
  }
  return !1
}
function jh(e, t, r) {
  ;(t = Nn(r, t)),
    (t = hg(e, t, 1)),
    (e = ti(e, t, 1)),
    (t = yt()),
    e !== null && (ea(e, 1, t), Nt(e, t))
}
function Ye(e, t, r) {
  if (e.tag === 3) jh(e, e, r)
  else
    for (; t !== null; ) {
      if (t.tag === 3) {
        jh(t, e, r)
        break
      } else if (t.tag === 1) {
        var i = t.stateNode
        if (
          typeof t.type.getDerivedStateFromError == 'function' ||
          (typeof i.componentDidCatch == 'function' && (ri === null || !ri.has(i)))
        ) {
          ;(e = Nn(r, e)),
            (e = mg(t, e, 1)),
            (t = ti(t, e, 1)),
            (e = yt()),
            t !== null && (ea(t, 1, e), Nt(t, e))
          break
        }
      }
      t = t.return
    }
}
function Yv(e, t, r) {
  var i = e.pingCache
  i !== null && i.delete(t),
    (t = yt()),
    (e.pingedLanes |= e.suspendedLanes & r),
    st === e &&
      (ot & r) === r &&
      (Ze === 4 || (Ze === 3 && (ot & 130023424) === ot && 500 > We() - $f) ? Si(e, 0) : (qf |= r)),
    Nt(e, t)
}
function Lg(e, t) {
  t === 0 && (e.mode & 1 ? ((t = Ea), (Ea <<= 1), !(Ea & 130023424) && (Ea = 4194304)) : (t = 1))
  var r = yt()
  ;(e = Dr(e, t)), e !== null && (ea(e, t, r), Nt(e, r))
}
function Wv(e) {
  var t = e.memoizedState,
    r = 0
  t !== null && (r = t.retryLane), Lg(e, r)
}
function Qv(e, t) {
  var r = 0
  switch (e.tag) {
    case 13:
      var i = e.stateNode,
        n = e.memoizedState
      n !== null && (r = n.retryLane)
      break
    case 19:
      i = e.stateNode
      break
    default:
      throw Error(ue(314))
  }
  i !== null && i.delete(t), Lg(e, r)
}
var Pg
Pg = function (e, t, r) {
  if (e !== null)
    if (e.memoizedProps !== t.pendingProps || kt.current) Ct = !0
    else {
      if (!(e.lanes & r) && !(t.flags & 128)) return (Ct = !1), Fv(e, t, r)
      Ct = !!(e.flags & 131072)
    }
  else (Ct = !1), qe && t.flags & 1048576 && M0(t, Eo, t.index)
  switch (((t.lanes = 0), t.tag)) {
    case 2:
      var i = t.type
      Ka(e, t), (e = t.pendingProps)
      var n = Sn(t, mt.current)
      _n(t, r), (n = Ff(null, t, i, e, n, r))
      var s = Mf()
      return (
        (t.flags |= 1),
        typeof n == 'object' && n !== null && typeof n.render == 'function' && n.$$typeof === void 0
          ? ((t.tag = 1),
            (t.memoizedState = null),
            (t.updateQueue = null),
            wt(i) ? ((s = !0), _o(t)) : (s = !1),
            (t.memoizedState = n.state !== null && n.state !== void 0 ? n.state : null),
            Df(t),
            (n.updater = Qo),
            (t.stateNode = n),
            (n._reactInternals = t),
            lc(t, i, e, r),
            (t = pc(null, t, i, !0, s, r)))
          : ((t.tag = 0), qe && s && Sf(t), gt(null, t, n, r), (t = t.child)),
        t
      )
    case 16:
      i = t.elementType
      e: {
        switch (
          (Ka(e, t),
          (e = t.pendingProps),
          (n = i._init),
          (i = n(i._payload)),
          (t.type = i),
          (n = t.tag = Jv(i)),
          (e = Zt(i, e)),
          n)
        ) {
          case 0:
            t = fc(null, t, i, e, r)
            break e
          case 1:
            t = Dh(null, t, i, e, r)
            break e
          case 11:
            t = Oh(null, t, i, e, r)
            break e
          case 14:
            t = Ih(null, t, i, Zt(i.type, e), r)
            break e
        }
        throw Error(ue(306, i, ''))
      }
      return t
    case 0:
      return (
        (i = t.type),
        (n = t.pendingProps),
        (n = t.elementType === i ? n : Zt(i, n)),
        fc(e, t, i, n, r)
      )
    case 1:
      return (
        (i = t.type),
        (n = t.pendingProps),
        (n = t.elementType === i ? n : Zt(i, n)),
        Dh(e, t, i, n, r)
      )
    case 3:
      e: {
        if ((yg(t), e === null)) throw Error(ue(387))
        ;(i = t.pendingProps), (s = t.memoizedState), (n = s.element), j0(e, t), Ao(t, i, null, r)
        var a = t.memoizedState
        if (((i = a.element), s.isDehydrated))
          if (
            ((s = {
              element: i,
              isDehydrated: !1,
              cache: a.cache,
              pendingSuspenseBoundaries: a.pendingSuspenseBoundaries,
              transitions: a.transitions,
            }),
            (t.updateQueue.baseState = s),
            (t.memoizedState = s),
            t.flags & 256)
          ) {
            ;(n = Nn(Error(ue(423)), t)), (t = Rh(e, t, i, r, n))
            break e
          } else if (i !== n) {
            ;(n = Nn(Error(ue(424)), t)), (t = Rh(e, t, i, r, n))
            break e
          } else
            for (
              Lt = ei(t.stateNode.containerInfo.firstChild),
                Pt = t,
                qe = !0,
                tr = null,
                r = G0(t, null, i, r),
                t.child = r;
              r;

            )
              (r.flags = (r.flags & -3) | 4096), (r = r.sibling)
        else {
          if ((Cn(), i === n)) {
            t = Rr(e, t, r)
            break e
          }
          gt(e, t, i, r)
        }
        t = t.child
      }
      return t
    case 5:
      return (
        X0(t),
        e === null && ac(t),
        (i = t.type),
        (n = t.pendingProps),
        (s = e !== null ? e.memoizedProps : null),
        (a = n.children),
        tc(i, n) ? (a = null) : s !== null && tc(i, s) && (t.flags |= 32),
        bg(e, t),
        gt(e, t, a, r),
        t.child
      )
    case 6:
      return e === null && ac(t), null
    case 13:
      return _g(e, t, r)
    case 4:
      return (
        Rf(t, t.stateNode.containerInfo),
        (i = t.pendingProps),
        e === null ? (t.child = kn(t, null, i, r)) : gt(e, t, i, r),
        t.child
      )
    case 11:
      return (
        (i = t.type),
        (n = t.pendingProps),
        (n = t.elementType === i ? n : Zt(i, n)),
        Oh(e, t, i, n, r)
      )
    case 7:
      return gt(e, t, t.pendingProps, r), t.child
    case 8:
      return gt(e, t, t.pendingProps.children, r), t.child
    case 12:
      return gt(e, t, t.pendingProps.children, r), t.child
    case 10:
      e: {
        if (
          ((i = t.type._context),
          (n = t.pendingProps),
          (s = t.memoizedProps),
          (a = n.value),
          Fe(xo, i._currentValue),
          (i._currentValue = a),
          s !== null)
        )
          if (ar(s.value, a)) {
            if (s.children === n.children && !kt.current) {
              t = Rr(e, t, r)
              break e
            }
          } else
            for (s = t.child, s !== null && (s.return = t); s !== null; ) {
              var o = s.dependencies
              if (o !== null) {
                a = s.child
                for (var u = o.firstContext; u !== null; ) {
                  if (u.context === i) {
                    if (s.tag === 1) {
                      ;(u = Nr(-1, r & -r)), (u.tag = 2)
                      var c = s.updateQueue
                      if (c !== null) {
                        c = c.shared
                        var f = c.pending
                        f === null ? (u.next = u) : ((u.next = f.next), (f.next = u)),
                          (c.pending = u)
                      }
                    }
                    ;(s.lanes |= r),
                      (u = s.alternate),
                      u !== null && (u.lanes |= r),
                      oc(s.return, r, t),
                      (o.lanes |= r)
                    break
                  }
                  u = u.next
                }
              } else if (s.tag === 10) a = s.type === t.type ? null : s.child
              else if (s.tag === 18) {
                if (((a = s.return), a === null)) throw Error(ue(341))
                ;(a.lanes |= r),
                  (o = a.alternate),
                  o !== null && (o.lanes |= r),
                  oc(a, r, t),
                  (a = s.sibling)
              } else a = s.child
              if (a !== null) a.return = s
              else
                for (a = s; a !== null; ) {
                  if (a === t) {
                    a = null
                    break
                  }
                  if (((s = a.sibling), s !== null)) {
                    ;(s.return = a.return), (a = s)
                    break
                  }
                  a = a.return
                }
              s = a
            }
        gt(e, t, n.children, r), (t = t.child)
      }
      return t
    case 9:
      return (
        (n = t.type),
        (i = t.pendingProps.children),
        _n(t, r),
        (n = Wt(n)),
        (i = i(n)),
        (t.flags |= 1),
        gt(e, t, i, r),
        t.child
      )
    case 14:
      return (i = t.type), (n = Zt(i, t.pendingProps)), (n = Zt(i.type, n)), Ih(e, t, i, n, r)
    case 15:
      return dg(e, t, t.type, t.pendingProps, r)
    case 17:
      return (
        (i = t.type),
        (n = t.pendingProps),
        (n = t.elementType === i ? n : Zt(i, n)),
        Ka(e, t),
        (t.tag = 1),
        wt(i) ? ((e = !0), _o(t)) : (e = !1),
        _n(t, r),
        $0(t, i, n),
        lc(t, i, n, r),
        pc(null, t, i, !0, e, r)
      )
    case 19:
      return vg(e, t, r)
    case 22:
      return gg(e, t, r)
  }
  throw Error(ue(156, t.tag))
}
function Bg(e, t) {
  return u0(e, t)
}
function Kv(e, t, r, i) {
  ;(this.tag = e),
    (this.key = r),
    (this.sibling =
      this.child =
      this.return =
      this.stateNode =
      this.type =
      this.elementType =
        null),
    (this.index = 0),
    (this.ref = null),
    (this.pendingProps = t),
    (this.dependencies = this.memoizedState = this.updateQueue = this.memoizedProps = null),
    (this.mode = i),
    (this.subtreeFlags = this.flags = 0),
    (this.deletions = null),
    (this.childLanes = this.lanes = 0),
    (this.alternate = null)
}
function Xt(e, t, r, i) {
  return new Kv(e, t, r, i)
}
function Yf(e) {
  return (e = e.prototype), !(!e || !e.isReactComponent)
}
function Jv(e) {
  if (typeof e == 'function') return Yf(e) ? 1 : 0
  if (e != null) {
    if (((e = e.$$typeof), e === hf)) return 11
    if (e === mf) return 14
  }
  return 2
}
function ni(e, t) {
  var r = e.alternate
  return (
    r === null
      ? ((r = Xt(e.tag, t, e.key, e.mode)),
        (r.elementType = e.elementType),
        (r.type = e.type),
        (r.stateNode = e.stateNode),
        (r.alternate = e),
        (e.alternate = r))
      : ((r.pendingProps = t),
        (r.type = e.type),
        (r.flags = 0),
        (r.subtreeFlags = 0),
        (r.deletions = null)),
    (r.flags = e.flags & 14680064),
    (r.childLanes = e.childLanes),
    (r.lanes = e.lanes),
    (r.child = e.child),
    (r.memoizedProps = e.memoizedProps),
    (r.memoizedState = e.memoizedState),
    (r.updateQueue = e.updateQueue),
    (t = e.dependencies),
    (r.dependencies = t === null ? null : { lanes: t.lanes, firstContext: t.firstContext }),
    (r.sibling = e.sibling),
    (r.index = e.index),
    (r.ref = e.ref),
    r
  )
}
function eo(e, t, r, i, n, s) {
  var a = 2
  if (((i = e), typeof e == 'function')) Yf(e) && (a = 1)
  else if (typeof e == 'string') a = 5
  else
    e: switch (e) {
      case Zi:
        return Ci(r.children, n, s, t)
      case pf:
        ;(a = 8), (n |= 8)
        break
      case Rl:
        return (e = Xt(12, r, t, n | 2)), (e.elementType = Rl), (e.lanes = s), e
      case Ll:
        return (e = Xt(13, r, t, n)), (e.elementType = Ll), (e.lanes = s), e
      case Pl:
        return (e = Xt(19, r, t, n)), (e.elementType = Pl), (e.lanes = s), e
      case Vd:
        return eu(r, n, s, t)
      default:
        if (typeof e == 'object' && e !== null)
          switch (e.$$typeof) {
            case qd:
              a = 10
              break e
            case $d:
              a = 9
              break e
            case hf:
              a = 11
              break e
            case mf:
              a = 14
              break e
            case $r:
              ;(a = 16), (i = null)
              break e
          }
        throw Error(ue(130, e == null ? e : typeof e, ''))
    }
  return (t = Xt(a, r, t, n)), (t.elementType = e), (t.type = i), (t.lanes = s), t
}
function Ci(e, t, r, i) {
  return (e = Xt(7, e, i, t)), (e.lanes = r), e
}
function eu(e, t, r, i) {
  return (
    (e = Xt(22, e, i, t)), (e.elementType = Vd), (e.lanes = r), (e.stateNode = { isHidden: !1 }), e
  )
}
function el(e, t, r) {
  return (e = Xt(6, e, null, t)), (e.lanes = r), e
}
function tl(e, t, r) {
  return (
    (t = Xt(4, e.children !== null ? e.children : [], e.key, t)),
    (t.lanes = r),
    (t.stateNode = {
      containerInfo: e.containerInfo,
      pendingChildren: null,
      implementation: e.implementation,
    }),
    t
  )
}
function Zv(e, t, r, i, n) {
  ;(this.tag = t),
    (this.containerInfo = e),
    (this.finishedWork = this.pingCache = this.current = this.pendingChildren = null),
    (this.timeoutHandle = -1),
    (this.callbackNode = this.pendingContext = this.context = null),
    (this.callbackPriority = 0),
    (this.eventTimes = Pu(0)),
    (this.expirationTimes = Pu(-1)),
    (this.entangledLanes =
      this.finishedLanes =
      this.mutableReadLanes =
      this.expiredLanes =
      this.pingedLanes =
      this.suspendedLanes =
      this.pendingLanes =
        0),
    (this.entanglements = Pu(0)),
    (this.identifierPrefix = i),
    (this.onRecoverableError = n),
    (this.mutableSourceEagerHydrationData = null)
}
function Wf(e, t, r, i, n, s, a, o, u) {
  return (
    (e = new Zv(e, t, r, o, u)),
    t === 1 ? ((t = 1), s === !0 && (t |= 8)) : (t = 0),
    (s = Xt(3, null, null, t)),
    (e.current = s),
    (s.stateNode = e),
    (s.memoizedState = {
      element: i,
      isDehydrated: r,
      cache: null,
      transitions: null,
      pendingSuspenseBoundaries: null,
    }),
    Df(s),
    e
  )
}
function eE(e, t, r) {
  var i = 3 < arguments.length && arguments[3] !== void 0 ? arguments[3] : null
  return {
    $$typeof: Ji,
    key: i == null ? null : '' + i,
    children: e,
    containerInfo: t,
    implementation: r,
  }
}
function Fg(e) {
  if (!e) return ui
  e = e._reactInternals
  e: {
    if (zi(e) !== e || e.tag !== 1) throw Error(ue(170))
    var t = e
    do {
      switch (t.tag) {
        case 3:
          t = t.stateNode.context
          break e
        case 1:
          if (wt(t.type)) {
            t = t.stateNode.__reactInternalMemoizedMergedChildContext
            break e
          }
      }
      t = t.return
    } while (t !== null)
    throw Error(ue(171))
  }
  if (e.tag === 1) {
    var r = e.type
    if (wt(r)) return B0(e, r, t)
  }
  return t
}
function Mg(e, t, r, i, n, s, a, o, u) {
  return (
    (e = Wf(r, i, !0, e, n, s, a, o, u)),
    (e.context = Fg(null)),
    (r = e.current),
    (i = yt()),
    (n = ii(r)),
    (s = Nr(i, n)),
    (s.callback = t ?? null),
    ti(r, s, n),
    (e.current.lanes = n),
    ea(e, n, i),
    Nt(e, i),
    e
  )
}
function tu(e, t, r, i) {
  var n = t.current,
    s = yt(),
    a = ii(n)
  return (
    (r = Fg(r)),
    t.context === null ? (t.context = r) : (t.pendingContext = r),
    (t = Nr(s, a)),
    (t.payload = { element: e }),
    (i = i === void 0 ? null : i),
    i !== null && (t.callback = i),
    (e = ti(n, t, a)),
    e !== null && (nr(e, n, a, s), Ya(e, n, a)),
    a
  )
}
function Do(e) {
  if (((e = e.current), !e.child)) return null
  switch (e.child.tag) {
    case 5:
      return e.child.stateNode
    default:
      return e.child.stateNode
  }
}
function qh(e, t) {
  if (((e = e.memoizedState), e !== null && e.dehydrated !== null)) {
    var r = e.retryLane
    e.retryLane = r !== 0 && r < t ? r : t
  }
}
function Qf(e, t) {
  qh(e, t), (e = e.alternate) && qh(e, t)
}
function tE() {
  return null
}
var Ug =
  typeof reportError == 'function'
    ? reportError
    : function (e) {
        console.error(e)
      }
function Kf(e) {
  this._internalRoot = e
}
ru.prototype.render = Kf.prototype.render = function (e) {
  var t = this._internalRoot
  if (t === null) throw Error(ue(409))
  tu(e, t, null, null)
}
ru.prototype.unmount = Kf.prototype.unmount = function () {
  var e = this._internalRoot
  if (e !== null) {
    this._internalRoot = null
    var t = e.containerInfo
    Di(function () {
      tu(null, e, null, null)
    }),
      (t[Ir] = null)
  }
}
function ru(e) {
  this._internalRoot = e
}
ru.prototype.unstable_scheduleHydration = function (e) {
  if (e) {
    var t = d0()
    e = { blockedOn: null, target: e, priority: t }
    for (var r = 0; r < Gr.length && t !== 0 && t < Gr[r].priority; r++);
    Gr.splice(r, 0, e), r === 0 && b0(e)
  }
}
function Jf(e) {
  return !(!e || (e.nodeType !== 1 && e.nodeType !== 9 && e.nodeType !== 11))
}
function iu(e) {
  return !(
    !e ||
    (e.nodeType !== 1 &&
      e.nodeType !== 9 &&
      e.nodeType !== 11 &&
      (e.nodeType !== 8 || e.nodeValue !== ' react-mount-point-unstable '))
  )
}
function $h() {}
function rE(e, t, r, i, n) {
  if (n) {
    if (typeof i == 'function') {
      var s = i
      i = function () {
        var c = Do(a)
        s.call(c)
      }
    }
    var a = Mg(t, i, e, 0, null, !1, !1, '', $h)
    return (
      (e._reactRootContainer = a),
      (e[Ir] = a.current),
      Ds(e.nodeType === 8 ? e.parentNode : e),
      Di(),
      a
    )
  }
  for (; (n = e.lastChild); ) e.removeChild(n)
  if (typeof i == 'function') {
    var o = i
    i = function () {
      var c = Do(u)
      o.call(c)
    }
  }
  var u = Wf(e, 0, !1, null, null, !1, !1, '', $h)
  return (
    (e._reactRootContainer = u),
    (e[Ir] = u.current),
    Ds(e.nodeType === 8 ? e.parentNode : e),
    Di(function () {
      tu(t, u, r, i)
    }),
    u
  )
}
function nu(e, t, r, i, n) {
  var s = r._reactRootContainer
  if (s) {
    var a = s
    if (typeof n == 'function') {
      var o = n
      n = function () {
        var u = Do(a)
        o.call(u)
      }
    }
    tu(t, a, e, n)
  } else a = rE(r, t, e, n, i)
  return Do(a)
}
h0 = function (e) {
  switch (e.tag) {
    case 3:
      var t = e.stateNode
      if (t.current.memoizedState.isDehydrated) {
        var r = ns(t.pendingLanes)
        r !== 0 && (bf(t, r | 1), Nt(t, We()), !(Ie & 6) && ((On = We() + 500), hi()))
      }
      break
    case 13:
      Di(function () {
        var i = Dr(e, 1)
        if (i !== null) {
          var n = yt()
          nr(i, e, 1, n)
        }
      }),
        Qf(e, 1)
  }
}
yf = function (e) {
  if (e.tag === 13) {
    var t = Dr(e, 134217728)
    if (t !== null) {
      var r = yt()
      nr(t, e, 134217728, r)
    }
    Qf(e, 134217728)
  }
}
m0 = function (e) {
  if (e.tag === 13) {
    var t = ii(e),
      r = Dr(e, t)
    if (r !== null) {
      var i = yt()
      nr(r, e, t, i)
    }
    Qf(e, t)
  }
}
d0 = function () {
  return Re
}
g0 = function (e, t) {
  var r = Re
  try {
    return (Re = e), t()
  } finally {
    Re = r
  }
}
Vl = function (e, t, r) {
  switch (t) {
    case 'input':
      if ((Ml(e, r), (t = r.name), r.type === 'radio' && t != null)) {
        for (r = e; r.parentNode; ) r = r.parentNode
        for (
          r = r.querySelectorAll('input[name=' + JSON.stringify('' + t) + '][type="radio"]'), t = 0;
          t < r.length;
          t++
        ) {
          var i = r[t]
          if (i !== e && i.form === e.form) {
            var n = Yo(i)
            if (!n) throw Error(ue(90))
            Xd(i), Ml(i, n)
          }
        }
      }
      break
    case 'textarea':
      Wd(e, r)
      break
    case 'select':
      ;(t = r.value), t != null && dn(e, !!r.multiple, t, !1)
  }
}
r0 = Vf
i0 = Di
var iE = { usingClientEntryPoint: !1, Events: [ra, nn, Yo, e0, t0, Vf] },
  Yn = {
    findFiberByHostInstance: Ei,
    bundleType: 0,
    version: '18.2.0',
    rendererPackageName: 'react-dom',
  },
  nE = {
    bundleType: Yn.bundleType,
    version: Yn.version,
    rendererPackageName: Yn.rendererPackageName,
    rendererConfig: Yn.rendererConfig,
    overrideHookState: null,
    overrideHookStateDeletePath: null,
    overrideHookStateRenamePath: null,
    overrideProps: null,
    overridePropsDeletePath: null,
    overridePropsRenamePath: null,
    setErrorHandler: null,
    setSuspenseHandler: null,
    scheduleUpdate: null,
    currentDispatcherRef: Br.ReactCurrentDispatcher,
    findHostInstanceByFiber: function (e) {
      return (e = a0(e)), e === null ? null : e.stateNode
    },
    findFiberByHostInstance: Yn.findFiberByHostInstance || tE,
    findHostInstancesForRefresh: null,
    scheduleRefresh: null,
    scheduleRoot: null,
    setRefreshHandler: null,
    getCurrentFiber: null,
    reconcilerVersion: '18.2.0-next-9e3b772b8-20220608',
  }
if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < 'u') {
  var Da = __REACT_DEVTOOLS_GLOBAL_HOOK__
  if (!Da.isDisabled && Da.supportsFiber)
    try {
      ;($o = Da.inject(nE)), (br = Da)
    } catch {}
}
Ut.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = iE
Ut.createPortal = function (e, t) {
  var r = 2 < arguments.length && arguments[2] !== void 0 ? arguments[2] : null
  if (!Jf(t)) throw Error(ue(200))
  return eE(e, t, null, r)
}
Ut.createRoot = function (e, t) {
  if (!Jf(e)) throw Error(ue(299))
  var r = !1,
    i = '',
    n = Ug
  return (
    t != null &&
      (t.unstable_strictMode === !0 && (r = !0),
      t.identifierPrefix !== void 0 && (i = t.identifierPrefix),
      t.onRecoverableError !== void 0 && (n = t.onRecoverableError)),
    (t = Wf(e, 1, !1, null, null, r, !1, i, n)),
    (e[Ir] = t.current),
    Ds(e.nodeType === 8 ? e.parentNode : e),
    new Kf(t)
  )
}
Ut.findDOMNode = function (e) {
  if (e == null) return null
  if (e.nodeType === 1) return e
  var t = e._reactInternals
  if (t === void 0)
    throw typeof e.render == 'function'
      ? Error(ue(188))
      : ((e = Object.keys(e).join(',')), Error(ue(268, e)))
  return (e = a0(t)), (e = e === null ? null : e.stateNode), e
}
Ut.flushSync = function (e) {
  return Di(e)
}
Ut.hydrate = function (e, t, r) {
  if (!iu(t)) throw Error(ue(200))
  return nu(null, e, t, !0, r)
}
Ut.hydrateRoot = function (e, t, r) {
  if (!Jf(e)) throw Error(ue(405))
  var i = (r != null && r.hydratedSources) || null,
    n = !1,
    s = '',
    a = Ug
  if (
    (r != null &&
      (r.unstable_strictMode === !0 && (n = !0),
      r.identifierPrefix !== void 0 && (s = r.identifierPrefix),
      r.onRecoverableError !== void 0 && (a = r.onRecoverableError)),
    (t = Mg(t, null, e, 1, r ?? null, n, !1, s, a)),
    (e[Ir] = t.current),
    Ds(e),
    i)
  )
    for (e = 0; e < i.length; e++)
      (r = i[e]),
        (n = r._getVersion),
        (n = n(r._source)),
        t.mutableSourceEagerHydrationData == null
          ? (t.mutableSourceEagerHydrationData = [r, n])
          : t.mutableSourceEagerHydrationData.push(r, n)
  return new ru(t)
}
Ut.render = function (e, t, r) {
  if (!iu(t)) throw Error(ue(200))
  return nu(null, e, t, !1, r)
}
Ut.unmountComponentAtNode = function (e) {
  if (!iu(e)) throw Error(ue(40))
  return e._reactRootContainer
    ? (Di(function () {
        nu(null, null, e, !1, function () {
          ;(e._reactRootContainer = null), (e[Ir] = null)
        })
      }),
      !0)
    : !1
}
Ut.unstable_batchedUpdates = Vf
Ut.unstable_renderSubtreeIntoContainer = function (e, t, r, i) {
  if (!iu(r)) throw Error(ue(200))
  if (e == null || e._reactInternals === void 0) throw Error(ue(38))
  return nu(e, t, r, !1, i)
}
Ut.version = '18.2.0-next-9e3b772b8-20220608'
function Hg() {
  if (
    !(
      typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ > 'u' ||
      typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE != 'function'
    )
  )
    try {
      __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(Hg)
    } catch (e) {
      console.error(e)
    }
}
Hg(), (Md.exports = Ut)
var sE = Md.exports
const aE = ci(sE)
function Vh(e) {
  if (e) throw e
}
var to = Object.prototype.hasOwnProperty,
  zg = Object.prototype.toString,
  Gh = Object.defineProperty,
  Xh = Object.getOwnPropertyDescriptor,
  Yh = function (t) {
    return typeof Array.isArray == 'function' ? Array.isArray(t) : zg.call(t) === '[object Array]'
  },
  Wh = function (t) {
    if (!t || zg.call(t) !== '[object Object]') return !1
    var r = to.call(t, 'constructor'),
      i =
        t.constructor &&
        t.constructor.prototype &&
        to.call(t.constructor.prototype, 'isPrototypeOf')
    if (t.constructor && !r && !i) return !1
    var n
    for (n in t);
    return typeof n > 'u' || to.call(t, n)
  },
  Qh = function (t, r) {
    Gh && r.name === '__proto__'
      ? Gh(t, r.name, { enumerable: !0, configurable: !0, value: r.newValue, writable: !0 })
      : (t[r.name] = r.newValue)
  },
  Kh = function (t, r) {
    if (r === '__proto__')
      if (to.call(t, r)) {
        if (Xh) return Xh(t, r).value
      } else return
    return t[r]
  },
  oE = function e() {
    var t,
      r,
      i,
      n,
      s,
      a,
      o = arguments[0],
      u = 1,
      c = arguments.length,
      f = !1
    for (
      typeof o == 'boolean' && ((f = o), (o = arguments[1] || {}), (u = 2)),
        (o == null || (typeof o != 'object' && typeof o != 'function')) && (o = {});
      u < c;
      ++u
    )
      if (((t = arguments[u]), t != null))
        for (r in t)
          (i = Kh(o, r)),
            (n = Kh(t, r)),
            o !== n &&
              (f && n && (Wh(n) || (s = Yh(n)))
                ? (s ? ((s = !1), (a = i && Yh(i) ? i : [])) : (a = i && Wh(i) ? i : {}),
                  Qh(o, { name: r, newValue: e(f, a, n) }))
                : typeof n < 'u' && Qh(o, { name: r, newValue: n }))
    return o
  }
const rl = ci(oE)
function Ac(e) {
  if (typeof e != 'object' || e === null) return !1
  const t = Object.getPrototypeOf(e)
  return (
    (t === null || t === Object.prototype || Object.getPrototypeOf(t) === null) &&
    !(Symbol.toStringTag in e) &&
    !(Symbol.iterator in e)
  )
}
function uE() {
  const e = [],
    t = { run: r, use: i }
  return t
  function r(...n) {
    let s = -1
    const a = n.pop()
    if (typeof a != 'function') throw new TypeError('Expected function as last argument, not ' + a)
    o(null, ...n)
    function o(u, ...c) {
      const f = e[++s]
      let h = -1
      if (u) {
        a(u)
        return
      }
      for (; ++h < n.length; ) (c[h] === null || c[h] === void 0) && (c[h] = n[h])
      ;(n = c), f ? lE(f, o)(...c) : a(null, ...c)
    }
  }
  function i(n) {
    if (typeof n != 'function')
      throw new TypeError('Expected `middelware` to be a function, not ' + n)
    return e.push(n), t
  }
}
function lE(e, t) {
  let r
  return i
  function i(...a) {
    const o = e.length > a.length
    let u
    o && a.push(n)
    try {
      u = e.apply(this, a)
    } catch (c) {
      const f = c
      if (o && r) throw f
      return n(f)
    }
    o || (u instanceof Promise ? u.then(s, n) : u instanceof Error ? n(u) : s(u))
  }
  function n(a, ...o) {
    r || ((r = !0), t(a, ...o))
  }
  function s(a) {
    n(null, a)
  }
}
function gs(e) {
  return !e || typeof e != 'object'
    ? ''
    : 'position' in e || 'type' in e
    ? Jh(e.position)
    : 'start' in e || 'end' in e
    ? Jh(e)
    : 'line' in e || 'column' in e
    ? Sc(e)
    : ''
}
function Sc(e) {
  return Zh(e && e.line) + ':' + Zh(e && e.column)
}
function Jh(e) {
  return Sc(e && e.start) + '-' + Sc(e && e.end)
}
function Zh(e) {
  return e && typeof e == 'number' ? e : 1
}
class Ot extends Error {
  constructor(t, r, i) {
    super(), typeof r == 'string' && ((i = r), (r = void 0))
    let n = '',
      s = {},
      a = !1
    if (
      (r &&
        ('line' in r && 'column' in r
          ? (s = { place: r })
          : 'start' in r && 'end' in r
          ? (s = { place: r })
          : 'type' in r
          ? (s = { ancestors: [r], place: r.position })
          : (s = { ...r })),
      typeof t == 'string' ? (n = t) : !s.cause && t && ((a = !0), (n = t.message), (s.cause = t)),
      !s.ruleId && !s.source && typeof i == 'string')
    ) {
      const u = i.indexOf(':')
      u === -1 ? (s.ruleId = i) : ((s.source = i.slice(0, u)), (s.ruleId = i.slice(u + 1)))
    }
    if (!s.place && s.ancestors && s.ancestors) {
      const u = s.ancestors[s.ancestors.length - 1]
      u && (s.place = u.position)
    }
    const o = s.place && 'start' in s.place ? s.place.start : s.place
    ;(this.ancestors = s.ancestors || void 0),
      (this.cause = s.cause || void 0),
      (this.column = o ? o.column : void 0),
      (this.fatal = void 0),
      this.file,
      (this.message = n),
      (this.line = o ? o.line : void 0),
      (this.name = gs(s.place) || '1:1'),
      (this.place = s.place || void 0),
      (this.reason = this.message),
      (this.ruleId = s.ruleId || void 0),
      (this.source = s.source || void 0),
      (this.stack = a && s.cause && typeof s.cause.stack == 'string' ? s.cause.stack : ''),
      this.actual,
      this.expected,
      this.note,
      this.url
  }
}
Ot.prototype.file = ''
Ot.prototype.name = ''
Ot.prototype.reason = ''
Ot.prototype.message = ''
Ot.prototype.stack = ''
Ot.prototype.column = void 0
Ot.prototype.line = void 0
Ot.prototype.ancestors = void 0
Ot.prototype.cause = void 0
Ot.prototype.fatal = void 0
Ot.prototype.place = void 0
Ot.prototype.ruleId = void 0
Ot.prototype.source = void 0
const pr = { basename: cE, dirname: fE, extname: pE, join: hE, sep: '/' }
function cE(e, t) {
  if (t !== void 0 && typeof t != 'string') throw new TypeError('"ext" argument must be a string')
  na(e)
  let r = 0,
    i = -1,
    n = e.length,
    s
  if (t === void 0 || t.length === 0 || t.length > e.length) {
    for (; n--; )
      if (e.codePointAt(n) === 47) {
        if (s) {
          r = n + 1
          break
        }
      } else i < 0 && ((s = !0), (i = n + 1))
    return i < 0 ? '' : e.slice(r, i)
  }
  if (t === e) return ''
  let a = -1,
    o = t.length - 1
  for (; n--; )
    if (e.codePointAt(n) === 47) {
      if (s) {
        r = n + 1
        break
      }
    } else
      a < 0 && ((s = !0), (a = n + 1)),
        o > -1 && (e.codePointAt(n) === t.codePointAt(o--) ? o < 0 && (i = n) : ((o = -1), (i = a)))
  return r === i ? (i = a) : i < 0 && (i = e.length), e.slice(r, i)
}
function fE(e) {
  if ((na(e), e.length === 0)) return '.'
  let t = -1,
    r = e.length,
    i
  for (; --r; )
    if (e.codePointAt(r) === 47) {
      if (i) {
        t = r
        break
      }
    } else i || (i = !0)
  return t < 0
    ? e.codePointAt(0) === 47
      ? '/'
      : '.'
    : t === 1 && e.codePointAt(0) === 47
    ? '//'
    : e.slice(0, t)
}
function pE(e) {
  na(e)
  let t = e.length,
    r = -1,
    i = 0,
    n = -1,
    s = 0,
    a
  for (; t--; ) {
    const o = e.codePointAt(t)
    if (o === 47) {
      if (a) {
        i = t + 1
        break
      }
      continue
    }
    r < 0 && ((a = !0), (r = t + 1)),
      o === 46 ? (n < 0 ? (n = t) : s !== 1 && (s = 1)) : n > -1 && (s = -1)
  }
  return n < 0 || r < 0 || s === 0 || (s === 1 && n === r - 1 && n === i + 1) ? '' : e.slice(n, r)
}
function hE(...e) {
  let t = -1,
    r
  for (; ++t < e.length; ) na(e[t]), e[t] && (r = r === void 0 ? e[t] : r + '/' + e[t])
  return r === void 0 ? '.' : mE(r)
}
function mE(e) {
  na(e)
  const t = e.codePointAt(0) === 47
  let r = dE(e, !t)
  return (
    r.length === 0 && !t && (r = '.'),
    r.length > 0 && e.codePointAt(e.length - 1) === 47 && (r += '/'),
    t ? '/' + r : r
  )
}
function dE(e, t) {
  let r = '',
    i = 0,
    n = -1,
    s = 0,
    a = -1,
    o,
    u
  for (; ++a <= e.length; ) {
    if (a < e.length) o = e.codePointAt(a)
    else {
      if (o === 47) break
      o = 47
    }
    if (o === 47) {
      if (!(n === a - 1 || s === 1))
        if (n !== a - 1 && s === 2) {
          if (
            r.length < 2 ||
            i !== 2 ||
            r.codePointAt(r.length - 1) !== 46 ||
            r.codePointAt(r.length - 2) !== 46
          ) {
            if (r.length > 2) {
              if (((u = r.lastIndexOf('/')), u !== r.length - 1)) {
                u < 0
                  ? ((r = ''), (i = 0))
                  : ((r = r.slice(0, u)), (i = r.length - 1 - r.lastIndexOf('/'))),
                  (n = a),
                  (s = 0)
                continue
              }
            } else if (r.length > 0) {
              ;(r = ''), (i = 0), (n = a), (s = 0)
              continue
            }
          }
          t && ((r = r.length > 0 ? r + '/..' : '..'), (i = 2))
        } else
          r.length > 0 ? (r += '/' + e.slice(n + 1, a)) : (r = e.slice(n + 1, a)), (i = a - n - 1)
      ;(n = a), (s = 0)
    } else o === 46 && s > -1 ? s++ : (s = -1)
  }
  return r
}
function na(e) {
  if (typeof e != 'string')
    throw new TypeError('Path must be a string. Received ' + JSON.stringify(e))
}
const gE = { cwd: bE }
function bE() {
  return '/'
}
function Cc(e) {
  return !!(
    e !== null &&
    typeof e == 'object' &&
    'href' in e &&
    e.href &&
    'protocol' in e &&
    e.protocol &&
    e.auth === void 0
  )
}
function yE(e) {
  if (typeof e == 'string') e = new URL(e)
  else if (!Cc(e)) {
    const t = new TypeError(
      'The "path" argument must be of type string or an instance of URL. Received `' + e + '`'
    )
    throw ((t.code = 'ERR_INVALID_ARG_TYPE'), t)
  }
  if (e.protocol !== 'file:') {
    const t = new TypeError('The URL must be of scheme file')
    throw ((t.code = 'ERR_INVALID_URL_SCHEME'), t)
  }
  return _E(e)
}
function _E(e) {
  if (e.hostname !== '') {
    const i = new TypeError('File URL host must be "localhost" or empty on darwin')
    throw ((i.code = 'ERR_INVALID_FILE_URL_HOST'), i)
  }
  const t = e.pathname
  let r = -1
  for (; ++r < t.length; )
    if (t.codePointAt(r) === 37 && t.codePointAt(r + 1) === 50) {
      const i = t.codePointAt(r + 2)
      if (i === 70 || i === 102) {
        const n = new TypeError('File URL path must not include encoded / characters')
        throw ((n.code = 'ERR_INVALID_FILE_URL_PATH'), n)
      }
    }
  return decodeURIComponent(t)
}
const il = ['history', 'path', 'basename', 'stem', 'extname', 'dirname']
class vE {
  constructor(t) {
    let r
    t
      ? Cc(t)
        ? (r = { path: t })
        : typeof t == 'string' || EE(t)
        ? (r = { value: t })
        : (r = t)
      : (r = {}),
      (this.cwd = gE.cwd()),
      (this.data = {}),
      (this.history = []),
      (this.messages = []),
      this.value,
      this.map,
      this.result,
      this.stored
    let i = -1
    for (; ++i < il.length; ) {
      const s = il[i]
      s in r && r[s] !== void 0 && r[s] !== null && (this[s] = s === 'history' ? [...r[s]] : r[s])
    }
    let n
    for (n in r) il.includes(n) || (this[n] = r[n])
  }
  get basename() {
    return typeof this.path == 'string' ? pr.basename(this.path) : void 0
  }
  set basename(t) {
    sl(t, 'basename'), nl(t, 'basename'), (this.path = pr.join(this.dirname || '', t))
  }
  get dirname() {
    return typeof this.path == 'string' ? pr.dirname(this.path) : void 0
  }
  set dirname(t) {
    em(this.basename, 'dirname'), (this.path = pr.join(t || '', this.basename))
  }
  get extname() {
    return typeof this.path == 'string' ? pr.extname(this.path) : void 0
  }
  set extname(t) {
    if ((nl(t, 'extname'), em(this.dirname, 'extname'), t)) {
      if (t.codePointAt(0) !== 46) throw new Error('`extname` must start with `.`')
      if (t.includes('.', 1)) throw new Error('`extname` cannot contain multiple dots')
    }
    this.path = pr.join(this.dirname, this.stem + (t || ''))
  }
  get path() {
    return this.history[this.history.length - 1]
  }
  set path(t) {
    Cc(t) && (t = yE(t)), sl(t, 'path'), this.path !== t && this.history.push(t)
  }
  get stem() {
    return typeof this.path == 'string' ? pr.basename(this.path, this.extname) : void 0
  }
  set stem(t) {
    sl(t, 'stem'),
      nl(t, 'stem'),
      (this.path = pr.join(this.dirname || '', t + (this.extname || '')))
  }
  fail(t, r, i) {
    const n = this.message(t, r, i)
    throw ((n.fatal = !0), n)
  }
  info(t, r, i) {
    const n = this.message(t, r, i)
    return (n.fatal = void 0), n
  }
  message(t, r, i) {
    const n = new Ot(t, r, i)
    return (
      this.path && ((n.name = this.path + ':' + n.name), (n.file = this.path)),
      (n.fatal = !1),
      this.messages.push(n),
      n
    )
  }
  toString(t) {
    return this.value === void 0
      ? ''
      : typeof this.value == 'string'
      ? this.value
      : new TextDecoder(t || void 0).decode(this.value)
  }
}
function nl(e, t) {
  if (e && e.includes(pr.sep))
    throw new Error('`' + t + '` cannot be a path: did not expect `' + pr.sep + '`')
}
function sl(e, t) {
  if (!e) throw new Error('`' + t + '` cannot be empty')
}
function em(e, t) {
  if (!e) throw new Error('Setting `' + t + '` requires `path` to be set too')
}
function EE(e) {
  return !!(e && typeof e == 'object' && 'byteLength' in e && 'byteOffset' in e)
}
const xE = function (e) {
    const i = this.constructor.prototype,
      n = i[e],
      s = function () {
        return n.apply(s, arguments)
      }
    Object.setPrototypeOf(s, i)
    const a = Object.getOwnPropertyNames(n)
    for (const o of a) {
      const u = Object.getOwnPropertyDescriptor(n, o)
      u && Object.defineProperty(s, o, u)
    }
    return s
  },
  TE = {}.hasOwnProperty
class Zf extends xE {
  constructor() {
    super('copy'),
      (this.Compiler = void 0),
      (this.Parser = void 0),
      (this.attachers = []),
      (this.compiler = void 0),
      (this.freezeIndex = -1),
      (this.frozen = void 0),
      (this.namespace = {}),
      (this.parser = void 0),
      (this.transformers = uE())
  }
  copy() {
    const t = new Zf()
    let r = -1
    for (; ++r < this.attachers.length; ) {
      const i = this.attachers[r]
      t.use(...i)
    }
    return t.data(rl(!0, {}, this.namespace)), t
  }
  data(t, r) {
    return typeof t == 'string'
      ? arguments.length === 2
        ? (ul('data', this.frozen), (this.namespace[t] = r), this)
        : (TE.call(this.namespace, t) && this.namespace[t]) || void 0
      : t
      ? (ul('data', this.frozen), (this.namespace = t), this)
      : this.namespace
  }
  freeze() {
    if (this.frozen) return this
    const t = this
    for (; ++this.freezeIndex < this.attachers.length; ) {
      const [r, ...i] = this.attachers[this.freezeIndex]
      if (i[0] === !1) continue
      i[0] === !0 && (i[0] = void 0)
      const n = r.call(t, ...i)
      typeof n == 'function' && this.transformers.use(n)
    }
    return (this.frozen = !0), (this.freezeIndex = Number.POSITIVE_INFINITY), this
  }
  parse(t) {
    this.freeze()
    const r = Ra(t),
      i = this.parser || this.Parser
    return al('parse', i), i(String(r), r)
  }
  process(t, r) {
    const i = this
    return (
      this.freeze(),
      al('process', this.parser || this.Parser),
      ol('process', this.compiler || this.Compiler),
      r ? n(void 0, r) : new Promise(n)
    )
    function n(s, a) {
      const o = Ra(t),
        u = i.parse(o)
      i.run(u, o, function (f, h, p) {
        if (f || !h || !p) return c(f)
        const m = h,
          v = i.stringify(m, p)
        CE(v) ? (p.value = v) : (p.result = v), c(f, p)
      })
      function c(f, h) {
        f || !h ? a(f) : s ? s(h) : r(void 0, h)
      }
    }
  }
  processSync(t) {
    let r = !1,
      i
    return (
      this.freeze(),
      al('processSync', this.parser || this.Parser),
      ol('processSync', this.compiler || this.Compiler),
      this.process(t, n),
      rm('processSync', 'process', r),
      i
    )
    function n(s, a) {
      ;(r = !0), Vh(s), (i = a)
    }
  }
  run(t, r, i) {
    tm(t), this.freeze()
    const n = this.transformers
    return (
      !i && typeof r == 'function' && ((i = r), (r = void 0)), i ? s(void 0, i) : new Promise(s)
    )
    function s(a, o) {
      const u = Ra(r)
      n.run(t, u, c)
      function c(f, h, p) {
        const m = h || t
        f ? o(f) : a ? a(m) : i(void 0, m, p)
      }
    }
  }
  runSync(t, r) {
    let i = !1,
      n
    return this.run(t, r, s), rm('runSync', 'run', i), n
    function s(a, o) {
      Vh(a), (n = o), (i = !0)
    }
  }
  stringify(t, r) {
    this.freeze()
    const i = Ra(r),
      n = this.compiler || this.Compiler
    return ol('stringify', n), tm(t), n(t, i)
  }
  use(t, ...r) {
    const i = this.attachers,
      n = this.namespace
    if ((ul('use', this.frozen), t != null))
      if (typeof t == 'function') u(t, r)
      else if (typeof t == 'object') Array.isArray(t) ? o(t) : a(t)
      else throw new TypeError('Expected usable value, not `' + t + '`')
    return this
    function s(c) {
      if (typeof c == 'function') u(c, [])
      else if (typeof c == 'object')
        if (Array.isArray(c)) {
          const [f, ...h] = c
          u(f, h)
        } else a(c)
      else throw new TypeError('Expected usable value, not `' + c + '`')
    }
    function a(c) {
      if (!('plugins' in c) && !('settings' in c))
        throw new Error(
          'Expected usable value but received an empty preset, which is probably a mistake: presets typically come with `plugins` and sometimes with `settings`, but this has neither'
        )
      o(c.plugins), c.settings && (n.settings = rl(!0, n.settings, c.settings))
    }
    function o(c) {
      let f = -1
      if (c != null)
        if (Array.isArray(c))
          for (; ++f < c.length; ) {
            const h = c[f]
            s(h)
          }
        else throw new TypeError('Expected a list of plugins, not `' + c + '`')
    }
    function u(c, f) {
      let h = -1,
        p = -1
      for (; ++h < i.length; )
        if (i[h][0] === c) {
          p = h
          break
        }
      if (p === -1) i.push([c, ...f])
      else if (f.length > 0) {
        let [m, ...v] = f
        const b = i[p][1]
        Ac(b) && Ac(m) && (m = rl(!0, b, m)), (i[p] = [c, m, ...v])
      }
    }
  }
}
const AE = new Zf().freeze()
function al(e, t) {
  if (typeof t != 'function') throw new TypeError('Cannot `' + e + '` without `parser`')
}
function ol(e, t) {
  if (typeof t != 'function') throw new TypeError('Cannot `' + e + '` without `compiler`')
}
function ul(e, t) {
  if (t)
    throw new Error(
      'Cannot call `' +
        e +
        '` on a frozen processor.\nCreate a new processor first, by calling it: use `processor()` instead of `processor`.'
    )
}
function tm(e) {
  if (!Ac(e) || typeof e.type != 'string') throw new TypeError('Expected node, got `' + e + '`')
}
function rm(e, t, r) {
  if (!r) throw new Error('`' + e + '` finished async. Use `' + t + '` instead')
}
function Ra(e) {
  return SE(e) ? e : new vE(e)
}
function SE(e) {
  return !!(e && typeof e == 'object' && 'message' in e && 'messages' in e)
}
function CE(e) {
  return typeof e == 'string' || kE(e)
}
function kE(e) {
  return !!(e && typeof e == 'object' && 'byteLength' in e && 'byteOffset' in e)
}
const wE = {}
function ep(e, t) {
  const r = t || wE,
    i = typeof r.includeImageAlt == 'boolean' ? r.includeImageAlt : !0,
    n = typeof r.includeHtml == 'boolean' ? r.includeHtml : !0
  return jg(e, i, n)
}
function jg(e, t, r) {
  if (NE(e)) {
    if ('value' in e) return e.type === 'html' && !r ? '' : e.value
    if (t && 'alt' in e && e.alt) return e.alt
    if ('children' in e) return im(e.children, t, r)
  }
  return Array.isArray(e) ? im(e, t, r) : ''
}
function im(e, t, r) {
  const i = []
  let n = -1
  for (; ++n < e.length; ) i[n] = jg(e[n], t, r)
  return i.join('')
}
function NE(e) {
  return !!(e && typeof e == 'object')
}
const nm = document.createElement('i')
function tp(e) {
  const t = '&' + e + ';'
  nm.innerHTML = t
  const r = nm.textContent
  return (r.charCodeAt(r.length - 1) === 59 && e !== 'semi') || r === t ? !1 : r
}
function Bt(e, t, r, i) {
  const n = e.length
  let s = 0,
    a
  if ((t < 0 ? (t = -t > n ? 0 : n + t) : (t = t > n ? n : t), (r = r > 0 ? r : 0), i.length < 1e4))
    (a = Array.from(i)), a.unshift(t, r), e.splice(...a)
  else
    for (r && e.splice(t, r); s < i.length; )
      (a = i.slice(s, s + 1e4)), a.unshift(t, 0), e.splice(...a), (s += 1e4), (t += 1e4)
}
function Gt(e, t) {
  return e.length > 0 ? (Bt(e, e.length, 0, t), e) : t
}
const sm = {}.hasOwnProperty
function qg(e) {
  const t = {}
  let r = -1
  for (; ++r < e.length; ) OE(t, e[r])
  return t
}
function OE(e, t) {
  let r
  for (r in t) {
    const n = (sm.call(e, r) ? e[r] : void 0) || (e[r] = {}),
      s = t[r]
    let a
    if (s)
      for (a in s) {
        sm.call(n, a) || (n[a] = [])
        const o = s[a]
        IE(n[a], Array.isArray(o) ? o : o ? [o] : [])
      }
  }
}
function IE(e, t) {
  let r = -1
  const i = []
  for (; ++r < t.length; ) (t[r].add === 'after' ? e : i).push(t[r])
  Bt(e, 0, 0, i)
}
function $g(e, t) {
  const r = Number.parseInt(e, t)
  return r < 9 ||
    r === 11 ||
    (r > 13 && r < 32) ||
    (r > 126 && r < 160) ||
    (r > 55295 && r < 57344) ||
    (r > 64975 && r < 65008) ||
    (r & 65535) === 65535 ||
    (r & 65535) === 65534 ||
    r > 1114111
    ? ''
    : String.fromCharCode(r)
}
function sr(e) {
  return e
    .replace(/[\t\n\r ]+/g, ' ')
    .replace(/^ | $/g, '')
    .toLowerCase()
    .toUpperCase()
}
const DE = mi(/\p{P}/u),
  bt = mi(/[A-Za-z]/),
  ht = mi(/[\dA-Za-z]/),
  RE = mi(/[#-'*+\--9=?A-Z^-~]/)
function Ro(e) {
  return e !== null && (e < 32 || e === 127)
}
const kc = mi(/\d/),
  LE = mi(/[\dA-Fa-f]/),
  Vg = mi(/[!-/:-@[-`{-~]/)
function ye(e) {
  return e !== null && e < -2
}
function Pe(e) {
  return e !== null && (e < 0 || e === 32)
}
function Ae(e) {
  return e === -2 || e === -1 || e === 32
}
function su(e) {
  return Vg(e) || DE(e)
}
const Ri = mi(/\s/)
function mi(e) {
  return t
  function t(r) {
    return r !== null && r > -1 && e.test(String.fromCharCode(r))
  }
}
function Mn(e) {
  const t = []
  let r = -1,
    i = 0,
    n = 0
  for (; ++r < e.length; ) {
    const s = e.charCodeAt(r)
    let a = ''
    if (s === 37 && ht(e.charCodeAt(r + 1)) && ht(e.charCodeAt(r + 2))) n = 2
    else if (s < 128)
      /[!#$&-;=?-Z_a-z~]/.test(String.fromCharCode(s)) || (a = String.fromCharCode(s))
    else if (s > 55295 && s < 57344) {
      const o = e.charCodeAt(r + 1)
      s < 56320 && o > 56319 && o < 57344 ? ((a = String.fromCharCode(s, o)), (n = 1)) : (a = '')
    } else a = String.fromCharCode(s)
    a && (t.push(e.slice(i, r), encodeURIComponent(a)), (i = r + n + 1), (a = '')),
      n && ((r += n), (n = 0))
  }
  return t.join('') + e.slice(i)
}
function we(e, t, r, i) {
  const n = i ? i - 1 : Number.POSITIVE_INFINITY
  let s = 0
  return a
  function a(u) {
    return Ae(u) ? (e.enter(r), o(u)) : t(u)
  }
  function o(u) {
    return Ae(u) && s++ < n ? (e.consume(u), o) : (e.exit(r), t(u))
  }
}
const PE = { tokenize: BE }
function BE(e) {
  const t = e.attempt(this.parser.constructs.contentInitial, i, n)
  let r
  return t
  function i(o) {
    if (o === null) {
      e.consume(o)
      return
    }
    return e.enter('lineEnding'), e.consume(o), e.exit('lineEnding'), we(e, t, 'linePrefix')
  }
  function n(o) {
    return e.enter('paragraph'), s(o)
  }
  function s(o) {
    const u = e.enter('chunkText', { contentType: 'text', previous: r })
    return r && (r.next = u), (r = u), a(o)
  }
  function a(o) {
    if (o === null) {
      e.exit('chunkText'), e.exit('paragraph'), e.consume(o)
      return
    }
    return ye(o) ? (e.consume(o), e.exit('chunkText'), s) : (e.consume(o), a)
  }
}
const FE = { tokenize: ME },
  am = { tokenize: UE }
function ME(e) {
  const t = this,
    r = []
  let i = 0,
    n,
    s,
    a
  return o
  function o(y) {
    if (i < r.length) {
      const x = r[i]
      return (t.containerState = x[1]), e.attempt(x[0].continuation, u, c)(y)
    }
    return c(y)
  }
  function u(y) {
    if ((i++, t.containerState._closeFlow)) {
      ;(t.containerState._closeFlow = void 0), n && _()
      const x = t.events.length
      let D = x,
        C
      for (; D--; )
        if (t.events[D][0] === 'exit' && t.events[D][1].type === 'chunkFlow') {
          C = t.events[D][1].end
          break
        }
      g(i)
      let H = x
      for (; H < t.events.length; ) (t.events[H][1].end = Object.assign({}, C)), H++
      return Bt(t.events, D + 1, 0, t.events.slice(x)), (t.events.length = H), c(y)
    }
    return o(y)
  }
  function c(y) {
    if (i === r.length) {
      if (!n) return p(y)
      if (n.currentConstruct && n.currentConstruct.concrete) return v(y)
      t.interrupt = !!(n.currentConstruct && !n._gfmTableDynamicInterruptHack)
    }
    return (t.containerState = {}), e.check(am, f, h)(y)
  }
  function f(y) {
    return n && _(), g(i), p(y)
  }
  function h(y) {
    return (t.parser.lazy[t.now().line] = i !== r.length), (a = t.now().offset), v(y)
  }
  function p(y) {
    return (t.containerState = {}), e.attempt(am, m, v)(y)
  }
  function m(y) {
    return i++, r.push([t.currentConstruct, t.containerState]), p(y)
  }
  function v(y) {
    if (y === null) {
      n && _(), g(0), e.consume(y)
      return
    }
    return (
      (n = n || t.parser.flow(t.now())),
      e.enter('chunkFlow', { contentType: 'flow', previous: s, _tokenizer: n }),
      b(y)
    )
  }
  function b(y) {
    if (y === null) {
      S(e.exit('chunkFlow'), !0), g(0), e.consume(y)
      return
    }
    return ye(y)
      ? (e.consume(y), S(e.exit('chunkFlow')), (i = 0), (t.interrupt = void 0), o)
      : (e.consume(y), b)
  }
  function S(y, x) {
    const D = t.sliceStream(y)
    if (
      (x && D.push(null),
      (y.previous = s),
      s && (s.next = y),
      (s = y),
      n.defineSkip(y.start),
      n.write(D),
      t.parser.lazy[y.start.line])
    ) {
      let C = n.events.length
      for (; C--; )
        if (
          n.events[C][1].start.offset < a &&
          (!n.events[C][1].end || n.events[C][1].end.offset > a)
        )
          return
      const H = t.events.length
      let T = H,
        k,
        O
      for (; T--; )
        if (t.events[T][0] === 'exit' && t.events[T][1].type === 'chunkFlow') {
          if (k) {
            O = t.events[T][1].end
            break
          }
          k = !0
        }
      for (g(i), C = H; C < t.events.length; ) (t.events[C][1].end = Object.assign({}, O)), C++
      Bt(t.events, T + 1, 0, t.events.slice(H)), (t.events.length = C)
    }
  }
  function g(y) {
    let x = r.length
    for (; x-- > y; ) {
      const D = r[x]
      ;(t.containerState = D[1]), D[0].exit.call(t, e)
    }
    r.length = y
  }
  function _() {
    n.write([null]), (s = void 0), (n = void 0), (t.containerState._closeFlow = void 0)
  }
}
function UE(e, t, r) {
  return we(
    e,
    e.attempt(this.parser.constructs.document, t, r),
    'linePrefix',
    this.parser.constructs.disable.null.includes('codeIndented') ? void 0 : 4
  )
}
function Lo(e) {
  if (e === null || Pe(e) || Ri(e)) return 1
  if (su(e)) return 2
}
function au(e, t, r) {
  const i = []
  let n = -1
  for (; ++n < e.length; ) {
    const s = e[n].resolveAll
    s && !i.includes(s) && ((t = s(t, r)), i.push(s))
  }
  return t
}
const wc = { name: 'attention', tokenize: zE, resolveAll: HE }
function HE(e, t) {
  let r = -1,
    i,
    n,
    s,
    a,
    o,
    u,
    c,
    f
  for (; ++r < e.length; )
    if (e[r][0] === 'enter' && e[r][1].type === 'attentionSequence' && e[r][1]._close) {
      for (i = r; i--; )
        if (
          e[i][0] === 'exit' &&
          e[i][1].type === 'attentionSequence' &&
          e[i][1]._open &&
          t.sliceSerialize(e[i][1]).charCodeAt(0) === t.sliceSerialize(e[r][1]).charCodeAt(0)
        ) {
          if (
            (e[i][1]._close || e[r][1]._open) &&
            (e[r][1].end.offset - e[r][1].start.offset) % 3 &&
            !(
              (e[i][1].end.offset -
                e[i][1].start.offset +
                e[r][1].end.offset -
                e[r][1].start.offset) %
              3
            )
          )
            continue
          u =
            e[i][1].end.offset - e[i][1].start.offset > 1 &&
            e[r][1].end.offset - e[r][1].start.offset > 1
              ? 2
              : 1
          const h = Object.assign({}, e[i][1].end),
            p = Object.assign({}, e[r][1].start)
          om(h, -u),
            om(p, u),
            (a = {
              type: u > 1 ? 'strongSequence' : 'emphasisSequence',
              start: h,
              end: Object.assign({}, e[i][1].end),
            }),
            (o = {
              type: u > 1 ? 'strongSequence' : 'emphasisSequence',
              start: Object.assign({}, e[r][1].start),
              end: p,
            }),
            (s = {
              type: u > 1 ? 'strongText' : 'emphasisText',
              start: Object.assign({}, e[i][1].end),
              end: Object.assign({}, e[r][1].start),
            }),
            (n = {
              type: u > 1 ? 'strong' : 'emphasis',
              start: Object.assign({}, a.start),
              end: Object.assign({}, o.end),
            }),
            (e[i][1].end = Object.assign({}, a.start)),
            (e[r][1].start = Object.assign({}, o.end)),
            (c = []),
            e[i][1].end.offset - e[i][1].start.offset &&
              (c = Gt(c, [
                ['enter', e[i][1], t],
                ['exit', e[i][1], t],
              ])),
            (c = Gt(c, [
              ['enter', n, t],
              ['enter', a, t],
              ['exit', a, t],
              ['enter', s, t],
            ])),
            (c = Gt(c, au(t.parser.constructs.insideSpan.null, e.slice(i + 1, r), t))),
            (c = Gt(c, [
              ['exit', s, t],
              ['enter', o, t],
              ['exit', o, t],
              ['exit', n, t],
            ])),
            e[r][1].end.offset - e[r][1].start.offset
              ? ((f = 2),
                (c = Gt(c, [
                  ['enter', e[r][1], t],
                  ['exit', e[r][1], t],
                ])))
              : (f = 0),
            Bt(e, i - 1, r - i + 3, c),
            (r = i + c.length - f - 2)
          break
        }
    }
  for (r = -1; ++r < e.length; ) e[r][1].type === 'attentionSequence' && (e[r][1].type = 'data')
  return e
}
function zE(e, t) {
  const r = this.parser.constructs.attentionMarkers.null,
    i = this.previous,
    n = Lo(i)
  let s
  return a
  function a(u) {
    return (s = u), e.enter('attentionSequence'), o(u)
  }
  function o(u) {
    if (u === s) return e.consume(u), o
    const c = e.exit('attentionSequence'),
      f = Lo(u),
      h = !f || (f === 2 && n) || r.includes(u),
      p = !n || (n === 2 && f) || r.includes(i)
    return (
      (c._open = !!(s === 42 ? h : h && (n || !p))),
      (c._close = !!(s === 42 ? p : p && (f || !h))),
      t(u)
    )
  }
}
function om(e, t) {
  ;(e.column += t), (e.offset += t), (e._bufferIndex += t)
}
const jE = { name: 'autolink', tokenize: qE }
function qE(e, t, r) {
  let i = 0
  return n
  function n(m) {
    return (
      e.enter('autolink'),
      e.enter('autolinkMarker'),
      e.consume(m),
      e.exit('autolinkMarker'),
      e.enter('autolinkProtocol'),
      s
    )
  }
  function s(m) {
    return bt(m) ? (e.consume(m), a) : c(m)
  }
  function a(m) {
    return m === 43 || m === 45 || m === 46 || ht(m) ? ((i = 1), o(m)) : c(m)
  }
  function o(m) {
    return m === 58
      ? (e.consume(m), (i = 0), u)
      : (m === 43 || m === 45 || m === 46 || ht(m)) && i++ < 32
      ? (e.consume(m), o)
      : ((i = 0), c(m))
  }
  function u(m) {
    return m === 62
      ? (e.exit('autolinkProtocol'),
        e.enter('autolinkMarker'),
        e.consume(m),
        e.exit('autolinkMarker'),
        e.exit('autolink'),
        t)
      : m === null || m === 32 || m === 60 || Ro(m)
      ? r(m)
      : (e.consume(m), u)
  }
  function c(m) {
    return m === 64 ? (e.consume(m), f) : RE(m) ? (e.consume(m), c) : r(m)
  }
  function f(m) {
    return ht(m) ? h(m) : r(m)
  }
  function h(m) {
    return m === 46
      ? (e.consume(m), (i = 0), f)
      : m === 62
      ? ((e.exit('autolinkProtocol').type = 'autolinkEmail'),
        e.enter('autolinkMarker'),
        e.consume(m),
        e.exit('autolinkMarker'),
        e.exit('autolink'),
        t)
      : p(m)
  }
  function p(m) {
    if ((m === 45 || ht(m)) && i++ < 63) {
      const v = m === 45 ? p : h
      return e.consume(m), v
    }
    return r(m)
  }
}
const sa = { tokenize: $E, partial: !0 }
function $E(e, t, r) {
  return i
  function i(s) {
    return Ae(s) ? we(e, n, 'linePrefix')(s) : n(s)
  }
  function n(s) {
    return s === null || ye(s) ? t(s) : r(s)
  }
}
const Gg = { name: 'blockQuote', tokenize: VE, continuation: { tokenize: GE }, exit: XE }
function VE(e, t, r) {
  const i = this
  return n
  function n(a) {
    if (a === 62) {
      const o = i.containerState
      return (
        o.open || (e.enter('blockQuote', { _container: !0 }), (o.open = !0)),
        e.enter('blockQuotePrefix'),
        e.enter('blockQuoteMarker'),
        e.consume(a),
        e.exit('blockQuoteMarker'),
        s
      )
    }
    return r(a)
  }
  function s(a) {
    return Ae(a)
      ? (e.enter('blockQuotePrefixWhitespace'),
        e.consume(a),
        e.exit('blockQuotePrefixWhitespace'),
        e.exit('blockQuotePrefix'),
        t)
      : (e.exit('blockQuotePrefix'), t(a))
  }
}
function GE(e, t, r) {
  const i = this
  return n
  function n(a) {
    return Ae(a)
      ? we(
          e,
          s,
          'linePrefix',
          i.parser.constructs.disable.null.includes('codeIndented') ? void 0 : 4
        )(a)
      : s(a)
  }
  function s(a) {
    return e.attempt(Gg, t, r)(a)
  }
}
function XE(e) {
  e.exit('blockQuote')
}
const Xg = { name: 'characterEscape', tokenize: YE }
function YE(e, t, r) {
  return i
  function i(s) {
    return (
      e.enter('characterEscape'), e.enter('escapeMarker'), e.consume(s), e.exit('escapeMarker'), n
    )
  }
  function n(s) {
    return Vg(s)
      ? (e.enter('characterEscapeValue'),
        e.consume(s),
        e.exit('characterEscapeValue'),
        e.exit('characterEscape'),
        t)
      : r(s)
  }
}
const Yg = { name: 'characterReference', tokenize: WE }
function WE(e, t, r) {
  const i = this
  let n = 0,
    s,
    a
  return o
  function o(h) {
    return (
      e.enter('characterReference'),
      e.enter('characterReferenceMarker'),
      e.consume(h),
      e.exit('characterReferenceMarker'),
      u
    )
  }
  function u(h) {
    return h === 35
      ? (e.enter('characterReferenceMarkerNumeric'),
        e.consume(h),
        e.exit('characterReferenceMarkerNumeric'),
        c)
      : (e.enter('characterReferenceValue'), (s = 31), (a = ht), f(h))
  }
  function c(h) {
    return h === 88 || h === 120
      ? (e.enter('characterReferenceMarkerHexadecimal'),
        e.consume(h),
        e.exit('characterReferenceMarkerHexadecimal'),
        e.enter('characterReferenceValue'),
        (s = 6),
        (a = LE),
        f)
      : (e.enter('characterReferenceValue'), (s = 7), (a = kc), f(h))
  }
  function f(h) {
    if (h === 59 && n) {
      const p = e.exit('characterReferenceValue')
      return a === ht && !tp(i.sliceSerialize(p))
        ? r(h)
        : (e.enter('characterReferenceMarker'),
          e.consume(h),
          e.exit('characterReferenceMarker'),
          e.exit('characterReference'),
          t)
    }
    return a(h) && n++ < s ? (e.consume(h), f) : r(h)
  }
}
const um = { tokenize: KE, partial: !0 },
  lm = { name: 'codeFenced', tokenize: QE, concrete: !0 }
function QE(e, t, r) {
  const i = this,
    n = { tokenize: D, partial: !0 }
  let s = 0,
    a = 0,
    o
  return u
  function u(C) {
    return c(C)
  }
  function c(C) {
    const H = i.events[i.events.length - 1]
    return (
      (s = H && H[1].type === 'linePrefix' ? H[2].sliceSerialize(H[1], !0).length : 0),
      (o = C),
      e.enter('codeFenced'),
      e.enter('codeFencedFence'),
      e.enter('codeFencedFenceSequence'),
      f(C)
    )
  }
  function f(C) {
    return C === o
      ? (a++, e.consume(C), f)
      : a < 3
      ? r(C)
      : (e.exit('codeFencedFenceSequence'), Ae(C) ? we(e, h, 'whitespace')(C) : h(C))
  }
  function h(C) {
    return C === null || ye(C)
      ? (e.exit('codeFencedFence'), i.interrupt ? t(C) : e.check(um, b, x)(C))
      : (e.enter('codeFencedFenceInfo'), e.enter('chunkString', { contentType: 'string' }), p(C))
  }
  function p(C) {
    return C === null || ye(C)
      ? (e.exit('chunkString'), e.exit('codeFencedFenceInfo'), h(C))
      : Ae(C)
      ? (e.exit('chunkString'), e.exit('codeFencedFenceInfo'), we(e, m, 'whitespace')(C))
      : C === 96 && C === o
      ? r(C)
      : (e.consume(C), p)
  }
  function m(C) {
    return C === null || ye(C)
      ? h(C)
      : (e.enter('codeFencedFenceMeta'), e.enter('chunkString', { contentType: 'string' }), v(C))
  }
  function v(C) {
    return C === null || ye(C)
      ? (e.exit('chunkString'), e.exit('codeFencedFenceMeta'), h(C))
      : C === 96 && C === o
      ? r(C)
      : (e.consume(C), v)
  }
  function b(C) {
    return e.attempt(n, x, S)(C)
  }
  function S(C) {
    return e.enter('lineEnding'), e.consume(C), e.exit('lineEnding'), g
  }
  function g(C) {
    return s > 0 && Ae(C) ? we(e, _, 'linePrefix', s + 1)(C) : _(C)
  }
  function _(C) {
    return C === null || ye(C) ? e.check(um, b, x)(C) : (e.enter('codeFlowValue'), y(C))
  }
  function y(C) {
    return C === null || ye(C) ? (e.exit('codeFlowValue'), _(C)) : (e.consume(C), y)
  }
  function x(C) {
    return e.exit('codeFenced'), t(C)
  }
  function D(C, H, T) {
    let k = 0
    return O
    function O(R) {
      return C.enter('lineEnding'), C.consume(R), C.exit('lineEnding'), N
    }
    function N(R) {
      return (
        C.enter('codeFencedFence'),
        Ae(R)
          ? we(
              C,
              M,
              'linePrefix',
              i.parser.constructs.disable.null.includes('codeIndented') ? void 0 : 4
            )(R)
          : M(R)
      )
    }
    function M(R) {
      return R === o ? (C.enter('codeFencedFenceSequence'), V(R)) : T(R)
    }
    function V(R) {
      return R === o
        ? (k++, C.consume(R), V)
        : k >= a
        ? (C.exit('codeFencedFenceSequence'), Ae(R) ? we(C, j, 'whitespace')(R) : j(R))
        : T(R)
    }
    function j(R) {
      return R === null || ye(R) ? (C.exit('codeFencedFence'), H(R)) : T(R)
    }
  }
}
function KE(e, t, r) {
  const i = this
  return n
  function n(a) {
    return a === null ? r(a) : (e.enter('lineEnding'), e.consume(a), e.exit('lineEnding'), s)
  }
  function s(a) {
    return i.parser.lazy[i.now().line] ? r(a) : t(a)
  }
}
const ll = { name: 'codeIndented', tokenize: ZE },
  JE = { tokenize: ex, partial: !0 }
function ZE(e, t, r) {
  const i = this
  return n
  function n(c) {
    return e.enter('codeIndented'), we(e, s, 'linePrefix', 4 + 1)(c)
  }
  function s(c) {
    const f = i.events[i.events.length - 1]
    return f && f[1].type === 'linePrefix' && f[2].sliceSerialize(f[1], !0).length >= 4
      ? a(c)
      : r(c)
  }
  function a(c) {
    return c === null ? u(c) : ye(c) ? e.attempt(JE, a, u)(c) : (e.enter('codeFlowValue'), o(c))
  }
  function o(c) {
    return c === null || ye(c) ? (e.exit('codeFlowValue'), a(c)) : (e.consume(c), o)
  }
  function u(c) {
    return e.exit('codeIndented'), t(c)
  }
}
function ex(e, t, r) {
  const i = this
  return n
  function n(a) {
    return i.parser.lazy[i.now().line]
      ? r(a)
      : ye(a)
      ? (e.enter('lineEnding'), e.consume(a), e.exit('lineEnding'), n)
      : we(e, s, 'linePrefix', 4 + 1)(a)
  }
  function s(a) {
    const o = i.events[i.events.length - 1]
    return o && o[1].type === 'linePrefix' && o[2].sliceSerialize(o[1], !0).length >= 4
      ? t(a)
      : ye(a)
      ? n(a)
      : r(a)
  }
}
const tx = { name: 'codeText', tokenize: nx, resolve: rx, previous: ix }
function rx(e) {
  let t = e.length - 4,
    r = 3,
    i,
    n
  if (
    (e[r][1].type === 'lineEnding' || e[r][1].type === 'space') &&
    (e[t][1].type === 'lineEnding' || e[t][1].type === 'space')
  ) {
    for (i = r; ++i < t; )
      if (e[i][1].type === 'codeTextData') {
        ;(e[r][1].type = 'codeTextPadding'), (e[t][1].type = 'codeTextPadding'), (r += 2), (t -= 2)
        break
      }
  }
  for (i = r - 1, t++; ++i <= t; )
    n === void 0
      ? i !== t && e[i][1].type !== 'lineEnding' && (n = i)
      : (i === t || e[i][1].type === 'lineEnding') &&
        ((e[n][1].type = 'codeTextData'),
        i !== n + 2 &&
          ((e[n][1].end = e[i - 1][1].end),
          e.splice(n + 2, i - n - 2),
          (t -= i - n - 2),
          (i = n + 2)),
        (n = void 0))
  return e
}
function ix(e) {
  return e !== 96 || this.events[this.events.length - 1][1].type === 'characterEscape'
}
function nx(e, t, r) {
  let i = 0,
    n,
    s
  return a
  function a(h) {
    return e.enter('codeText'), e.enter('codeTextSequence'), o(h)
  }
  function o(h) {
    return h === 96 ? (e.consume(h), i++, o) : (e.exit('codeTextSequence'), u(h))
  }
  function u(h) {
    return h === null
      ? r(h)
      : h === 32
      ? (e.enter('space'), e.consume(h), e.exit('space'), u)
      : h === 96
      ? ((s = e.enter('codeTextSequence')), (n = 0), f(h))
      : ye(h)
      ? (e.enter('lineEnding'), e.consume(h), e.exit('lineEnding'), u)
      : (e.enter('codeTextData'), c(h))
  }
  function c(h) {
    return h === null || h === 32 || h === 96 || ye(h)
      ? (e.exit('codeTextData'), u(h))
      : (e.consume(h), c)
  }
  function f(h) {
    return h === 96
      ? (e.consume(h), n++, f)
      : n === i
      ? (e.exit('codeTextSequence'), e.exit('codeText'), t(h))
      : ((s.type = 'codeTextData'), c(h))
  }
}
function Wg(e) {
  const t = {}
  let r = -1,
    i,
    n,
    s,
    a,
    o,
    u,
    c
  for (; ++r < e.length; ) {
    for (; r in t; ) r = t[r]
    if (
      ((i = e[r]),
      r &&
        i[1].type === 'chunkFlow' &&
        e[r - 1][1].type === 'listItemPrefix' &&
        ((u = i[1]._tokenizer.events),
        (s = 0),
        s < u.length && u[s][1].type === 'lineEndingBlank' && (s += 2),
        s < u.length && u[s][1].type === 'content'))
    )
      for (; ++s < u.length && u[s][1].type !== 'content'; )
        u[s][1].type === 'chunkText' && ((u[s][1]._isInFirstContentOfListItem = !0), s++)
    if (i[0] === 'enter') i[1].contentType && (Object.assign(t, sx(e, r)), (r = t[r]), (c = !0))
    else if (i[1]._container) {
      for (
        s = r, n = void 0;
        s-- && ((a = e[s]), a[1].type === 'lineEnding' || a[1].type === 'lineEndingBlank');

      )
        a[0] === 'enter' &&
          (n && (e[n][1].type = 'lineEndingBlank'), (a[1].type = 'lineEnding'), (n = s))
      n &&
        ((i[1].end = Object.assign({}, e[n][1].start)),
        (o = e.slice(n, r)),
        o.unshift(i),
        Bt(e, n, r - n + 1, o))
    }
  }
  return !c
}
function sx(e, t) {
  const r = e[t][1],
    i = e[t][2]
  let n = t - 1
  const s = [],
    a = r._tokenizer || i.parser[r.contentType](r.start),
    o = a.events,
    u = [],
    c = {}
  let f,
    h,
    p = -1,
    m = r,
    v = 0,
    b = 0
  const S = [b]
  for (; m; ) {
    for (; e[++n][1] !== m; );
    s.push(n),
      m._tokenizer ||
        ((f = i.sliceStream(m)),
        m.next || f.push(null),
        h && a.defineSkip(m.start),
        m._isInFirstContentOfListItem && (a._gfmTasklistFirstContentOfListItem = !0),
        a.write(f),
        m._isInFirstContentOfListItem && (a._gfmTasklistFirstContentOfListItem = void 0)),
      (h = m),
      (m = m.next)
  }
  for (m = r; ++p < o.length; )
    o[p][0] === 'exit' &&
      o[p - 1][0] === 'enter' &&
      o[p][1].type === o[p - 1][1].type &&
      o[p][1].start.line !== o[p][1].end.line &&
      ((b = p + 1), S.push(b), (m._tokenizer = void 0), (m.previous = void 0), (m = m.next))
  for (
    a.events = [], m ? ((m._tokenizer = void 0), (m.previous = void 0)) : S.pop(), p = S.length;
    p--;

  ) {
    const g = o.slice(S[p], S[p + 1]),
      _ = s.pop()
    u.unshift([_, _ + g.length - 1]), Bt(e, _, 2, g)
  }
  for (p = -1; ++p < u.length; ) (c[v + u[p][0]] = v + u[p][1]), (v += u[p][1] - u[p][0] - 1)
  return c
}
const ax = { tokenize: lx, resolve: ux },
  ox = { tokenize: cx, partial: !0 }
function ux(e) {
  return Wg(e), e
}
function lx(e, t) {
  let r
  return i
  function i(o) {
    return e.enter('content'), (r = e.enter('chunkContent', { contentType: 'content' })), n(o)
  }
  function n(o) {
    return o === null ? s(o) : ye(o) ? e.check(ox, a, s)(o) : (e.consume(o), n)
  }
  function s(o) {
    return e.exit('chunkContent'), e.exit('content'), t(o)
  }
  function a(o) {
    return (
      e.consume(o),
      e.exit('chunkContent'),
      (r.next = e.enter('chunkContent', { contentType: 'content', previous: r })),
      (r = r.next),
      n
    )
  }
}
function cx(e, t, r) {
  const i = this
  return n
  function n(a) {
    return (
      e.exit('chunkContent'),
      e.enter('lineEnding'),
      e.consume(a),
      e.exit('lineEnding'),
      we(e, s, 'linePrefix')
    )
  }
  function s(a) {
    if (a === null || ye(a)) return r(a)
    const o = i.events[i.events.length - 1]
    return !i.parser.constructs.disable.null.includes('codeIndented') &&
      o &&
      o[1].type === 'linePrefix' &&
      o[2].sliceSerialize(o[1], !0).length >= 4
      ? t(a)
      : e.interrupt(i.parser.constructs.flow, r, t)(a)
  }
}
function Qg(e, t, r, i, n, s, a, o, u) {
  const c = u || Number.POSITIVE_INFINITY
  let f = 0
  return h
  function h(g) {
    return g === 60
      ? (e.enter(i), e.enter(n), e.enter(s), e.consume(g), e.exit(s), p)
      : g === null || g === 32 || g === 41 || Ro(g)
      ? r(g)
      : (e.enter(i),
        e.enter(a),
        e.enter(o),
        e.enter('chunkString', { contentType: 'string' }),
        b(g))
  }
  function p(g) {
    return g === 62
      ? (e.enter(s), e.consume(g), e.exit(s), e.exit(n), e.exit(i), t)
      : (e.enter(o), e.enter('chunkString', { contentType: 'string' }), m(g))
  }
  function m(g) {
    return g === 62
      ? (e.exit('chunkString'), e.exit(o), p(g))
      : g === null || g === 60 || ye(g)
      ? r(g)
      : (e.consume(g), g === 92 ? v : m)
  }
  function v(g) {
    return g === 60 || g === 62 || g === 92 ? (e.consume(g), m) : m(g)
  }
  function b(g) {
    return !f && (g === null || g === 41 || Pe(g))
      ? (e.exit('chunkString'), e.exit(o), e.exit(a), e.exit(i), t(g))
      : f < c && g === 40
      ? (e.consume(g), f++, b)
      : g === 41
      ? (e.consume(g), f--, b)
      : g === null || g === 32 || g === 40 || Ro(g)
      ? r(g)
      : (e.consume(g), g === 92 ? S : b)
  }
  function S(g) {
    return g === 40 || g === 41 || g === 92 ? (e.consume(g), b) : b(g)
  }
}
function Kg(e, t, r, i, n, s) {
  const a = this
  let o = 0,
    u
  return c
  function c(m) {
    return e.enter(i), e.enter(n), e.consume(m), e.exit(n), e.enter(s), f
  }
  function f(m) {
    return o > 999 ||
      m === null ||
      m === 91 ||
      (m === 93 && !u) ||
      (m === 94 && !o && '_hiddenFootnoteSupport' in a.parser.constructs)
      ? r(m)
      : m === 93
      ? (e.exit(s), e.enter(n), e.consume(m), e.exit(n), e.exit(i), t)
      : ye(m)
      ? (e.enter('lineEnding'), e.consume(m), e.exit('lineEnding'), f)
      : (e.enter('chunkString', { contentType: 'string' }), h(m))
  }
  function h(m) {
    return m === null || m === 91 || m === 93 || ye(m) || o++ > 999
      ? (e.exit('chunkString'), f(m))
      : (e.consume(m), u || (u = !Ae(m)), m === 92 ? p : h)
  }
  function p(m) {
    return m === 91 || m === 92 || m === 93 ? (e.consume(m), o++, h) : h(m)
  }
}
function Jg(e, t, r, i, n, s) {
  let a
  return o
  function o(p) {
    return p === 34 || p === 39 || p === 40
      ? (e.enter(i), e.enter(n), e.consume(p), e.exit(n), (a = p === 40 ? 41 : p), u)
      : r(p)
  }
  function u(p) {
    return p === a ? (e.enter(n), e.consume(p), e.exit(n), e.exit(i), t) : (e.enter(s), c(p))
  }
  function c(p) {
    return p === a
      ? (e.exit(s), u(a))
      : p === null
      ? r(p)
      : ye(p)
      ? (e.enter('lineEnding'), e.consume(p), e.exit('lineEnding'), we(e, c, 'linePrefix'))
      : (e.enter('chunkString', { contentType: 'string' }), f(p))
  }
  function f(p) {
    return p === a || p === null || ye(p)
      ? (e.exit('chunkString'), c(p))
      : (e.consume(p), p === 92 ? h : f)
  }
  function h(p) {
    return p === a || p === 92 ? (e.consume(p), f) : f(p)
  }
}
function bs(e, t) {
  let r
  return i
  function i(n) {
    return ye(n)
      ? (e.enter('lineEnding'), e.consume(n), e.exit('lineEnding'), (r = !0), i)
      : Ae(n)
      ? we(e, i, r ? 'linePrefix' : 'lineSuffix')(n)
      : t(n)
  }
}
const fx = { name: 'definition', tokenize: hx },
  px = { tokenize: mx, partial: !0 }
function hx(e, t, r) {
  const i = this
  let n
  return s
  function s(m) {
    return e.enter('definition'), a(m)
  }
  function a(m) {
    return Kg.call(
      i,
      e,
      o,
      r,
      'definitionLabel',
      'definitionLabelMarker',
      'definitionLabelString'
    )(m)
  }
  function o(m) {
    return (
      (n = sr(i.sliceSerialize(i.events[i.events.length - 1][1]).slice(1, -1))),
      m === 58 ? (e.enter('definitionMarker'), e.consume(m), e.exit('definitionMarker'), u) : r(m)
    )
  }
  function u(m) {
    return Pe(m) ? bs(e, c)(m) : c(m)
  }
  function c(m) {
    return Qg(
      e,
      f,
      r,
      'definitionDestination',
      'definitionDestinationLiteral',
      'definitionDestinationLiteralMarker',
      'definitionDestinationRaw',
      'definitionDestinationString'
    )(m)
  }
  function f(m) {
    return e.attempt(px, h, h)(m)
  }
  function h(m) {
    return Ae(m) ? we(e, p, 'whitespace')(m) : p(m)
  }
  function p(m) {
    return m === null || ye(m) ? (e.exit('definition'), i.parser.defined.push(n), t(m)) : r(m)
  }
}
function mx(e, t, r) {
  return i
  function i(o) {
    return Pe(o) ? bs(e, n)(o) : r(o)
  }
  function n(o) {
    return Jg(e, s, r, 'definitionTitle', 'definitionTitleMarker', 'definitionTitleString')(o)
  }
  function s(o) {
    return Ae(o) ? we(e, a, 'whitespace')(o) : a(o)
  }
  function a(o) {
    return o === null || ye(o) ? t(o) : r(o)
  }
}
const dx = { name: 'hardBreakEscape', tokenize: gx }
function gx(e, t, r) {
  return i
  function i(s) {
    return e.enter('hardBreakEscape'), e.consume(s), n
  }
  function n(s) {
    return ye(s) ? (e.exit('hardBreakEscape'), t(s)) : r(s)
  }
}
const bx = { name: 'headingAtx', tokenize: _x, resolve: yx }
function yx(e, t) {
  let r = e.length - 2,
    i = 3,
    n,
    s
  return (
    e[i][1].type === 'whitespace' && (i += 2),
    r - 2 > i && e[r][1].type === 'whitespace' && (r -= 2),
    e[r][1].type === 'atxHeadingSequence' &&
      (i === r - 1 || (r - 4 > i && e[r - 2][1].type === 'whitespace')) &&
      (r -= i + 1 === r ? 2 : 4),
    r > i &&
      ((n = { type: 'atxHeadingText', start: e[i][1].start, end: e[r][1].end }),
      (s = { type: 'chunkText', start: e[i][1].start, end: e[r][1].end, contentType: 'text' }),
      Bt(e, i, r - i + 1, [
        ['enter', n, t],
        ['enter', s, t],
        ['exit', s, t],
        ['exit', n, t],
      ])),
    e
  )
}
function _x(e, t, r) {
  let i = 0
  return n
  function n(f) {
    return e.enter('atxHeading'), s(f)
  }
  function s(f) {
    return e.enter('atxHeadingSequence'), a(f)
  }
  function a(f) {
    return f === 35 && i++ < 6
      ? (e.consume(f), a)
      : f === null || Pe(f)
      ? (e.exit('atxHeadingSequence'), o(f))
      : r(f)
  }
  function o(f) {
    return f === 35
      ? (e.enter('atxHeadingSequence'), u(f))
      : f === null || ye(f)
      ? (e.exit('atxHeading'), t(f))
      : Ae(f)
      ? we(e, o, 'whitespace')(f)
      : (e.enter('atxHeadingText'), c(f))
  }
  function u(f) {
    return f === 35 ? (e.consume(f), u) : (e.exit('atxHeadingSequence'), o(f))
  }
  function c(f) {
    return f === null || f === 35 || Pe(f) ? (e.exit('atxHeadingText'), o(f)) : (e.consume(f), c)
  }
}
const vx = [
    'address',
    'article',
    'aside',
    'base',
    'basefont',
    'blockquote',
    'body',
    'caption',
    'center',
    'col',
    'colgroup',
    'dd',
    'details',
    'dialog',
    'dir',
    'div',
    'dl',
    'dt',
    'fieldset',
    'figcaption',
    'figure',
    'footer',
    'form',
    'frame',
    'frameset',
    'h1',
    'h2',
    'h3',
    'h4',
    'h5',
    'h6',
    'head',
    'header',
    'hr',
    'html',
    'iframe',
    'legend',
    'li',
    'link',
    'main',
    'menu',
    'menuitem',
    'nav',
    'noframes',
    'ol',
    'optgroup',
    'option',
    'p',
    'param',
    'search',
    'section',
    'summary',
    'table',
    'tbody',
    'td',
    'tfoot',
    'th',
    'thead',
    'title',
    'tr',
    'track',
    'ul',
  ],
  cm = ['pre', 'script', 'style', 'textarea'],
  Ex = { name: 'htmlFlow', tokenize: Sx, resolveTo: Ax, concrete: !0 },
  xx = { tokenize: kx, partial: !0 },
  Tx = { tokenize: Cx, partial: !0 }
function Ax(e) {
  let t = e.length
  for (; t-- && !(e[t][0] === 'enter' && e[t][1].type === 'htmlFlow'); );
  return (
    t > 1 &&
      e[t - 2][1].type === 'linePrefix' &&
      ((e[t][1].start = e[t - 2][1].start),
      (e[t + 1][1].start = e[t - 2][1].start),
      e.splice(t - 2, 2)),
    e
  )
}
function Sx(e, t, r) {
  const i = this
  let n, s, a, o, u
  return c
  function c(I) {
    return f(I)
  }
  function f(I) {
    return e.enter('htmlFlow'), e.enter('htmlFlowData'), e.consume(I), h
  }
  function h(I) {
    return I === 33
      ? (e.consume(I), p)
      : I === 47
      ? (e.consume(I), (s = !0), b)
      : I === 63
      ? (e.consume(I), (n = 3), i.interrupt ? t : w)
      : bt(I)
      ? (e.consume(I), (a = String.fromCharCode(I)), S)
      : r(I)
  }
  function p(I) {
    return I === 45
      ? (e.consume(I), (n = 2), m)
      : I === 91
      ? (e.consume(I), (n = 5), (o = 0), v)
      : bt(I)
      ? (e.consume(I), (n = 4), i.interrupt ? t : w)
      : r(I)
  }
  function m(I) {
    return I === 45 ? (e.consume(I), i.interrupt ? t : w) : r(I)
  }
  function v(I) {
    const re = 'CDATA['
    return I === re.charCodeAt(o++)
      ? (e.consume(I), o === re.length ? (i.interrupt ? t : M) : v)
      : r(I)
  }
  function b(I) {
    return bt(I) ? (e.consume(I), (a = String.fromCharCode(I)), S) : r(I)
  }
  function S(I) {
    if (I === null || I === 47 || I === 62 || Pe(I)) {
      const re = I === 47,
        ie = a.toLowerCase()
      return !re && !s && cm.includes(ie)
        ? ((n = 1), i.interrupt ? t(I) : M(I))
        : vx.includes(a.toLowerCase())
        ? ((n = 6), re ? (e.consume(I), g) : i.interrupt ? t(I) : M(I))
        : ((n = 7), i.interrupt && !i.parser.lazy[i.now().line] ? r(I) : s ? _(I) : y(I))
    }
    return I === 45 || ht(I) ? (e.consume(I), (a += String.fromCharCode(I)), S) : r(I)
  }
  function g(I) {
    return I === 62 ? (e.consume(I), i.interrupt ? t : M) : r(I)
  }
  function _(I) {
    return Ae(I) ? (e.consume(I), _) : O(I)
  }
  function y(I) {
    return I === 47
      ? (e.consume(I), O)
      : I === 58 || I === 95 || bt(I)
      ? (e.consume(I), x)
      : Ae(I)
      ? (e.consume(I), y)
      : O(I)
  }
  function x(I) {
    return I === 45 || I === 46 || I === 58 || I === 95 || ht(I) ? (e.consume(I), x) : D(I)
  }
  function D(I) {
    return I === 61 ? (e.consume(I), C) : Ae(I) ? (e.consume(I), D) : y(I)
  }
  function C(I) {
    return I === null || I === 60 || I === 61 || I === 62 || I === 96
      ? r(I)
      : I === 34 || I === 39
      ? (e.consume(I), (u = I), H)
      : Ae(I)
      ? (e.consume(I), C)
      : T(I)
  }
  function H(I) {
    return I === u ? (e.consume(I), (u = null), k) : I === null || ye(I) ? r(I) : (e.consume(I), H)
  }
  function T(I) {
    return I === null ||
      I === 34 ||
      I === 39 ||
      I === 47 ||
      I === 60 ||
      I === 61 ||
      I === 62 ||
      I === 96 ||
      Pe(I)
      ? D(I)
      : (e.consume(I), T)
  }
  function k(I) {
    return I === 47 || I === 62 || Ae(I) ? y(I) : r(I)
  }
  function O(I) {
    return I === 62 ? (e.consume(I), N) : r(I)
  }
  function N(I) {
    return I === null || ye(I) ? M(I) : Ae(I) ? (e.consume(I), N) : r(I)
  }
  function M(I) {
    return I === 45 && n === 2
      ? (e.consume(I), $)
      : I === 60 && n === 1
      ? (e.consume(I), L)
      : I === 62 && n === 4
      ? (e.consume(I), q)
      : I === 63 && n === 3
      ? (e.consume(I), w)
      : I === 93 && n === 5
      ? (e.consume(I), Y)
      : ye(I) && (n === 6 || n === 7)
      ? (e.exit('htmlFlowData'), e.check(xx, X, V)(I))
      : I === null || ye(I)
      ? (e.exit('htmlFlowData'), V(I))
      : (e.consume(I), M)
  }
  function V(I) {
    return e.check(Tx, j, X)(I)
  }
  function j(I) {
    return e.enter('lineEnding'), e.consume(I), e.exit('lineEnding'), R
  }
  function R(I) {
    return I === null || ye(I) ? V(I) : (e.enter('htmlFlowData'), M(I))
  }
  function $(I) {
    return I === 45 ? (e.consume(I), w) : M(I)
  }
  function L(I) {
    return I === 47 ? (e.consume(I), (a = ''), P) : M(I)
  }
  function P(I) {
    if (I === 62) {
      const re = a.toLowerCase()
      return cm.includes(re) ? (e.consume(I), q) : M(I)
    }
    return bt(I) && a.length < 8 ? (e.consume(I), (a += String.fromCharCode(I)), P) : M(I)
  }
  function Y(I) {
    return I === 93 ? (e.consume(I), w) : M(I)
  }
  function w(I) {
    return I === 62 ? (e.consume(I), q) : I === 45 && n === 2 ? (e.consume(I), w) : M(I)
  }
  function q(I) {
    return I === null || ye(I) ? (e.exit('htmlFlowData'), X(I)) : (e.consume(I), q)
  }
  function X(I) {
    return e.exit('htmlFlow'), t(I)
  }
}
function Cx(e, t, r) {
  const i = this
  return n
  function n(a) {
    return ye(a) ? (e.enter('lineEnding'), e.consume(a), e.exit('lineEnding'), s) : r(a)
  }
  function s(a) {
    return i.parser.lazy[i.now().line] ? r(a) : t(a)
  }
}
function kx(e, t, r) {
  return i
  function i(n) {
    return e.enter('lineEnding'), e.consume(n), e.exit('lineEnding'), e.attempt(sa, t, r)
  }
}
const wx = { name: 'htmlText', tokenize: Nx }
function Nx(e, t, r) {
  const i = this
  let n, s, a
  return o
  function o(w) {
    return e.enter('htmlText'), e.enter('htmlTextData'), e.consume(w), u
  }
  function u(w) {
    return w === 33
      ? (e.consume(w), c)
      : w === 47
      ? (e.consume(w), D)
      : w === 63
      ? (e.consume(w), y)
      : bt(w)
      ? (e.consume(w), T)
      : r(w)
  }
  function c(w) {
    return w === 45
      ? (e.consume(w), f)
      : w === 91
      ? (e.consume(w), (s = 0), v)
      : bt(w)
      ? (e.consume(w), _)
      : r(w)
  }
  function f(w) {
    return w === 45 ? (e.consume(w), m) : r(w)
  }
  function h(w) {
    return w === null
      ? r(w)
      : w === 45
      ? (e.consume(w), p)
      : ye(w)
      ? ((a = h), L(w))
      : (e.consume(w), h)
  }
  function p(w) {
    return w === 45 ? (e.consume(w), m) : h(w)
  }
  function m(w) {
    return w === 62 ? $(w) : w === 45 ? p(w) : h(w)
  }
  function v(w) {
    const q = 'CDATA['
    return w === q.charCodeAt(s++) ? (e.consume(w), s === q.length ? b : v) : r(w)
  }
  function b(w) {
    return w === null
      ? r(w)
      : w === 93
      ? (e.consume(w), S)
      : ye(w)
      ? ((a = b), L(w))
      : (e.consume(w), b)
  }
  function S(w) {
    return w === 93 ? (e.consume(w), g) : b(w)
  }
  function g(w) {
    return w === 62 ? $(w) : w === 93 ? (e.consume(w), g) : b(w)
  }
  function _(w) {
    return w === null || w === 62 ? $(w) : ye(w) ? ((a = _), L(w)) : (e.consume(w), _)
  }
  function y(w) {
    return w === null
      ? r(w)
      : w === 63
      ? (e.consume(w), x)
      : ye(w)
      ? ((a = y), L(w))
      : (e.consume(w), y)
  }
  function x(w) {
    return w === 62 ? $(w) : y(w)
  }
  function D(w) {
    return bt(w) ? (e.consume(w), C) : r(w)
  }
  function C(w) {
    return w === 45 || ht(w) ? (e.consume(w), C) : H(w)
  }
  function H(w) {
    return ye(w) ? ((a = H), L(w)) : Ae(w) ? (e.consume(w), H) : $(w)
  }
  function T(w) {
    return w === 45 || ht(w) ? (e.consume(w), T) : w === 47 || w === 62 || Pe(w) ? k(w) : r(w)
  }
  function k(w) {
    return w === 47
      ? (e.consume(w), $)
      : w === 58 || w === 95 || bt(w)
      ? (e.consume(w), O)
      : ye(w)
      ? ((a = k), L(w))
      : Ae(w)
      ? (e.consume(w), k)
      : $(w)
  }
  function O(w) {
    return w === 45 || w === 46 || w === 58 || w === 95 || ht(w) ? (e.consume(w), O) : N(w)
  }
  function N(w) {
    return w === 61 ? (e.consume(w), M) : ye(w) ? ((a = N), L(w)) : Ae(w) ? (e.consume(w), N) : k(w)
  }
  function M(w) {
    return w === null || w === 60 || w === 61 || w === 62 || w === 96
      ? r(w)
      : w === 34 || w === 39
      ? (e.consume(w), (n = w), V)
      : ye(w)
      ? ((a = M), L(w))
      : Ae(w)
      ? (e.consume(w), M)
      : (e.consume(w), j)
  }
  function V(w) {
    return w === n
      ? (e.consume(w), (n = void 0), R)
      : w === null
      ? r(w)
      : ye(w)
      ? ((a = V), L(w))
      : (e.consume(w), V)
  }
  function j(w) {
    return w === null || w === 34 || w === 39 || w === 60 || w === 61 || w === 96
      ? r(w)
      : w === 47 || w === 62 || Pe(w)
      ? k(w)
      : (e.consume(w), j)
  }
  function R(w) {
    return w === 47 || w === 62 || Pe(w) ? k(w) : r(w)
  }
  function $(w) {
    return w === 62 ? (e.consume(w), e.exit('htmlTextData'), e.exit('htmlText'), t) : r(w)
  }
  function L(w) {
    return e.exit('htmlTextData'), e.enter('lineEnding'), e.consume(w), e.exit('lineEnding'), P
  }
  function P(w) {
    return Ae(w)
      ? we(
          e,
          Y,
          'linePrefix',
          i.parser.constructs.disable.null.includes('codeIndented') ? void 0 : 4
        )(w)
      : Y(w)
  }
  function Y(w) {
    return e.enter('htmlTextData'), a(w)
  }
}
const rp = { name: 'labelEnd', tokenize: Px, resolveTo: Lx, resolveAll: Rx },
  Ox = { tokenize: Bx },
  Ix = { tokenize: Fx },
  Dx = { tokenize: Mx }
function Rx(e) {
  let t = -1
  for (; ++t < e.length; ) {
    const r = e[t][1]
    ;(r.type === 'labelImage' || r.type === 'labelLink' || r.type === 'labelEnd') &&
      (e.splice(t + 1, r.type === 'labelImage' ? 4 : 2), (r.type = 'data'), t++)
  }
  return e
}
function Lx(e, t) {
  let r = e.length,
    i = 0,
    n,
    s,
    a,
    o
  for (; r--; )
    if (((n = e[r][1]), s)) {
      if (n.type === 'link' || (n.type === 'labelLink' && n._inactive)) break
      e[r][0] === 'enter' && n.type === 'labelLink' && (n._inactive = !0)
    } else if (a) {
      if (
        e[r][0] === 'enter' &&
        (n.type === 'labelImage' || n.type === 'labelLink') &&
        !n._balanced &&
        ((s = r), n.type !== 'labelLink')
      ) {
        i = 2
        break
      }
    } else n.type === 'labelEnd' && (a = r)
  const u = {
      type: e[s][1].type === 'labelLink' ? 'link' : 'image',
      start: Object.assign({}, e[s][1].start),
      end: Object.assign({}, e[e.length - 1][1].end),
    },
    c = {
      type: 'label',
      start: Object.assign({}, e[s][1].start),
      end: Object.assign({}, e[a][1].end),
    },
    f = {
      type: 'labelText',
      start: Object.assign({}, e[s + i + 2][1].end),
      end: Object.assign({}, e[a - 2][1].start),
    }
  return (
    (o = [
      ['enter', u, t],
      ['enter', c, t],
    ]),
    (o = Gt(o, e.slice(s + 1, s + i + 3))),
    (o = Gt(o, [['enter', f, t]])),
    (o = Gt(o, au(t.parser.constructs.insideSpan.null, e.slice(s + i + 4, a - 3), t))),
    (o = Gt(o, [['exit', f, t], e[a - 2], e[a - 1], ['exit', c, t]])),
    (o = Gt(o, e.slice(a + 1))),
    (o = Gt(o, [['exit', u, t]])),
    Bt(e, s, e.length, o),
    e
  )
}
function Px(e, t, r) {
  const i = this
  let n = i.events.length,
    s,
    a
  for (; n--; )
    if (
      (i.events[n][1].type === 'labelImage' || i.events[n][1].type === 'labelLink') &&
      !i.events[n][1]._balanced
    ) {
      s = i.events[n][1]
      break
    }
  return o
  function o(p) {
    return s
      ? s._inactive
        ? h(p)
        : ((a = i.parser.defined.includes(sr(i.sliceSerialize({ start: s.end, end: i.now() })))),
          e.enter('labelEnd'),
          e.enter('labelMarker'),
          e.consume(p),
          e.exit('labelMarker'),
          e.exit('labelEnd'),
          u)
      : r(p)
  }
  function u(p) {
    return p === 40
      ? e.attempt(Ox, f, a ? f : h)(p)
      : p === 91
      ? e.attempt(Ix, f, a ? c : h)(p)
      : a
      ? f(p)
      : h(p)
  }
  function c(p) {
    return e.attempt(Dx, f, h)(p)
  }
  function f(p) {
    return t(p)
  }
  function h(p) {
    return (s._balanced = !0), r(p)
  }
}
function Bx(e, t, r) {
  return i
  function i(h) {
    return e.enter('resource'), e.enter('resourceMarker'), e.consume(h), e.exit('resourceMarker'), n
  }
  function n(h) {
    return Pe(h) ? bs(e, s)(h) : s(h)
  }
  function s(h) {
    return h === 41
      ? f(h)
      : Qg(
          e,
          a,
          o,
          'resourceDestination',
          'resourceDestinationLiteral',
          'resourceDestinationLiteralMarker',
          'resourceDestinationRaw',
          'resourceDestinationString',
          32
        )(h)
  }
  function a(h) {
    return Pe(h) ? bs(e, u)(h) : f(h)
  }
  function o(h) {
    return r(h)
  }
  function u(h) {
    return h === 34 || h === 39 || h === 40
      ? Jg(e, c, r, 'resourceTitle', 'resourceTitleMarker', 'resourceTitleString')(h)
      : f(h)
  }
  function c(h) {
    return Pe(h) ? bs(e, f)(h) : f(h)
  }
  function f(h) {
    return h === 41
      ? (e.enter('resourceMarker'), e.consume(h), e.exit('resourceMarker'), e.exit('resource'), t)
      : r(h)
  }
}
function Fx(e, t, r) {
  const i = this
  return n
  function n(o) {
    return Kg.call(i, e, s, a, 'reference', 'referenceMarker', 'referenceString')(o)
  }
  function s(o) {
    return i.parser.defined.includes(
      sr(i.sliceSerialize(i.events[i.events.length - 1][1]).slice(1, -1))
    )
      ? t(o)
      : r(o)
  }
  function a(o) {
    return r(o)
  }
}
function Mx(e, t, r) {
  return i
  function i(s) {
    return (
      e.enter('reference'), e.enter('referenceMarker'), e.consume(s), e.exit('referenceMarker'), n
    )
  }
  function n(s) {
    return s === 93
      ? (e.enter('referenceMarker'),
        e.consume(s),
        e.exit('referenceMarker'),
        e.exit('reference'),
        t)
      : r(s)
  }
}
const Ux = { name: 'labelStartImage', tokenize: Hx, resolveAll: rp.resolveAll }
function Hx(e, t, r) {
  const i = this
  return n
  function n(o) {
    return (
      e.enter('labelImage'),
      e.enter('labelImageMarker'),
      e.consume(o),
      e.exit('labelImageMarker'),
      s
    )
  }
  function s(o) {
    return o === 91
      ? (e.enter('labelMarker'), e.consume(o), e.exit('labelMarker'), e.exit('labelImage'), a)
      : r(o)
  }
  function a(o) {
    return o === 94 && '_hiddenFootnoteSupport' in i.parser.constructs ? r(o) : t(o)
  }
}
const zx = { name: 'labelStartLink', tokenize: jx, resolveAll: rp.resolveAll }
function jx(e, t, r) {
  const i = this
  return n
  function n(a) {
    return (
      e.enter('labelLink'),
      e.enter('labelMarker'),
      e.consume(a),
      e.exit('labelMarker'),
      e.exit('labelLink'),
      s
    )
  }
  function s(a) {
    return a === 94 && '_hiddenFootnoteSupport' in i.parser.constructs ? r(a) : t(a)
  }
}
const cl = { name: 'lineEnding', tokenize: qx }
function qx(e, t) {
  return r
  function r(i) {
    return e.enter('lineEnding'), e.consume(i), e.exit('lineEnding'), we(e, t, 'linePrefix')
  }
}
const ro = { name: 'thematicBreak', tokenize: $x }
function $x(e, t, r) {
  let i = 0,
    n
  return s
  function s(c) {
    return e.enter('thematicBreak'), a(c)
  }
  function a(c) {
    return (n = c), o(c)
  }
  function o(c) {
    return c === n
      ? (e.enter('thematicBreakSequence'), u(c))
      : i >= 3 && (c === null || ye(c))
      ? (e.exit('thematicBreak'), t(c))
      : r(c)
  }
  function u(c) {
    return c === n
      ? (e.consume(c), i++, u)
      : (e.exit('thematicBreakSequence'), Ae(c) ? we(e, o, 'whitespace')(c) : o(c))
  }
}
const Tt = { name: 'list', tokenize: Xx, continuation: { tokenize: Yx }, exit: Qx },
  Vx = { tokenize: Kx, partial: !0 },
  Gx = { tokenize: Wx, partial: !0 }
function Xx(e, t, r) {
  const i = this,
    n = i.events[i.events.length - 1]
  let s = n && n[1].type === 'linePrefix' ? n[2].sliceSerialize(n[1], !0).length : 0,
    a = 0
  return o
  function o(m) {
    const v =
      i.containerState.type || (m === 42 || m === 43 || m === 45 ? 'listUnordered' : 'listOrdered')
    if (v === 'listUnordered' ? !i.containerState.marker || m === i.containerState.marker : kc(m)) {
      if (
        (i.containerState.type || ((i.containerState.type = v), e.enter(v, { _container: !0 })),
        v === 'listUnordered')
      )
        return e.enter('listItemPrefix'), m === 42 || m === 45 ? e.check(ro, r, c)(m) : c(m)
      if (!i.interrupt || m === 49) return e.enter('listItemPrefix'), e.enter('listItemValue'), u(m)
    }
    return r(m)
  }
  function u(m) {
    return kc(m) && ++a < 10
      ? (e.consume(m), u)
      : (!i.interrupt || a < 2) &&
        (i.containerState.marker ? m === i.containerState.marker : m === 41 || m === 46)
      ? (e.exit('listItemValue'), c(m))
      : r(m)
  }
  function c(m) {
    return (
      e.enter('listItemMarker'),
      e.consume(m),
      e.exit('listItemMarker'),
      (i.containerState.marker = i.containerState.marker || m),
      e.check(sa, i.interrupt ? r : f, e.attempt(Vx, p, h))
    )
  }
  function f(m) {
    return (i.containerState.initialBlankLine = !0), s++, p(m)
  }
  function h(m) {
    return Ae(m)
      ? (e.enter('listItemPrefixWhitespace'), e.consume(m), e.exit('listItemPrefixWhitespace'), p)
      : r(m)
  }
  function p(m) {
    return (i.containerState.size = s + i.sliceSerialize(e.exit('listItemPrefix'), !0).length), t(m)
  }
}
function Yx(e, t, r) {
  const i = this
  return (i.containerState._closeFlow = void 0), e.check(sa, n, s)
  function n(o) {
    return (
      (i.containerState.furtherBlankLines =
        i.containerState.furtherBlankLines || i.containerState.initialBlankLine),
      we(e, t, 'listItemIndent', i.containerState.size + 1)(o)
    )
  }
  function s(o) {
    return i.containerState.furtherBlankLines || !Ae(o)
      ? ((i.containerState.furtherBlankLines = void 0),
        (i.containerState.initialBlankLine = void 0),
        a(o))
      : ((i.containerState.furtherBlankLines = void 0),
        (i.containerState.initialBlankLine = void 0),
        e.attempt(Gx, t, a)(o))
  }
  function a(o) {
    return (
      (i.containerState._closeFlow = !0),
      (i.interrupt = void 0),
      we(
        e,
        e.attempt(Tt, t, r),
        'linePrefix',
        i.parser.constructs.disable.null.includes('codeIndented') ? void 0 : 4
      )(o)
    )
  }
}
function Wx(e, t, r) {
  const i = this
  return we(e, n, 'listItemIndent', i.containerState.size + 1)
  function n(s) {
    const a = i.events[i.events.length - 1]
    return a &&
      a[1].type === 'listItemIndent' &&
      a[2].sliceSerialize(a[1], !0).length === i.containerState.size
      ? t(s)
      : r(s)
  }
}
function Qx(e) {
  e.exit(this.containerState.type)
}
function Kx(e, t, r) {
  const i = this
  return we(
    e,
    n,
    'listItemPrefixWhitespace',
    i.parser.constructs.disable.null.includes('codeIndented') ? void 0 : 4 + 1
  )
  function n(s) {
    const a = i.events[i.events.length - 1]
    return !Ae(s) && a && a[1].type === 'listItemPrefixWhitespace' ? t(s) : r(s)
  }
}
const fm = { name: 'setextUnderline', tokenize: Zx, resolveTo: Jx }
function Jx(e, t) {
  let r = e.length,
    i,
    n,
    s
  for (; r--; )
    if (e[r][0] === 'enter') {
      if (e[r][1].type === 'content') {
        i = r
        break
      }
      e[r][1].type === 'paragraph' && (n = r)
    } else
      e[r][1].type === 'content' && e.splice(r, 1), !s && e[r][1].type === 'definition' && (s = r)
  const a = {
    type: 'setextHeading',
    start: Object.assign({}, e[n][1].start),
    end: Object.assign({}, e[e.length - 1][1].end),
  }
  return (
    (e[n][1].type = 'setextHeadingText'),
    s
      ? (e.splice(n, 0, ['enter', a, t]),
        e.splice(s + 1, 0, ['exit', e[i][1], t]),
        (e[i][1].end = Object.assign({}, e[s][1].end)))
      : (e[i][1] = a),
    e.push(['exit', a, t]),
    e
  )
}
function Zx(e, t, r) {
  const i = this
  let n
  return s
  function s(c) {
    let f = i.events.length,
      h
    for (; f--; )
      if (
        i.events[f][1].type !== 'lineEnding' &&
        i.events[f][1].type !== 'linePrefix' &&
        i.events[f][1].type !== 'content'
      ) {
        h = i.events[f][1].type === 'paragraph'
        break
      }
    return !i.parser.lazy[i.now().line] && (i.interrupt || h)
      ? (e.enter('setextHeadingLine'), (n = c), a(c))
      : r(c)
  }
  function a(c) {
    return e.enter('setextHeadingLineSequence'), o(c)
  }
  function o(c) {
    return c === n
      ? (e.consume(c), o)
      : (e.exit('setextHeadingLineSequence'), Ae(c) ? we(e, u, 'lineSuffix')(c) : u(c))
  }
  function u(c) {
    return c === null || ye(c) ? (e.exit('setextHeadingLine'), t(c)) : r(c)
  }
}
const eT = { tokenize: tT }
function tT(e) {
  const t = this,
    r = e.attempt(
      sa,
      i,
      e.attempt(
        this.parser.constructs.flowInitial,
        n,
        we(e, e.attempt(this.parser.constructs.flow, n, e.attempt(ax, n)), 'linePrefix')
      )
    )
  return r
  function i(s) {
    if (s === null) {
      e.consume(s)
      return
    }
    return (
      e.enter('lineEndingBlank'),
      e.consume(s),
      e.exit('lineEndingBlank'),
      (t.currentConstruct = void 0),
      r
    )
  }
  function n(s) {
    if (s === null) {
      e.consume(s)
      return
    }
    return (
      e.enter('lineEnding'), e.consume(s), e.exit('lineEnding'), (t.currentConstruct = void 0), r
    )
  }
}
const rT = { resolveAll: e1() },
  iT = Zg('string'),
  nT = Zg('text')
function Zg(e) {
  return { tokenize: t, resolveAll: e1(e === 'text' ? sT : void 0) }
  function t(r) {
    const i = this,
      n = this.parser.constructs[e],
      s = r.attempt(n, a, o)
    return a
    function a(f) {
      return c(f) ? s(f) : o(f)
    }
    function o(f) {
      if (f === null) {
        r.consume(f)
        return
      }
      return r.enter('data'), r.consume(f), u
    }
    function u(f) {
      return c(f) ? (r.exit('data'), s(f)) : (r.consume(f), u)
    }
    function c(f) {
      if (f === null) return !0
      const h = n[f]
      let p = -1
      if (h)
        for (; ++p < h.length; ) {
          const m = h[p]
          if (!m.previous || m.previous.call(i, i.previous)) return !0
        }
      return !1
    }
  }
}
function e1(e) {
  return t
  function t(r, i) {
    let n = -1,
      s
    for (; ++n <= r.length; )
      s === void 0
        ? r[n] && r[n][1].type === 'data' && ((s = n), n++)
        : (!r[n] || r[n][1].type !== 'data') &&
          (n !== s + 2 &&
            ((r[s][1].end = r[n - 1][1].end), r.splice(s + 2, n - s - 2), (n = s + 2)),
          (s = void 0))
    return e ? e(r, i) : r
  }
}
function sT(e, t) {
  let r = 0
  for (; ++r <= e.length; )
    if ((r === e.length || e[r][1].type === 'lineEnding') && e[r - 1][1].type === 'data') {
      const i = e[r - 1][1],
        n = t.sliceStream(i)
      let s = n.length,
        a = -1,
        o = 0,
        u
      for (; s--; ) {
        const c = n[s]
        if (typeof c == 'string') {
          for (a = c.length; c.charCodeAt(a - 1) === 32; ) o++, a--
          if (a) break
          a = -1
        } else if (c === -2) (u = !0), o++
        else if (c !== -1) {
          s++
          break
        }
      }
      if (o) {
        const c = {
          type: r === e.length || u || o < 2 ? 'lineSuffix' : 'hardBreakTrailing',
          start: {
            line: i.end.line,
            column: i.end.column - o,
            offset: i.end.offset - o,
            _index: i.start._index + s,
            _bufferIndex: s ? a : i.start._bufferIndex + a,
          },
          end: Object.assign({}, i.end),
        }
        ;(i.end = Object.assign({}, c.start)),
          i.start.offset === i.end.offset
            ? Object.assign(i, c)
            : (e.splice(r, 0, ['enter', c, t], ['exit', c, t]), (r += 2))
      }
      r++
    }
  return e
}
function aT(e, t, r) {
  let i = Object.assign(r ? Object.assign({}, r) : { line: 1, column: 1, offset: 0 }, {
    _index: 0,
    _bufferIndex: -1,
  })
  const n = {},
    s = []
  let a = [],
    o = []
  const u = {
      consume: _,
      enter: y,
      exit: x,
      attempt: H(D),
      check: H(C),
      interrupt: H(C, { interrupt: !0 }),
    },
    c = {
      previous: null,
      code: null,
      containerState: {},
      events: [],
      parser: e,
      sliceStream: m,
      sliceSerialize: p,
      now: v,
      defineSkip: b,
      write: h,
    }
  let f = t.tokenize.call(c, u)
  return t.resolveAll && s.push(t), c
  function h(N) {
    return (
      (a = Gt(a, N)),
      S(),
      a[a.length - 1] !== null ? [] : (T(t, 0), (c.events = au(s, c.events, c)), c.events)
    )
  }
  function p(N, M) {
    return uT(m(N), M)
  }
  function m(N) {
    return oT(a, N)
  }
  function v() {
    const { line: N, column: M, offset: V, _index: j, _bufferIndex: R } = i
    return { line: N, column: M, offset: V, _index: j, _bufferIndex: R }
  }
  function b(N) {
    ;(n[N.line] = N.column), O()
  }
  function S() {
    let N
    for (; i._index < a.length; ) {
      const M = a[i._index]
      if (typeof M == 'string')
        for (
          N = i._index, i._bufferIndex < 0 && (i._bufferIndex = 0);
          i._index === N && i._bufferIndex < M.length;

        )
          g(M.charCodeAt(i._bufferIndex))
      else g(M)
    }
  }
  function g(N) {
    f = f(N)
  }
  function _(N) {
    ye(N)
      ? (i.line++, (i.column = 1), (i.offset += N === -3 ? 2 : 1), O())
      : N !== -1 && (i.column++, i.offset++),
      i._bufferIndex < 0
        ? i._index++
        : (i._bufferIndex++,
          i._bufferIndex === a[i._index].length && ((i._bufferIndex = -1), i._index++)),
      (c.previous = N)
  }
  function y(N, M) {
    const V = M || {}
    return (V.type = N), (V.start = v()), c.events.push(['enter', V, c]), o.push(V), V
  }
  function x(N) {
    const M = o.pop()
    return (M.end = v()), c.events.push(['exit', M, c]), M
  }
  function D(N, M) {
    T(N, M.from)
  }
  function C(N, M) {
    M.restore()
  }
  function H(N, M) {
    return V
    function V(j, R, $) {
      let L, P, Y, w
      return Array.isArray(j) ? X(j) : 'tokenize' in j ? X([j]) : q(j)
      function q(Z) {
        return oe
        function oe(ce) {
          const fe = ce !== null && Z[ce],
            ge = ce !== null && Z.null,
            me = [
              ...(Array.isArray(fe) ? fe : fe ? [fe] : []),
              ...(Array.isArray(ge) ? ge : ge ? [ge] : []),
            ]
          return X(me)(ce)
        }
      }
      function X(Z) {
        return (L = Z), (P = 0), Z.length === 0 ? $ : I(Z[P])
      }
      function I(Z) {
        return oe
        function oe(ce) {
          return (
            (w = k()),
            (Y = Z),
            Z.partial || (c.currentConstruct = Z),
            Z.name && c.parser.constructs.disable.null.includes(Z.name)
              ? ie()
              : Z.tokenize.call(M ? Object.assign(Object.create(c), M) : c, u, re, ie)(ce)
          )
        }
      }
      function re(Z) {
        return N(Y, w), R
      }
      function ie(Z) {
        return w.restore(), ++P < L.length ? I(L[P]) : $
      }
    }
  }
  function T(N, M) {
    N.resolveAll && !s.includes(N) && s.push(N),
      N.resolve && Bt(c.events, M, c.events.length - M, N.resolve(c.events.slice(M), c)),
      N.resolveTo && (c.events = N.resolveTo(c.events, c))
  }
  function k() {
    const N = v(),
      M = c.previous,
      V = c.currentConstruct,
      j = c.events.length,
      R = Array.from(o)
    return { restore: $, from: j }
    function $() {
      ;(i = N), (c.previous = M), (c.currentConstruct = V), (c.events.length = j), (o = R), O()
    }
  }
  function O() {
    i.line in n && i.column < 2 && ((i.column = n[i.line]), (i.offset += n[i.line] - 1))
  }
}
function oT(e, t) {
  const r = t.start._index,
    i = t.start._bufferIndex,
    n = t.end._index,
    s = t.end._bufferIndex
  let a
  if (r === n) a = [e[r].slice(i, s)]
  else {
    if (((a = e.slice(r, n)), i > -1)) {
      const o = a[0]
      typeof o == 'string' ? (a[0] = o.slice(i)) : a.shift()
    }
    s > 0 && a.push(e[n].slice(0, s))
  }
  return a
}
function uT(e, t) {
  let r = -1
  const i = []
  let n
  for (; ++r < e.length; ) {
    const s = e[r]
    let a
    if (typeof s == 'string') a = s
    else
      switch (s) {
        case -5: {
          a = '\r'
          break
        }
        case -4: {
          a = `
`
          break
        }
        case -3: {
          a = `\r
`
          break
        }
        case -2: {
          a = t ? ' ' : '	'
          break
        }
        case -1: {
          if (!t && n) continue
          a = ' '
          break
        }
        default:
          a = String.fromCharCode(s)
      }
    ;(n = s === -2), i.push(a)
  }
  return i.join('')
}
const lT = {
    42: Tt,
    43: Tt,
    45: Tt,
    48: Tt,
    49: Tt,
    50: Tt,
    51: Tt,
    52: Tt,
    53: Tt,
    54: Tt,
    55: Tt,
    56: Tt,
    57: Tt,
    62: Gg,
  },
  cT = { 91: fx },
  fT = { [-2]: ll, [-1]: ll, 32: ll },
  pT = { 35: bx, 42: ro, 45: [fm, ro], 60: Ex, 61: fm, 95: ro, 96: lm, 126: lm },
  hT = { 38: Yg, 92: Xg },
  mT = {
    [-5]: cl,
    [-4]: cl,
    [-3]: cl,
    33: Ux,
    38: Yg,
    42: wc,
    60: [jE, wx],
    91: zx,
    92: [dx, Xg],
    93: rp,
    95: wc,
    96: tx,
  },
  dT = { null: [wc, rT] },
  gT = { null: [42, 95] },
  bT = { null: [] },
  yT = Object.freeze(
    Object.defineProperty(
      {
        __proto__: null,
        attentionMarkers: gT,
        contentInitial: cT,
        disable: bT,
        document: lT,
        flow: pT,
        flowInitial: fT,
        insideSpan: dT,
        string: hT,
        text: mT,
      },
      Symbol.toStringTag,
      { value: 'Module' }
    )
  )
function _T(e) {
  const r = qg([yT, ...((e || {}).extensions || [])]),
    i = {
      defined: [],
      lazy: {},
      constructs: r,
      content: n(PE),
      document: n(FE),
      flow: n(eT),
      string: n(iT),
      text: n(nT),
    }
  return i
  function n(s) {
    return a
    function a(o) {
      return aT(i, s, o)
    }
  }
}
function vT(e) {
  for (; !Wg(e); );
  return e
}
const pm = /[\0\t\n\r]/g
function ET() {
  let e = 1,
    t = '',
    r = !0,
    i
  return n
  function n(s, a, o) {
    const u = []
    let c, f, h, p, m
    for (
      s = t + (typeof s == 'string' ? s.toString() : new TextDecoder(a || void 0).decode(s)),
        h = 0,
        t = '',
        r && (s.charCodeAt(0) === 65279 && h++, (r = void 0));
      h < s.length;

    ) {
      if (
        ((pm.lastIndex = h),
        (c = pm.exec(s)),
        (p = c && c.index !== void 0 ? c.index : s.length),
        (m = s.charCodeAt(p)),
        !c)
      ) {
        t = s.slice(h)
        break
      }
      if (m === 10 && h === p && i) u.push(-3), (i = void 0)
      else
        switch (
          (i && (u.push(-5), (i = void 0)), h < p && (u.push(s.slice(h, p)), (e += p - h)), m)
        ) {
          case 0: {
            u.push(65533), e++
            break
          }
          case 9: {
            for (f = Math.ceil(e / 4) * 4, u.push(-2); e++ < f; ) u.push(-1)
            break
          }
          case 10: {
            u.push(-4), (e = 1)
            break
          }
          default:
            ;(i = !0), (e = 1)
        }
      h = p + 1
    }
    return o && (i && u.push(-5), t && u.push(t), u.push(null)), u
  }
}
const xT = /\\([!-/:-@[-`{-~])|&(#(?:\d{1,7}|x[\da-f]{1,6})|[\da-z]{1,31});/gi
function TT(e) {
  return e.replace(xT, AT)
}
function AT(e, t, r) {
  if (t) return t
  if (r.charCodeAt(0) === 35) {
    const n = r.charCodeAt(1),
      s = n === 120 || n === 88
    return $g(r.slice(s ? 2 : 1), s ? 16 : 10)
  }
  return tp(r) || e
}
const t1 = {}.hasOwnProperty
function ST(e, t, r) {
  return (
    typeof t != 'string' && ((r = t), (t = void 0)),
    CT(r)(vT(_T(r).document().write(ET()(e, t, !0))))
  )
}
function CT(e) {
  const t = {
    transforms: [],
    canContainEols: ['emphasis', 'fragment', 'heading', 'paragraph', 'strong'],
    enter: {
      autolink: s(A),
      autolinkProtocol: k,
      autolinkEmail: k,
      atxHeading: s(Oe),
      blockQuote: s(fe),
      characterEscape: k,
      characterReference: k,
      codeFenced: s(ge),
      codeFencedFenceInfo: a,
      codeFencedFenceMeta: a,
      codeIndented: s(ge, a),
      codeText: s(me, a),
      codeTextData: k,
      data: k,
      codeFlowValue: k,
      definition: s(be),
      definitionDestinationString: a,
      definitionLabelString: a,
      definitionTitleString: a,
      emphasis: s(Ne),
      hardBreakEscape: s(_e),
      hardBreakTrailing: s(_e),
      htmlFlow: s(F, a),
      htmlFlowData: k,
      htmlText: s(F, a),
      htmlTextData: k,
      image: s(E),
      label: a,
      link: s(A),
      listItem: s(W),
      listItemValue: p,
      listOrdered: s(z, h),
      listUnordered: s(z),
      paragraph: s(te),
      reference: I,
      referenceString: a,
      resourceDestinationString: a,
      resourceTitleString: a,
      setextHeading: s(Oe),
      strong: s(ne),
      thematicBreak: s(De),
    },
    exit: {
      atxHeading: u(),
      atxHeadingSequence: D,
      autolink: u(),
      autolinkEmail: ce,
      autolinkProtocol: oe,
      blockQuote: u(),
      characterEscapeValue: O,
      characterReferenceMarkerHexadecimal: ie,
      characterReferenceMarkerNumeric: ie,
      characterReferenceValue: Z,
      codeFenced: u(S),
      codeFencedFence: b,
      codeFencedFenceInfo: m,
      codeFencedFenceMeta: v,
      codeFlowValue: O,
      codeIndented: u(g),
      codeText: u(R),
      codeTextData: O,
      data: O,
      definition: u(),
      definitionDestinationString: x,
      definitionLabelString: _,
      definitionTitleString: y,
      emphasis: u(),
      hardBreakEscape: u(M),
      hardBreakTrailing: u(M),
      htmlFlow: u(V),
      htmlFlowData: O,
      htmlText: u(j),
      htmlTextData: O,
      image: u(L),
      label: Y,
      labelText: P,
      lineEnding: N,
      link: u($),
      listItem: u(),
      listOrdered: u(),
      listUnordered: u(),
      paragraph: u(),
      referenceString: re,
      resourceDestinationString: w,
      resourceTitleString: q,
      resource: X,
      setextHeading: u(T),
      setextHeadingLineSequence: H,
      setextHeadingText: C,
      strong: u(),
      thematicBreak: u(),
    },
  }
  r1(t, (e || {}).mdastExtensions || [])
  const r = {}
  return i
  function i(K) {
    let se = { type: 'root', children: [] }
    const pe = {
        stack: [se],
        tokenStack: [],
        config: t,
        enter: o,
        exit: c,
        buffer: a,
        resume: f,
        data: r,
      },
      ve = []
    let Ce = -1
    for (; ++Ce < K.length; )
      if (K[Ce][1].type === 'listOrdered' || K[Ce][1].type === 'listUnordered')
        if (K[Ce][0] === 'enter') ve.push(Ce)
        else {
          const ze = ve.pop()
          Ce = n(K, ze, Ce)
        }
    for (Ce = -1; ++Ce < K.length; ) {
      const ze = t[K[Ce][0]]
      t1.call(ze, K[Ce][1].type) &&
        ze[K[Ce][1].type].call(
          Object.assign({ sliceSerialize: K[Ce][2].sliceSerialize }, pe),
          K[Ce][1]
        )
    }
    if (pe.tokenStack.length > 0) {
      const ze = pe.tokenStack[pe.tokenStack.length - 1]
      ;(ze[1] || hm).call(pe, void 0, ze[0])
    }
    for (
      se.position = {
        start: Hr(K.length > 0 ? K[0][1].start : { line: 1, column: 1, offset: 0 }),
        end: Hr(K.length > 0 ? K[K.length - 2][1].end : { line: 1, column: 1, offset: 0 }),
      },
        Ce = -1;
      ++Ce < t.transforms.length;

    )
      se = t.transforms[Ce](se) || se
    return se
  }
  function n(K, se, pe) {
    let ve = se - 1,
      Ce = -1,
      ze = !1,
      Et,
      Me,
      ur,
      Er
    for (; ++ve <= pe; ) {
      const lt = K[ve]
      switch (lt[1].type) {
        case 'listUnordered':
        case 'listOrdered':
        case 'blockQuote': {
          lt[0] === 'enter' ? Ce++ : Ce--, (Er = void 0)
          break
        }
        case 'lineEndingBlank': {
          lt[0] === 'enter' && (Et && !Er && !Ce && !ur && (ur = ve), (Er = void 0))
          break
        }
        case 'linePrefix':
        case 'listItemValue':
        case 'listItemMarker':
        case 'listItemPrefix':
        case 'listItemPrefixWhitespace':
          break
        default:
          Er = void 0
      }
      if (
        (!Ce && lt[0] === 'enter' && lt[1].type === 'listItemPrefix') ||
        (Ce === -1 &&
          lt[0] === 'exit' &&
          (lt[1].type === 'listUnordered' || lt[1].type === 'listOrdered'))
      ) {
        if (Et) {
          let xr = ve
          for (Me = void 0; xr--; ) {
            const zt = K[xr]
            if (zt[1].type === 'lineEnding' || zt[1].type === 'lineEndingBlank') {
              if (zt[0] === 'exit') continue
              Me && ((K[Me][1].type = 'lineEndingBlank'), (ze = !0)),
                (zt[1].type = 'lineEnding'),
                (Me = xr)
            } else if (
              !(
                zt[1].type === 'linePrefix' ||
                zt[1].type === 'blockQuotePrefix' ||
                zt[1].type === 'blockQuotePrefixWhitespace' ||
                zt[1].type === 'blockQuoteMarker' ||
                zt[1].type === 'listItemIndent'
              )
            )
              break
          }
          ur && (!Me || ur < Me) && (Et._spread = !0),
            (Et.end = Object.assign({}, Me ? K[Me][1].start : lt[1].end)),
            K.splice(Me || ve, 0, ['exit', Et, lt[2]]),
            ve++,
            pe++
        }
        if (lt[1].type === 'listItemPrefix') {
          const xr = {
            type: 'listItem',
            _spread: !1,
            start: Object.assign({}, lt[1].start),
            end: void 0,
          }
          ;(Et = xr), K.splice(ve, 0, ['enter', xr, lt[2]]), ve++, pe++, (ur = void 0), (Er = !0)
        }
      }
    }
    return (K[se][1]._spread = ze), pe
  }
  function s(K, se) {
    return pe
    function pe(ve) {
      o.call(this, K(ve), ve), se && se.call(this, ve)
    }
  }
  function a() {
    this.stack.push({ type: 'fragment', children: [] })
  }
  function o(K, se, pe) {
    this.stack[this.stack.length - 1].children.push(K),
      this.stack.push(K),
      this.tokenStack.push([se, pe]),
      (K.position = { start: Hr(se.start), end: void 0 })
  }
  function u(K) {
    return se
    function se(pe) {
      K && K.call(this, pe), c.call(this, pe)
    }
  }
  function c(K, se) {
    const pe = this.stack.pop(),
      ve = this.tokenStack.pop()
    if (ve)
      ve[0].type !== K.type && (se ? se.call(this, K, ve[0]) : (ve[1] || hm).call(this, K, ve[0]))
    else
      throw new Error(
        'Cannot close `' + K.type + '` (' + gs({ start: K.start, end: K.end }) + '): its not open'
      )
    pe.position.end = Hr(K.end)
  }
  function f() {
    return ep(this.stack.pop())
  }
  function h() {
    this.data.expectingFirstListItemValue = !0
  }
  function p(K) {
    if (this.data.expectingFirstListItemValue) {
      const se = this.stack[this.stack.length - 2]
      ;(se.start = Number.parseInt(this.sliceSerialize(K), 10)),
        (this.data.expectingFirstListItemValue = void 0)
    }
  }
  function m() {
    const K = this.resume(),
      se = this.stack[this.stack.length - 1]
    se.lang = K
  }
  function v() {
    const K = this.resume(),
      se = this.stack[this.stack.length - 1]
    se.meta = K
  }
  function b() {
    this.data.flowCodeInside || (this.buffer(), (this.data.flowCodeInside = !0))
  }
  function S() {
    const K = this.resume(),
      se = this.stack[this.stack.length - 1]
    ;(se.value = K.replace(/^(\r?\n|\r)|(\r?\n|\r)$/g, '')), (this.data.flowCodeInside = void 0)
  }
  function g() {
    const K = this.resume(),
      se = this.stack[this.stack.length - 1]
    se.value = K.replace(/(\r?\n|\r)$/g, '')
  }
  function _(K) {
    const se = this.resume(),
      pe = this.stack[this.stack.length - 1]
    ;(pe.label = se), (pe.identifier = sr(this.sliceSerialize(K)).toLowerCase())
  }
  function y() {
    const K = this.resume(),
      se = this.stack[this.stack.length - 1]
    se.title = K
  }
  function x() {
    const K = this.resume(),
      se = this.stack[this.stack.length - 1]
    se.url = K
  }
  function D(K) {
    const se = this.stack[this.stack.length - 1]
    if (!se.depth) {
      const pe = this.sliceSerialize(K).length
      se.depth = pe
    }
  }
  function C() {
    this.data.setextHeadingSlurpLineEnding = !0
  }
  function H(K) {
    const se = this.stack[this.stack.length - 1]
    se.depth = this.sliceSerialize(K).codePointAt(0) === 61 ? 1 : 2
  }
  function T() {
    this.data.setextHeadingSlurpLineEnding = void 0
  }
  function k(K) {
    const pe = this.stack[this.stack.length - 1].children
    let ve = pe[pe.length - 1]
    ;(!ve || ve.type !== 'text') &&
      ((ve = Te()), (ve.position = { start: Hr(K.start), end: void 0 }), pe.push(ve)),
      this.stack.push(ve)
  }
  function O(K) {
    const se = this.stack.pop()
    ;(se.value += this.sliceSerialize(K)), (se.position.end = Hr(K.end))
  }
  function N(K) {
    const se = this.stack[this.stack.length - 1]
    if (this.data.atHardBreak) {
      const pe = se.children[se.children.length - 1]
      ;(pe.position.end = Hr(K.end)), (this.data.atHardBreak = void 0)
      return
    }
    !this.data.setextHeadingSlurpLineEnding &&
      t.canContainEols.includes(se.type) &&
      (k.call(this, K), O.call(this, K))
  }
  function M() {
    this.data.atHardBreak = !0
  }
  function V() {
    const K = this.resume(),
      se = this.stack[this.stack.length - 1]
    se.value = K
  }
  function j() {
    const K = this.resume(),
      se = this.stack[this.stack.length - 1]
    se.value = K
  }
  function R() {
    const K = this.resume(),
      se = this.stack[this.stack.length - 1]
    se.value = K
  }
  function $() {
    const K = this.stack[this.stack.length - 1]
    if (this.data.inReference) {
      const se = this.data.referenceType || 'shortcut'
      ;(K.type += 'Reference'), (K.referenceType = se), delete K.url, delete K.title
    } else delete K.identifier, delete K.label
    this.data.referenceType = void 0
  }
  function L() {
    const K = this.stack[this.stack.length - 1]
    if (this.data.inReference) {
      const se = this.data.referenceType || 'shortcut'
      ;(K.type += 'Reference'), (K.referenceType = se), delete K.url, delete K.title
    } else delete K.identifier, delete K.label
    this.data.referenceType = void 0
  }
  function P(K) {
    const se = this.sliceSerialize(K),
      pe = this.stack[this.stack.length - 2]
    ;(pe.label = TT(se)), (pe.identifier = sr(se).toLowerCase())
  }
  function Y() {
    const K = this.stack[this.stack.length - 1],
      se = this.resume(),
      pe = this.stack[this.stack.length - 1]
    if (((this.data.inReference = !0), pe.type === 'link')) {
      const ve = K.children
      pe.children = ve
    } else pe.alt = se
  }
  function w() {
    const K = this.resume(),
      se = this.stack[this.stack.length - 1]
    se.url = K
  }
  function q() {
    const K = this.resume(),
      se = this.stack[this.stack.length - 1]
    se.title = K
  }
  function X() {
    this.data.inReference = void 0
  }
  function I() {
    this.data.referenceType = 'collapsed'
  }
  function re(K) {
    const se = this.resume(),
      pe = this.stack[this.stack.length - 1]
    ;(pe.label = se),
      (pe.identifier = sr(this.sliceSerialize(K)).toLowerCase()),
      (this.data.referenceType = 'full')
  }
  function ie(K) {
    this.data.characterReferenceType = K.type
  }
  function Z(K) {
    const se = this.sliceSerialize(K),
      pe = this.data.characterReferenceType
    let ve
    pe
      ? ((ve = $g(se, pe === 'characterReferenceMarkerNumeric' ? 10 : 16)),
        (this.data.characterReferenceType = void 0))
      : (ve = tp(se))
    const Ce = this.stack.pop()
    ;(Ce.value += ve), (Ce.position.end = Hr(K.end))
  }
  function oe(K) {
    O.call(this, K)
    const se = this.stack[this.stack.length - 1]
    se.url = this.sliceSerialize(K)
  }
  function ce(K) {
    O.call(this, K)
    const se = this.stack[this.stack.length - 1]
    se.url = 'mailto:' + this.sliceSerialize(K)
  }
  function fe() {
    return { type: 'blockquote', children: [] }
  }
  function ge() {
    return { type: 'code', lang: null, meta: null, value: '' }
  }
  function me() {
    return { type: 'inlineCode', value: '' }
  }
  function be() {
    return { type: 'definition', identifier: '', label: null, title: null, url: '' }
  }
  function Ne() {
    return { type: 'emphasis', children: [] }
  }
  function Oe() {
    return { type: 'heading', depth: 0, children: [] }
  }
  function _e() {
    return { type: 'break' }
  }
  function F() {
    return { type: 'html', value: '' }
  }
  function E() {
    return { type: 'image', title: null, url: '', alt: null }
  }
  function A() {
    return { type: 'link', title: null, url: '', children: [] }
  }
  function z(K) {
    return {
      type: 'list',
      ordered: K.type === 'listOrdered',
      start: null,
      spread: K._spread,
      children: [],
    }
  }
  function W(K) {
    return { type: 'listItem', spread: K._spread, checked: null, children: [] }
  }
  function te() {
    return { type: 'paragraph', children: [] }
  }
  function ne() {
    return { type: 'strong', children: [] }
  }
  function Te() {
    return { type: 'text', value: '' }
  }
  function De() {
    return { type: 'thematicBreak' }
  }
}
function Hr(e) {
  return { line: e.line, column: e.column, offset: e.offset }
}
function r1(e, t) {
  let r = -1
  for (; ++r < t.length; ) {
    const i = t[r]
    Array.isArray(i) ? r1(e, i) : kT(e, i)
  }
}
function kT(e, t) {
  let r
  for (r in t)
    if (t1.call(t, r))
      switch (r) {
        case 'canContainEols': {
          const i = t[r]
          i && e[r].push(...i)
          break
        }
        case 'transforms': {
          const i = t[r]
          i && e[r].push(...i)
          break
        }
        case 'enter':
        case 'exit': {
          const i = t[r]
          i && Object.assign(e[r], i)
          break
        }
      }
}
function hm(e, t) {
  throw e
    ? new Error(
        'Cannot close `' +
          e.type +
          '` (' +
          gs({ start: e.start, end: e.end }) +
          '): a different token (`' +
          t.type +
          '`, ' +
          gs({ start: t.start, end: t.end }) +
          ') is open'
      )
    : new Error(
        'Cannot close document, a token (`' +
          t.type +
          '`, ' +
          gs({ start: t.start, end: t.end }) +
          ') is still open'
      )
}
function wT(e) {
  const t = this
  t.parser = r
  function r(i) {
    return ST(i, {
      ...t.data('settings'),
      ...e,
      extensions: t.data('micromarkExtensions') || [],
      mdastExtensions: t.data('fromMarkdownExtensions') || [],
    })
  }
}
function NT(e, t) {
  const r = {
    type: 'element',
    tagName: 'blockquote',
    properties: {},
    children: e.wrap(e.all(t), !0),
  }
  return e.patch(t, r), e.applyData(t, r)
}
function OT(e, t) {
  const r = { type: 'element', tagName: 'br', properties: {}, children: [] }
  return (
    e.patch(t, r),
    [
      e.applyData(t, r),
      {
        type: 'text',
        value: `
`,
      },
    ]
  )
}
function IT(e, t) {
  const r = t.value
      ? t.value +
        `
`
      : '',
    i = {}
  t.lang && (i.className = ['language-' + t.lang])
  let n = {
    type: 'element',
    tagName: 'code',
    properties: i,
    children: [{ type: 'text', value: r }],
  }
  return (
    t.meta && (n.data = { meta: t.meta }),
    e.patch(t, n),
    (n = e.applyData(t, n)),
    (n = { type: 'element', tagName: 'pre', properties: {}, children: [n] }),
    e.patch(t, n),
    n
  )
}
function DT(e, t) {
  const r = { type: 'element', tagName: 'del', properties: {}, children: e.all(t) }
  return e.patch(t, r), e.applyData(t, r)
}
function RT(e, t) {
  const r = { type: 'element', tagName: 'em', properties: {}, children: e.all(t) }
  return e.patch(t, r), e.applyData(t, r)
}
function LT(e, t) {
  const r = typeof e.options.clobberPrefix == 'string' ? e.options.clobberPrefix : 'user-content-',
    i = String(t.identifier).toUpperCase(),
    n = Mn(i.toLowerCase()),
    s = e.footnoteOrder.indexOf(i)
  let a,
    o = e.footnoteCounts.get(i)
  o === void 0 ? ((o = 0), e.footnoteOrder.push(i), (a = e.footnoteOrder.length)) : (a = s + 1),
    (o += 1),
    e.footnoteCounts.set(i, o)
  const u = {
    type: 'element',
    tagName: 'a',
    properties: {
      href: '#' + r + 'fn-' + n,
      id: r + 'fnref-' + n + (o > 1 ? '-' + o : ''),
      dataFootnoteRef: !0,
      ariaDescribedBy: ['footnote-label'],
    },
    children: [{ type: 'text', value: String(a) }],
  }
  e.patch(t, u)
  const c = { type: 'element', tagName: 'sup', properties: {}, children: [u] }
  return e.patch(t, c), e.applyData(t, c)
}
function PT(e, t) {
  const r = { type: 'element', tagName: 'h' + t.depth, properties: {}, children: e.all(t) }
  return e.patch(t, r), e.applyData(t, r)
}
function BT(e, t) {
  if (e.options.allowDangerousHtml) {
    const r = { type: 'raw', value: t.value }
    return e.patch(t, r), e.applyData(t, r)
  }
}
function i1(e, t) {
  const r = t.referenceType
  let i = ']'
  if (
    (r === 'collapsed' ? (i += '[]') : r === 'full' && (i += '[' + (t.label || t.identifier) + ']'),
    t.type === 'imageReference')
  )
    return [{ type: 'text', value: '![' + t.alt + i }]
  const n = e.all(t),
    s = n[0]
  s && s.type === 'text' ? (s.value = '[' + s.value) : n.unshift({ type: 'text', value: '[' })
  const a = n[n.length - 1]
  return a && a.type === 'text' ? (a.value += i) : n.push({ type: 'text', value: i }), n
}
function FT(e, t) {
  const r = String(t.identifier).toUpperCase(),
    i = e.definitionById.get(r)
  if (!i) return i1(e, t)
  const n = { src: Mn(i.url || ''), alt: t.alt }
  i.title !== null && i.title !== void 0 && (n.title = i.title)
  const s = { type: 'element', tagName: 'img', properties: n, children: [] }
  return e.patch(t, s), e.applyData(t, s)
}
function MT(e, t) {
  const r = { src: Mn(t.url) }
  t.alt !== null && t.alt !== void 0 && (r.alt = t.alt),
    t.title !== null && t.title !== void 0 && (r.title = t.title)
  const i = { type: 'element', tagName: 'img', properties: r, children: [] }
  return e.patch(t, i), e.applyData(t, i)
}
function UT(e, t) {
  const r = { type: 'text', value: t.value.replace(/\r?\n|\r/g, ' ') }
  e.patch(t, r)
  const i = { type: 'element', tagName: 'code', properties: {}, children: [r] }
  return e.patch(t, i), e.applyData(t, i)
}
function HT(e, t) {
  const r = String(t.identifier).toUpperCase(),
    i = e.definitionById.get(r)
  if (!i) return i1(e, t)
  const n = { href: Mn(i.url || '') }
  i.title !== null && i.title !== void 0 && (n.title = i.title)
  const s = { type: 'element', tagName: 'a', properties: n, children: e.all(t) }
  return e.patch(t, s), e.applyData(t, s)
}
function zT(e, t) {
  const r = { href: Mn(t.url) }
  t.title !== null && t.title !== void 0 && (r.title = t.title)
  const i = { type: 'element', tagName: 'a', properties: r, children: e.all(t) }
  return e.patch(t, i), e.applyData(t, i)
}
function jT(e, t, r) {
  const i = e.all(t),
    n = r ? qT(r) : n1(t),
    s = {},
    a = []
  if (typeof t.checked == 'boolean') {
    const f = i[0]
    let h
    f && f.type === 'element' && f.tagName === 'p'
      ? (h = f)
      : ((h = { type: 'element', tagName: 'p', properties: {}, children: [] }), i.unshift(h)),
      h.children.length > 0 && h.children.unshift({ type: 'text', value: ' ' }),
      h.children.unshift({
        type: 'element',
        tagName: 'input',
        properties: { type: 'checkbox', checked: t.checked, disabled: !0 },
        children: [],
      }),
      (s.className = ['task-list-item'])
  }
  let o = -1
  for (; ++o < i.length; ) {
    const f = i[o]
    ;(n || o !== 0 || f.type !== 'element' || f.tagName !== 'p') &&
      a.push({
        type: 'text',
        value: `
`,
      }),
      f.type === 'element' && f.tagName === 'p' && !n ? a.push(...f.children) : a.push(f)
  }
  const u = i[i.length - 1]
  u &&
    (n || u.type !== 'element' || u.tagName !== 'p') &&
    a.push({
      type: 'text',
      value: `
`,
    })
  const c = { type: 'element', tagName: 'li', properties: s, children: a }
  return e.patch(t, c), e.applyData(t, c)
}
function qT(e) {
  let t = !1
  if (e.type === 'list') {
    t = e.spread || !1
    const r = e.children
    let i = -1
    for (; !t && ++i < r.length; ) t = n1(r[i])
  }
  return t
}
function n1(e) {
  const t = e.spread
  return t ?? e.children.length > 1
}
function $T(e, t) {
  const r = {},
    i = e.all(t)
  let n = -1
  for (typeof t.start == 'number' && t.start !== 1 && (r.start = t.start); ++n < i.length; ) {
    const a = i[n]
    if (
      a.type === 'element' &&
      a.tagName === 'li' &&
      a.properties &&
      Array.isArray(a.properties.className) &&
      a.properties.className.includes('task-list-item')
    ) {
      r.className = ['contains-task-list']
      break
    }
  }
  const s = {
    type: 'element',
    tagName: t.ordered ? 'ol' : 'ul',
    properties: r,
    children: e.wrap(i, !0),
  }
  return e.patch(t, s), e.applyData(t, s)
}
function VT(e, t) {
  const r = { type: 'element', tagName: 'p', properties: {}, children: e.all(t) }
  return e.patch(t, r), e.applyData(t, r)
}
function GT(e, t) {
  const r = { type: 'root', children: e.wrap(e.all(t)) }
  return e.patch(t, r), e.applyData(t, r)
}
function XT(e, t) {
  const r = { type: 'element', tagName: 'strong', properties: {}, children: e.all(t) }
  return e.patch(t, r), e.applyData(t, r)
}
const s1 = o1('end'),
  a1 = o1('start')
function o1(e) {
  return t
  function t(r) {
    const i = (r && r.position && r.position[e]) || {}
    if (typeof i.line == 'number' && i.line > 0 && typeof i.column == 'number' && i.column > 0)
      return {
        line: i.line,
        column: i.column,
        offset: typeof i.offset == 'number' && i.offset > -1 ? i.offset : void 0,
      }
  }
}
function YT(e) {
  const t = a1(e),
    r = s1(e)
  if (t && r) return { start: t, end: r }
}
function WT(e, t) {
  const r = e.all(t),
    i = r.shift(),
    n = []
  if (i) {
    const a = { type: 'element', tagName: 'thead', properties: {}, children: e.wrap([i], !0) }
    e.patch(t.children[0], a), n.push(a)
  }
  if (r.length > 0) {
    const a = { type: 'element', tagName: 'tbody', properties: {}, children: e.wrap(r, !0) },
      o = a1(t.children[1]),
      u = s1(t.children[t.children.length - 1])
    o && u && (a.position = { start: o, end: u }), n.push(a)
  }
  const s = { type: 'element', tagName: 'table', properties: {}, children: e.wrap(n, !0) }
  return e.patch(t, s), e.applyData(t, s)
}
function QT(e, t, r) {
  const i = r ? r.children : void 0,
    s = (i ? i.indexOf(t) : 1) === 0 ? 'th' : 'td',
    a = r && r.type === 'table' ? r.align : void 0,
    o = a ? a.length : t.children.length
  let u = -1
  const c = []
  for (; ++u < o; ) {
    const h = t.children[u],
      p = {},
      m = a ? a[u] : void 0
    m && (p.align = m)
    let v = { type: 'element', tagName: s, properties: p, children: [] }
    h && ((v.children = e.all(h)), e.patch(h, v), (v = e.applyData(h, v))), c.push(v)
  }
  const f = { type: 'element', tagName: 'tr', properties: {}, children: e.wrap(c, !0) }
  return e.patch(t, f), e.applyData(t, f)
}
function KT(e, t) {
  const r = { type: 'element', tagName: 'td', properties: {}, children: e.all(t) }
  return e.patch(t, r), e.applyData(t, r)
}
const mm = 9,
  dm = 32
function JT(e) {
  const t = String(e),
    r = /\r?\n|\r/g
  let i = r.exec(t),
    n = 0
  const s = []
  for (; i; )
    s.push(gm(t.slice(n, i.index), n > 0, !0), i[0]), (n = i.index + i[0].length), (i = r.exec(t))
  return s.push(gm(t.slice(n), n > 0, !1)), s.join('')
}
function gm(e, t, r) {
  let i = 0,
    n = e.length
  if (t) {
    let s = e.codePointAt(i)
    for (; s === mm || s === dm; ) i++, (s = e.codePointAt(i))
  }
  if (r) {
    let s = e.codePointAt(n - 1)
    for (; s === mm || s === dm; ) n--, (s = e.codePointAt(n - 1))
  }
  return n > i ? e.slice(i, n) : ''
}
function ZT(e, t) {
  const r = { type: 'text', value: JT(String(t.value)) }
  return e.patch(t, r), e.applyData(t, r)
}
function e2(e, t) {
  const r = { type: 'element', tagName: 'hr', properties: {}, children: [] }
  return e.patch(t, r), e.applyData(t, r)
}
const t2 = {
  blockquote: NT,
  break: OT,
  code: IT,
  delete: DT,
  emphasis: RT,
  footnoteReference: LT,
  heading: PT,
  html: BT,
  imageReference: FT,
  image: MT,
  inlineCode: UT,
  linkReference: HT,
  link: zT,
  listItem: jT,
  list: $T,
  paragraph: VT,
  root: GT,
  strong: XT,
  table: WT,
  tableCell: KT,
  tableRow: QT,
  text: ZT,
  thematicBreak: e2,
  toml: La,
  yaml: La,
  definition: La,
  footnoteDefinition: La,
}
function La() {}
const u1 = -1,
  ou = 0,
  Po = 1,
  Bo = 2,
  ip = 3,
  np = 4,
  sp = 5,
  ap = 6,
  l1 = 7,
  c1 = 8,
  bm = typeof self == 'object' ? self : globalThis,
  r2 = (e, t) => {
    const r = (n, s) => (e.set(s, n), n),
      i = (n) => {
        if (e.has(n)) return e.get(n)
        const [s, a] = t[n]
        switch (s) {
          case ou:
          case u1:
            return r(a, n)
          case Po: {
            const o = r([], n)
            for (const u of a) o.push(i(u))
            return o
          }
          case Bo: {
            const o = r({}, n)
            for (const [u, c] of a) o[i(u)] = i(c)
            return o
          }
          case ip:
            return r(new Date(a), n)
          case np: {
            const { source: o, flags: u } = a
            return r(new RegExp(o, u), n)
          }
          case sp: {
            const o = r(new Map(), n)
            for (const [u, c] of a) o.set(i(u), i(c))
            return o
          }
          case ap: {
            const o = r(new Set(), n)
            for (const u of a) o.add(i(u))
            return o
          }
          case l1: {
            const { name: o, message: u } = a
            return r(new bm[o](u), n)
          }
          case c1:
            return r(BigInt(a), n)
          case 'BigInt':
            return r(Object(BigInt(a)), n)
        }
        return r(new bm[s](a), n)
      }
    return i
  },
  ym = (e) => r2(new Map(), e)(0),
  Vi = '',
  { toString: i2 } = {},
  { keys: n2 } = Object,
  Wn = (e) => {
    const t = typeof e
    if (t !== 'object' || !e) return [ou, t]
    const r = i2.call(e).slice(8, -1)
    switch (r) {
      case 'Array':
        return [Po, Vi]
      case 'Object':
        return [Bo, Vi]
      case 'Date':
        return [ip, Vi]
      case 'RegExp':
        return [np, Vi]
      case 'Map':
        return [sp, Vi]
      case 'Set':
        return [ap, Vi]
    }
    return r.includes('Array') ? [Po, r] : r.includes('Error') ? [l1, r] : [Bo, r]
  },
  Pa = ([e, t]) => e === ou && (t === 'function' || t === 'symbol'),
  s2 = (e, t, r, i) => {
    const n = (a, o) => {
        const u = i.push(a) - 1
        return r.set(o, u), u
      },
      s = (a) => {
        if (r.has(a)) return r.get(a)
        let [o, u] = Wn(a)
        switch (o) {
          case ou: {
            let f = a
            switch (u) {
              case 'bigint':
                ;(o = c1), (f = a.toString())
                break
              case 'function':
              case 'symbol':
                if (e) throw new TypeError('unable to serialize ' + u)
                f = null
                break
              case 'undefined':
                return n([u1], a)
            }
            return n([o, f], a)
          }
          case Po: {
            if (u) return n([u, [...a]], a)
            const f = [],
              h = n([o, f], a)
            for (const p of a) f.push(s(p))
            return h
          }
          case Bo: {
            if (u)
              switch (u) {
                case 'BigInt':
                  return n([u, a.toString()], a)
                case 'Boolean':
                case 'Number':
                case 'String':
                  return n([u, a.valueOf()], a)
              }
            if (t && 'toJSON' in a) return s(a.toJSON())
            const f = [],
              h = n([o, f], a)
            for (const p of n2(a)) (e || !Pa(Wn(a[p]))) && f.push([s(p), s(a[p])])
            return h
          }
          case ip:
            return n([o, a.toISOString()], a)
          case np: {
            const { source: f, flags: h } = a
            return n([o, { source: f, flags: h }], a)
          }
          case sp: {
            const f = [],
              h = n([o, f], a)
            for (const [p, m] of a) (e || !(Pa(Wn(p)) || Pa(Wn(m)))) && f.push([s(p), s(m)])
            return h
          }
          case ap: {
            const f = [],
              h = n([o, f], a)
            for (const p of a) (e || !Pa(Wn(p))) && f.push(s(p))
            return h
          }
        }
        const { message: c } = a
        return n([o, { name: u, message: c }], a)
      }
    return s
  },
  _m = (e, { json: t, lossy: r } = {}) => {
    const i = []
    return s2(!(t || r), !!t, new Map(), i)(e), i
  },
  Fo =
    typeof structuredClone == 'function'
      ? (e, t) => (t && ('json' in t || 'lossy' in t) ? ym(_m(e, t)) : structuredClone(e))
      : (e, t) => ym(_m(e, t))
function a2(e, t) {
  const r = [{ type: 'text', value: '' }]
  return (
    t > 1 &&
      r.push({
        type: 'element',
        tagName: 'sup',
        properties: {},
        children: [{ type: 'text', value: String(t) }],
      }),
    r
  )
}
function o2(e, t) {
  return 'Back to reference ' + (e + 1) + (t > 1 ? '-' + t : '')
}
function u2(e) {
  const t = typeof e.options.clobberPrefix == 'string' ? e.options.clobberPrefix : 'user-content-',
    r = e.options.footnoteBackContent || a2,
    i = e.options.footnoteBackLabel || o2,
    n = e.options.footnoteLabel || 'Footnotes',
    s = e.options.footnoteLabelTagName || 'h2',
    a = e.options.footnoteLabelProperties || { className: ['sr-only'] },
    o = []
  let u = -1
  for (; ++u < e.footnoteOrder.length; ) {
    const c = e.footnoteById.get(e.footnoteOrder[u])
    if (!c) continue
    const f = e.all(c),
      h = String(c.identifier).toUpperCase(),
      p = Mn(h.toLowerCase())
    let m = 0
    const v = [],
      b = e.footnoteCounts.get(h)
    for (; b !== void 0 && ++m <= b; ) {
      v.length > 0 && v.push({ type: 'text', value: ' ' })
      let _ = typeof r == 'string' ? r : r(u, m)
      typeof _ == 'string' && (_ = { type: 'text', value: _ }),
        v.push({
          type: 'element',
          tagName: 'a',
          properties: {
            href: '#' + t + 'fnref-' + p + (m > 1 ? '-' + m : ''),
            dataFootnoteBackref: '',
            ariaLabel: typeof i == 'string' ? i : i(u, m),
            className: ['data-footnote-backref'],
          },
          children: Array.isArray(_) ? _ : [_],
        })
    }
    const S = f[f.length - 1]
    if (S && S.type === 'element' && S.tagName === 'p') {
      const _ = S.children[S.children.length - 1]
      _ && _.type === 'text' ? (_.value += ' ') : S.children.push({ type: 'text', value: ' ' }),
        S.children.push(...v)
    } else f.push(...v)
    const g = {
      type: 'element',
      tagName: 'li',
      properties: { id: t + 'fn-' + p },
      children: e.wrap(f, !0),
    }
    e.patch(c, g), o.push(g)
  }
  if (o.length !== 0)
    return {
      type: 'element',
      tagName: 'section',
      properties: { dataFootnotes: !0, className: ['footnotes'] },
      children: [
        {
          type: 'element',
          tagName: s,
          properties: { ...Fo(a), id: 'footnote-label' },
          children: [{ type: 'text', value: n }],
        },
        {
          type: 'text',
          value: `
`,
        },
        { type: 'element', tagName: 'ol', properties: {}, children: e.wrap(o, !0) },
        {
          type: 'text',
          value: `
`,
        },
      ],
    }
}
const uu = function (e) {
  if (e == null) return p2
  if (typeof e == 'function') return lu(e)
  if (typeof e == 'object') return Array.isArray(e) ? l2(e) : c2(e)
  if (typeof e == 'string') return f2(e)
  throw new Error('Expected function, string, or object as test')
}
function l2(e) {
  const t = []
  let r = -1
  for (; ++r < e.length; ) t[r] = uu(e[r])
  return lu(i)
  function i(...n) {
    let s = -1
    for (; ++s < t.length; ) if (t[s].apply(this, n)) return !0
    return !1
  }
}
function c2(e) {
  const t = e
  return lu(r)
  function r(i) {
    const n = i
    let s
    for (s in e) if (n[s] !== t[s]) return !1
    return !0
  }
}
function f2(e) {
  return lu(t)
  function t(r) {
    return r && r.type === e
  }
}
function lu(e) {
  return t
  function t(r, i, n) {
    return !!(h2(r) && e.call(this, r, typeof i == 'number' ? i : void 0, n || void 0))
  }
}
function p2() {
  return !0
}
function h2(e) {
  return e !== null && typeof e == 'object' && 'type' in e
}
const f1 = [],
  m2 = !0,
  Nc = !1,
  d2 = 'skip'
function p1(e, t, r, i) {
  let n
  typeof t == 'function' && typeof r != 'function' ? ((i = r), (r = t)) : (n = t)
  const s = uu(n),
    a = i ? -1 : 1
  o(e, void 0, [])()
  function o(u, c, f) {
    const h = u && typeof u == 'object' ? u : {}
    if (typeof h.type == 'string') {
      const m =
        typeof h.tagName == 'string' ? h.tagName : typeof h.name == 'string' ? h.name : void 0
      Object.defineProperty(p, 'name', {
        value: 'node (' + (u.type + (m ? '<' + m + '>' : '')) + ')',
      })
    }
    return p
    function p() {
      let m = f1,
        v,
        b,
        S
      if ((!t || s(u, c, f[f.length - 1] || void 0)) && ((m = g2(r(u, f))), m[0] === Nc)) return m
      if ('children' in u && u.children) {
        const g = u
        if (g.children && m[0] !== d2)
          for (
            b = (i ? g.children.length : -1) + a, S = f.concat(g);
            b > -1 && b < g.children.length;

          ) {
            const _ = g.children[b]
            if (((v = o(_, b, S)()), v[0] === Nc)) return v
            b = typeof v[1] == 'number' ? v[1] : b + a
          }
      }
      return m
    }
  }
}
function g2(e) {
  return Array.isArray(e) ? e : typeof e == 'number' ? [m2, e] : e == null ? f1 : [e]
}
function fn(e, t, r, i) {
  let n, s, a
  typeof t == 'function' && typeof r != 'function'
    ? ((s = void 0), (a = t), (n = r))
    : ((s = t), (a = r), (n = i)),
    p1(e, s, o, n)
  function o(u, c) {
    const f = c[c.length - 1],
      h = f ? f.children.indexOf(u) : void 0
    return a(u, h, f)
  }
}
const Oc = {}.hasOwnProperty,
  b2 = {}
function y2(e, t) {
  const r = t || b2,
    i = new Map(),
    n = new Map(),
    s = new Map(),
    a = { ...t2, ...r.handlers },
    o = {
      all: c,
      applyData: v2,
      definitionById: i,
      footnoteById: n,
      footnoteCounts: s,
      footnoteOrder: [],
      handlers: a,
      one: u,
      options: r,
      patch: _2,
      wrap: x2,
    }
  return (
    fn(e, function (f) {
      if (f.type === 'definition' || f.type === 'footnoteDefinition') {
        const h = f.type === 'definition' ? i : n,
          p = String(f.identifier).toUpperCase()
        h.has(p) || h.set(p, f)
      }
    }),
    o
  )
  function u(f, h) {
    const p = f.type,
      m = o.handlers[p]
    if (Oc.call(o.handlers, p) && m) return m(o, f, h)
    if (o.options.passThrough && o.options.passThrough.includes(p)) {
      if ('children' in f) {
        const { children: b, ...S } = f,
          g = Fo(S)
        return (g.children = o.all(f)), g
      }
      return Fo(f)
    }
    return (o.options.unknownHandler || E2)(o, f, h)
  }
  function c(f) {
    const h = []
    if ('children' in f) {
      const p = f.children
      let m = -1
      for (; ++m < p.length; ) {
        const v = o.one(p[m], f)
        if (v) {
          if (
            m &&
            p[m - 1].type === 'break' &&
            (!Array.isArray(v) && v.type === 'text' && (v.value = vm(v.value)),
            !Array.isArray(v) && v.type === 'element')
          ) {
            const b = v.children[0]
            b && b.type === 'text' && (b.value = vm(b.value))
          }
          Array.isArray(v) ? h.push(...v) : h.push(v)
        }
      }
    }
    return h
  }
}
function _2(e, t) {
  e.position && (t.position = YT(e))
}
function v2(e, t) {
  let r = t
  if (e && e.data) {
    const i = e.data.hName,
      n = e.data.hChildren,
      s = e.data.hProperties
    if (typeof i == 'string')
      if (r.type === 'element') r.tagName = i
      else {
        const a = 'children' in r ? r.children : [r]
        r = { type: 'element', tagName: i, properties: {}, children: a }
      }
    r.type === 'element' && s && Object.assign(r.properties, Fo(s)),
      'children' in r && r.children && n !== null && n !== void 0 && (r.children = n)
  }
  return r
}
function E2(e, t) {
  const r = t.data || {},
    i =
      'value' in t && !(Oc.call(r, 'hProperties') || Oc.call(r, 'hChildren'))
        ? { type: 'text', value: t.value }
        : { type: 'element', tagName: 'div', properties: {}, children: e.all(t) }
  return e.patch(t, i), e.applyData(t, i)
}
function x2(e, t) {
  const r = []
  let i = -1
  for (
    t &&
    r.push({
      type: 'text',
      value: `
`,
    });
    ++i < e.length;

  )
    i &&
      r.push({
        type: 'text',
        value: `
`,
      }),
      r.push(e[i])
  return (
    t &&
      e.length > 0 &&
      r.push({
        type: 'text',
        value: `
`,
      }),
    r
  )
}
function vm(e) {
  let t = 0,
    r = e.charCodeAt(t)
  for (; r === 9 || r === 32; ) t++, (r = e.charCodeAt(t))
  return e.slice(t)
}
function Em(e, t) {
  const r = y2(e, t),
    i = r.one(e, void 0),
    n = u2(r),
    s = Array.isArray(i) ? { type: 'root', children: i } : i || { type: 'root', children: [] }
  return (
    n &&
      s.children.push(
        {
          type: 'text',
          value: `
`,
        },
        n
      ),
    s
  )
}
function T2(e, t) {
  return e && 'run' in e
    ? async function (r, i) {
        const n = Em(r, t)
        await e.run(n, i)
      }
    : function (r) {
        return Em(r, t || e)
      }
}
function Mo(e, t) {
  const r = String(e)
  if (typeof t != 'string') throw new TypeError('Expected character')
  let i = 0,
    n = r.indexOf(t)
  for (; n !== -1; ) i++, (n = r.indexOf(t, n + t.length))
  return i
}
function A2(e) {
  if (typeof e != 'string') throw new TypeError('Expected a string')
  return e.replace(/[|\\{}()[\]^$+*?.]/g, '\\$&').replace(/-/g, '\\x2d')
}
function S2(e, t, r) {
  const n = uu((r || {}).ignore || []),
    s = C2(t)
  let a = -1
  for (; ++a < s.length; ) p1(e, 'text', o)
  function o(c, f) {
    let h = -1,
      p
    for (; ++h < f.length; ) {
      const m = f[h],
        v = p ? p.children : void 0
      if (n(m, v ? v.indexOf(m) : void 0, p)) return
      p = m
    }
    if (p) return u(c, f)
  }
  function u(c, f) {
    const h = f[f.length - 1],
      p = s[a][0],
      m = s[a][1]
    let v = 0
    const S = h.children.indexOf(c)
    let g = !1,
      _ = []
    p.lastIndex = 0
    let y = p.exec(c.value)
    for (; y; ) {
      const x = y.index,
        D = { index: y.index, input: y.input, stack: [...f, c] }
      let C = m(...y, D)
      if (
        (typeof C == 'string' && (C = C.length > 0 ? { type: 'text', value: C } : void 0),
        C === !1
          ? (p.lastIndex = x + 1)
          : (v !== x && _.push({ type: 'text', value: c.value.slice(v, x) }),
            Array.isArray(C) ? _.push(...C) : C && _.push(C),
            (v = x + y[0].length),
            (g = !0)),
        !p.global)
      )
        break
      y = p.exec(c.value)
    }
    return (
      g
        ? (v < c.value.length && _.push({ type: 'text', value: c.value.slice(v) }),
          h.children.splice(S, 1, ..._))
        : (_ = [c]),
      S + _.length
    )
  }
}
function C2(e) {
  const t = []
  if (!Array.isArray(e)) throw new TypeError('Expected find and replace tuple or list of tuples')
  const r = !e[0] || Array.isArray(e[0]) ? e : [e]
  let i = -1
  for (; ++i < r.length; ) {
    const n = r[i]
    t.push([k2(n[0]), w2(n[1])])
  }
  return t
}
function k2(e) {
  return typeof e == 'string' ? new RegExp(A2(e), 'g') : e
}
function w2(e) {
  return typeof e == 'function'
    ? e
    : function () {
        return e
      }
}
const fl = 'phrasing',
  pl = ['autolink', 'link', 'image', 'label']
function N2() {
  return {
    transforms: [B2],
    enter: {
      literalAutolink: I2,
      literalAutolinkEmail: hl,
      literalAutolinkHttp: hl,
      literalAutolinkWww: hl,
    },
    exit: {
      literalAutolink: P2,
      literalAutolinkEmail: L2,
      literalAutolinkHttp: D2,
      literalAutolinkWww: R2,
    },
  }
}
function O2() {
  return {
    unsafe: [
      {
        character: '@',
        before: '[+\\-.\\w]',
        after: '[\\-.\\w]',
        inConstruct: fl,
        notInConstruct: pl,
      },
      { character: '.', before: '[Ww]', after: '[\\-.\\w]', inConstruct: fl, notInConstruct: pl },
      { character: ':', before: '[ps]', after: '\\/', inConstruct: fl, notInConstruct: pl },
    ],
  }
}
function I2(e) {
  this.enter({ type: 'link', title: null, url: '', children: [] }, e)
}
function hl(e) {
  this.config.enter.autolinkProtocol.call(this, e)
}
function D2(e) {
  this.config.exit.autolinkProtocol.call(this, e)
}
function R2(e) {
  this.config.exit.data.call(this, e)
  const t = this.stack[this.stack.length - 1]
  t.type, (t.url = 'http://' + this.sliceSerialize(e))
}
function L2(e) {
  this.config.exit.autolinkEmail.call(this, e)
}
function P2(e) {
  this.exit(e)
}
function B2(e) {
  S2(
    e,
    [
      [/(https?:\/\/|www(?=\.))([-.\w]+)([^ \t\r\n]*)/gi, F2],
      [/([-.\w+]+)@([-\w]+(?:\.[-\w]+)+)/g, M2],
    ],
    { ignore: ['link', 'linkReference'] }
  )
}
function F2(e, t, r, i, n) {
  let s = ''
  if (!h1(n) || (/^w/i.test(t) && ((r = t + r), (t = ''), (s = 'http://')), !U2(r))) return !1
  const a = H2(r + i)
  if (!a[0]) return !1
  const o = {
    type: 'link',
    title: null,
    url: s + t + a[0],
    children: [{ type: 'text', value: t + a[0] }],
  }
  return a[1] ? [o, { type: 'text', value: a[1] }] : o
}
function M2(e, t, r, i) {
  return !h1(i, !0) || /[-\d_]$/.test(r)
    ? !1
    : {
        type: 'link',
        title: null,
        url: 'mailto:' + t + '@' + r,
        children: [{ type: 'text', value: t + '@' + r }],
      }
}
function U2(e) {
  const t = e.split('.')
  return !(
    t.length < 2 ||
    (t[t.length - 1] && (/_/.test(t[t.length - 1]) || !/[a-zA-Z\d]/.test(t[t.length - 1]))) ||
    (t[t.length - 2] && (/_/.test(t[t.length - 2]) || !/[a-zA-Z\d]/.test(t[t.length - 2])))
  )
}
function H2(e) {
  const t = /[!"&'),.:;<>?\]}]+$/.exec(e)
  if (!t) return [e, void 0]
  e = e.slice(0, t.index)
  let r = t[0],
    i = r.indexOf(')')
  const n = Mo(e, '(')
  let s = Mo(e, ')')
  for (; i !== -1 && n > s; )
    (e += r.slice(0, i + 1)), (r = r.slice(i + 1)), (i = r.indexOf(')')), s++
  return [e, r]
}
function h1(e, t) {
  const r = e.input.charCodeAt(e.index - 1)
  return (e.index === 0 || Ri(r) || su(r)) && (!t || r !== 47)
}
m1.peek = K2
function z2() {
  return {
    enter: {
      gfmFootnoteDefinition: q2,
      gfmFootnoteDefinitionLabelString: $2,
      gfmFootnoteCall: X2,
      gfmFootnoteCallString: Y2,
    },
    exit: {
      gfmFootnoteDefinition: G2,
      gfmFootnoteDefinitionLabelString: V2,
      gfmFootnoteCall: Q2,
      gfmFootnoteCallString: W2,
    },
  }
}
function j2() {
  return {
    unsafe: [{ character: '[', inConstruct: ['phrasing', 'label', 'reference'] }],
    handlers: { footnoteDefinition: J2, footnoteReference: m1 },
  }
}
function q2(e) {
  this.enter({ type: 'footnoteDefinition', identifier: '', label: '', children: [] }, e)
}
function $2() {
  this.buffer()
}
function V2(e) {
  const t = this.resume(),
    r = this.stack[this.stack.length - 1]
  r.type, (r.label = t), (r.identifier = sr(this.sliceSerialize(e)).toLowerCase())
}
function G2(e) {
  this.exit(e)
}
function X2(e) {
  this.enter({ type: 'footnoteReference', identifier: '', label: '' }, e)
}
function Y2() {
  this.buffer()
}
function W2(e) {
  const t = this.resume(),
    r = this.stack[this.stack.length - 1]
  r.type, (r.label = t), (r.identifier = sr(this.sliceSerialize(e)).toLowerCase())
}
function Q2(e) {
  this.exit(e)
}
function m1(e, t, r, i) {
  const n = r.createTracker(i)
  let s = n.move('[^')
  const a = r.enter('footnoteReference'),
    o = r.enter('reference')
  return (
    (s += n.move(r.safe(r.associationId(e), { ...n.current(), before: s, after: ']' }))),
    o(),
    a(),
    (s += n.move(']')),
    s
  )
}
function K2() {
  return '['
}
function J2(e, t, r, i) {
  const n = r.createTracker(i)
  let s = n.move('[^')
  const a = r.enter('footnoteDefinition'),
    o = r.enter('label')
  return (
    (s += n.move(r.safe(r.associationId(e), { ...n.current(), before: s, after: ']' }))),
    o(),
    (s += n.move(']:' + (e.children && e.children.length > 0 ? ' ' : ''))),
    n.shift(4),
    (s += n.move(r.indentLines(r.containerFlow(e, n.current()), Z2))),
    a(),
    s
  )
}
function Z2(e, t, r) {
  return t === 0 ? e : (r ? '' : '    ') + e
}
const eA = [
  'autolink',
  'destinationLiteral',
  'destinationRaw',
  'reference',
  'titleQuote',
  'titleApostrophe',
]
d1.peek = sA
function tA() {
  return { canContainEols: ['delete'], enter: { strikethrough: iA }, exit: { strikethrough: nA } }
}
function rA() {
  return {
    unsafe: [{ character: '~', inConstruct: 'phrasing', notInConstruct: eA }],
    handlers: { delete: d1 },
  }
}
function iA(e) {
  this.enter({ type: 'delete', children: [] }, e)
}
function nA(e) {
  this.exit(e)
}
function d1(e, t, r, i) {
  const n = r.createTracker(i),
    s = r.enter('strikethrough')
  let a = n.move('~~')
  return (
    (a += r.containerPhrasing(e, { ...n.current(), before: a, after: '~' })),
    (a += n.move('~~')),
    s(),
    a
  )
}
function sA() {
  return '~'
}
function aA(e, t = {}) {
  const r = (t.align || []).concat(),
    i = t.stringLength || uA,
    n = [],
    s = [],
    a = [],
    o = []
  let u = 0,
    c = -1
  for (; ++c < e.length; ) {
    const v = [],
      b = []
    let S = -1
    for (e[c].length > u && (u = e[c].length); ++S < e[c].length; ) {
      const g = oA(e[c][S])
      if (t.alignDelimiters !== !1) {
        const _ = i(g)
        ;(b[S] = _), (o[S] === void 0 || _ > o[S]) && (o[S] = _)
      }
      v.push(g)
    }
    ;(s[c] = v), (a[c] = b)
  }
  let f = -1
  if (typeof r == 'object' && 'length' in r) for (; ++f < u; ) n[f] = xm(r[f])
  else {
    const v = xm(r)
    for (; ++f < u; ) n[f] = v
  }
  f = -1
  const h = [],
    p = []
  for (; ++f < u; ) {
    const v = n[f]
    let b = '',
      S = ''
    v === 99 ? ((b = ':'), (S = ':')) : v === 108 ? (b = ':') : v === 114 && (S = ':')
    let g = t.alignDelimiters === !1 ? 1 : Math.max(1, o[f] - b.length - S.length)
    const _ = b + '-'.repeat(g) + S
    t.alignDelimiters !== !1 && ((g = b.length + g + S.length), g > o[f] && (o[f] = g), (p[f] = g)),
      (h[f] = _)
  }
  s.splice(1, 0, h), a.splice(1, 0, p), (c = -1)
  const m = []
  for (; ++c < s.length; ) {
    const v = s[c],
      b = a[c]
    f = -1
    const S = []
    for (; ++f < u; ) {
      const g = v[f] || ''
      let _ = '',
        y = ''
      if (t.alignDelimiters !== !1) {
        const x = o[f] - (b[f] || 0),
          D = n[f]
        D === 114
          ? (_ = ' '.repeat(x))
          : D === 99
          ? x % 2
            ? ((_ = ' '.repeat(x / 2 + 0.5)), (y = ' '.repeat(x / 2 - 0.5)))
            : ((_ = ' '.repeat(x / 2)), (y = _))
          : (y = ' '.repeat(x))
      }
      t.delimiterStart !== !1 && !f && S.push('|'),
        t.padding !== !1 &&
          !(t.alignDelimiters === !1 && g === '') &&
          (t.delimiterStart !== !1 || f) &&
          S.push(' '),
        t.alignDelimiters !== !1 && S.push(_),
        S.push(g),
        t.alignDelimiters !== !1 && S.push(y),
        t.padding !== !1 && S.push(' '),
        (t.delimiterEnd !== !1 || f !== u - 1) && S.push('|')
    }
    m.push(t.delimiterEnd === !1 ? S.join('').replace(/ +$/, '') : S.join(''))
  }
  return m.join(`
`)
}
function oA(e) {
  return e == null ? '' : String(e)
}
function uA(e) {
  return e.length
}
function xm(e) {
  const t = typeof e == 'string' ? e.codePointAt(0) : 0
  return t === 67 || t === 99 ? 99 : t === 76 || t === 108 ? 108 : t === 82 || t === 114 ? 114 : 0
}
const Tm = {}.hasOwnProperty
function lA(e, t) {
  const r = t || {}
  function i(n, ...s) {
    let a = i.invalid
    const o = i.handlers
    if (n && Tm.call(n, e)) {
      const u = String(n[e])
      a = Tm.call(o, u) ? o[u] : i.unknown
    }
    if (a) return a.call(this, n, ...s)
  }
  return (i.handlers = r.handlers || {}), (i.invalid = r.invalid), (i.unknown = r.unknown), i
}
function cA(e, t, r, i) {
  const n = r.enter('blockquote'),
    s = r.createTracker(i)
  s.move('> '), s.shift(2)
  const a = r.indentLines(r.containerFlow(e, s.current()), fA)
  return n(), a
}
function fA(e, t, r) {
  return '>' + (r ? '' : ' ') + e
}
function pA(e, t) {
  return Am(e, t.inConstruct, !0) && !Am(e, t.notInConstruct, !1)
}
function Am(e, t, r) {
  if ((typeof t == 'string' && (t = [t]), !t || t.length === 0)) return r
  let i = -1
  for (; ++i < t.length; ) if (e.includes(t[i])) return !0
  return !1
}
function Sm(e, t, r, i) {
  let n = -1
  for (; ++n < r.unsafe.length; )
    if (
      r.unsafe[n].character ===
        `
` &&
      pA(r.stack, r.unsafe[n])
    )
      return /[ \t]/.test(i.before) ? '' : ' '
  return `\\
`
}
function hA(e, t) {
  const r = String(e)
  let i = r.indexOf(t),
    n = i,
    s = 0,
    a = 0
  if (typeof t != 'string') throw new TypeError('Expected substring')
  for (; i !== -1; )
    i === n ? ++s > a && (a = s) : (s = 1), (n = i + t.length), (i = r.indexOf(t, n))
  return a
}
function mA(e, t) {
  return !!(
    t.options.fences === !1 &&
    e.value &&
    !e.lang &&
    /[^ \r\n]/.test(e.value) &&
    !/^[\t ]*(?:[\r\n]|$)|(?:^|[\r\n])[\t ]*$/.test(e.value)
  )
}
function dA(e) {
  const t = e.options.fence || '`'
  if (t !== '`' && t !== '~')
    throw new Error(
      'Cannot serialize code with `' + t + '` for `options.fence`, expected `` ` `` or `~`'
    )
  return t
}
function gA(e, t, r, i) {
  const n = dA(r),
    s = e.value || '',
    a = n === '`' ? 'GraveAccent' : 'Tilde'
  if (mA(e, r)) {
    const h = r.enter('codeIndented'),
      p = r.indentLines(s, bA)
    return h(), p
  }
  const o = r.createTracker(i),
    u = n.repeat(Math.max(hA(s, n) + 1, 3)),
    c = r.enter('codeFenced')
  let f = o.move(u)
  if (e.lang) {
    const h = r.enter(`codeFencedLang${a}`)
    ;(f += o.move(r.safe(e.lang, { before: f, after: ' ', encode: ['`'], ...o.current() }))), h()
  }
  if (e.lang && e.meta) {
    const h = r.enter(`codeFencedMeta${a}`)
    ;(f += o.move(' ')),
      (f += o.move(
        r.safe(e.meta, {
          before: f,
          after: `
`,
          encode: ['`'],
          ...o.current(),
        })
      )),
      h()
  }
  return (
    (f += o.move(`
`)),
    s &&
      (f += o.move(
        s +
          `
`
      )),
    (f += o.move(u)),
    c(),
    f
  )
}
function bA(e, t, r) {
  return (r ? '' : '    ') + e
}
function op(e) {
  const t = e.options.quote || '"'
  if (t !== '"' && t !== "'")
    throw new Error(
      'Cannot serialize title with `' + t + '` for `options.quote`, expected `"`, or `\'`'
    )
  return t
}
function yA(e, t, r, i) {
  const n = op(r),
    s = n === '"' ? 'Quote' : 'Apostrophe',
    a = r.enter('definition')
  let o = r.enter('label')
  const u = r.createTracker(i)
  let c = u.move('[')
  return (
    (c += u.move(r.safe(r.associationId(e), { before: c, after: ']', ...u.current() }))),
    (c += u.move(']: ')),
    o(),
    !e.url || /[\0- \u007F]/.test(e.url)
      ? ((o = r.enter('destinationLiteral')),
        (c += u.move('<')),
        (c += u.move(r.safe(e.url, { before: c, after: '>', ...u.current() }))),
        (c += u.move('>')))
      : ((o = r.enter('destinationRaw')),
        (c += u.move(
          r.safe(e.url, {
            before: c,
            after: e.title
              ? ' '
              : `
`,
            ...u.current(),
          })
        ))),
    o(),
    e.title &&
      ((o = r.enter(`title${s}`)),
      (c += u.move(' ' + n)),
      (c += u.move(r.safe(e.title, { before: c, after: n, ...u.current() }))),
      (c += u.move(n)),
      o()),
    a(),
    c
  )
}
function _A(e) {
  const t = e.options.emphasis || '*'
  if (t !== '*' && t !== '_')
    throw new Error(
      'Cannot serialize emphasis with `' + t + '` for `options.emphasis`, expected `*`, or `_`'
    )
  return t
}
g1.peek = vA
function g1(e, t, r, i) {
  const n = _A(r),
    s = r.enter('emphasis'),
    a = r.createTracker(i)
  let o = a.move(n)
  return (
    (o += a.move(r.containerPhrasing(e, { before: o, after: n, ...a.current() }))),
    (o += a.move(n)),
    s(),
    o
  )
}
function vA(e, t, r) {
  return r.options.emphasis || '*'
}
function EA(e, t) {
  let r = !1
  return (
    fn(e, function (i) {
      if (('value' in i && /\r?\n|\r/.test(i.value)) || i.type === 'break') return (r = !0), Nc
    }),
    !!((!e.depth || e.depth < 3) && ep(e) && (t.options.setext || r))
  )
}
function xA(e, t, r, i) {
  const n = Math.max(Math.min(6, e.depth || 1), 1),
    s = r.createTracker(i)
  if (EA(e, r)) {
    const f = r.enter('headingSetext'),
      h = r.enter('phrasing'),
      p = r.containerPhrasing(e, {
        ...s.current(),
        before: `
`,
        after: `
`,
      })
    return (
      h(),
      f(),
      p +
        `
` +
        (n === 1 ? '=' : '-').repeat(
          p.length -
            (Math.max(
              p.lastIndexOf('\r'),
              p.lastIndexOf(`
`)
            ) +
              1)
        )
    )
  }
  const a = '#'.repeat(n),
    o = r.enter('headingAtx'),
    u = r.enter('phrasing')
  s.move(a + ' ')
  let c = r.containerPhrasing(e, {
    before: '# ',
    after: `
`,
    ...s.current(),
  })
  return (
    /^[\t ]/.test(c) && (c = '&#x' + c.charCodeAt(0).toString(16).toUpperCase() + ';' + c.slice(1)),
    (c = c ? a + ' ' + c : a),
    r.options.closeAtx && (c += ' ' + a),
    u(),
    o(),
    c
  )
}
b1.peek = TA
function b1(e) {
  return e.value || ''
}
function TA() {
  return '<'
}
y1.peek = AA
function y1(e, t, r, i) {
  const n = op(r),
    s = n === '"' ? 'Quote' : 'Apostrophe',
    a = r.enter('image')
  let o = r.enter('label')
  const u = r.createTracker(i)
  let c = u.move('![')
  return (
    (c += u.move(r.safe(e.alt, { before: c, after: ']', ...u.current() }))),
    (c += u.move('](')),
    o(),
    (!e.url && e.title) || /[\0- \u007F]/.test(e.url)
      ? ((o = r.enter('destinationLiteral')),
        (c += u.move('<')),
        (c += u.move(r.safe(e.url, { before: c, after: '>', ...u.current() }))),
        (c += u.move('>')))
      : ((o = r.enter('destinationRaw')),
        (c += u.move(r.safe(e.url, { before: c, after: e.title ? ' ' : ')', ...u.current() })))),
    o(),
    e.title &&
      ((o = r.enter(`title${s}`)),
      (c += u.move(' ' + n)),
      (c += u.move(r.safe(e.title, { before: c, after: n, ...u.current() }))),
      (c += u.move(n)),
      o()),
    (c += u.move(')')),
    a(),
    c
  )
}
function AA() {
  return '!'
}
_1.peek = SA
function _1(e, t, r, i) {
  const n = e.referenceType,
    s = r.enter('imageReference')
  let a = r.enter('label')
  const o = r.createTracker(i)
  let u = o.move('![')
  const c = r.safe(e.alt, { before: u, after: ']', ...o.current() })
  ;(u += o.move(c + '][')), a()
  const f = r.stack
  ;(r.stack = []), (a = r.enter('reference'))
  const h = r.safe(r.associationId(e), { before: u, after: ']', ...o.current() })
  return (
    a(),
    (r.stack = f),
    s(),
    n === 'full' || !c || c !== h
      ? (u += o.move(h + ']'))
      : n === 'shortcut'
      ? (u = u.slice(0, -1))
      : (u += o.move(']')),
    u
  )
}
function SA() {
  return '!'
}
v1.peek = CA
function v1(e, t, r) {
  let i = e.value || '',
    n = '`',
    s = -1
  for (; new RegExp('(^|[^`])' + n + '([^`]|$)').test(i); ) n += '`'
  for (
    /[^ \r\n]/.test(i) &&
    ((/^[ \r\n]/.test(i) && /[ \r\n]$/.test(i)) || /^`|`$/.test(i)) &&
    (i = ' ' + i + ' ');
    ++s < r.unsafe.length;

  ) {
    const a = r.unsafe[s],
      o = r.compilePattern(a)
    let u
    if (a.atBreak)
      for (; (u = o.exec(i)); ) {
        let c = u.index
        i.charCodeAt(c) === 10 && i.charCodeAt(c - 1) === 13 && c--,
          (i = i.slice(0, c) + ' ' + i.slice(u.index + 1))
      }
  }
  return n + i + n
}
function CA() {
  return '`'
}
function E1(e, t) {
  const r = ep(e)
  return !!(
    !t.options.resourceLink &&
    e.url &&
    !e.title &&
    e.children &&
    e.children.length === 1 &&
    e.children[0].type === 'text' &&
    (r === e.url || 'mailto:' + r === e.url) &&
    /^[a-z][a-z+.-]+:/i.test(e.url) &&
    !/[\0- <>\u007F]/.test(e.url)
  )
}
x1.peek = kA
function x1(e, t, r, i) {
  const n = op(r),
    s = n === '"' ? 'Quote' : 'Apostrophe',
    a = r.createTracker(i)
  let o, u
  if (E1(e, r)) {
    const f = r.stack
    ;(r.stack = []), (o = r.enter('autolink'))
    let h = a.move('<')
    return (
      (h += a.move(r.containerPhrasing(e, { before: h, after: '>', ...a.current() }))),
      (h += a.move('>')),
      o(),
      (r.stack = f),
      h
    )
  }
  ;(o = r.enter('link')), (u = r.enter('label'))
  let c = a.move('[')
  return (
    (c += a.move(r.containerPhrasing(e, { before: c, after: '](', ...a.current() }))),
    (c += a.move('](')),
    u(),
    (!e.url && e.title) || /[\0- \u007F]/.test(e.url)
      ? ((u = r.enter('destinationLiteral')),
        (c += a.move('<')),
        (c += a.move(r.safe(e.url, { before: c, after: '>', ...a.current() }))),
        (c += a.move('>')))
      : ((u = r.enter('destinationRaw')),
        (c += a.move(r.safe(e.url, { before: c, after: e.title ? ' ' : ')', ...a.current() })))),
    u(),
    e.title &&
      ((u = r.enter(`title${s}`)),
      (c += a.move(' ' + n)),
      (c += a.move(r.safe(e.title, { before: c, after: n, ...a.current() }))),
      (c += a.move(n)),
      u()),
    (c += a.move(')')),
    o(),
    c
  )
}
function kA(e, t, r) {
  return E1(e, r) ? '<' : '['
}
T1.peek = wA
function T1(e, t, r, i) {
  const n = e.referenceType,
    s = r.enter('linkReference')
  let a = r.enter('label')
  const o = r.createTracker(i)
  let u = o.move('[')
  const c = r.containerPhrasing(e, { before: u, after: ']', ...o.current() })
  ;(u += o.move(c + '][')), a()
  const f = r.stack
  ;(r.stack = []), (a = r.enter('reference'))
  const h = r.safe(r.associationId(e), { before: u, after: ']', ...o.current() })
  return (
    a(),
    (r.stack = f),
    s(),
    n === 'full' || !c || c !== h
      ? (u += o.move(h + ']'))
      : n === 'shortcut'
      ? (u = u.slice(0, -1))
      : (u += o.move(']')),
    u
  )
}
function wA() {
  return '['
}
function up(e) {
  const t = e.options.bullet || '*'
  if (t !== '*' && t !== '+' && t !== '-')
    throw new Error(
      'Cannot serialize items with `' + t + '` for `options.bullet`, expected `*`, `+`, or `-`'
    )
  return t
}
function NA(e) {
  const t = up(e),
    r = e.options.bulletOther
  if (!r) return t === '*' ? '-' : '*'
  if (r !== '*' && r !== '+' && r !== '-')
    throw new Error(
      'Cannot serialize items with `' + r + '` for `options.bulletOther`, expected `*`, `+`, or `-`'
    )
  if (r === t)
    throw new Error(
      'Expected `bullet` (`' + t + '`) and `bulletOther` (`' + r + '`) to be different'
    )
  return r
}
function OA(e) {
  const t = e.options.bulletOrdered || '.'
  if (t !== '.' && t !== ')')
    throw new Error(
      'Cannot serialize items with `' + t + '` for `options.bulletOrdered`, expected `.` or `)`'
    )
  return t
}
function A1(e) {
  const t = e.options.rule || '*'
  if (t !== '*' && t !== '-' && t !== '_')
    throw new Error(
      'Cannot serialize rules with `' + t + '` for `options.rule`, expected `*`, `-`, or `_`'
    )
  return t
}
function IA(e, t, r, i) {
  const n = r.enter('list'),
    s = r.bulletCurrent
  let a = e.ordered ? OA(r) : up(r)
  const o = e.ordered ? (a === '.' ? ')' : '.') : NA(r)
  let u = t && r.bulletLastUsed ? a === r.bulletLastUsed : !1
  if (!e.ordered) {
    const f = e.children ? e.children[0] : void 0
    if (
      ((a === '*' || a === '-') &&
        f &&
        (!f.children || !f.children[0]) &&
        r.stack[r.stack.length - 1] === 'list' &&
        r.stack[r.stack.length - 2] === 'listItem' &&
        r.stack[r.stack.length - 3] === 'list' &&
        r.stack[r.stack.length - 4] === 'listItem' &&
        r.indexStack[r.indexStack.length - 1] === 0 &&
        r.indexStack[r.indexStack.length - 2] === 0 &&
        r.indexStack[r.indexStack.length - 3] === 0 &&
        (u = !0),
      A1(r) === a && f)
    ) {
      let h = -1
      for (; ++h < e.children.length; ) {
        const p = e.children[h]
        if (
          p &&
          p.type === 'listItem' &&
          p.children &&
          p.children[0] &&
          p.children[0].type === 'thematicBreak'
        ) {
          u = !0
          break
        }
      }
    }
  }
  u && (a = o), (r.bulletCurrent = a)
  const c = r.containerFlow(e, i)
  return (r.bulletLastUsed = a), (r.bulletCurrent = s), n(), c
}
function DA(e) {
  const t = e.options.listItemIndent || 'one'
  if (t !== 'tab' && t !== 'one' && t !== 'mixed')
    throw new Error(
      'Cannot serialize items with `' +
        t +
        '` for `options.listItemIndent`, expected `tab`, `one`, or `mixed`'
    )
  return t
}
function RA(e, t, r, i) {
  const n = DA(r)
  let s = r.bulletCurrent || up(r)
  t &&
    t.type === 'list' &&
    t.ordered &&
    (s =
      (typeof t.start == 'number' && t.start > -1 ? t.start : 1) +
      (r.options.incrementListMarker === !1 ? 0 : t.children.indexOf(e)) +
      s)
  let a = s.length + 1
  ;(n === 'tab' || (n === 'mixed' && ((t && t.type === 'list' && t.spread) || e.spread))) &&
    (a = Math.ceil(a / 4) * 4)
  const o = r.createTracker(i)
  o.move(s + ' '.repeat(a - s.length)), o.shift(a)
  const u = r.enter('listItem'),
    c = r.indentLines(r.containerFlow(e, o.current()), f)
  return u(), c
  function f(h, p, m) {
    return p ? (m ? '' : ' '.repeat(a)) + h : (m ? s : s + ' '.repeat(a - s.length)) + h
  }
}
function LA(e, t, r, i) {
  const n = r.enter('paragraph'),
    s = r.enter('phrasing'),
    a = r.containerPhrasing(e, i)
  return s(), n(), a
}
const PA = uu([
  'break',
  'delete',
  'emphasis',
  'footnote',
  'footnoteReference',
  'image',
  'imageReference',
  'inlineCode',
  'link',
  'linkReference',
  'strong',
  'text',
])
function BA(e, t, r, i) {
  return (
    e.children.some(function (a) {
      return PA(a)
    })
      ? r.containerPhrasing
      : r.containerFlow
  ).call(r, e, i)
}
function FA(e) {
  const t = e.options.strong || '*'
  if (t !== '*' && t !== '_')
    throw new Error(
      'Cannot serialize strong with `' + t + '` for `options.strong`, expected `*`, or `_`'
    )
  return t
}
S1.peek = MA
function S1(e, t, r, i) {
  const n = FA(r),
    s = r.enter('strong'),
    a = r.createTracker(i)
  let o = a.move(n + n)
  return (
    (o += a.move(r.containerPhrasing(e, { before: o, after: n, ...a.current() }))),
    (o += a.move(n + n)),
    s(),
    o
  )
}
function MA(e, t, r) {
  return r.options.strong || '*'
}
function UA(e, t, r, i) {
  return r.safe(e.value, i)
}
function HA(e) {
  const t = e.options.ruleRepetition || 3
  if (t < 3)
    throw new Error(
      'Cannot serialize rules with repetition `' +
        t +
        '` for `options.ruleRepetition`, expected `3` or more'
    )
  return t
}
function zA(e, t, r) {
  const i = (A1(r) + (r.options.ruleSpaces ? ' ' : '')).repeat(HA(r))
  return r.options.ruleSpaces ? i.slice(0, -1) : i
}
const C1 = {
  blockquote: cA,
  break: Sm,
  code: gA,
  definition: yA,
  emphasis: g1,
  hardBreak: Sm,
  heading: xA,
  html: b1,
  image: y1,
  imageReference: _1,
  inlineCode: v1,
  link: x1,
  linkReference: T1,
  list: IA,
  listItem: RA,
  paragraph: LA,
  root: BA,
  strong: S1,
  text: UA,
  thematicBreak: zA,
}
function jA() {
  return {
    enter: { table: qA, tableData: Cm, tableHeader: Cm, tableRow: VA },
    exit: { codeText: GA, table: $A, tableData: ml, tableHeader: ml, tableRow: ml },
  }
}
function qA(e) {
  const t = e._align
  this.enter(
    {
      type: 'table',
      align: t.map(function (r) {
        return r === 'none' ? null : r
      }),
      children: [],
    },
    e
  ),
    (this.data.inTable = !0)
}
function $A(e) {
  this.exit(e), (this.data.inTable = void 0)
}
function VA(e) {
  this.enter({ type: 'tableRow', children: [] }, e)
}
function ml(e) {
  this.exit(e)
}
function Cm(e) {
  this.enter({ type: 'tableCell', children: [] }, e)
}
function GA(e) {
  let t = this.resume()
  this.data.inTable && (t = t.replace(/\\([\\|])/g, XA))
  const r = this.stack[this.stack.length - 1]
  r.type, (r.value = t), this.exit(e)
}
function XA(e, t) {
  return t === '|' ? t : e
}
function YA(e) {
  const t = e || {},
    r = t.tableCellPadding,
    i = t.tablePipeAlign,
    n = t.stringLength,
    s = r ? ' ' : '|'
  return {
    unsafe: [
      { character: '\r', inConstruct: 'tableCell' },
      {
        character: `
`,
        inConstruct: 'tableCell',
      },
      { atBreak: !0, character: '|', after: '[	 :-]' },
      { character: '|', inConstruct: 'tableCell' },
      { atBreak: !0, character: ':', after: '-' },
      { atBreak: !0, character: '-', after: '[:|-]' },
    ],
    handlers: { inlineCode: p, table: a, tableCell: u, tableRow: o },
  }
  function a(m, v, b, S) {
    return c(f(m, b, S), m.align)
  }
  function o(m, v, b, S) {
    const g = h(m, b, S),
      _ = c([g])
    return _.slice(
      0,
      _.indexOf(`
`)
    )
  }
  function u(m, v, b, S) {
    const g = b.enter('tableCell'),
      _ = b.enter('phrasing'),
      y = b.containerPhrasing(m, { ...S, before: s, after: s })
    return _(), g(), y
  }
  function c(m, v) {
    return aA(m, { align: v, alignDelimiters: i, padding: r, stringLength: n })
  }
  function f(m, v, b) {
    const S = m.children
    let g = -1
    const _ = [],
      y = v.enter('table')
    for (; ++g < S.length; ) _[g] = h(S[g], v, b)
    return y(), _
  }
  function h(m, v, b) {
    const S = m.children
    let g = -1
    const _ = [],
      y = v.enter('tableRow')
    for (; ++g < S.length; ) _[g] = u(S[g], m, v, b)
    return y(), _
  }
  function p(m, v, b) {
    let S = C1.inlineCode(m, v, b)
    return b.stack.includes('tableCell') && (S = S.replace(/\|/g, '\\$&')), S
  }
}
function WA() {
  return { exit: { taskListCheckValueChecked: km, taskListCheckValueUnchecked: km, paragraph: KA } }
}
function QA() {
  return { unsafe: [{ atBreak: !0, character: '-', after: '[:|-]' }], handlers: { listItem: JA } }
}
function km(e) {
  const t = this.stack[this.stack.length - 2]
  t.type, (t.checked = e.type === 'taskListCheckValueChecked')
}
function KA(e) {
  const t = this.stack[this.stack.length - 2]
  if (t && t.type === 'listItem' && typeof t.checked == 'boolean') {
    const r = this.stack[this.stack.length - 1]
    r.type
    const i = r.children[0]
    if (i && i.type === 'text') {
      const n = t.children
      let s = -1,
        a
      for (; ++s < n.length; ) {
        const o = n[s]
        if (o.type === 'paragraph') {
          a = o
          break
        }
      }
      a === r &&
        ((i.value = i.value.slice(1)),
        i.value.length === 0
          ? r.children.shift()
          : r.position &&
            i.position &&
            typeof i.position.start.offset == 'number' &&
            (i.position.start.column++,
            i.position.start.offset++,
            (r.position.start = Object.assign({}, i.position.start))))
    }
  }
  this.exit(e)
}
function JA(e, t, r, i) {
  const n = e.children[0],
    s = typeof e.checked == 'boolean' && n && n.type === 'paragraph',
    a = '[' + (e.checked ? 'x' : ' ') + '] ',
    o = r.createTracker(i)
  s && o.move(a)
  let u = C1.listItem(e, t, r, { ...i, ...o.current() })
  return s && (u = u.replace(/^(?:[*+-]|\d+\.)([\r\n]| {1,3})/, c)), u
  function c(f) {
    return f + a
  }
}
function ZA() {
  return [N2(), z2(), tA(), jA(), WA()]
}
function eS(e) {
  return { extensions: [O2(), j2(), rA(), YA(e), QA()] }
}
const tS = { tokenize: oS, partial: !0 },
  k1 = { tokenize: uS, partial: !0 },
  w1 = { tokenize: lS, partial: !0 },
  N1 = { tokenize: cS, partial: !0 },
  rS = { tokenize: fS, partial: !0 },
  O1 = { tokenize: sS, previous: D1 },
  I1 = { tokenize: aS, previous: R1 },
  Fr = { tokenize: nS, previous: L1 },
  vr = {}
function iS() {
  return { text: vr }
}
let gi = 48
for (; gi < 123; ) (vr[gi] = Fr), gi++, gi === 58 ? (gi = 65) : gi === 91 && (gi = 97)
vr[43] = Fr
vr[45] = Fr
vr[46] = Fr
vr[95] = Fr
vr[72] = [Fr, I1]
vr[104] = [Fr, I1]
vr[87] = [Fr, O1]
vr[119] = [Fr, O1]
function nS(e, t, r) {
  const i = this
  let n, s
  return a
  function a(h) {
    return !Ic(h) || !L1.call(i, i.previous) || lp(i.events)
      ? r(h)
      : (e.enter('literalAutolink'), e.enter('literalAutolinkEmail'), o(h))
  }
  function o(h) {
    return Ic(h) ? (e.consume(h), o) : h === 64 ? (e.consume(h), u) : r(h)
  }
  function u(h) {
    return h === 46
      ? e.check(rS, f, c)(h)
      : h === 45 || h === 95 || ht(h)
      ? ((s = !0), e.consume(h), u)
      : f(h)
  }
  function c(h) {
    return e.consume(h), (n = !0), u
  }
  function f(h) {
    return s && n && bt(i.previous)
      ? (e.exit('literalAutolinkEmail'), e.exit('literalAutolink'), t(h))
      : r(h)
  }
}
function sS(e, t, r) {
  const i = this
  return n
  function n(a) {
    return (a !== 87 && a !== 119) || !D1.call(i, i.previous) || lp(i.events)
      ? r(a)
      : (e.enter('literalAutolink'),
        e.enter('literalAutolinkWww'),
        e.check(tS, e.attempt(k1, e.attempt(w1, s), r), r)(a))
  }
  function s(a) {
    return e.exit('literalAutolinkWww'), e.exit('literalAutolink'), t(a)
  }
}
function aS(e, t, r) {
  const i = this
  let n = '',
    s = !1
  return a
  function a(h) {
    return (h === 72 || h === 104) && R1.call(i, i.previous) && !lp(i.events)
      ? (e.enter('literalAutolink'),
        e.enter('literalAutolinkHttp'),
        (n += String.fromCodePoint(h)),
        e.consume(h),
        o)
      : r(h)
  }
  function o(h) {
    if (bt(h) && n.length < 5) return (n += String.fromCodePoint(h)), e.consume(h), o
    if (h === 58) {
      const p = n.toLowerCase()
      if (p === 'http' || p === 'https') return e.consume(h), u
    }
    return r(h)
  }
  function u(h) {
    return h === 47 ? (e.consume(h), s ? c : ((s = !0), u)) : r(h)
  }
  function c(h) {
    return h === null || Ro(h) || Pe(h) || Ri(h) || su(h)
      ? r(h)
      : e.attempt(k1, e.attempt(w1, f), r)(h)
  }
  function f(h) {
    return e.exit('literalAutolinkHttp'), e.exit('literalAutolink'), t(h)
  }
}
function oS(e, t, r) {
  let i = 0
  return n
  function n(a) {
    return (a === 87 || a === 119) && i < 3
      ? (i++, e.consume(a), n)
      : a === 46 && i === 3
      ? (e.consume(a), s)
      : r(a)
  }
  function s(a) {
    return a === null ? r(a) : t(a)
  }
}
function uS(e, t, r) {
  let i, n, s
  return a
  function a(c) {
    return c === 46 || c === 95
      ? e.check(N1, u, o)(c)
      : c === null || Pe(c) || Ri(c) || (c !== 45 && su(c))
      ? u(c)
      : ((s = !0), e.consume(c), a)
  }
  function o(c) {
    return c === 95 ? (i = !0) : ((n = i), (i = void 0)), e.consume(c), a
  }
  function u(c) {
    return n || i || !s ? r(c) : t(c)
  }
}
function lS(e, t) {
  let r = 0,
    i = 0
  return n
  function n(a) {
    return a === 40
      ? (r++, e.consume(a), n)
      : a === 41 && i < r
      ? s(a)
      : a === 33 ||
        a === 34 ||
        a === 38 ||
        a === 39 ||
        a === 41 ||
        a === 42 ||
        a === 44 ||
        a === 46 ||
        a === 58 ||
        a === 59 ||
        a === 60 ||
        a === 63 ||
        a === 93 ||
        a === 95 ||
        a === 126
      ? e.check(N1, t, s)(a)
      : a === null || Pe(a) || Ri(a)
      ? t(a)
      : (e.consume(a), n)
  }
  function s(a) {
    return a === 41 && i++, e.consume(a), n
  }
}
function cS(e, t, r) {
  return i
  function i(o) {
    return o === 33 ||
      o === 34 ||
      o === 39 ||
      o === 41 ||
      o === 42 ||
      o === 44 ||
      o === 46 ||
      o === 58 ||
      o === 59 ||
      o === 63 ||
      o === 95 ||
      o === 126
      ? (e.consume(o), i)
      : o === 38
      ? (e.consume(o), s)
      : o === 93
      ? (e.consume(o), n)
      : o === 60 || o === null || Pe(o) || Ri(o)
      ? t(o)
      : r(o)
  }
  function n(o) {
    return o === null || o === 40 || o === 91 || Pe(o) || Ri(o) ? t(o) : i(o)
  }
  function s(o) {
    return bt(o) ? a(o) : r(o)
  }
  function a(o) {
    return o === 59 ? (e.consume(o), i) : bt(o) ? (e.consume(o), a) : r(o)
  }
}
function fS(e, t, r) {
  return i
  function i(s) {
    return e.consume(s), n
  }
  function n(s) {
    return ht(s) ? r(s) : t(s)
  }
}
function D1(e) {
  return (
    e === null || e === 40 || e === 42 || e === 95 || e === 91 || e === 93 || e === 126 || Pe(e)
  )
}
function R1(e) {
  return !bt(e)
}
function L1(e) {
  return !(e === 47 || Ic(e))
}
function Ic(e) {
  return e === 43 || e === 45 || e === 46 || e === 95 || ht(e)
}
function lp(e) {
  let t = e.length,
    r = !1
  for (; t--; ) {
    const i = e[t][1]
    if ((i.type === 'labelLink' || i.type === 'labelImage') && !i._balanced) {
      r = !0
      break
    }
    if (i._gfmAutolinkLiteralWalkedInto) {
      r = !1
      break
    }
  }
  return e.length > 0 && !r && (e[e.length - 1][1]._gfmAutolinkLiteralWalkedInto = !0), r
}
const pS = { tokenize: vS, partial: !0 }
function hS() {
  return {
    document: { 91: { tokenize: bS, continuation: { tokenize: yS }, exit: _S } },
    text: { 91: { tokenize: gS }, 93: { add: 'after', tokenize: mS, resolveTo: dS } },
  }
}
function mS(e, t, r) {
  const i = this
  let n = i.events.length
  const s = i.parser.gfmFootnotes || (i.parser.gfmFootnotes = [])
  let a
  for (; n--; ) {
    const u = i.events[n][1]
    if (u.type === 'labelImage') {
      a = u
      break
    }
    if (
      u.type === 'gfmFootnoteCall' ||
      u.type === 'labelLink' ||
      u.type === 'label' ||
      u.type === 'image' ||
      u.type === 'link'
    )
      break
  }
  return o
  function o(u) {
    if (!a || !a._balanced) return r(u)
    const c = sr(i.sliceSerialize({ start: a.end, end: i.now() }))
    return c.codePointAt(0) !== 94 || !s.includes(c.slice(1))
      ? r(u)
      : (e.enter('gfmFootnoteCallLabelMarker'),
        e.consume(u),
        e.exit('gfmFootnoteCallLabelMarker'),
        t(u))
  }
}
function dS(e, t) {
  let r = e.length
  for (; r--; )
    if (e[r][1].type === 'labelImage' && e[r][0] === 'enter') {
      e[r][1]
      break
    }
  ;(e[r + 1][1].type = 'data'), (e[r + 3][1].type = 'gfmFootnoteCallLabelMarker')
  const i = {
      type: 'gfmFootnoteCall',
      start: Object.assign({}, e[r + 3][1].start),
      end: Object.assign({}, e[e.length - 1][1].end),
    },
    n = {
      type: 'gfmFootnoteCallMarker',
      start: Object.assign({}, e[r + 3][1].end),
      end: Object.assign({}, e[r + 3][1].end),
    }
  n.end.column++, n.end.offset++, n.end._bufferIndex++
  const s = {
      type: 'gfmFootnoteCallString',
      start: Object.assign({}, n.end),
      end: Object.assign({}, e[e.length - 1][1].start),
    },
    a = {
      type: 'chunkString',
      contentType: 'string',
      start: Object.assign({}, s.start),
      end: Object.assign({}, s.end),
    },
    o = [
      e[r + 1],
      e[r + 2],
      ['enter', i, t],
      e[r + 3],
      e[r + 4],
      ['enter', n, t],
      ['exit', n, t],
      ['enter', s, t],
      ['enter', a, t],
      ['exit', a, t],
      ['exit', s, t],
      e[e.length - 2],
      e[e.length - 1],
      ['exit', i, t],
    ]
  return e.splice(r, e.length - r + 1, ...o), e
}
function gS(e, t, r) {
  const i = this,
    n = i.parser.gfmFootnotes || (i.parser.gfmFootnotes = [])
  let s = 0,
    a
  return o
  function o(h) {
    return (
      e.enter('gfmFootnoteCall'),
      e.enter('gfmFootnoteCallLabelMarker'),
      e.consume(h),
      e.exit('gfmFootnoteCallLabelMarker'),
      u
    )
  }
  function u(h) {
    return h !== 94
      ? r(h)
      : (e.enter('gfmFootnoteCallMarker'),
        e.consume(h),
        e.exit('gfmFootnoteCallMarker'),
        e.enter('gfmFootnoteCallString'),
        (e.enter('chunkString').contentType = 'string'),
        c)
  }
  function c(h) {
    if (s > 999 || (h === 93 && !a) || h === null || h === 91 || Pe(h)) return r(h)
    if (h === 93) {
      e.exit('chunkString')
      const p = e.exit('gfmFootnoteCallString')
      return n.includes(sr(i.sliceSerialize(p)))
        ? (e.enter('gfmFootnoteCallLabelMarker'),
          e.consume(h),
          e.exit('gfmFootnoteCallLabelMarker'),
          e.exit('gfmFootnoteCall'),
          t)
        : r(h)
    }
    return Pe(h) || (a = !0), s++, e.consume(h), h === 92 ? f : c
  }
  function f(h) {
    return h === 91 || h === 92 || h === 93 ? (e.consume(h), s++, c) : c(h)
  }
}
function bS(e, t, r) {
  const i = this,
    n = i.parser.gfmFootnotes || (i.parser.gfmFootnotes = [])
  let s,
    a = 0,
    o
  return u
  function u(v) {
    return (
      (e.enter('gfmFootnoteDefinition')._container = !0),
      e.enter('gfmFootnoteDefinitionLabel'),
      e.enter('gfmFootnoteDefinitionLabelMarker'),
      e.consume(v),
      e.exit('gfmFootnoteDefinitionLabelMarker'),
      c
    )
  }
  function c(v) {
    return v === 94
      ? (e.enter('gfmFootnoteDefinitionMarker'),
        e.consume(v),
        e.exit('gfmFootnoteDefinitionMarker'),
        e.enter('gfmFootnoteDefinitionLabelString'),
        (e.enter('chunkString').contentType = 'string'),
        f)
      : r(v)
  }
  function f(v) {
    if (a > 999 || (v === 93 && !o) || v === null || v === 91 || Pe(v)) return r(v)
    if (v === 93) {
      e.exit('chunkString')
      const b = e.exit('gfmFootnoteDefinitionLabelString')
      return (
        (s = sr(i.sliceSerialize(b))),
        e.enter('gfmFootnoteDefinitionLabelMarker'),
        e.consume(v),
        e.exit('gfmFootnoteDefinitionLabelMarker'),
        e.exit('gfmFootnoteDefinitionLabel'),
        p
      )
    }
    return Pe(v) || (o = !0), a++, e.consume(v), v === 92 ? h : f
  }
  function h(v) {
    return v === 91 || v === 92 || v === 93 ? (e.consume(v), a++, f) : f(v)
  }
  function p(v) {
    return v === 58
      ? (e.enter('definitionMarker'),
        e.consume(v),
        e.exit('definitionMarker'),
        n.includes(s) || n.push(s),
        we(e, m, 'gfmFootnoteDefinitionWhitespace'))
      : r(v)
  }
  function m(v) {
    return t(v)
  }
}
function yS(e, t, r) {
  return e.check(sa, t, e.attempt(pS, t, r))
}
function _S(e) {
  e.exit('gfmFootnoteDefinition')
}
function vS(e, t, r) {
  const i = this
  return we(e, n, 'gfmFootnoteDefinitionIndent', 4 + 1)
  function n(s) {
    const a = i.events[i.events.length - 1]
    return a &&
      a[1].type === 'gfmFootnoteDefinitionIndent' &&
      a[2].sliceSerialize(a[1], !0).length === 4
      ? t(s)
      : r(s)
  }
}
function ES(e) {
  let r = (e || {}).singleTilde
  const i = { tokenize: s, resolveAll: n }
  return (
    r == null && (r = !0),
    { text: { 126: i }, insideSpan: { null: [i] }, attentionMarkers: { null: [126] } }
  )
  function n(a, o) {
    let u = -1
    for (; ++u < a.length; )
      if (
        a[u][0] === 'enter' &&
        a[u][1].type === 'strikethroughSequenceTemporary' &&
        a[u][1]._close
      ) {
        let c = u
        for (; c--; )
          if (
            a[c][0] === 'exit' &&
            a[c][1].type === 'strikethroughSequenceTemporary' &&
            a[c][1]._open &&
            a[u][1].end.offset - a[u][1].start.offset === a[c][1].end.offset - a[c][1].start.offset
          ) {
            ;(a[u][1].type = 'strikethroughSequence'), (a[c][1].type = 'strikethroughSequence')
            const f = {
                type: 'strikethrough',
                start: Object.assign({}, a[c][1].start),
                end: Object.assign({}, a[u][1].end),
              },
              h = {
                type: 'strikethroughText',
                start: Object.assign({}, a[c][1].end),
                end: Object.assign({}, a[u][1].start),
              },
              p = [
                ['enter', f, o],
                ['enter', a[c][1], o],
                ['exit', a[c][1], o],
                ['enter', h, o],
              ],
              m = o.parser.constructs.insideSpan.null
            m && Bt(p, p.length, 0, au(m, a.slice(c + 1, u), o)),
              Bt(p, p.length, 0, [
                ['exit', h, o],
                ['enter', a[u][1], o],
                ['exit', a[u][1], o],
                ['exit', f, o],
              ]),
              Bt(a, c - 1, u - c + 3, p),
              (u = c + p.length - 2)
            break
          }
      }
    for (u = -1; ++u < a.length; )
      a[u][1].type === 'strikethroughSequenceTemporary' && (a[u][1].type = 'data')
    return a
  }
  function s(a, o, u) {
    const c = this.previous,
      f = this.events
    let h = 0
    return p
    function p(v) {
      return c === 126 && f[f.length - 1][1].type !== 'characterEscape'
        ? u(v)
        : (a.enter('strikethroughSequenceTemporary'), m(v))
    }
    function m(v) {
      const b = Lo(c)
      if (v === 126) return h > 1 ? u(v) : (a.consume(v), h++, m)
      if (h < 2 && !r) return u(v)
      const S = a.exit('strikethroughSequenceTemporary'),
        g = Lo(v)
      return (S._open = !g || (g === 2 && !!b)), (S._close = !b || (b === 2 && !!g)), o(v)
    }
  }
}
class xS {
  constructor() {
    this.map = []
  }
  add(t, r, i) {
    TS(this, t, r, i)
  }
  consume(t) {
    if (
      (this.map.sort(function (s, a) {
        return s[0] - a[0]
      }),
      this.map.length === 0)
    )
      return
    let r = this.map.length
    const i = []
    for (; r > 0; )
      (r -= 1),
        i.push(t.slice(this.map[r][0] + this.map[r][1]), this.map[r][2]),
        (t.length = this.map[r][0])
    i.push([...t]), (t.length = 0)
    let n = i.pop()
    for (; n; ) t.push(...n), (n = i.pop())
    this.map.length = 0
  }
}
function TS(e, t, r, i) {
  let n = 0
  if (!(r === 0 && i.length === 0)) {
    for (; n < e.map.length; ) {
      if (e.map[n][0] === t) {
        ;(e.map[n][1] += r), e.map[n][2].push(...i)
        return
      }
      n += 1
    }
    e.map.push([t, r, i])
  }
}
function AS(e, t) {
  let r = !1
  const i = []
  for (; t < e.length; ) {
    const n = e[t]
    if (r) {
      if (n[0] === 'enter')
        n[1].type === 'tableContent' &&
          i.push(e[t + 1][1].type === 'tableDelimiterMarker' ? 'left' : 'none')
      else if (n[1].type === 'tableContent') {
        if (e[t - 1][1].type === 'tableDelimiterMarker') {
          const s = i.length - 1
          i[s] = i[s] === 'left' ? 'center' : 'right'
        }
      } else if (n[1].type === 'tableDelimiterRow') break
    } else n[0] === 'enter' && n[1].type === 'tableDelimiterRow' && (r = !0)
    t += 1
  }
  return i
}
function SS() {
  return { flow: { null: { tokenize: CS, resolveAll: kS } } }
}
function CS(e, t, r) {
  const i = this
  let n = 0,
    s = 0,
    a
  return o
  function o(O) {
    let N = i.events.length - 1
    for (; N > -1; ) {
      const j = i.events[N][1].type
      if (j === 'lineEnding' || j === 'linePrefix') N--
      else break
    }
    const M = N > -1 ? i.events[N][1].type : null,
      V = M === 'tableHead' || M === 'tableRow' ? C : u
    return V === C && i.parser.lazy[i.now().line] ? r(O) : V(O)
  }
  function u(O) {
    return e.enter('tableHead'), e.enter('tableRow'), c(O)
  }
  function c(O) {
    return O === 124 || ((a = !0), (s += 1)), f(O)
  }
  function f(O) {
    return O === null
      ? r(O)
      : ye(O)
      ? s > 1
        ? ((s = 0),
          (i.interrupt = !0),
          e.exit('tableRow'),
          e.enter('lineEnding'),
          e.consume(O),
          e.exit('lineEnding'),
          m)
        : r(O)
      : Ae(O)
      ? we(e, f, 'whitespace')(O)
      : ((s += 1),
        a && ((a = !1), (n += 1)),
        O === 124
          ? (e.enter('tableCellDivider'), e.consume(O), e.exit('tableCellDivider'), (a = !0), f)
          : (e.enter('data'), h(O)))
  }
  function h(O) {
    return O === null || O === 124 || Pe(O)
      ? (e.exit('data'), f(O))
      : (e.consume(O), O === 92 ? p : h)
  }
  function p(O) {
    return O === 92 || O === 124 ? (e.consume(O), h) : h(O)
  }
  function m(O) {
    return (
      (i.interrupt = !1),
      i.parser.lazy[i.now().line]
        ? r(O)
        : (e.enter('tableDelimiterRow'),
          (a = !1),
          Ae(O)
            ? we(
                e,
                v,
                'linePrefix',
                i.parser.constructs.disable.null.includes('codeIndented') ? void 0 : 4
              )(O)
            : v(O))
    )
  }
  function v(O) {
    return O === 45 || O === 58
      ? S(O)
      : O === 124
      ? ((a = !0), e.enter('tableCellDivider'), e.consume(O), e.exit('tableCellDivider'), b)
      : D(O)
  }
  function b(O) {
    return Ae(O) ? we(e, S, 'whitespace')(O) : S(O)
  }
  function S(O) {
    return O === 58
      ? ((s += 1),
        (a = !0),
        e.enter('tableDelimiterMarker'),
        e.consume(O),
        e.exit('tableDelimiterMarker'),
        g)
      : O === 45
      ? ((s += 1), g(O))
      : O === null || ye(O)
      ? x(O)
      : D(O)
  }
  function g(O) {
    return O === 45 ? (e.enter('tableDelimiterFiller'), _(O)) : D(O)
  }
  function _(O) {
    return O === 45
      ? (e.consume(O), _)
      : O === 58
      ? ((a = !0),
        e.exit('tableDelimiterFiller'),
        e.enter('tableDelimiterMarker'),
        e.consume(O),
        e.exit('tableDelimiterMarker'),
        y)
      : (e.exit('tableDelimiterFiller'), y(O))
  }
  function y(O) {
    return Ae(O) ? we(e, x, 'whitespace')(O) : x(O)
  }
  function x(O) {
    return O === 124
      ? v(O)
      : O === null || ye(O)
      ? !a || n !== s
        ? D(O)
        : (e.exit('tableDelimiterRow'), e.exit('tableHead'), t(O))
      : D(O)
  }
  function D(O) {
    return r(O)
  }
  function C(O) {
    return e.enter('tableRow'), H(O)
  }
  function H(O) {
    return O === 124
      ? (e.enter('tableCellDivider'), e.consume(O), e.exit('tableCellDivider'), H)
      : O === null || ye(O)
      ? (e.exit('tableRow'), t(O))
      : Ae(O)
      ? we(e, H, 'whitespace')(O)
      : (e.enter('data'), T(O))
  }
  function T(O) {
    return O === null || O === 124 || Pe(O)
      ? (e.exit('data'), H(O))
      : (e.consume(O), O === 92 ? k : T)
  }
  function k(O) {
    return O === 92 || O === 124 ? (e.consume(O), T) : T(O)
  }
}
function kS(e, t) {
  let r = -1,
    i = !0,
    n = 0,
    s = [0, 0, 0, 0],
    a = [0, 0, 0, 0],
    o = !1,
    u = 0,
    c,
    f,
    h
  const p = new xS()
  for (; ++r < e.length; ) {
    const m = e[r],
      v = m[1]
    m[0] === 'enter'
      ? v.type === 'tableHead'
        ? ((o = !1),
          u !== 0 && (wm(p, t, u, c, f), (f = void 0), (u = 0)),
          (c = { type: 'table', start: Object.assign({}, v.start), end: Object.assign({}, v.end) }),
          p.add(r, 0, [['enter', c, t]]))
        : v.type === 'tableRow' || v.type === 'tableDelimiterRow'
        ? ((i = !0),
          (h = void 0),
          (s = [0, 0, 0, 0]),
          (a = [0, r + 1, 0, 0]),
          o &&
            ((o = !1),
            (f = {
              type: 'tableBody',
              start: Object.assign({}, v.start),
              end: Object.assign({}, v.end),
            }),
            p.add(r, 0, [['enter', f, t]])),
          (n = v.type === 'tableDelimiterRow' ? 2 : f ? 3 : 1))
        : n &&
          (v.type === 'data' ||
            v.type === 'tableDelimiterMarker' ||
            v.type === 'tableDelimiterFiller')
        ? ((i = !1),
          a[2] === 0 &&
            (s[1] !== 0 && ((a[0] = a[1]), (h = Ba(p, t, s, n, void 0, h)), (s = [0, 0, 0, 0])),
            (a[2] = r)))
        : v.type === 'tableCellDivider' &&
          (i
            ? (i = !1)
            : (s[1] !== 0 && ((a[0] = a[1]), (h = Ba(p, t, s, n, void 0, h))),
              (s = a),
              (a = [s[1], r, 0, 0])))
      : v.type === 'tableHead'
      ? ((o = !0), (u = r))
      : v.type === 'tableRow' || v.type === 'tableDelimiterRow'
      ? ((u = r),
        s[1] !== 0
          ? ((a[0] = a[1]), (h = Ba(p, t, s, n, r, h)))
          : a[1] !== 0 && (h = Ba(p, t, a, n, r, h)),
        (n = 0))
      : n &&
        (v.type === 'data' ||
          v.type === 'tableDelimiterMarker' ||
          v.type === 'tableDelimiterFiller') &&
        (a[3] = r)
  }
  for (u !== 0 && wm(p, t, u, c, f), p.consume(t.events), r = -1; ++r < t.events.length; ) {
    const m = t.events[r]
    m[0] === 'enter' && m[1].type === 'table' && (m[1]._align = AS(t.events, r))
  }
  return e
}
function Ba(e, t, r, i, n, s) {
  const a = i === 1 ? 'tableHeader' : i === 2 ? 'tableDelimiter' : 'tableData',
    o = 'tableContent'
  r[0] !== 0 && ((s.end = Object.assign({}, Qi(t.events, r[0]))), e.add(r[0], 0, [['exit', s, t]]))
  const u = Qi(t.events, r[1])
  if (
    ((s = { type: a, start: Object.assign({}, u), end: Object.assign({}, u) }),
    e.add(r[1], 0, [['enter', s, t]]),
    r[2] !== 0)
  ) {
    const c = Qi(t.events, r[2]),
      f = Qi(t.events, r[3]),
      h = { type: o, start: Object.assign({}, c), end: Object.assign({}, f) }
    if ((e.add(r[2], 0, [['enter', h, t]]), i !== 2)) {
      const p = t.events[r[2]],
        m = t.events[r[3]]
      if (
        ((p[1].end = Object.assign({}, m[1].end)),
        (p[1].type = 'chunkText'),
        (p[1].contentType = 'text'),
        r[3] > r[2] + 1)
      ) {
        const v = r[2] + 1,
          b = r[3] - r[2] - 1
        e.add(v, b, [])
      }
    }
    e.add(r[3] + 1, 0, [['exit', h, t]])
  }
  return (
    n !== void 0 &&
      ((s.end = Object.assign({}, Qi(t.events, n))), e.add(n, 0, [['exit', s, t]]), (s = void 0)),
    s
  )
}
function wm(e, t, r, i, n) {
  const s = [],
    a = Qi(t.events, r)
  n && ((n.end = Object.assign({}, a)), s.push(['exit', n, t])),
    (i.end = Object.assign({}, a)),
    s.push(['exit', i, t]),
    e.add(r + 1, 0, s)
}
function Qi(e, t) {
  const r = e[t],
    i = r[0] === 'enter' ? 'start' : 'end'
  return r[1][i]
}
const wS = { tokenize: OS }
function NS() {
  return { text: { 91: wS } }
}
function OS(e, t, r) {
  const i = this
  return n
  function n(u) {
    return i.previous !== null || !i._gfmTasklistFirstContentOfListItem
      ? r(u)
      : (e.enter('taskListCheck'),
        e.enter('taskListCheckMarker'),
        e.consume(u),
        e.exit('taskListCheckMarker'),
        s)
  }
  function s(u) {
    return Pe(u)
      ? (e.enter('taskListCheckValueUnchecked'),
        e.consume(u),
        e.exit('taskListCheckValueUnchecked'),
        a)
      : u === 88 || u === 120
      ? (e.enter('taskListCheckValueChecked'), e.consume(u), e.exit('taskListCheckValueChecked'), a)
      : r(u)
  }
  function a(u) {
    return u === 93
      ? (e.enter('taskListCheckMarker'),
        e.consume(u),
        e.exit('taskListCheckMarker'),
        e.exit('taskListCheck'),
        o)
      : r(u)
  }
  function o(u) {
    return ye(u) ? t(u) : Ae(u) ? e.check({ tokenize: IS }, t, r)(u) : r(u)
  }
}
function IS(e, t, r) {
  return we(e, i, 'whitespace')
  function i(n) {
    return n === null ? r(n) : t(n)
  }
}
function DS(e) {
  return qg([iS(), hS(), ES(e), SS(), NS()])
}
const RS = {}
function LS(e) {
  const t = this,
    r = e || RS,
    i = t.data(),
    n = i.micromarkExtensions || (i.micromarkExtensions = []),
    s = i.fromMarkdownExtensions || (i.fromMarkdownExtensions = []),
    a = i.toMarkdownExtensions || (i.toMarkdownExtensions = [])
  n.push(DS(r)), s.push(ZA()), a.push(eS(r))
}
const PS = [
  'area',
  'base',
  'basefont',
  'bgsound',
  'br',
  'col',
  'command',
  'embed',
  'frame',
  'hr',
  'image',
  'img',
  'input',
  'keygen',
  'link',
  'meta',
  'param',
  'source',
  'track',
  'wbr',
]
class aa {
  constructor(t, r, i) {
    ;(this.property = t), (this.normal = r), i && (this.space = i)
  }
}
aa.prototype.property = {}
aa.prototype.normal = {}
aa.prototype.space = null
function P1(e, t) {
  const r = {},
    i = {}
  let n = -1
  for (; ++n < e.length; ) Object.assign(r, e[n].property), Object.assign(i, e[n].normal)
  return new aa(r, i, t)
}
function zs(e) {
  return e.toLowerCase()
}
class Kt {
  constructor(t, r) {
    ;(this.property = t), (this.attribute = r)
  }
}
Kt.prototype.space = null
Kt.prototype.boolean = !1
Kt.prototype.booleanish = !1
Kt.prototype.overloadedBoolean = !1
Kt.prototype.number = !1
Kt.prototype.commaSeparated = !1
Kt.prototype.spaceSeparated = !1
Kt.prototype.commaOrSpaceSeparated = !1
Kt.prototype.mustUseProperty = !1
Kt.prototype.defined = !1
let BS = 0
const Ee = ji(),
  Qe = ji(),
  B1 = ji(),
  le = ji(),
  Be = ji(),
  En = ji(),
  It = ji()
function ji() {
  return 2 ** ++BS
}
const Dc = Object.freeze(
    Object.defineProperty(
      {
        __proto__: null,
        boolean: Ee,
        booleanish: Qe,
        commaOrSpaceSeparated: It,
        commaSeparated: En,
        number: le,
        overloadedBoolean: B1,
        spaceSeparated: Be,
      },
      Symbol.toStringTag,
      { value: 'Module' }
    )
  ),
  dl = Object.keys(Dc)
class cp extends Kt {
  constructor(t, r, i, n) {
    let s = -1
    if ((super(t, r), Nm(this, 'space', n), typeof i == 'number'))
      for (; ++s < dl.length; ) {
        const a = dl[s]
        Nm(this, dl[s], (i & Dc[a]) === Dc[a])
      }
  }
}
cp.prototype.defined = !0
function Nm(e, t, r) {
  r && (e[t] = r)
}
const FS = {}.hasOwnProperty
function Un(e) {
  const t = {},
    r = {}
  let i
  for (i in e.properties)
    if (FS.call(e.properties, i)) {
      const n = e.properties[i],
        s = new cp(i, e.transform(e.attributes || {}, i), n, e.space)
      e.mustUseProperty && e.mustUseProperty.includes(i) && (s.mustUseProperty = !0),
        (t[i] = s),
        (r[zs(i)] = i),
        (r[zs(s.attribute)] = i)
    }
  return new aa(t, r, e.space)
}
const F1 = Un({
    space: 'xlink',
    transform(e, t) {
      return 'xlink:' + t.slice(5).toLowerCase()
    },
    properties: {
      xLinkActuate: null,
      xLinkArcRole: null,
      xLinkHref: null,
      xLinkRole: null,
      xLinkShow: null,
      xLinkTitle: null,
      xLinkType: null,
    },
  }),
  M1 = Un({
    space: 'xml',
    transform(e, t) {
      return 'xml:' + t.slice(3).toLowerCase()
    },
    properties: { xmlLang: null, xmlBase: null, xmlSpace: null },
  })
function U1(e, t) {
  return t in e ? e[t] : t
}
function H1(e, t) {
  return U1(e, t.toLowerCase())
}
const z1 = Un({
    space: 'xmlns',
    attributes: { xmlnsxlink: 'xmlns:xlink' },
    transform: H1,
    properties: { xmlns: null, xmlnsXLink: null },
  }),
  j1 = Un({
    transform(e, t) {
      return t === 'role' ? t : 'aria-' + t.slice(4).toLowerCase()
    },
    properties: {
      ariaActiveDescendant: null,
      ariaAtomic: Qe,
      ariaAutoComplete: null,
      ariaBusy: Qe,
      ariaChecked: Qe,
      ariaColCount: le,
      ariaColIndex: le,
      ariaColSpan: le,
      ariaControls: Be,
      ariaCurrent: null,
      ariaDescribedBy: Be,
      ariaDetails: null,
      ariaDisabled: Qe,
      ariaDropEffect: Be,
      ariaErrorMessage: null,
      ariaExpanded: Qe,
      ariaFlowTo: Be,
      ariaGrabbed: Qe,
      ariaHasPopup: null,
      ariaHidden: Qe,
      ariaInvalid: null,
      ariaKeyShortcuts: null,
      ariaLabel: null,
      ariaLabelledBy: Be,
      ariaLevel: le,
      ariaLive: null,
      ariaModal: Qe,
      ariaMultiLine: Qe,
      ariaMultiSelectable: Qe,
      ariaOrientation: null,
      ariaOwns: Be,
      ariaPlaceholder: null,
      ariaPosInSet: le,
      ariaPressed: Qe,
      ariaReadOnly: Qe,
      ariaRelevant: null,
      ariaRequired: Qe,
      ariaRoleDescription: Be,
      ariaRowCount: le,
      ariaRowIndex: le,
      ariaRowSpan: le,
      ariaSelected: Qe,
      ariaSetSize: le,
      ariaSort: null,
      ariaValueMax: le,
      ariaValueMin: le,
      ariaValueNow: le,
      ariaValueText: null,
      role: null,
    },
  }),
  MS = Un({
    space: 'html',
    attributes: {
      acceptcharset: 'accept-charset',
      classname: 'class',
      htmlfor: 'for',
      httpequiv: 'http-equiv',
    },
    transform: H1,
    mustUseProperty: ['checked', 'multiple', 'muted', 'selected'],
    properties: {
      abbr: null,
      accept: En,
      acceptCharset: Be,
      accessKey: Be,
      action: null,
      allow: null,
      allowFullScreen: Ee,
      allowPaymentRequest: Ee,
      allowUserMedia: Ee,
      alt: null,
      as: null,
      async: Ee,
      autoCapitalize: null,
      autoComplete: Be,
      autoFocus: Ee,
      autoPlay: Ee,
      blocking: Be,
      capture: Ee,
      charSet: null,
      checked: Ee,
      cite: null,
      className: Be,
      cols: le,
      colSpan: null,
      content: null,
      contentEditable: Qe,
      controls: Ee,
      controlsList: Be,
      coords: le | En,
      crossOrigin: null,
      data: null,
      dateTime: null,
      decoding: null,
      default: Ee,
      defer: Ee,
      dir: null,
      dirName: null,
      disabled: Ee,
      download: B1,
      draggable: Qe,
      encType: null,
      enterKeyHint: null,
      fetchPriority: null,
      form: null,
      formAction: null,
      formEncType: null,
      formMethod: null,
      formNoValidate: Ee,
      formTarget: null,
      headers: Be,
      height: le,
      hidden: Ee,
      high: le,
      href: null,
      hrefLang: null,
      htmlFor: Be,
      httpEquiv: Be,
      id: null,
      imageSizes: null,
      imageSrcSet: null,
      inert: Ee,
      inputMode: null,
      integrity: null,
      is: null,
      isMap: Ee,
      itemId: null,
      itemProp: Be,
      itemRef: Be,
      itemScope: Ee,
      itemType: Be,
      kind: null,
      label: null,
      lang: null,
      language: null,
      list: null,
      loading: null,
      loop: Ee,
      low: le,
      manifest: null,
      max: null,
      maxLength: le,
      media: null,
      method: null,
      min: null,
      minLength: le,
      multiple: Ee,
      muted: Ee,
      name: null,
      nonce: null,
      noModule: Ee,
      noValidate: Ee,
      onAbort: null,
      onAfterPrint: null,
      onAuxClick: null,
      onBeforeMatch: null,
      onBeforePrint: null,
      onBeforeUnload: null,
      onBlur: null,
      onCancel: null,
      onCanPlay: null,
      onCanPlayThrough: null,
      onChange: null,
      onClick: null,
      onClose: null,
      onContextLost: null,
      onContextMenu: null,
      onContextRestored: null,
      onCopy: null,
      onCueChange: null,
      onCut: null,
      onDblClick: null,
      onDrag: null,
      onDragEnd: null,
      onDragEnter: null,
      onDragExit: null,
      onDragLeave: null,
      onDragOver: null,
      onDragStart: null,
      onDrop: null,
      onDurationChange: null,
      onEmptied: null,
      onEnded: null,
      onError: null,
      onFocus: null,
      onFormData: null,
      onHashChange: null,
      onInput: null,
      onInvalid: null,
      onKeyDown: null,
      onKeyPress: null,
      onKeyUp: null,
      onLanguageChange: null,
      onLoad: null,
      onLoadedData: null,
      onLoadedMetadata: null,
      onLoadEnd: null,
      onLoadStart: null,
      onMessage: null,
      onMessageError: null,
      onMouseDown: null,
      onMouseEnter: null,
      onMouseLeave: null,
      onMouseMove: null,
      onMouseOut: null,
      onMouseOver: null,
      onMouseUp: null,
      onOffline: null,
      onOnline: null,
      onPageHide: null,
      onPageShow: null,
      onPaste: null,
      onPause: null,
      onPlay: null,
      onPlaying: null,
      onPopState: null,
      onProgress: null,
      onRateChange: null,
      onRejectionHandled: null,
      onReset: null,
      onResize: null,
      onScroll: null,
      onScrollEnd: null,
      onSecurityPolicyViolation: null,
      onSeeked: null,
      onSeeking: null,
      onSelect: null,
      onSlotChange: null,
      onStalled: null,
      onStorage: null,
      onSubmit: null,
      onSuspend: null,
      onTimeUpdate: null,
      onToggle: null,
      onUnhandledRejection: null,
      onUnload: null,
      onVolumeChange: null,
      onWaiting: null,
      onWheel: null,
      open: Ee,
      optimum: le,
      pattern: null,
      ping: Be,
      placeholder: null,
      playsInline: Ee,
      popover: null,
      popoverTarget: null,
      popoverTargetAction: null,
      poster: null,
      preload: null,
      readOnly: Ee,
      referrerPolicy: null,
      rel: Be,
      required: Ee,
      reversed: Ee,
      rows: le,
      rowSpan: le,
      sandbox: Be,
      scope: null,
      scoped: Ee,
      seamless: Ee,
      selected: Ee,
      shape: null,
      size: le,
      sizes: null,
      slot: null,
      span: le,
      spellCheck: Qe,
      src: null,
      srcDoc: null,
      srcLang: null,
      srcSet: null,
      start: le,
      step: null,
      style: null,
      tabIndex: le,
      target: null,
      title: null,
      translate: null,
      type: null,
      typeMustMatch: Ee,
      useMap: null,
      value: Qe,
      width: le,
      wrap: null,
      align: null,
      aLink: null,
      archive: Be,
      axis: null,
      background: null,
      bgColor: null,
      border: le,
      borderColor: null,
      bottomMargin: le,
      cellPadding: null,
      cellSpacing: null,
      char: null,
      charOff: null,
      classId: null,
      clear: null,
      code: null,
      codeBase: null,
      codeType: null,
      color: null,
      compact: Ee,
      declare: Ee,
      event: null,
      face: null,
      frame: null,
      frameBorder: null,
      hSpace: le,
      leftMargin: le,
      link: null,
      longDesc: null,
      lowSrc: null,
      marginHeight: le,
      marginWidth: le,
      noResize: Ee,
      noHref: Ee,
      noShade: Ee,
      noWrap: Ee,
      object: null,
      profile: null,
      prompt: null,
      rev: null,
      rightMargin: le,
      rules: null,
      scheme: null,
      scrolling: Qe,
      standby: null,
      summary: null,
      text: null,
      topMargin: le,
      valueType: null,
      version: null,
      vAlign: null,
      vLink: null,
      vSpace: le,
      allowTransparency: null,
      autoCorrect: null,
      autoSave: null,
      disablePictureInPicture: Ee,
      disableRemotePlayback: Ee,
      prefix: null,
      property: null,
      results: le,
      security: null,
      unselectable: null,
    },
  }),
  US = Un({
    space: 'svg',
    attributes: {
      accentHeight: 'accent-height',
      alignmentBaseline: 'alignment-baseline',
      arabicForm: 'arabic-form',
      baselineShift: 'baseline-shift',
      capHeight: 'cap-height',
      className: 'class',
      clipPath: 'clip-path',
      clipRule: 'clip-rule',
      colorInterpolation: 'color-interpolation',
      colorInterpolationFilters: 'color-interpolation-filters',
      colorProfile: 'color-profile',
      colorRendering: 'color-rendering',
      crossOrigin: 'crossorigin',
      dataType: 'datatype',
      dominantBaseline: 'dominant-baseline',
      enableBackground: 'enable-background',
      fillOpacity: 'fill-opacity',
      fillRule: 'fill-rule',
      floodColor: 'flood-color',
      floodOpacity: 'flood-opacity',
      fontFamily: 'font-family',
      fontSize: 'font-size',
      fontSizeAdjust: 'font-size-adjust',
      fontStretch: 'font-stretch',
      fontStyle: 'font-style',
      fontVariant: 'font-variant',
      fontWeight: 'font-weight',
      glyphName: 'glyph-name',
      glyphOrientationHorizontal: 'glyph-orientation-horizontal',
      glyphOrientationVertical: 'glyph-orientation-vertical',
      hrefLang: 'hreflang',
      horizAdvX: 'horiz-adv-x',
      horizOriginX: 'horiz-origin-x',
      horizOriginY: 'horiz-origin-y',
      imageRendering: 'image-rendering',
      letterSpacing: 'letter-spacing',
      lightingColor: 'lighting-color',
      markerEnd: 'marker-end',
      markerMid: 'marker-mid',
      markerStart: 'marker-start',
      navDown: 'nav-down',
      navDownLeft: 'nav-down-left',
      navDownRight: 'nav-down-right',
      navLeft: 'nav-left',
      navNext: 'nav-next',
      navPrev: 'nav-prev',
      navRight: 'nav-right',
      navUp: 'nav-up',
      navUpLeft: 'nav-up-left',
      navUpRight: 'nav-up-right',
      onAbort: 'onabort',
      onActivate: 'onactivate',
      onAfterPrint: 'onafterprint',
      onBeforePrint: 'onbeforeprint',
      onBegin: 'onbegin',
      onCancel: 'oncancel',
      onCanPlay: 'oncanplay',
      onCanPlayThrough: 'oncanplaythrough',
      onChange: 'onchange',
      onClick: 'onclick',
      onClose: 'onclose',
      onCopy: 'oncopy',
      onCueChange: 'oncuechange',
      onCut: 'oncut',
      onDblClick: 'ondblclick',
      onDrag: 'ondrag',
      onDragEnd: 'ondragend',
      onDragEnter: 'ondragenter',
      onDragExit: 'ondragexit',
      onDragLeave: 'ondragleave',
      onDragOver: 'ondragover',
      onDragStart: 'ondragstart',
      onDrop: 'ondrop',
      onDurationChange: 'ondurationchange',
      onEmptied: 'onemptied',
      onEnd: 'onend',
      onEnded: 'onended',
      onError: 'onerror',
      onFocus: 'onfocus',
      onFocusIn: 'onfocusin',
      onFocusOut: 'onfocusout',
      onHashChange: 'onhashchange',
      onInput: 'oninput',
      onInvalid: 'oninvalid',
      onKeyDown: 'onkeydown',
      onKeyPress: 'onkeypress',
      onKeyUp: 'onkeyup',
      onLoad: 'onload',
      onLoadedData: 'onloadeddata',
      onLoadedMetadata: 'onloadedmetadata',
      onLoadStart: 'onloadstart',
      onMessage: 'onmessage',
      onMouseDown: 'onmousedown',
      onMouseEnter: 'onmouseenter',
      onMouseLeave: 'onmouseleave',
      onMouseMove: 'onmousemove',
      onMouseOut: 'onmouseout',
      onMouseOver: 'onmouseover',
      onMouseUp: 'onmouseup',
      onMouseWheel: 'onmousewheel',
      onOffline: 'onoffline',
      onOnline: 'ononline',
      onPageHide: 'onpagehide',
      onPageShow: 'onpageshow',
      onPaste: 'onpaste',
      onPause: 'onpause',
      onPlay: 'onplay',
      onPlaying: 'onplaying',
      onPopState: 'onpopstate',
      onProgress: 'onprogress',
      onRateChange: 'onratechange',
      onRepeat: 'onrepeat',
      onReset: 'onreset',
      onResize: 'onresize',
      onScroll: 'onscroll',
      onSeeked: 'onseeked',
      onSeeking: 'onseeking',
      onSelect: 'onselect',
      onShow: 'onshow',
      onStalled: 'onstalled',
      onStorage: 'onstorage',
      onSubmit: 'onsubmit',
      onSuspend: 'onsuspend',
      onTimeUpdate: 'ontimeupdate',
      onToggle: 'ontoggle',
      onUnload: 'onunload',
      onVolumeChange: 'onvolumechange',
      onWaiting: 'onwaiting',
      onZoom: 'onzoom',
      overlinePosition: 'overline-position',
      overlineThickness: 'overline-thickness',
      paintOrder: 'paint-order',
      panose1: 'panose-1',
      pointerEvents: 'pointer-events',
      referrerPolicy: 'referrerpolicy',
      renderingIntent: 'rendering-intent',
      shapeRendering: 'shape-rendering',
      stopColor: 'stop-color',
      stopOpacity: 'stop-opacity',
      strikethroughPosition: 'strikethrough-position',
      strikethroughThickness: 'strikethrough-thickness',
      strokeDashArray: 'stroke-dasharray',
      strokeDashOffset: 'stroke-dashoffset',
      strokeLineCap: 'stroke-linecap',
      strokeLineJoin: 'stroke-linejoin',
      strokeMiterLimit: 'stroke-miterlimit',
      strokeOpacity: 'stroke-opacity',
      strokeWidth: 'stroke-width',
      tabIndex: 'tabindex',
      textAnchor: 'text-anchor',
      textDecoration: 'text-decoration',
      textRendering: 'text-rendering',
      transformOrigin: 'transform-origin',
      typeOf: 'typeof',
      underlinePosition: 'underline-position',
      underlineThickness: 'underline-thickness',
      unicodeBidi: 'unicode-bidi',
      unicodeRange: 'unicode-range',
      unitsPerEm: 'units-per-em',
      vAlphabetic: 'v-alphabetic',
      vHanging: 'v-hanging',
      vIdeographic: 'v-ideographic',
      vMathematical: 'v-mathematical',
      vectorEffect: 'vector-effect',
      vertAdvY: 'vert-adv-y',
      vertOriginX: 'vert-origin-x',
      vertOriginY: 'vert-origin-y',
      wordSpacing: 'word-spacing',
      writingMode: 'writing-mode',
      xHeight: 'x-height',
      playbackOrder: 'playbackorder',
      timelineBegin: 'timelinebegin',
    },
    transform: U1,
    properties: {
      about: It,
      accentHeight: le,
      accumulate: null,
      additive: null,
      alignmentBaseline: null,
      alphabetic: le,
      amplitude: le,
      arabicForm: null,
      ascent: le,
      attributeName: null,
      attributeType: null,
      azimuth: le,
      bandwidth: null,
      baselineShift: null,
      baseFrequency: null,
      baseProfile: null,
      bbox: null,
      begin: null,
      bias: le,
      by: null,
      calcMode: null,
      capHeight: le,
      className: Be,
      clip: null,
      clipPath: null,
      clipPathUnits: null,
      clipRule: null,
      color: null,
      colorInterpolation: null,
      colorInterpolationFilters: null,
      colorProfile: null,
      colorRendering: null,
      content: null,
      contentScriptType: null,
      contentStyleType: null,
      crossOrigin: null,
      cursor: null,
      cx: null,
      cy: null,
      d: null,
      dataType: null,
      defaultAction: null,
      descent: le,
      diffuseConstant: le,
      direction: null,
      display: null,
      dur: null,
      divisor: le,
      dominantBaseline: null,
      download: Ee,
      dx: null,
      dy: null,
      edgeMode: null,
      editable: null,
      elevation: le,
      enableBackground: null,
      end: null,
      event: null,
      exponent: le,
      externalResourcesRequired: null,
      fill: null,
      fillOpacity: le,
      fillRule: null,
      filter: null,
      filterRes: null,
      filterUnits: null,
      floodColor: null,
      floodOpacity: null,
      focusable: null,
      focusHighlight: null,
      fontFamily: null,
      fontSize: null,
      fontSizeAdjust: null,
      fontStretch: null,
      fontStyle: null,
      fontVariant: null,
      fontWeight: null,
      format: null,
      fr: null,
      from: null,
      fx: null,
      fy: null,
      g1: En,
      g2: En,
      glyphName: En,
      glyphOrientationHorizontal: null,
      glyphOrientationVertical: null,
      glyphRef: null,
      gradientTransform: null,
      gradientUnits: null,
      handler: null,
      hanging: le,
      hatchContentUnits: null,
      hatchUnits: null,
      height: null,
      href: null,
      hrefLang: null,
      horizAdvX: le,
      horizOriginX: le,
      horizOriginY: le,
      id: null,
      ideographic: le,
      imageRendering: null,
      initialVisibility: null,
      in: null,
      in2: null,
      intercept: le,
      k: le,
      k1: le,
      k2: le,
      k3: le,
      k4: le,
      kernelMatrix: It,
      kernelUnitLength: null,
      keyPoints: null,
      keySplines: null,
      keyTimes: null,
      kerning: null,
      lang: null,
      lengthAdjust: null,
      letterSpacing: null,
      lightingColor: null,
      limitingConeAngle: le,
      local: null,
      markerEnd: null,
      markerMid: null,
      markerStart: null,
      markerHeight: null,
      markerUnits: null,
      markerWidth: null,
      mask: null,
      maskContentUnits: null,
      maskUnits: null,
      mathematical: null,
      max: null,
      media: null,
      mediaCharacterEncoding: null,
      mediaContentEncodings: null,
      mediaSize: le,
      mediaTime: null,
      method: null,
      min: null,
      mode: null,
      name: null,
      navDown: null,
      navDownLeft: null,
      navDownRight: null,
      navLeft: null,
      navNext: null,
      navPrev: null,
      navRight: null,
      navUp: null,
      navUpLeft: null,
      navUpRight: null,
      numOctaves: null,
      observer: null,
      offset: null,
      onAbort: null,
      onActivate: null,
      onAfterPrint: null,
      onBeforePrint: null,
      onBegin: null,
      onCancel: null,
      onCanPlay: null,
      onCanPlayThrough: null,
      onChange: null,
      onClick: null,
      onClose: null,
      onCopy: null,
      onCueChange: null,
      onCut: null,
      onDblClick: null,
      onDrag: null,
      onDragEnd: null,
      onDragEnter: null,
      onDragExit: null,
      onDragLeave: null,
      onDragOver: null,
      onDragStart: null,
      onDrop: null,
      onDurationChange: null,
      onEmptied: null,
      onEnd: null,
      onEnded: null,
      onError: null,
      onFocus: null,
      onFocusIn: null,
      onFocusOut: null,
      onHashChange: null,
      onInput: null,
      onInvalid: null,
      onKeyDown: null,
      onKeyPress: null,
      onKeyUp: null,
      onLoad: null,
      onLoadedData: null,
      onLoadedMetadata: null,
      onLoadStart: null,
      onMessage: null,
      onMouseDown: null,
      onMouseEnter: null,
      onMouseLeave: null,
      onMouseMove: null,
      onMouseOut: null,
      onMouseOver: null,
      onMouseUp: null,
      onMouseWheel: null,
      onOffline: null,
      onOnline: null,
      onPageHide: null,
      onPageShow: null,
      onPaste: null,
      onPause: null,
      onPlay: null,
      onPlaying: null,
      onPopState: null,
      onProgress: null,
      onRateChange: null,
      onRepeat: null,
      onReset: null,
      onResize: null,
      onScroll: null,
      onSeeked: null,
      onSeeking: null,
      onSelect: null,
      onShow: null,
      onStalled: null,
      onStorage: null,
      onSubmit: null,
      onSuspend: null,
      onTimeUpdate: null,
      onToggle: null,
      onUnload: null,
      onVolumeChange: null,
      onWaiting: null,
      onZoom: null,
      opacity: null,
      operator: null,
      order: null,
      orient: null,
      orientation: null,
      origin: null,
      overflow: null,
      overlay: null,
      overlinePosition: le,
      overlineThickness: le,
      paintOrder: null,
      panose1: null,
      path: null,
      pathLength: le,
      patternContentUnits: null,
      patternTransform: null,
      patternUnits: null,
      phase: null,
      ping: Be,
      pitch: null,
      playbackOrder: null,
      pointerEvents: null,
      points: null,
      pointsAtX: le,
      pointsAtY: le,
      pointsAtZ: le,
      preserveAlpha: null,
      preserveAspectRatio: null,
      primitiveUnits: null,
      propagate: null,
      property: It,
      r: null,
      radius: null,
      referrerPolicy: null,
      refX: null,
      refY: null,
      rel: It,
      rev: It,
      renderingIntent: null,
      repeatCount: null,
      repeatDur: null,
      requiredExtensions: It,
      requiredFeatures: It,
      requiredFonts: It,
      requiredFormats: It,
      resource: null,
      restart: null,
      result: null,
      rotate: null,
      rx: null,
      ry: null,
      scale: null,
      seed: null,
      shapeRendering: null,
      side: null,
      slope: null,
      snapshotTime: null,
      specularConstant: le,
      specularExponent: le,
      spreadMethod: null,
      spacing: null,
      startOffset: null,
      stdDeviation: null,
      stemh: null,
      stemv: null,
      stitchTiles: null,
      stopColor: null,
      stopOpacity: null,
      strikethroughPosition: le,
      strikethroughThickness: le,
      string: null,
      stroke: null,
      strokeDashArray: It,
      strokeDashOffset: null,
      strokeLineCap: null,
      strokeLineJoin: null,
      strokeMiterLimit: le,
      strokeOpacity: le,
      strokeWidth: null,
      style: null,
      surfaceScale: le,
      syncBehavior: null,
      syncBehaviorDefault: null,
      syncMaster: null,
      syncTolerance: null,
      syncToleranceDefault: null,
      systemLanguage: It,
      tabIndex: le,
      tableValues: null,
      target: null,
      targetX: le,
      targetY: le,
      textAnchor: null,
      textDecoration: null,
      textRendering: null,
      textLength: null,
      timelineBegin: null,
      title: null,
      transformBehavior: null,
      type: null,
      typeOf: It,
      to: null,
      transform: null,
      transformOrigin: null,
      u1: null,
      u2: null,
      underlinePosition: le,
      underlineThickness: le,
      unicode: null,
      unicodeBidi: null,
      unicodeRange: null,
      unitsPerEm: le,
      values: null,
      vAlphabetic: le,
      vMathematical: le,
      vectorEffect: null,
      vHanging: le,
      vIdeographic: le,
      version: null,
      vertAdvY: le,
      vertOriginX: le,
      vertOriginY: le,
      viewBox: null,
      viewTarget: null,
      visibility: null,
      width: null,
      widths: null,
      wordSpacing: null,
      writingMode: null,
      x: null,
      x1: null,
      x2: null,
      xChannelSelector: null,
      xHeight: le,
      y: null,
      y1: null,
      y2: null,
      yChannelSelector: null,
      z: null,
      zoomAndPan: null,
    },
  }),
  HS = /^data[-\w.:]+$/i,
  Om = /-[a-z]/g,
  zS = /[A-Z]/g
function fp(e, t) {
  const r = zs(t)
  let i = t,
    n = Kt
  if (r in e.normal) return e.property[e.normal[r]]
  if (r.length > 4 && r.slice(0, 4) === 'data' && HS.test(t)) {
    if (t.charAt(4) === '-') {
      const s = t.slice(5).replace(Om, qS)
      i = 'data' + s.charAt(0).toUpperCase() + s.slice(1)
    } else {
      const s = t.slice(4)
      if (!Om.test(s)) {
        let a = s.replace(zS, jS)
        a.charAt(0) !== '-' && (a = '-' + a), (t = 'data' + a)
      }
    }
    n = cp
  }
  return new n(i, t)
}
function jS(e) {
  return '-' + e.toLowerCase()
}
function qS(e) {
  return e.charAt(1).toUpperCase()
}
const cu = P1([M1, F1, z1, j1, MS], 'html'),
  oa = P1([M1, F1, z1, j1, US], 'svg')
function $S(e, t) {
  if (((e = e.replace(t.subset ? VS(t.subset) : /["&'<>`]/g, i)), t.subset || t.escapeOnly))
    return e
  return e
    .replace(/[\uD800-\uDBFF][\uDC00-\uDFFF]/g, r)
    .replace(/[\x01-\t\v\f\x0E-\x1F\x7F\x81\x8D\x8F\x90\x9D\xA0-\uFFFF]/g, i)
  function r(n, s, a) {
    return t.format(
      (n.charCodeAt(0) - 55296) * 1024 + n.charCodeAt(1) - 56320 + 65536,
      a.charCodeAt(s + 2),
      t
    )
  }
  function i(n, s, a) {
    return t.format(n.charCodeAt(0), a.charCodeAt(s + 1), t)
  }
}
function VS(e) {
  const t = []
  let r = -1
  for (; ++r < e.length; ) t.push(e[r].replace(/[|\\{}()[\]^$+*?.]/g, '\\$&'))
  return new RegExp('(?:' + t.join('|') + ')', 'g')
}
function GS(e, t, r) {
  const i = '&#x' + e.toString(16).toUpperCase()
  return r && t && !/[\dA-Fa-f]/.test(String.fromCharCode(t)) ? i : i + ';'
}
function XS(e, t, r) {
  const i = '&#' + String(e)
  return r && t && !/\d/.test(String.fromCharCode(t)) ? i : i + ';'
}
const YS = [
    'AElig',
    'AMP',
    'Aacute',
    'Acirc',
    'Agrave',
    'Aring',
    'Atilde',
    'Auml',
    'COPY',
    'Ccedil',
    'ETH',
    'Eacute',
    'Ecirc',
    'Egrave',
    'Euml',
    'GT',
    'Iacute',
    'Icirc',
    'Igrave',
    'Iuml',
    'LT',
    'Ntilde',
    'Oacute',
    'Ocirc',
    'Ograve',
    'Oslash',
    'Otilde',
    'Ouml',
    'QUOT',
    'REG',
    'THORN',
    'Uacute',
    'Ucirc',
    'Ugrave',
    'Uuml',
    'Yacute',
    'aacute',
    'acirc',
    'acute',
    'aelig',
    'agrave',
    'amp',
    'aring',
    'atilde',
    'auml',
    'brvbar',
    'ccedil',
    'cedil',
    'cent',
    'copy',
    'curren',
    'deg',
    'divide',
    'eacute',
    'ecirc',
    'egrave',
    'eth',
    'euml',
    'frac12',
    'frac14',
    'frac34',
    'gt',
    'iacute',
    'icirc',
    'iexcl',
    'igrave',
    'iquest',
    'iuml',
    'laquo',
    'lt',
    'macr',
    'micro',
    'middot',
    'nbsp',
    'not',
    'ntilde',
    'oacute',
    'ocirc',
    'ograve',
    'ordf',
    'ordm',
    'oslash',
    'otilde',
    'ouml',
    'para',
    'plusmn',
    'pound',
    'quot',
    'raquo',
    'reg',
    'sect',
    'shy',
    'sup1',
    'sup2',
    'sup3',
    'szlig',
    'thorn',
    'times',
    'uacute',
    'ucirc',
    'ugrave',
    'uml',
    'uuml',
    'yacute',
    'yen',
    'yuml',
  ],
  gl = {
    nbsp: '',
    iexcl: '',
    cent: '',
    pound: '',
    curren: '',
    yen: '',
    brvbar: '',
    sect: '',
    uml: '',
    copy: '',
    ordf: '',
    laquo: '',
    not: '',
    shy: '',
    reg: '',
    macr: '',
    deg: '',
    plusmn: '',
    sup2: '',
    sup3: '',
    acute: '',
    micro: '',
    para: '',
    middot: '',
    cedil: '',
    sup1: '',
    ordm: '',
    raquo: '',
    frac14: '',
    frac12: '',
    frac34: '',
    iquest: '',
    Agrave: '',
    Aacute: '',
    Acirc: '',
    Atilde: '',
    Auml: '',
    Aring: '',
    AElig: '',
    Ccedil: '',
    Egrave: '',
    Eacute: '',
    Ecirc: '',
    Euml: '',
    Igrave: '',
    Iacute: '',
    Icirc: '',
    Iuml: '',
    ETH: '',
    Ntilde: '',
    Ograve: '',
    Oacute: '',
    Ocirc: '',
    Otilde: '',
    Ouml: '',
    times: '',
    Oslash: '',
    Ugrave: '',
    Uacute: '',
    Ucirc: '',
    Uuml: '',
    Yacute: '',
    THORN: '',
    szlig: '',
    agrave: '',
    aacute: '',
    acirc: '',
    atilde: '',
    auml: '',
    aring: '',
    aelig: '',
    ccedil: '',
    egrave: '',
    eacute: '',
    ecirc: '',
    euml: '',
    igrave: '',
    iacute: '',
    icirc: '',
    iuml: '',
    eth: '',
    ntilde: '',
    ograve: '',
    oacute: '',
    ocirc: '',
    otilde: '',
    ouml: '',
    divide: '',
    oslash: '',
    ugrave: '',
    uacute: '',
    ucirc: '',
    uuml: '',
    yacute: '',
    thorn: '',
    yuml: '',
    fnof: '',
    Alpha: '',
    Beta: '',
    Gamma: '',
    Delta: '',
    Epsilon: '',
    Zeta: '',
    Eta: '',
    Theta: '',
    Iota: '',
    Kappa: '',
    Lambda: '',
    Mu: '',
    Nu: '',
    Xi: '',
    Omicron: '',
    Pi: '',
    Rho: '',
    Sigma: '',
    Tau: '',
    Upsilon: '',
    Phi: '',
    Chi: '',
    Psi: '',
    Omega: '',
    alpha: '',
    beta: '',
    gamma: '',
    delta: '',
    epsilon: '',
    zeta: '',
    eta: '',
    theta: '',
    iota: '',
    kappa: '',
    lambda: '',
    mu: '',
    nu: '',
    xi: '',
    omicron: '',
    pi: '',
    rho: '',
    sigmaf: '',
    sigma: '',
    tau: '',
    upsilon: '',
    phi: '',
    chi: '',
    psi: '',
    omega: '',
    thetasym: '',
    upsih: '',
    piv: '',
    bull: '',
    hellip: '',
    prime: '',
    Prime: '',
    oline: '',
    frasl: '',
    weierp: '',
    image: '',
    real: '',
    trade: '',
    alefsym: '',
    larr: '',
    uarr: '',
    rarr: '',
    darr: '',
    harr: '',
    crarr: '',
    lArr: '',
    uArr: '',
    rArr: '',
    dArr: '',
    hArr: '',
    forall: '',
    part: '',
    exist: '',
    empty: '',
    nabla: '',
    isin: '',
    notin: '',
    ni: '',
    prod: '',
    sum: '',
    minus: '',
    lowast: '',
    radic: '',
    prop: '',
    infin: '',
    ang: '',
    and: '',
    or: '',
    cap: '',
    cup: '',
    int: '',
    there4: '',
    sim: '',
    cong: '',
    asymp: '',
    ne: '',
    equiv: '',
    le: '',
    ge: '',
    sub: '',
    sup: '',
    nsub: '',
    sube: '',
    supe: '',
    oplus: '',
    otimes: '',
    perp: '',
    sdot: '',
    lceil: '',
    rceil: '',
    lfloor: '',
    rfloor: '',
    lang: '',
    rang: '',
    loz: '',
    spades: '',
    clubs: '',
    hearts: '',
    diams: '',
    quot: '"',
    amp: '&',
    lt: '<',
    gt: '>',
    OElig: '',
    oelig: '',
    Scaron: '',
    scaron: '',
    Yuml: '',
    circ: '',
    tilde: '',
    ensp: '',
    emsp: '',
    thinsp: '',
    zwnj: '',
    zwj: '',
    lrm: '',
    rlm: '',
    ndash: '',
    mdash: '',
    lsquo: '',
    rsquo: '',
    sbquo: '',
    ldquo: '',
    rdquo: '',
    bdquo: '',
    dagger: '',
    Dagger: '',
    permil: '',
    lsaquo: '',
    rsaquo: '',
    euro: '',
  },
  WS = ['cent', 'copy', 'divide', 'gt', 'lt', 'not', 'para', 'times'],
  q1 = {}.hasOwnProperty,
  Rc = {}
let Fa
for (Fa in gl) q1.call(gl, Fa) && (Rc[gl[Fa]] = Fa)
function QS(e, t, r, i) {
  const n = String.fromCharCode(e)
  if (q1.call(Rc, n)) {
    const s = Rc[n],
      a = '&' + s
    return r &&
      YS.includes(s) &&
      !WS.includes(s) &&
      (!i || (t && t !== 61 && /[^\da-z]/i.test(String.fromCharCode(t))))
      ? a
      : a + ';'
  }
  return ''
}
function KS(e, t, r) {
  let i = GS(e, t, r.omitOptionalSemicolons),
    n
  if (
    ((r.useNamedReferences || r.useShortestReferences) &&
      (n = QS(e, t, r.omitOptionalSemicolons, r.attribute)),
    (r.useShortestReferences || !n) && r.useShortestReferences)
  ) {
    const s = XS(e, t, r.omitOptionalSemicolons)
    s.length < i.length && (i = s)
  }
  return n && (!r.useShortestReferences || n.length < i.length) ? n : i
}
function xn(e, t) {
  return $S(e, Object.assign({ format: KS }, t))
}
function JS(e, t, r, i) {
  return i.settings.bogusComments
    ? '<?' + xn(e.value, Object.assign({}, i.settings.characterReferences, { subset: ['>'] })) + '>'
    : '<!--' + e.value.replace(/^>|^->|<!--|-->|--!>|<!-$/g, n) + '-->'
  function n(s) {
    return xn(s, Object.assign({}, i.settings.characterReferences, { subset: ['<', '>'] }))
  }
}
function ZS(e, t, r, i) {
  return (
    '<!' +
    (i.settings.upperDoctype ? 'DOCTYPE' : 'doctype') +
    (i.settings.tightDoctype ? '' : ' ') +
    'html>'
  )
}
function Im(e) {
  const t = [],
    r = String(e || '')
  let i = r.indexOf(','),
    n = 0,
    s = !1
  for (; !s; ) {
    i === -1 && ((i = r.length), (s = !0))
    const a = r.slice(n, i).trim()
    ;(a || !s) && t.push(a), (n = i + 1), (i = r.indexOf(',', n))
  }
  return t
}
function eC(e, t) {
  const r = t || {}
  return (e[e.length - 1] === '' ? [...e, ''] : e)
    .join((r.padRight ? ' ' : '') + ',' + (r.padLeft === !1 ? '' : ' '))
    .trim()
}
function Dm(e) {
  const t = String(e || '').trim()
  return t ? t.split(/[ \t\n\r\f]+/g) : []
}
function tC(e) {
  return e.join(' ').trim()
}
const rC = /[ \t\n\f\r]/g
function pp(e) {
  return typeof e == 'object' ? (e.type === 'text' ? Rm(e.value) : !1) : Rm(e)
}
function Rm(e) {
  return e.replace(rC, '') === ''
}
const et = V1(1),
  $1 = V1(-1),
  iC = []
function V1(e) {
  return t
  function t(r, i, n) {
    const s = r ? r.children : iC
    let a = (i || 0) + e,
      o = s[a]
    if (!n) for (; o && pp(o); ) (a += e), (o = s[a])
    return o
  }
}
const nC = {}.hasOwnProperty
function G1(e) {
  return t
  function t(r, i, n) {
    return nC.call(e, r.tagName) && e[r.tagName](r, i, n)
  }
}
const hp = G1({
  body: aC,
  caption: bl,
  colgroup: bl,
  dd: cC,
  dt: lC,
  head: bl,
  html: sC,
  li: uC,
  optgroup: fC,
  option: pC,
  p: oC,
  rp: Lm,
  rt: Lm,
  tbody: mC,
  td: Pm,
  tfoot: dC,
  th: Pm,
  thead: hC,
  tr: gC,
})
function bl(e, t, r) {
  const i = et(r, t, !0)
  return !i || (i.type !== 'comment' && !(i.type === 'text' && pp(i.value.charAt(0))))
}
function sC(e, t, r) {
  const i = et(r, t)
  return !i || i.type !== 'comment'
}
function aC(e, t, r) {
  const i = et(r, t)
  return !i || i.type !== 'comment'
}
function oC(e, t, r) {
  const i = et(r, t)
  return i
    ? i.type === 'element' &&
        (i.tagName === 'address' ||
          i.tagName === 'article' ||
          i.tagName === 'aside' ||
          i.tagName === 'blockquote' ||
          i.tagName === 'details' ||
          i.tagName === 'div' ||
          i.tagName === 'dl' ||
          i.tagName === 'fieldset' ||
          i.tagName === 'figcaption' ||
          i.tagName === 'figure' ||
          i.tagName === 'footer' ||
          i.tagName === 'form' ||
          i.tagName === 'h1' ||
          i.tagName === 'h2' ||
          i.tagName === 'h3' ||
          i.tagName === 'h4' ||
          i.tagName === 'h5' ||
          i.tagName === 'h6' ||
          i.tagName === 'header' ||
          i.tagName === 'hgroup' ||
          i.tagName === 'hr' ||
          i.tagName === 'main' ||
          i.tagName === 'menu' ||
          i.tagName === 'nav' ||
          i.tagName === 'ol' ||
          i.tagName === 'p' ||
          i.tagName === 'pre' ||
          i.tagName === 'section' ||
          i.tagName === 'table' ||
          i.tagName === 'ul')
    : !r ||
        !(
          r.type === 'element' &&
          (r.tagName === 'a' ||
            r.tagName === 'audio' ||
            r.tagName === 'del' ||
            r.tagName === 'ins' ||
            r.tagName === 'map' ||
            r.tagName === 'noscript' ||
            r.tagName === 'video')
        )
}
function uC(e, t, r) {
  const i = et(r, t)
  return !i || (i.type === 'element' && i.tagName === 'li')
}
function lC(e, t, r) {
  const i = et(r, t)
  return !!(i && i.type === 'element' && (i.tagName === 'dt' || i.tagName === 'dd'))
}
function cC(e, t, r) {
  const i = et(r, t)
  return !i || (i.type === 'element' && (i.tagName === 'dt' || i.tagName === 'dd'))
}
function Lm(e, t, r) {
  const i = et(r, t)
  return !i || (i.type === 'element' && (i.tagName === 'rp' || i.tagName === 'rt'))
}
function fC(e, t, r) {
  const i = et(r, t)
  return !i || (i.type === 'element' && i.tagName === 'optgroup')
}
function pC(e, t, r) {
  const i = et(r, t)
  return !i || (i.type === 'element' && (i.tagName === 'option' || i.tagName === 'optgroup'))
}
function hC(e, t, r) {
  const i = et(r, t)
  return !!(i && i.type === 'element' && (i.tagName === 'tbody' || i.tagName === 'tfoot'))
}
function mC(e, t, r) {
  const i = et(r, t)
  return !i || (i.type === 'element' && (i.tagName === 'tbody' || i.tagName === 'tfoot'))
}
function dC(e, t, r) {
  return !et(r, t)
}
function gC(e, t, r) {
  const i = et(r, t)
  return !i || (i.type === 'element' && i.tagName === 'tr')
}
function Pm(e, t, r) {
  const i = et(r, t)
  return !i || (i.type === 'element' && (i.tagName === 'td' || i.tagName === 'th'))
}
const bC = G1({ body: vC, colgroup: EC, head: _C, html: yC, tbody: xC })
function yC(e) {
  const t = et(e, -1)
  return !t || t.type !== 'comment'
}
function _C(e) {
  const t = e.children,
    r = []
  let i = -1
  for (; ++i < t.length; ) {
    const n = t[i]
    if (n.type === 'element' && (n.tagName === 'title' || n.tagName === 'base')) {
      if (r.includes(n.tagName)) return !1
      r.push(n.tagName)
    }
  }
  return t.length > 0
}
function vC(e) {
  const t = et(e, -1, !0)
  return (
    !t ||
    (t.type !== 'comment' &&
      !(t.type === 'text' && pp(t.value.charAt(0))) &&
      !(
        t.type === 'element' &&
        (t.tagName === 'meta' ||
          t.tagName === 'link' ||
          t.tagName === 'script' ||
          t.tagName === 'style' ||
          t.tagName === 'template')
      ))
  )
}
function EC(e, t, r) {
  const i = $1(r, t),
    n = et(e, -1, !0)
  return r &&
    i &&
    i.type === 'element' &&
    i.tagName === 'colgroup' &&
    hp(i, r.children.indexOf(i), r)
    ? !1
    : !!(n && n.type === 'element' && n.tagName === 'col')
}
function xC(e, t, r) {
  const i = $1(r, t),
    n = et(e, -1)
  return r &&
    i &&
    i.type === 'element' &&
    (i.tagName === 'thead' || i.tagName === 'tbody') &&
    hp(i, r.children.indexOf(i), r)
    ? !1
    : !!(n && n.type === 'element' && n.tagName === 'tr')
}
const Ma = {
  name: [
    [
      `	
\f\r &/=>`.split(''),
      `	
\f\r "&'/=>\``.split(''),
    ],
    [
      `\0	
\f\r "&'/<=>`.split(''),
      `\0	
\f\r "&'/<=>\``.split(''),
    ],
  ],
  unquoted: [
    [
      `	
\f\r &>`.split(''),
      `\0	
\f\r "&'<=>\``.split(''),
    ],
    [
      `\0	
\f\r "&'<=>\``.split(''),
      `\0	
\f\r "&'<=>\``.split(''),
    ],
  ],
  single: [
    ["&'".split(''), '"&\'`'.split('')],
    ["\0&'".split(''), '\0"&\'`'.split('')],
  ],
  double: [
    ['"&'.split(''), '"&\'`'.split('')],
    ['\0"&'.split(''), '\0"&\'`'.split('')],
  ],
}
function TC(e, t, r, i) {
  const n = i.schema,
    s = n.space === 'svg' ? !1 : i.settings.omitOptionalTags
  let a =
    n.space === 'svg'
      ? i.settings.closeEmptyElements
      : i.settings.voids.includes(e.tagName.toLowerCase())
  const o = []
  let u
  n.space === 'html' && e.tagName === 'svg' && (i.schema = oa)
  const c = AC(i, e.properties),
    f = i.all(n.space === 'html' && e.tagName === 'template' ? e.content : e)
  return (
    (i.schema = n),
    f && (a = !1),
    (c || !s || !bC(e, t, r)) &&
      (o.push('<', e.tagName, c ? ' ' + c : ''),
      a &&
        (n.space === 'svg' || i.settings.closeSelfClosing) &&
        ((u = c.charAt(c.length - 1)),
        (!i.settings.tightSelfClosing || u === '/' || (u && u !== '"' && u !== "'")) && o.push(' '),
        o.push('/')),
      o.push('>')),
    o.push(f),
    !a && (!s || !hp(e, t, r)) && o.push('</' + e.tagName + '>'),
    o.join('')
  )
}
function AC(e, t) {
  const r = []
  let i = -1,
    n
  if (t) {
    for (n in t)
      if (t[n] !== null && t[n] !== void 0) {
        const s = SC(e, n, t[n])
        s && r.push(s)
      }
  }
  for (; ++i < r.length; ) {
    const s = e.settings.tightAttributes ? r[i].charAt(r[i].length - 1) : void 0
    i !== r.length - 1 && s !== '"' && s !== "'" && (r[i] += ' ')
  }
  return r.join('')
}
function SC(e, t, r) {
  const i = fp(e.schema, t),
    n = e.settings.allowParseErrors && e.schema.space === 'html' ? 0 : 1,
    s = e.settings.allowDangerousCharacters ? 0 : 1
  let a = e.quote,
    o
  if (
    (i.overloadedBoolean && (r === i.attribute || r === '')
      ? (r = !0)
      : (i.boolean || (i.overloadedBoolean && typeof r != 'string')) && (r = !!r),
    r == null || r === !1 || (typeof r == 'number' && Number.isNaN(r)))
  )
    return ''
  const u = xn(
    i.attribute,
    Object.assign({}, e.settings.characterReferences, { subset: Ma.name[n][s] })
  )
  return r === !0 ||
    ((r = Array.isArray(r)
      ? (i.commaSeparated ? eC : tC)(r, { padLeft: !e.settings.tightCommaSeparatedLists })
      : String(r)),
    e.settings.collapseEmptyAttributes && !r)
    ? u
    : (e.settings.preferUnquoted &&
        (o = xn(
          r,
          Object.assign({}, e.settings.characterReferences, {
            attribute: !0,
            subset: Ma.unquoted[n][s],
          })
        )),
      o !== r &&
        (e.settings.quoteSmart && Mo(r, a) > Mo(r, e.alternative) && (a = e.alternative),
        (o =
          a +
          xn(
            r,
            Object.assign({}, e.settings.characterReferences, {
              subset: (a === "'" ? Ma.single : Ma.double)[n][s],
              attribute: !0,
            })
          ) +
          a)),
      u + (o && '=' + o))
}
function X1(e, t, r, i) {
  return r && r.type === 'element' && (r.tagName === 'script' || r.tagName === 'style')
    ? e.value
    : xn(e.value, Object.assign({}, i.settings.characterReferences, { subset: ['<', '&'] }))
}
function CC(e, t, r, i) {
  return i.settings.allowDangerousHtml ? e.value : X1(e, t, r, i)
}
function kC(e, t, r, i) {
  return i.all(e)
}
const wC = lA('type', {
  invalid: NC,
  unknown: OC,
  handlers: { comment: JS, doctype: ZS, element: TC, raw: CC, root: kC, text: X1 },
})
function NC(e) {
  throw new Error('Expected node, not `' + e + '`')
}
function OC(e) {
  const t = e
  throw new Error('Cannot compile unknown node `' + t.type + '`')
}
const IC = {},
  DC = {},
  RC = []
function LC(e, t) {
  const r = t || IC,
    i = r.quote || '"',
    n = i === '"' ? "'" : '"'
  if (i !== '"' && i !== "'") throw new Error('Invalid quote `' + i + '`, expected `\'` or `"`')
  return {
    one: PC,
    all: BC,
    settings: {
      omitOptionalTags: r.omitOptionalTags || !1,
      allowParseErrors: r.allowParseErrors || !1,
      allowDangerousCharacters: r.allowDangerousCharacters || !1,
      quoteSmart: r.quoteSmart || !1,
      preferUnquoted: r.preferUnquoted || !1,
      tightAttributes: r.tightAttributes || !1,
      upperDoctype: r.upperDoctype || !1,
      tightDoctype: r.tightDoctype || !1,
      bogusComments: r.bogusComments || !1,
      tightCommaSeparatedLists: r.tightCommaSeparatedLists || !1,
      tightSelfClosing: r.tightSelfClosing || !1,
      collapseEmptyAttributes: r.collapseEmptyAttributes || !1,
      allowDangerousHtml: r.allowDangerousHtml || !1,
      voids: r.voids || PS,
      characterReferences: r.characterReferences || DC,
      closeSelfClosing: r.closeSelfClosing || !1,
      closeEmptyElements: r.closeEmptyElements || !1,
    },
    schema: r.space === 'svg' ? oa : cu,
    quote: i,
    alternative: n,
  }.one(Array.isArray(e) ? { type: 'root', children: e } : e, void 0, void 0)
}
function PC(e, t, r) {
  return wC(e, t, r, this)
}
function BC(e) {
  const t = [],
    r = (e && e.children) || RC
  let i = -1
  for (; ++i < r.length; ) t[i] = this.one(r[i], i, e)
  return t.join('')
}
function FC(e) {
  const t = this,
    r = { ...t.data('settings'), ...e }
  t.compiler = i
  function i(n) {
    return LC(n, r)
  }
}
var Lc = { exports: {} }
;(function (e, t) {
  var r =
      (typeof globalThis < 'u' && globalThis) ||
      (typeof self < 'u' && self) ||
      (typeof mn < 'u' && mn),
    i = (function () {
      function s() {
        ;(this.fetch = !1), (this.DOMException = r.DOMException)
      }
      return (s.prototype = r), new s()
    })()
  ;(function (s) {
    ;(function (a) {
      var o = (typeof s < 'u' && s) || (typeof self < 'u' && self) || (typeof o < 'u' && o),
        u = {
          searchParams: 'URLSearchParams' in o,
          iterable: 'Symbol' in o && 'iterator' in Symbol,
          blob:
            'FileReader' in o &&
            'Blob' in o &&
            (function () {
              try {
                return new Blob(), !0
              } catch {
                return !1
              }
            })(),
          formData: 'FormData' in o,
          arrayBuffer: 'ArrayBuffer' in o,
        }
      function c(R) {
        return R && DataView.prototype.isPrototypeOf(R)
      }
      if (u.arrayBuffer)
        var f = [
            '[object Int8Array]',
            '[object Uint8Array]',
            '[object Uint8ClampedArray]',
            '[object Int16Array]',
            '[object Uint16Array]',
            '[object Int32Array]',
            '[object Uint32Array]',
            '[object Float32Array]',
            '[object Float64Array]',
          ],
          h =
            ArrayBuffer.isView ||
            function (R) {
              return R && f.indexOf(Object.prototype.toString.call(R)) > -1
            }
      function p(R) {
        if (
          (typeof R != 'string' && (R = String(R)),
          /[^a-z0-9\-#$%&'*+.^_`|~!]/i.test(R) || R === '')
        )
          throw new TypeError('Invalid character in header field name: "' + R + '"')
        return R.toLowerCase()
      }
      function m(R) {
        return typeof R != 'string' && (R = String(R)), R
      }
      function v(R) {
        var $ = {
          next: function () {
            var L = R.shift()
            return { done: L === void 0, value: L }
          },
        }
        return (
          u.iterable &&
            ($[Symbol.iterator] = function () {
              return $
            }),
          $
        )
      }
      function b(R) {
        ;(this.map = {}),
          R instanceof b
            ? R.forEach(function ($, L) {
                this.append(L, $)
              }, this)
            : Array.isArray(R)
            ? R.forEach(function ($) {
                this.append($[0], $[1])
              }, this)
            : R &&
              Object.getOwnPropertyNames(R).forEach(function ($) {
                this.append($, R[$])
              }, this)
      }
      ;(b.prototype.append = function (R, $) {
        ;(R = p(R)), ($ = m($))
        var L = this.map[R]
        this.map[R] = L ? L + ', ' + $ : $
      }),
        (b.prototype.delete = function (R) {
          delete this.map[p(R)]
        }),
        (b.prototype.get = function (R) {
          return (R = p(R)), this.has(R) ? this.map[R] : null
        }),
        (b.prototype.has = function (R) {
          return this.map.hasOwnProperty(p(R))
        }),
        (b.prototype.set = function (R, $) {
          this.map[p(R)] = m($)
        }),
        (b.prototype.forEach = function (R, $) {
          for (var L in this.map) this.map.hasOwnProperty(L) && R.call($, this.map[L], L, this)
        }),
        (b.prototype.keys = function () {
          var R = []
          return (
            this.forEach(function ($, L) {
              R.push(L)
            }),
            v(R)
          )
        }),
        (b.prototype.values = function () {
          var R = []
          return (
            this.forEach(function ($) {
              R.push($)
            }),
            v(R)
          )
        }),
        (b.prototype.entries = function () {
          var R = []
          return (
            this.forEach(function ($, L) {
              R.push([L, $])
            }),
            v(R)
          )
        }),
        u.iterable && (b.prototype[Symbol.iterator] = b.prototype.entries)
      function S(R) {
        if (R.bodyUsed) return Promise.reject(new TypeError('Already read'))
        R.bodyUsed = !0
      }
      function g(R) {
        return new Promise(function ($, L) {
          ;(R.onload = function () {
            $(R.result)
          }),
            (R.onerror = function () {
              L(R.error)
            })
        })
      }
      function _(R) {
        var $ = new FileReader(),
          L = g($)
        return $.readAsArrayBuffer(R), L
      }
      function y(R) {
        var $ = new FileReader(),
          L = g($)
        return $.readAsText(R), L
      }
      function x(R) {
        for (var $ = new Uint8Array(R), L = new Array($.length), P = 0; P < $.length; P++)
          L[P] = String.fromCharCode($[P])
        return L.join('')
      }
      function D(R) {
        if (R.slice) return R.slice(0)
        var $ = new Uint8Array(R.byteLength)
        return $.set(new Uint8Array(R)), $.buffer
      }
      function C() {
        return (
          (this.bodyUsed = !1),
          (this._initBody = function (R) {
            ;(this.bodyUsed = this.bodyUsed),
              (this._bodyInit = R),
              R
                ? typeof R == 'string'
                  ? (this._bodyText = R)
                  : u.blob && Blob.prototype.isPrototypeOf(R)
                  ? (this._bodyBlob = R)
                  : u.formData && FormData.prototype.isPrototypeOf(R)
                  ? (this._bodyFormData = R)
                  : u.searchParams && URLSearchParams.prototype.isPrototypeOf(R)
                  ? (this._bodyText = R.toString())
                  : u.arrayBuffer && u.blob && c(R)
                  ? ((this._bodyArrayBuffer = D(R.buffer)),
                    (this._bodyInit = new Blob([this._bodyArrayBuffer])))
                  : u.arrayBuffer && (ArrayBuffer.prototype.isPrototypeOf(R) || h(R))
                  ? (this._bodyArrayBuffer = D(R))
                  : (this._bodyText = R = Object.prototype.toString.call(R))
                : (this._bodyText = ''),
              this.headers.get('content-type') ||
                (typeof R == 'string'
                  ? this.headers.set('content-type', 'text/plain;charset=UTF-8')
                  : this._bodyBlob && this._bodyBlob.type
                  ? this.headers.set('content-type', this._bodyBlob.type)
                  : u.searchParams &&
                    URLSearchParams.prototype.isPrototypeOf(R) &&
                    this.headers.set(
                      'content-type',
                      'application/x-www-form-urlencoded;charset=UTF-8'
                    ))
          }),
          u.blob &&
            ((this.blob = function () {
              var R = S(this)
              if (R) return R
              if (this._bodyBlob) return Promise.resolve(this._bodyBlob)
              if (this._bodyArrayBuffer) return Promise.resolve(new Blob([this._bodyArrayBuffer]))
              if (this._bodyFormData) throw new Error('could not read FormData body as blob')
              return Promise.resolve(new Blob([this._bodyText]))
            }),
            (this.arrayBuffer = function () {
              if (this._bodyArrayBuffer) {
                var R = S(this)
                return (
                  R ||
                  (ArrayBuffer.isView(this._bodyArrayBuffer)
                    ? Promise.resolve(
                        this._bodyArrayBuffer.buffer.slice(
                          this._bodyArrayBuffer.byteOffset,
                          this._bodyArrayBuffer.byteOffset + this._bodyArrayBuffer.byteLength
                        )
                      )
                    : Promise.resolve(this._bodyArrayBuffer))
                )
              } else return this.blob().then(_)
            })),
          (this.text = function () {
            var R = S(this)
            if (R) return R
            if (this._bodyBlob) return y(this._bodyBlob)
            if (this._bodyArrayBuffer) return Promise.resolve(x(this._bodyArrayBuffer))
            if (this._bodyFormData) throw new Error('could not read FormData body as text')
            return Promise.resolve(this._bodyText)
          }),
          u.formData &&
            (this.formData = function () {
              return this.text().then(O)
            }),
          (this.json = function () {
            return this.text().then(JSON.parse)
          }),
          this
        )
      }
      var H = ['DELETE', 'GET', 'HEAD', 'OPTIONS', 'POST', 'PUT']
      function T(R) {
        var $ = R.toUpperCase()
        return H.indexOf($) > -1 ? $ : R
      }
      function k(R, $) {
        if (!(this instanceof k))
          throw new TypeError(
            'Please use the "new" operator, this DOM object constructor cannot be called as a function.'
          )
        $ = $ || {}
        var L = $.body
        if (R instanceof k) {
          if (R.bodyUsed) throw new TypeError('Already read')
          ;(this.url = R.url),
            (this.credentials = R.credentials),
            $.headers || (this.headers = new b(R.headers)),
            (this.method = R.method),
            (this.mode = R.mode),
            (this.signal = R.signal),
            !L && R._bodyInit != null && ((L = R._bodyInit), (R.bodyUsed = !0))
        } else this.url = String(R)
        if (
          ((this.credentials = $.credentials || this.credentials || 'same-origin'),
          ($.headers || !this.headers) && (this.headers = new b($.headers)),
          (this.method = T($.method || this.method || 'GET')),
          (this.mode = $.mode || this.mode || null),
          (this.signal = $.signal || this.signal),
          (this.referrer = null),
          (this.method === 'GET' || this.method === 'HEAD') && L)
        )
          throw new TypeError('Body not allowed for GET or HEAD requests')
        if (
          (this._initBody(L),
          (this.method === 'GET' || this.method === 'HEAD') &&
            ($.cache === 'no-store' || $.cache === 'no-cache'))
        ) {
          var P = /([?&])_=[^&]*/
          if (P.test(this.url)) this.url = this.url.replace(P, '$1_=' + new Date().getTime())
          else {
            var Y = /\?/
            this.url += (Y.test(this.url) ? '&' : '?') + '_=' + new Date().getTime()
          }
        }
      }
      k.prototype.clone = function () {
        return new k(this, { body: this._bodyInit })
      }
      function O(R) {
        var $ = new FormData()
        return (
          R.trim()
            .split('&')
            .forEach(function (L) {
              if (L) {
                var P = L.split('='),
                  Y = P.shift().replace(/\+/g, ' '),
                  w = P.join('=').replace(/\+/g, ' ')
                $.append(decodeURIComponent(Y), decodeURIComponent(w))
              }
            }),
          $
        )
      }
      function N(R) {
        var $ = new b(),
          L = R.replace(/\r?\n[\t ]+/g, ' ')
        return (
          L.split('\r')
            .map(function (P) {
              return P.indexOf(`
`) === 0
                ? P.substr(1, P.length)
                : P
            })
            .forEach(function (P) {
              var Y = P.split(':'),
                w = Y.shift().trim()
              if (w) {
                var q = Y.join(':').trim()
                $.append(w, q)
              }
            }),
          $
        )
      }
      C.call(k.prototype)
      function M(R, $) {
        if (!(this instanceof M))
          throw new TypeError(
            'Please use the "new" operator, this DOM object constructor cannot be called as a function.'
          )
        $ || ($ = {}),
          (this.type = 'default'),
          (this.status = $.status === void 0 ? 200 : $.status),
          (this.ok = this.status >= 200 && this.status < 300),
          (this.statusText = $.statusText === void 0 ? '' : '' + $.statusText),
          (this.headers = new b($.headers)),
          (this.url = $.url || ''),
          this._initBody(R)
      }
      C.call(M.prototype),
        (M.prototype.clone = function () {
          return new M(this._bodyInit, {
            status: this.status,
            statusText: this.statusText,
            headers: new b(this.headers),
            url: this.url,
          })
        }),
        (M.error = function () {
          var R = new M(null, { status: 0, statusText: '' })
          return (R.type = 'error'), R
        })
      var V = [301, 302, 303, 307, 308]
      ;(M.redirect = function (R, $) {
        if (V.indexOf($) === -1) throw new RangeError('Invalid status code')
        return new M(null, { status: $, headers: { location: R } })
      }),
        (a.DOMException = o.DOMException)
      try {
        new a.DOMException()
      } catch {
        ;(a.DOMException = function ($, L) {
          ;(this.message = $), (this.name = L)
          var P = Error($)
          this.stack = P.stack
        }),
          (a.DOMException.prototype = Object.create(Error.prototype)),
          (a.DOMException.prototype.constructor = a.DOMException)
      }
      function j(R, $) {
        return new Promise(function (L, P) {
          var Y = new k(R, $)
          if (Y.signal && Y.signal.aborted) return P(new a.DOMException('Aborted', 'AbortError'))
          var w = new XMLHttpRequest()
          function q() {
            w.abort()
          }
          ;(w.onload = function () {
            var I = {
              status: w.status,
              statusText: w.statusText,
              headers: N(w.getAllResponseHeaders() || ''),
            }
            I.url = 'responseURL' in w ? w.responseURL : I.headers.get('X-Request-URL')
            var re = 'response' in w ? w.response : w.responseText
            setTimeout(function () {
              L(new M(re, I))
            }, 0)
          }),
            (w.onerror = function () {
              setTimeout(function () {
                P(new TypeError('Network request failed'))
              }, 0)
            }),
            (w.ontimeout = function () {
              setTimeout(function () {
                P(new TypeError('Network request failed'))
              }, 0)
            }),
            (w.onabort = function () {
              setTimeout(function () {
                P(new a.DOMException('Aborted', 'AbortError'))
              }, 0)
            })
          function X(I) {
            try {
              return I === '' && o.location.href ? o.location.href : I
            } catch {
              return I
            }
          }
          w.open(Y.method, X(Y.url), !0),
            Y.credentials === 'include'
              ? (w.withCredentials = !0)
              : Y.credentials === 'omit' && (w.withCredentials = !1),
            'responseType' in w &&
              (u.blob
                ? (w.responseType = 'blob')
                : u.arrayBuffer &&
                  Y.headers.get('Content-Type') &&
                  Y.headers.get('Content-Type').indexOf('application/octet-stream') !== -1 &&
                  (w.responseType = 'arraybuffer')),
            $ && typeof $.headers == 'object' && !($.headers instanceof b)
              ? Object.getOwnPropertyNames($.headers).forEach(function (I) {
                  w.setRequestHeader(I, m($.headers[I]))
                })
              : Y.headers.forEach(function (I, re) {
                  w.setRequestHeader(re, I)
                }),
            Y.signal &&
              (Y.signal.addEventListener('abort', q),
              (w.onreadystatechange = function () {
                w.readyState === 4 && Y.signal.removeEventListener('abort', q)
              })),
            w.send(typeof Y._bodyInit > 'u' ? null : Y._bodyInit)
        })
      }
      return (
        (j.polyfill = !0),
        o.fetch || ((o.fetch = j), (o.Headers = b), (o.Request = k), (o.Response = M)),
        (a.Headers = b),
        (a.Request = k),
        (a.Response = M),
        (a.fetch = j),
        a
      )
    })({})
  })(i),
    (i.fetch.ponyfill = !0),
    delete i.fetch.polyfill
  var n = r.fetch ? r : i
  ;(t = n.fetch),
    (t.default = n.fetch),
    (t.fetch = n.fetch),
    (t.Headers = n.Headers),
    (t.Request = n.Request),
    (t.Response = n.Response),
    (e.exports = t)
})(Lc, Lc.exports)
var MC = Lc.exports
const Y1 = ci(MC),
  UC = new RegExp(
    '(?:\\[([^[\\]]*@[^[\\]]+)\\])|(?<=\\s|^|(-))(?:@([\\p{L}\\d_][^\\s]*[\\p{L}\\d_]|\\{.+\\})(?:\\s+\\[(.*?)\\])?)',
    'u'
  ),
  HC =
    /(?<prefix>.+)?(?:@(?<citekey>[\p{L}\d_][^\s{]*[\p{L}\d_]|\{.+\}))(?:\{(?<explicitLocator>.*)\})?(?:,\s+(?:\{(?<explicitLocatorInSuffix>.*)\})?(?<suffix>.*))?/u,
  Bm = /^(?:[\d, -]*\d|[ivxlcdm, -]*[ivxlcdm])/i,
  Fm = {
    book: ['Buch', 'Bcher', 'B.', 'book', 'books', 'bk.', 'bks.', 'livre', 'livres', 'liv.'],
    chapter: ['Kapitel', 'Kap.', 'chapter', 'chapters', 'chap.', 'chaps', 'chapitre', 'chapitres'],
    column: [
      'Spalte',
      'Spalten',
      'Sp.',
      'column',
      'columns',
      'col.',
      'cols',
      'colonne',
      'colonnes',
    ],
    figure: ['Abbildung', 'Abbildungen', 'Abb.', 'figure', 'figures', 'fig.', 'figs'],
    folio: ['Blatt', 'Bltter', 'Fol.', 'folio', 'folios', 'fol.', 'fols', 'f', 'f'],
    issue: [
      'Nummer',
      'Nummern',
      'Nr.',
      'number',
      'numbers',
      'no.',
      'nos.',
      'numro',
      'numros',
      'n',
      'n',
    ],
    line: ['Zeile', 'Zeilen', 'Z', 'line', 'lines', 'l.', 'll.', 'ligne', 'lignes'],
    note: ['Note', 'Noten', 'N.', 'note', 'notes', 'n.', 'nn.'],
    opus: ['Opus', 'Opera', 'op.', 'opus', 'opera', 'opp.'],
    page: ['Seite', 'Seiten', 'S.', 'page', 'pages', 'p.', 'pp.'],
    paragraph: [
      'Absatz',
      'Abstze',
      'Abs.',
      '',
      '',
      'paragraph',
      'paragraphs',
      'para.',
      'paras',
      'paragraphe',
      'paragraphes',
      'paragr.',
    ],
    part: ['Teil', 'Teile', 'part', 'parts', 'pt.', 'pts', 'partie', 'parties', 'part.'],
    section: [
      'Abschnitt',
      'Abschnitte',
      'Abschn.',
      '',
      '',
      'section',
      'sections',
      'sec.',
      'secs',
      'sect.',
    ],
    'sub verbo': ['sub verbo', 'sub verbis', 's.&#160;v.', 's.&#160;vv.', 's.v.', 's.vv.'],
    verse: ['Vers', 'Verse', 'V.', 'verse', 'verses', 'v.', 'vv.', 'verset', 'versets'],
    volume: ['Band', 'Bnde', 'Bd.', 'Bde.', 'volume', 'volumes', 'vol.', 'vols.'],
  },
  zC = (e) => {
    let t = [],
      r = !1
    const i = e[1],
      n = e[2],
      s = e[3],
      a = e[4]
    if (i !== void 0)
      for (const o of i.split(';')) {
        const u = HC.exec(o.trim())
        if (u === null) continue
        const c = {
            id: u.groups.citekey.replace(/{(.+)}/, '$1'),
            prefix: void 0,
            locator: void 0,
            label: 'page',
            'suppress-author': !1,
            suffix: void 0,
          },
          f = u.groups.prefix
        f !== void 0 &&
          ((c['suppress-author'] = f.trim().endsWith('-')),
          c['suppress-author']
            ? (c.prefix = f.substring(0, f.trim().length - 1).trim())
            : (c.prefix = f.trim()))
        const h = u.groups.explicitLocator,
          p = u.groups.explicitLocatorInSuffix,
          m = u.groups.suffix
        let v,
          b = !0
        h === void 0 && p === void 0
          ? ((v = m), (b = !1))
          : (p !== void 0 || h !== void 0) &&
            ((v = h !== void 0 ? h : p), (c.suffix = m == null ? void 0 : m.trim()))
        const { label: S, locator: g, suffix: _ } = Mm(v, b)
        ;(c.locator = g),
          S !== void 0 && (c.label = S),
          h === void 0 && p === void 0
            ? (c.suffix = _)
            : _ !== void 0 && c.locator !== void 0 && (c.locator += _),
          t.push(c)
      }
    else
      (r = !0),
        t.push({
          prefix: void 0,
          id: s.replace(/{(.+)}/, '$1'),
          'suppress-author': n !== void 0,
          ...Mm(a, !1),
        })
    return [t, r]
  }
function Mm(e, t) {
  const r = { locator: void 0, label: 'page', suffix: void 0 }
  if (e === void 0) return r
  e = e.trim()
  for (const i in Fm)
    for (const n of Fm[i])
      if (e.toLowerCase().startsWith(n.toLowerCase())) {
        if (((r.label = i), t)) r.locator = e.substr(n.length).trim()
        else {
          r.suffix = e.substr(n.length).trim()
          const s = Bm.exec(r.suffix)
          s !== null && ((r.locator = s[0]), (r.suffix = r.suffix.substr(s[0].length).trim()))
        }
        return r
      }
  if (t) r.locator = e
  else {
    const i = Bm.exec(e)
    i !== null && ((r.locator = i[0]), (r.suffix = e.substr(i[0].length).trim()))
  }
  return r
}
const jC = 'modulepreload',
  qC = function (e) {
    return '/' + e
  },
  Um = {},
  fu = function (t, r, i) {
    if (!r || r.length === 0) return t()
    const n = document.getElementsByTagName('link')
    return Promise.all(
      r.map((s) => {
        if (((s = qC(s)), s in Um)) return
        Um[s] = !0
        const a = s.endsWith('.css'),
          o = a ? '[rel="stylesheet"]' : ''
        if (!!i)
          for (let f = n.length - 1; f >= 0; f--) {
            const h = n[f]
            if (h.href === s && (!a || h.rel === 'stylesheet')) return
          }
        else if (document.querySelector(`link[href="${s}"]${o}`)) return
        const c = document.createElement('link')
        if (
          ((c.rel = a ? 'stylesheet' : jC),
          a || ((c.as = 'script'), (c.crossOrigin = '')),
          (c.href = s),
          document.head.appendChild(c),
          a)
        )
          return new Promise((f, h) => {
            c.addEventListener('load', f),
              c.addEventListener('error', () => h(new Error(`Unable to preload CSS for ${s}`)))
          })
      })
    )
      .then(() => t())
      .catch((s) => {
        const a = new Event('vite:preloadError', { cancelable: !0 })
        if (((a.payload = s), window.dispatchEvent(a), !a.defaultPrevented)) throw s
      })
  },
  ua = typeof window > 'u',
  mp = async (e) => {
    if (la(e))
      return Y1(e)
        .then((t) => t.text())
        .then((t) => t)
    if (ua)
      return fu(() => import('./__vite-browser-external-b25bb000.js'), []).then((t) =>
        t.readFileSync(e, 'utf8')
      )
    throw new Error('Cannot read non valid URL in node env.')
  },
  la = (e) => {
    let t
    try {
      t = new URL(e)
    } catch {
      return !1
    }
    return t.protocol === 'http:' || t.protocol === 'https:'
  },
  $C = async (e, t) => {
    var i, n
    let r = ''
    if (e.bibliography) r = e.bibliography
    else if (
      (n = (i = t == null ? void 0 : t.data) == null ? void 0 : i.frontmatter) != null &&
      n.bibliography &&
      ((r = t.data.frontmatter.bibliography), !la(r))
    )
      if (ua)
        r = await fu(() => import('./__vite-browser-external-b25bb000.js'), []).then((s) =>
          s.join(e.path || t.cwd, r)
        )
      else throw new Error('Cannot read non valid bibliography URL in node env.')
    return r
  },
  VC = async (e, t, r = '') => {
    const i = e.plugins.config.get('@csl')
    if (Object.keys(i.templates.data).includes(t)) return t
    {
      const n = `customCSL-${Math.random().toString(36).slice(2, 7)}`
      let s = ''
      la(t)
        ? (s = t)
        : ua &&
          (s = await fu(() => import('./__vite-browser-external-b25bb000.js'), []).then((a) =>
            a.join(r, t)
          ))
      try {
        i.templates.add(n, await mp(s))
      } catch {
        throw new Error(`Input CSL option, ${t}, is invalid or is an unknown file.`)
      }
      return n
    }
  },
  GC = async (e, t, r = '') => {
    const i = e.plugins.config.get('@csl')
    if (Object.keys(i.locales.data).includes(t)) return t
    {
      let n = ''
      la(t)
        ? (n = t)
        : ua &&
          (n = await fu(() => import('./__vite-browser-external-b25bb000.js'), []).then((s) =>
            s.join(r, t)
          ))
      try {
        const s = await mp(n),
          a = /xml:lang="(.+)"/,
          o = s.match(a)[1]
        return i.locales.add(o, s), o
      } catch {
        throw new Error(`Input locale option, ${t}, is invalid or is an unknown file.`)
      }
    }
  },
  XC = (e) =>
    e.cslXml.dataObj.children[0].children.find((n) => n.attrs && n.attrs['citation-format']).attrs[
      'citation-format'
    ],
  YC = (e, t, r) => {
    const i = []
    if (r) for (const n of e.registry.reflist) t.includes(n.id) && i.push(n)
    else for (const n of t) i.push(e.registry.reflist.find((s) => s.id === n))
    return i
  },
  WC = (e, t) => [e.slice(0, t), e.slice(t)],
  QC = (e, t) => {
    const r = e.ref.author,
      i = t.ref.author
    if (r.length !== i.length) return !1
    for (let n = 0; n < r.length; n++) if (r[n].family !== i[n].family) return !1
    return !0
  },
  KC = new Set([
    65534, 65535, 131070, 131071, 196606, 196607, 262142, 262143, 327678, 327679, 393214, 393215,
    458750, 458751, 524286, 524287, 589822, 589823, 655358, 655359, 720894, 720895, 786430, 786431,
    851966, 851967, 917502, 917503, 983038, 983039, 1048574, 1048575, 1114110, 1114111,
  ]),
  je = ''
var B
;(function (e) {
  ;(e[(e.EOF = -1)] = 'EOF'),
    (e[(e.NULL = 0)] = 'NULL'),
    (e[(e.TABULATION = 9)] = 'TABULATION'),
    (e[(e.CARRIAGE_RETURN = 13)] = 'CARRIAGE_RETURN'),
    (e[(e.LINE_FEED = 10)] = 'LINE_FEED'),
    (e[(e.FORM_FEED = 12)] = 'FORM_FEED'),
    (e[(e.SPACE = 32)] = 'SPACE'),
    (e[(e.EXCLAMATION_MARK = 33)] = 'EXCLAMATION_MARK'),
    (e[(e.QUOTATION_MARK = 34)] = 'QUOTATION_MARK'),
    (e[(e.NUMBER_SIGN = 35)] = 'NUMBER_SIGN'),
    (e[(e.AMPERSAND = 38)] = 'AMPERSAND'),
    (e[(e.APOSTROPHE = 39)] = 'APOSTROPHE'),
    (e[(e.HYPHEN_MINUS = 45)] = 'HYPHEN_MINUS'),
    (e[(e.SOLIDUS = 47)] = 'SOLIDUS'),
    (e[(e.DIGIT_0 = 48)] = 'DIGIT_0'),
    (e[(e.DIGIT_9 = 57)] = 'DIGIT_9'),
    (e[(e.SEMICOLON = 59)] = 'SEMICOLON'),
    (e[(e.LESS_THAN_SIGN = 60)] = 'LESS_THAN_SIGN'),
    (e[(e.EQUALS_SIGN = 61)] = 'EQUALS_SIGN'),
    (e[(e.GREATER_THAN_SIGN = 62)] = 'GREATER_THAN_SIGN'),
    (e[(e.QUESTION_MARK = 63)] = 'QUESTION_MARK'),
    (e[(e.LATIN_CAPITAL_A = 65)] = 'LATIN_CAPITAL_A'),
    (e[(e.LATIN_CAPITAL_F = 70)] = 'LATIN_CAPITAL_F'),
    (e[(e.LATIN_CAPITAL_X = 88)] = 'LATIN_CAPITAL_X'),
    (e[(e.LATIN_CAPITAL_Z = 90)] = 'LATIN_CAPITAL_Z'),
    (e[(e.RIGHT_SQUARE_BRACKET = 93)] = 'RIGHT_SQUARE_BRACKET'),
    (e[(e.GRAVE_ACCENT = 96)] = 'GRAVE_ACCENT'),
    (e[(e.LATIN_SMALL_A = 97)] = 'LATIN_SMALL_A'),
    (e[(e.LATIN_SMALL_F = 102)] = 'LATIN_SMALL_F'),
    (e[(e.LATIN_SMALL_X = 120)] = 'LATIN_SMALL_X'),
    (e[(e.LATIN_SMALL_Z = 122)] = 'LATIN_SMALL_Z'),
    (e[(e.REPLACEMENT_CHARACTER = 65533)] = 'REPLACEMENT_CHARACTER')
})((B = B || (B = {})))
const xt = {
  DASH_DASH: '--',
  CDATA_START: '[CDATA[',
  DOCTYPE: 'doctype',
  SCRIPT: 'script',
  PUBLIC: 'public',
  SYSTEM: 'system',
}
function W1(e) {
  return e >= 55296 && e <= 57343
}
function JC(e) {
  return e >= 56320 && e <= 57343
}
function ZC(e, t) {
  return (e - 55296) * 1024 + 9216 + t
}
function Q1(e) {
  return (
    (e !== 32 && e !== 10 && e !== 13 && e !== 9 && e !== 12 && e >= 1 && e <= 31) ||
    (e >= 127 && e <= 159)
  )
}
function K1(e) {
  return (e >= 64976 && e <= 65007) || KC.has(e)
}
var J
;(function (e) {
  ;(e.controlCharacterInInputStream = 'control-character-in-input-stream'),
    (e.noncharacterInInputStream = 'noncharacter-in-input-stream'),
    (e.surrogateInInputStream = 'surrogate-in-input-stream'),
    (e.nonVoidHtmlElementStartTagWithTrailingSolidus =
      'non-void-html-element-start-tag-with-trailing-solidus'),
    (e.endTagWithAttributes = 'end-tag-with-attributes'),
    (e.endTagWithTrailingSolidus = 'end-tag-with-trailing-solidus'),
    (e.unexpectedSolidusInTag = 'unexpected-solidus-in-tag'),
    (e.unexpectedNullCharacter = 'unexpected-null-character'),
    (e.unexpectedQuestionMarkInsteadOfTagName = 'unexpected-question-mark-instead-of-tag-name'),
    (e.invalidFirstCharacterOfTagName = 'invalid-first-character-of-tag-name'),
    (e.unexpectedEqualsSignBeforeAttributeName = 'unexpected-equals-sign-before-attribute-name'),
    (e.missingEndTagName = 'missing-end-tag-name'),
    (e.unexpectedCharacterInAttributeName = 'unexpected-character-in-attribute-name'),
    (e.unknownNamedCharacterReference = 'unknown-named-character-reference'),
    (e.missingSemicolonAfterCharacterReference = 'missing-semicolon-after-character-reference'),
    (e.unexpectedCharacterAfterDoctypeSystemIdentifier =
      'unexpected-character-after-doctype-system-identifier'),
    (e.unexpectedCharacterInUnquotedAttributeValue =
      'unexpected-character-in-unquoted-attribute-value'),
    (e.eofBeforeTagName = 'eof-before-tag-name'),
    (e.eofInTag = 'eof-in-tag'),
    (e.missingAttributeValue = 'missing-attribute-value'),
    (e.missingWhitespaceBetweenAttributes = 'missing-whitespace-between-attributes'),
    (e.missingWhitespaceAfterDoctypePublicKeyword =
      'missing-whitespace-after-doctype-public-keyword'),
    (e.missingWhitespaceBetweenDoctypePublicAndSystemIdentifiers =
      'missing-whitespace-between-doctype-public-and-system-identifiers'),
    (e.missingWhitespaceAfterDoctypeSystemKeyword =
      'missing-whitespace-after-doctype-system-keyword'),
    (e.missingQuoteBeforeDoctypePublicIdentifier =
      'missing-quote-before-doctype-public-identifier'),
    (e.missingQuoteBeforeDoctypeSystemIdentifier =
      'missing-quote-before-doctype-system-identifier'),
    (e.missingDoctypePublicIdentifier = 'missing-doctype-public-identifier'),
    (e.missingDoctypeSystemIdentifier = 'missing-doctype-system-identifier'),
    (e.abruptDoctypePublicIdentifier = 'abrupt-doctype-public-identifier'),
    (e.abruptDoctypeSystemIdentifier = 'abrupt-doctype-system-identifier'),
    (e.cdataInHtmlContent = 'cdata-in-html-content'),
    (e.incorrectlyOpenedComment = 'incorrectly-opened-comment'),
    (e.eofInScriptHtmlCommentLikeText = 'eof-in-script-html-comment-like-text'),
    (e.eofInDoctype = 'eof-in-doctype'),
    (e.nestedComment = 'nested-comment'),
    (e.abruptClosingOfEmptyComment = 'abrupt-closing-of-empty-comment'),
    (e.eofInComment = 'eof-in-comment'),
    (e.incorrectlyClosedComment = 'incorrectly-closed-comment'),
    (e.eofInCdata = 'eof-in-cdata'),
    (e.absenceOfDigitsInNumericCharacterReference =
      'absence-of-digits-in-numeric-character-reference'),
    (e.nullCharacterReference = 'null-character-reference'),
    (e.surrogateCharacterReference = 'surrogate-character-reference'),
    (e.characterReferenceOutsideUnicodeRange = 'character-reference-outside-unicode-range'),
    (e.controlCharacterReference = 'control-character-reference'),
    (e.noncharacterCharacterReference = 'noncharacter-character-reference'),
    (e.missingWhitespaceBeforeDoctypeName = 'missing-whitespace-before-doctype-name'),
    (e.missingDoctypeName = 'missing-doctype-name'),
    (e.invalidCharacterSequenceAfterDoctypeName = 'invalid-character-sequence-after-doctype-name'),
    (e.duplicateAttribute = 'duplicate-attribute'),
    (e.nonConformingDoctype = 'non-conforming-doctype'),
    (e.missingDoctype = 'missing-doctype'),
    (e.misplacedDoctype = 'misplaced-doctype'),
    (e.endTagWithoutMatchingOpenElement = 'end-tag-without-matching-open-element'),
    (e.closingOfElementWithOpenChildElements = 'closing-of-element-with-open-child-elements'),
    (e.disallowedContentInNoscriptInHead = 'disallowed-content-in-noscript-in-head'),
    (e.openElementsLeftAfterEof = 'open-elements-left-after-eof'),
    (e.abandonedHeadElementChild = 'abandoned-head-element-child'),
    (e.misplacedStartTagForHeadElement = 'misplaced-start-tag-for-head-element'),
    (e.nestedNoscriptInHead = 'nested-noscript-in-head'),
    (e.eofInElementThatCanContainOnlyText = 'eof-in-element-that-can-contain-only-text')
})((J = J || (J = {})))
const ek = 65536
class tk {
  constructor(t) {
    ;(this.handler = t),
      (this.html = ''),
      (this.pos = -1),
      (this.lastGapPos = -2),
      (this.gapStack = []),
      (this.skipNextNewLine = !1),
      (this.lastChunkWritten = !1),
      (this.endOfChunkHit = !1),
      (this.bufferWaterline = ek),
      (this.isEol = !1),
      (this.lineStartPos = 0),
      (this.droppedBufferSize = 0),
      (this.line = 1),
      (this.lastErrOffset = -1)
  }
  get col() {
    return this.pos - this.lineStartPos + +(this.lastGapPos !== this.pos)
  }
  get offset() {
    return this.droppedBufferSize + this.pos
  }
  getError(t) {
    const { line: r, col: i, offset: n } = this
    return {
      code: t,
      startLine: r,
      endLine: r,
      startCol: i,
      endCol: i,
      startOffset: n,
      endOffset: n,
    }
  }
  _err(t) {
    this.handler.onParseError &&
      this.lastErrOffset !== this.offset &&
      ((this.lastErrOffset = this.offset), this.handler.onParseError(this.getError(t)))
  }
  _addGap() {
    this.gapStack.push(this.lastGapPos), (this.lastGapPos = this.pos)
  }
  _processSurrogate(t) {
    if (this.pos !== this.html.length - 1) {
      const r = this.html.charCodeAt(this.pos + 1)
      if (JC(r)) return this.pos++, this._addGap(), ZC(t, r)
    } else if (!this.lastChunkWritten) return (this.endOfChunkHit = !0), B.EOF
    return this._err(J.surrogateInInputStream), t
  }
  willDropParsedChunk() {
    return this.pos > this.bufferWaterline
  }
  dropParsedChunk() {
    this.willDropParsedChunk() &&
      ((this.html = this.html.substring(this.pos)),
      (this.lineStartPos -= this.pos),
      (this.droppedBufferSize += this.pos),
      (this.pos = 0),
      (this.lastGapPos = -2),
      (this.gapStack.length = 0))
  }
  write(t, r) {
    this.html.length > 0 ? (this.html += t) : (this.html = t),
      (this.endOfChunkHit = !1),
      (this.lastChunkWritten = r)
  }
  insertHtmlAtCurrentPos(t) {
    ;(this.html = this.html.substring(0, this.pos + 1) + t + this.html.substring(this.pos + 1)),
      (this.endOfChunkHit = !1)
  }
  startsWith(t, r) {
    if (this.pos + t.length > this.html.length)
      return (this.endOfChunkHit = !this.lastChunkWritten), !1
    if (r) return this.html.startsWith(t, this.pos)
    for (let i = 0; i < t.length; i++)
      if ((this.html.charCodeAt(this.pos + i) | 32) !== t.charCodeAt(i)) return !1
    return !0
  }
  peek(t) {
    const r = this.pos + t
    if (r >= this.html.length) return (this.endOfChunkHit = !this.lastChunkWritten), B.EOF
    const i = this.html.charCodeAt(r)
    return i === B.CARRIAGE_RETURN ? B.LINE_FEED : i
  }
  advance() {
    if (
      (this.pos++,
      this.isEol && ((this.isEol = !1), this.line++, (this.lineStartPos = this.pos)),
      this.pos >= this.html.length)
    )
      return (this.endOfChunkHit = !this.lastChunkWritten), B.EOF
    let t = this.html.charCodeAt(this.pos)
    return t === B.CARRIAGE_RETURN
      ? ((this.isEol = !0), (this.skipNextNewLine = !0), B.LINE_FEED)
      : t === B.LINE_FEED && ((this.isEol = !0), this.skipNextNewLine)
      ? (this.line--, (this.skipNextNewLine = !1), this._addGap(), this.advance())
      : ((this.skipNextNewLine = !1),
        W1(t) && (t = this._processSurrogate(t)),
        this.handler.onParseError === null ||
          (t > 31 && t < 127) ||
          t === B.LINE_FEED ||
          t === B.CARRIAGE_RETURN ||
          (t > 159 && t < 64976) ||
          this._checkForProblematicCharacters(t),
        t)
  }
  _checkForProblematicCharacters(t) {
    Q1(t)
      ? this._err(J.controlCharacterInInputStream)
      : K1(t) && this._err(J.noncharacterInInputStream)
  }
  retreat(t) {
    for (this.pos -= t; this.pos < this.lastGapPos; )
      (this.lastGapPos = this.gapStack.pop()), this.pos--
    this.isEol = !1
  }
}
var ke
;(function (e) {
  ;(e[(e.CHARACTER = 0)] = 'CHARACTER'),
    (e[(e.NULL_CHARACTER = 1)] = 'NULL_CHARACTER'),
    (e[(e.WHITESPACE_CHARACTER = 2)] = 'WHITESPACE_CHARACTER'),
    (e[(e.START_TAG = 3)] = 'START_TAG'),
    (e[(e.END_TAG = 4)] = 'END_TAG'),
    (e[(e.COMMENT = 5)] = 'COMMENT'),
    (e[(e.DOCTYPE = 6)] = 'DOCTYPE'),
    (e[(e.EOF = 7)] = 'EOF'),
    (e[(e.HIBERNATION = 8)] = 'HIBERNATION')
})((ke = ke || (ke = {})))
function J1(e, t) {
  for (let r = e.attrs.length - 1; r >= 0; r--) if (e.attrs[r].name === t) return e.attrs[r].value
  return null
}
const zr = new Uint16Array(
    '<\0\0\0\0\0\0EMabcfglmnoprstu\\bfmsligP&cutereve;iyx}rc;r;ravepha;acr;d;gpon;f;plyFunction;ingcsr;ign;ildemlaceforsucrkslash;;ed;y;crtause;noullis;a;r;pf;eve;cmpeq;HOacdefhilorsucy;PYcpyute;;italDifferentialD;leys;aeioron;dilrc;nint;ot;dnilla;terDot;i;rcleDMPTot;inus;lus;imes;ocskwiseContourIntegral;eCurlyDQoubleQuote;uote;lnpuon;e;gitruent;nt;ourIntegral;fr;oduct;nterClockwiseContourIntegral;oss;cr;p;Cap;DJSZacefios;otrahd;cy;cy;cy;grsger;r;hv;ayron;;l;ta;r;afcmriticalADGTcute;o;bleAcute;rave;ilde;ond;ferentialD;\0\0\0\0f;;DEot;qual;bleCDLRUVontourIntegrao\0\0nArrow;eoftARTrrow;ightArrow;engLReftARrrow;ightArrow;ightArrow;ightATrrow;ee;p\0\0rrow;ownArrow;erticalBar;nABLRTarrow;BUar;pArrow;reve;eft\0\0ightVector;eeVector;ector;Bar;ight\0eeVector;ector;Bar;ee;Arrow;ctr;rok;NTacdfglmopqstuxG;Hcuteaiyron;rc;ot;r;raveement;apcr;ty\0\0mallSquare;erySmallSquare;gpon;f;silon;uail;Tilde;librium;cir;m;a;mlipsts;onentialE;cfiosy;r;lled\0\0mallSquare;erySmallSquare;\0\0\0f;All;riertrf;cJTabcdfgorstcy;>mma;d;reve;eiydil;rc;;ot;r;;pf;eaterEFGLSTqual;Less;ullEqual;reater;ess;lantEqual;ilde;cr;;AacfiosuRDcy;ctek;;irc;r;lbertSpace;\0f;izontalLine;ctrok;mpownHumqual;EJOacdfgmnostucy;lig;cy;cuteiyrc;ot;r;rave;apcgr;inaryI;lie\0;egrral;section;isibleCTomma;imes;gpton;f;a;cr;ilde;\0cy;lcfosuiyrc;;r;pf;\0r;rcy;kcy;HJacfoscy;cy;ppa;eydil;;r;pf;cr;JTaceflmostcy;<cmnprute;bda;g;lacetrf;r;aeyron;dil;;fstACDFRTUVarnrgleBracket;row;BRar;ightArrow;eiling;o\0bleBracket;n\0eeVector;ector;Bar;loor;ightAVrrow;ector;ere;AVrrow;ector;iangle;BEar;qual;pDTVownVector;eeVector;ector;Bar;ector;Bar;ightsEFGLSTqualGreater;ullEqual;reater;ess;lantEqual;ilde;r;;eftarrow;idot;npwgLRlreftARrrow;ightArrow;ightArrow;eftarightightf;erLReftArrow;ightArrow;cht;rok;;acefiosup;y;dliumSpace;lintrf;r;nusPlus;pf;c;Jacefostucy;cute;aeyron;dil;;gswativeMTVediumSpace;hicneryThitedGLreaterGreateessLesLine;r;Bnptreak;BreakingSpace;f;;CDEGHLNPRSTVoungruent;pCap;oubleVerticalBar;lqxement;ual;Tilde;ists;reater;EFGLSTqual;ullEqual;reater;ess;lantEqual;ilde;umpownHump;qual;efstTriangle;BEar;qual;s;EGLSTqual;reater;ess;lantEqual;ilde;estedGLreaterGreater;essLess;recedes;ESqual;lantEqual;eiverseElement;ghtTriangle;BEar;qual;quuareSubpset;Equal;erset;Equal;bcpset;Equal;ceeds;ESTqual;lantEqual;ilde;erset;Equal;ilde;EFTqual;ullEqual;ilde;erticalBar;cr;ilde;Eacdfgmoprstuvlig;cuteiyrc;blac;r;raveaeicr;ga;cron;pf;enCurlyDQoubleQuote;uote;;clr;ashidees;mlerBParr;acek;et;arenthesis;acfhilorsrtialD;y;r;i;;usMinus;ipncareplanf;;eiocedes;ESTqual;lantEqual;ilde;me;dpuct;ortion;al;cir;;UfosOT"r;pf;cr;BEacefhiorsuarr;Gcnrute;g;r;tl;aeyron;dil;;;verseEUlqement;uilibrium;pEquilibrium;ro;ghtACDFTUVanrgleBracket;row;BLar;eftArrow;eiling;o\0bleBracket;n\0eeVector;ector;Bar;loor;ere;AVrrow;ector;iangle;BEar;qual;pDTVownVector;eeVector;ector;Bar;ector;Bar;puf;ndImplies;ightarrow;chr;;leDelayed;HOacfhimoqstuCcHcy;y;FTcy;cute;;aeiyron;dil;rc;;r;ortDLRUownArroweftArrowightArrowpArrow;gma;allCircle;pf;\0\0t;are;ISUntersection;ubpset;Equal;erset;Equal;nion;cr;ar;bcmp;set;Equal;cheeds;ESTqual;lantEqual;ilde;Th;;esrset;Equal;etHRSacfhiorsORNADE;Hccy;y;bu;;aeyron;dil;;r;ei\0efore;a;cnkSpace;Space;lde;EFTqual;ullEqual;ilde;pf;ipleDot;ctr;rok;\0\0\0\0\0\0\0cruter;ocir;r\0y;ve;iyrc;blac;r;raveacr;dierBParr;acek;et;arenthesis;on;Plus;gpon;f;ADETadpsrrow;BDar;ownArrow;ownArrow;quilibrium;ee;Arrow;ownerLReftArrow;ightArrow;i;lon;ing;cr;ilde;mlDbcdefosvash;ar;y;ash;l;er;btyar;;icalBLSTar;ine;eparator;ilde;ThinSpace;r;pf;cr;dash;cefosirc;dge;r;pf;cr;fiosr;;pf;cr;AIUacfosucy;cy;cy;cuteiyrc;;r;pf;cr;ml;Hacdefoscy;cute;ayron;;ot;\0oWidta;r;pf;cr;\0\0\0\0\0\0\0cutereve;;Ediuy;;rcte;lig;r;raveepfpsym;ha;apcclr;g;\0\0;adsvnd;;lope;;;elmrsz;esd;a;;;;;;;;t;vb;d;pth;arr;gpon;f;;Eaeiop;cir;;d;s;rox;eingctyr;;mp;eildemlcioninnt;Nabcdefiklnoprsuot;crkcepsong;psilon;rime;im;eq;ee;ed;gerk;tbrk;oy;quo;cmprtaus;eptyv;snoahw;;een;r;gcostuvwaiurc;pdptot;lus;imes;\0\0cup;ar;riangleduown;p;plus;earow;akocnklstozenge;riangle;dlrown;eft;ight;k;\0\0;;4;ck;eo;q=uiv;t;ptwxf;;tomtie;DHUVbdhmptuvLRlr;;;;;DUdu;;;;LRlr;;;;;HLRhlr;;;;;;ox;LRlr;;;;;DUdu;;;;inus;lus;imes;LRlr;;;;;HLRhlr;;;;;;evbarceior;mi;m;el;bh;sub;l;etp;Ee;;q\0\0\0\0\0\0\0\0\0\0cprute;;abcdsnd;rcup;aup;p;ot;;eot;aeiu\0s;on;dilrc;ps;sm;ot;dmnilptyv;t;err;ceiy;ck;mark;r;Ecefms;;elq;e\0\0rrowlreft;ight;RSacd;st;irc;ash;nint;id;cir;ubs;uit\0on;e;q\0\0a;t;;flemxente\0;dot;nfry;o;sr;aorr;ss;cur;bp;e;;e;dot;delprvwarrlr;;\0\0r;c;arr;p;;bcdosrcap;aup;p;ot;r;;alrvrr;m;yevwq\0\0reuee;edge;enearrowlreftightecioninnt;lcty;AHabcdefhijlorstuwzrar;glrsger;eth;h;varow;aayron;;;aogrr;tseq;glmta;ptyv;irsht;;arlraegsvm;osnd;suit;amma;in;;iode;ontimes;ncy;c\0\0rn;op;lptuwlar;f;;empsq;dot;inus;lus;quare;blebarwedgnadhownarrowarpoonlrefighkaro\0\0rn;op;cotry;;l;rok;drot;i;fahraangle;ciy;grarr;DacdefglmnopqrstuxDoocsuteter;aioyron;r;clon;;ot;Drot;;;rsave;dot;;ilsnters;;;dot;apscr;ty;svetp1;;;gs;p;gpon;f;alsr;sl;us;i;lvon;csuviorc\0\0antgltressaeils;st;v;DD;parsl;Daot;rr;cdir;oah;mrlo;cipl;seoctationential\0\0\0\0\0\0\0llingdotsey;male;ilrlig;\0\0g;ig;;lig;lig;fjaltt;ig;ns;of;\0f;ak;v;artint;aocs\0\0;;;;\0;;\0\0;;5;\0;;8;l;wn;cr;Eabcdefgijlnorstv;l;cmpute;ma;d;reve;iyrc;;ot;;lqs;qslan;cdlc;ot;o;l;;es;r;;gmel;cy;;Eaj;;;Eaes;p;prox;q;qim;pf;cir;m;el;;>;cdlqrci;r;ot;Par;uest;adels\0pror;qlqlesienrtneqq;Aabcefkosyrilmrrsfildrcy;;cwir;;ar;irc;alrrts;uitlip;con;r;sewarow;arow;amoprrr;tht;klreftarrow;ightarrow;f;bar;cltr;asrok;bpull;hen\0\0\0\0\0\0cute;iyrc;cxy;clfr;rave;inoinnt;t;fin;ta;lig;aopcgtr;elpinarh;f;ed;;cfotare;in;tie;do;celpal;grerarhk;rod;cgpty;on;f;a;uestcir;n;Edsv;ot;;v;;ilde;\0cy;lcfmosuiyrc;;r;ath;pf;\0r;rcy;kcy;acfghjosppa;v;eydil;;r;reen;cy;cy;pf;cr;ABEHabcdefghjlmnoprstuvartrail;arr;;g;ar;\0\0\0\0\0\0\0\0\0ute;mptyv;rabda;g;dl;;uor;bfhlpst;fs;s;p;l;im;l;;aeil;;s;abrrr;rk;akcek;;es;ldu;;aeuyron;diil;;cqrsa;uo;rduhar;shar;h;;fgqstahlrtrrow;taarpoonduownpeftarrows;ightahsrrow;sarpoonquigarrohreetimes;;qslan;cdgsc;ot;o;r;;es;adegspproot;qgqgtiilrsht;;;E;rdu;l;lk;cy;;achtrorneard;ri;iodot;ust;acheEaes;p;prox;q;qim;abnoptwznrg;r;rglmreftarightapsto;ightparrowlrefight;aflr;;us;imes;st;;efngear;lt;achmtrornear;d;;ri;achiqtquo;r;m;eg;;buo;r;rok;<;cdhilqrci;r;remes;arr;uest;Piar;;efrdushar;har;enrtneqq;DacdefhilnopsuDot;clprret;;ese;sto;dluowefker;oymma;;ash;asuredangler;o;cdnro;acdsir;otus;bd;u;p;dpels;f;ctr;pos;lmtimap;GLRVabcdefghijlmoprstuvwgt;;veltftarrrow;ightarrow;;;vightarrow;Ddash;ash;bcnptlaute;g;;Eiop;d;s;rour;al;s\0pmp;eaeouy\0;on;dil;ng;dot;p;;ash;;Aadqsxrr;rhrk;;oot;uieiar;ist;sr;Eest;qs;qslani;rAaprrr;ar;;sv;d;cy;AEadestr;rr;r;;fqstarrroightarro;qslan;si;ri;eiptf;;inn;Edv;ot;;;i;v;;aorr;astllel;;lint;;ceu;c;eAaitrrr;cw;;ghtarrowri;echimpqu;ceru;ort\0\0arm;e;qsubpbcp;Ees;et;eq;qc;e;Ees;et;eq;qgilrldeianglelreft;eight;e;m;esro;p;DHadgilrsash;arr;p;ash;et;;>nfin;Aetrr;;;r<ie;Atrr;rie;im;Aanrr;rhrk;;oear;\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0csuteiyr;c;abioslac;v;old;lig;crir;;\0\0\0n;ave;bmar;acitrirr;oss;n;aeicr;ga;cdnron;;pf;aelr;rp;;adiosvr;efmr;ofgof;r;lope;;cloashl;idees;as;mlbar;\0\0\0\0\0\0\0\0\0r;ast;lle\0\0m;;y;rcimptnt;od;il;enk;r;imo;v;mane;;tvchfork;aunckk;h;s;abcdemstcir;ir;ou;;nim;wo;ipuntint;f;nd;Eaceinosu;p;u;c;acenspprourlyeaespprox;qq;im;ime;sEasdfpalslar;ine;urf;;trel;cir;;ncsp;fiopsur;pf;rime;cr;aeoteirnionnt;st;eABHabcdefhilmnoprstuxartrail;arar;cdenqrteu;te;imptyv;g;del;;uor;abcfhlpstwp;;fs;;s;l;im;l;;aiil;o;nalabrrrk;akcek;;es;ldu;;aeuyron;diil;;clqsa;dhar;uo;rh;acgl;ipsnart;ilrsht;;aordu;l;;v;gnshtahlrstrrow;taarpoonduowpeftahrrowarpoonightarrows;quigarrohreetimes;g;ingdotseahmra;oust;achemid;abptnrg;r;raflr;;us;imes;apr;gt;olint;arachqquo;r;buo;rhirremes;i;efltri;luhar;;\0\0\0\0\0\0\0cute;qu;Eaceinpsy;\0;on;u;dil;rc;Eas;p;im;olint;i;ot;be;Aacmstxrr;rhr;oti;war;minnut;r;oacoyrp;hycy;;rt\0\0iaragmma;fv;;deglnprot;;q;E;;E;e;lus;arr;araeitlslsetmhp;parsl;dle;;e;s;flptcy;;b;ar;f;adres;uitcsuaup;s;p;s;ubp;eset;e;eset;e;afrarcemtr;tmiararr;fanighteppsilohsbcmnp;Edemnprs;ot;;dot;ult;Ee;;lus;arr;eiut;enq;qeq;qm;bp;;c;acenspprourlyeaespproqg;123;Edehlmnps;ost;ub;;dot;soul;b;arr;ult;Ee;;lus;eiut;enq;qeq;qm;bp;;Aanrr;rhr;owar;lig\0\0\0\0\0\0\0\0\0\0\0\0get;;raeyron;dil;;lrec;r;eiko\0e4fa;svym;cnkaspproimsasrnes;bd;ar;;eps;bcfot;ir;;ork;rime;aipdadempstngle;dlqrowneft;e;ight;eot;inus;lus;b;ime;ezium;chtry;;cy;rok;ioxheadlreftarroightarrowAHabcdfghlmoprstuwrar;cruter\0y;ve;iyrc;abhrlac;airsht;;raverlrlk;ct\0\0rn;erop;ri;alcr;gpon;f;adhlsuownarpoonlrefighi;hlonparrows;cit\0\0rn;erop;ng;ri;cr;dirot;lde;i;famrlangle;ABDacdeflnoprszrar;v;asnrgrt;eknprstappothinhirop;hiugmbpsetneq;q;setneq;q;hretianglelreftighty;ashelr;bear;q;lip;btar;trsubppf;rotrcur;bpnEenEeigzag;cefoprsirc;dibgar;e;q;erp;r;pf;;eatcr;\0\0\0\0\0\0\0trr;Aarr;Aarrais;dptfl;imAarrcqr;ptracefiosucuyte;iyrc;;nr;cy;pf;cr;cmy;lacdefhioswcute;ayron;;ot;ettra;r;cy;grarr;pf;cr;jn;j;'
      .split('')
      .map((e) => e.charCodeAt(0))
  ),
  rk = new Uint16Array(
    'aglq	\x1B\0\0p;os;t;t;uot;'.split('').map((e) => e.charCodeAt(0))
  )
var yl
const ik = new Map([
    [0, 65533],
    [128, 8364],
    [130, 8218],
    [131, 402],
    [132, 8222],
    [133, 8230],
    [134, 8224],
    [135, 8225],
    [136, 710],
    [137, 8240],
    [138, 352],
    [139, 8249],
    [140, 338],
    [142, 381],
    [145, 8216],
    [146, 8217],
    [147, 8220],
    [148, 8221],
    [149, 8226],
    [150, 8211],
    [151, 8212],
    [152, 732],
    [153, 8482],
    [154, 353],
    [155, 8250],
    [156, 339],
    [158, 382],
    [159, 376],
  ]),
  nk =
    (yl = String.fromCodePoint) !== null && yl !== void 0
      ? yl
      : function (e) {
          let t = ''
          return (
            e > 65535 &&
              ((e -= 65536),
              (t += String.fromCharCode(((e >>> 10) & 1023) | 55296)),
              (e = 56320 | (e & 1023))),
            (t += String.fromCharCode(e)),
            t
          )
        }
function sk(e) {
  var t
  return (e >= 55296 && e <= 57343) || e > 1114111
    ? 65533
    : (t = ik.get(e)) !== null && t !== void 0
    ? t
    : e
}
var nt
;(function (e) {
  ;(e[(e.NUM = 35)] = 'NUM'),
    (e[(e.SEMI = 59)] = 'SEMI'),
    (e[(e.EQUALS = 61)] = 'EQUALS'),
    (e[(e.ZERO = 48)] = 'ZERO'),
    (e[(e.NINE = 57)] = 'NINE'),
    (e[(e.LOWER_A = 97)] = 'LOWER_A'),
    (e[(e.LOWER_F = 102)] = 'LOWER_F'),
    (e[(e.LOWER_X = 120)] = 'LOWER_X'),
    (e[(e.LOWER_Z = 122)] = 'LOWER_Z'),
    (e[(e.UPPER_A = 65)] = 'UPPER_A'),
    (e[(e.UPPER_F = 70)] = 'UPPER_F'),
    (e[(e.UPPER_Z = 90)] = 'UPPER_Z')
})(nt || (nt = {}))
const ak = 32
var dr
;(function (e) {
  ;(e[(e.VALUE_LENGTH = 49152)] = 'VALUE_LENGTH'),
    (e[(e.BRANCH_LENGTH = 16256)] = 'BRANCH_LENGTH'),
    (e[(e.JUMP_TABLE = 127)] = 'JUMP_TABLE')
})(dr || (dr = {}))
function Pc(e) {
  return e >= nt.ZERO && e <= nt.NINE
}
function ok(e) {
  return (e >= nt.UPPER_A && e <= nt.UPPER_F) || (e >= nt.LOWER_A && e <= nt.LOWER_F)
}
function uk(e) {
  return (e >= nt.UPPER_A && e <= nt.UPPER_Z) || (e >= nt.LOWER_A && e <= nt.LOWER_Z) || Pc(e)
}
function lk(e) {
  return e === nt.EQUALS || uk(e)
}
var tt
;(function (e) {
  ;(e[(e.EntityStart = 0)] = 'EntityStart'),
    (e[(e.NumericStart = 1)] = 'NumericStart'),
    (e[(e.NumericDecimal = 2)] = 'NumericDecimal'),
    (e[(e.NumericHex = 3)] = 'NumericHex'),
    (e[(e.NamedEntity = 4)] = 'NamedEntity')
})(tt || (tt = {}))
var _i
;(function (e) {
  ;(e[(e.Legacy = 0)] = 'Legacy'),
    (e[(e.Strict = 1)] = 'Strict'),
    (e[(e.Attribute = 2)] = 'Attribute')
})(_i || (_i = {}))
class ck {
  constructor(t, r, i) {
    ;(this.decodeTree = t),
      (this.emitCodePoint = r),
      (this.errors = i),
      (this.state = tt.EntityStart),
      (this.consumed = 1),
      (this.result = 0),
      (this.treeIndex = 0),
      (this.excess = 1),
      (this.decodeMode = _i.Strict)
  }
  startEntity(t) {
    ;(this.decodeMode = t),
      (this.state = tt.EntityStart),
      (this.result = 0),
      (this.treeIndex = 0),
      (this.excess = 1),
      (this.consumed = 1)
  }
  write(t, r) {
    switch (this.state) {
      case tt.EntityStart:
        return t.charCodeAt(r) === nt.NUM
          ? ((this.state = tt.NumericStart), (this.consumed += 1), this.stateNumericStart(t, r + 1))
          : ((this.state = tt.NamedEntity), this.stateNamedEntity(t, r))
      case tt.NumericStart:
        return this.stateNumericStart(t, r)
      case tt.NumericDecimal:
        return this.stateNumericDecimal(t, r)
      case tt.NumericHex:
        return this.stateNumericHex(t, r)
      case tt.NamedEntity:
        return this.stateNamedEntity(t, r)
    }
  }
  stateNumericStart(t, r) {
    return r >= t.length
      ? -1
      : (t.charCodeAt(r) | ak) === nt.LOWER_X
      ? ((this.state = tt.NumericHex), (this.consumed += 1), this.stateNumericHex(t, r + 1))
      : ((this.state = tt.NumericDecimal), this.stateNumericDecimal(t, r))
  }
  addToNumericResult(t, r, i, n) {
    if (r !== i) {
      const s = i - r
      ;(this.result = this.result * Math.pow(n, s) + parseInt(t.substr(r, s), n)),
        (this.consumed += s)
    }
  }
  stateNumericHex(t, r) {
    const i = r
    for (; r < t.length; ) {
      const n = t.charCodeAt(r)
      if (Pc(n) || ok(n)) r += 1
      else return this.addToNumericResult(t, i, r, 16), this.emitNumericEntity(n, 3)
    }
    return this.addToNumericResult(t, i, r, 16), -1
  }
  stateNumericDecimal(t, r) {
    const i = r
    for (; r < t.length; ) {
      const n = t.charCodeAt(r)
      if (Pc(n)) r += 1
      else return this.addToNumericResult(t, i, r, 10), this.emitNumericEntity(n, 2)
    }
    return this.addToNumericResult(t, i, r, 10), -1
  }
  emitNumericEntity(t, r) {
    var i
    if (this.consumed <= r)
      return (
        (i = this.errors) === null ||
          i === void 0 ||
          i.absenceOfDigitsInNumericCharacterReference(this.consumed),
        0
      )
    if (t === nt.SEMI) this.consumed += 1
    else if (this.decodeMode === _i.Strict) return 0
    return (
      this.emitCodePoint(sk(this.result), this.consumed),
      this.errors &&
        (t !== nt.SEMI && this.errors.missingSemicolonAfterCharacterReference(),
        this.errors.validateNumericCharacterReference(this.result)),
      this.consumed
    )
  }
  stateNamedEntity(t, r) {
    const { decodeTree: i } = this
    let n = i[this.treeIndex],
      s = (n & dr.VALUE_LENGTH) >> 14
    for (; r < t.length; r++, this.excess++) {
      const a = t.charCodeAt(r)
      if (((this.treeIndex = eb(i, n, this.treeIndex + Math.max(1, s), a)), this.treeIndex < 0))
        return this.result === 0 || (this.decodeMode === _i.Attribute && (s === 0 || lk(a)))
          ? 0
          : this.emitNotTerminatedNamedEntity()
      if (((n = i[this.treeIndex]), (s = (n & dr.VALUE_LENGTH) >> 14), s !== 0)) {
        if (a === nt.SEMI)
          return this.emitNamedEntityData(this.treeIndex, s, this.consumed + this.excess)
        this.decodeMode !== _i.Strict &&
          ((this.result = this.treeIndex), (this.consumed += this.excess), (this.excess = 0))
      }
    }
    return -1
  }
  emitNotTerminatedNamedEntity() {
    var t
    const { result: r, decodeTree: i } = this,
      n = (i[r] & dr.VALUE_LENGTH) >> 14
    return (
      this.emitNamedEntityData(r, n, this.consumed),
      (t = this.errors) === null || t === void 0 || t.missingSemicolonAfterCharacterReference(),
      this.consumed
    )
  }
  emitNamedEntityData(t, r, i) {
    const { decodeTree: n } = this
    return (
      this.emitCodePoint(r === 1 ? n[t] & ~dr.VALUE_LENGTH : n[t + 1], i),
      r === 3 && this.emitCodePoint(n[t + 2], i),
      i
    )
  }
  end() {
    var t
    switch (this.state) {
      case tt.NamedEntity:
        return this.result !== 0 &&
          (this.decodeMode !== _i.Attribute || this.result === this.treeIndex)
          ? this.emitNotTerminatedNamedEntity()
          : 0
      case tt.NumericDecimal:
        return this.emitNumericEntity(0, 2)
      case tt.NumericHex:
        return this.emitNumericEntity(0, 3)
      case tt.NumericStart:
        return (
          (t = this.errors) === null ||
            t === void 0 ||
            t.absenceOfDigitsInNumericCharacterReference(this.consumed),
          0
        )
      case tt.EntityStart:
        return 0
    }
  }
}
function Z1(e) {
  let t = ''
  const r = new ck(e, (i) => (t += nk(i)))
  return function (n, s) {
    let a = 0,
      o = 0
    for (; (o = n.indexOf('&', o)) >= 0; ) {
      ;(t += n.slice(a, o)), r.startEntity(s)
      const c = r.write(n, o + 1)
      if (c < 0) {
        a = o + r.end()
        break
      }
      ;(a = o + c), (o = c === 0 ? a + 1 : a)
    }
    const u = t + n.slice(a)
    return (t = ''), u
  }
}
function eb(e, t, r, i) {
  const n = (t & dr.BRANCH_LENGTH) >> 7,
    s = t & dr.JUMP_TABLE
  if (n === 0) return s !== 0 && i === s ? r : -1
  if (s) {
    const u = i - s
    return u < 0 || u >= n ? -1 : e[r + u] - 1
  }
  let a = r,
    o = a + n - 1
  for (; a <= o; ) {
    const u = (a + o) >>> 1,
      c = e[u]
    if (c < i) a = u + 1
    else if (c > i) o = u - 1
    else return e[u + n]
  }
  return -1
}
Z1(zr)
Z1(rk)
var ee
;(function (e) {
  ;(e.HTML = 'http://www.w3.org/1999/xhtml'),
    (e.MATHML = 'http://www.w3.org/1998/Math/MathML'),
    (e.SVG = 'http://www.w3.org/2000/svg'),
    (e.XLINK = 'http://www.w3.org/1999/xlink'),
    (e.XML = 'http://www.w3.org/XML/1998/namespace'),
    (e.XMLNS = 'http://www.w3.org/2000/xmlns/')
})((ee = ee || (ee = {})))
var si
;(function (e) {
  ;(e.TYPE = 'type'),
    (e.ACTION = 'action'),
    (e.ENCODING = 'encoding'),
    (e.PROMPT = 'prompt'),
    (e.NAME = 'name'),
    (e.COLOR = 'color'),
    (e.FACE = 'face'),
    (e.SIZE = 'size')
})((si = si || (si = {})))
var Rt
;(function (e) {
  ;(e.NO_QUIRKS = 'no-quirks'), (e.QUIRKS = 'quirks'), (e.LIMITED_QUIRKS = 'limited-quirks')
})((Rt = Rt || (Rt = {})))
var Q
;(function (e) {
  ;(e.A = 'a'),
    (e.ADDRESS = 'address'),
    (e.ANNOTATION_XML = 'annotation-xml'),
    (e.APPLET = 'applet'),
    (e.AREA = 'area'),
    (e.ARTICLE = 'article'),
    (e.ASIDE = 'aside'),
    (e.B = 'b'),
    (e.BASE = 'base'),
    (e.BASEFONT = 'basefont'),
    (e.BGSOUND = 'bgsound'),
    (e.BIG = 'big'),
    (e.BLOCKQUOTE = 'blockquote'),
    (e.BODY = 'body'),
    (e.BR = 'br'),
    (e.BUTTON = 'button'),
    (e.CAPTION = 'caption'),
    (e.CENTER = 'center'),
    (e.CODE = 'code'),
    (e.COL = 'col'),
    (e.COLGROUP = 'colgroup'),
    (e.DD = 'dd'),
    (e.DESC = 'desc'),
    (e.DETAILS = 'details'),
    (e.DIALOG = 'dialog'),
    (e.DIR = 'dir'),
    (e.DIV = 'div'),
    (e.DL = 'dl'),
    (e.DT = 'dt'),
    (e.EM = 'em'),
    (e.EMBED = 'embed'),
    (e.FIELDSET = 'fieldset'),
    (e.FIGCAPTION = 'figcaption'),
    (e.FIGURE = 'figure'),
    (e.FONT = 'font'),
    (e.FOOTER = 'footer'),
    (e.FOREIGN_OBJECT = 'foreignObject'),
    (e.FORM = 'form'),
    (e.FRAME = 'frame'),
    (e.FRAMESET = 'frameset'),
    (e.H1 = 'h1'),
    (e.H2 = 'h2'),
    (e.H3 = 'h3'),
    (e.H4 = 'h4'),
    (e.H5 = 'h5'),
    (e.H6 = 'h6'),
    (e.HEAD = 'head'),
    (e.HEADER = 'header'),
    (e.HGROUP = 'hgroup'),
    (e.HR = 'hr'),
    (e.HTML = 'html'),
    (e.I = 'i'),
    (e.IMG = 'img'),
    (e.IMAGE = 'image'),
    (e.INPUT = 'input'),
    (e.IFRAME = 'iframe'),
    (e.KEYGEN = 'keygen'),
    (e.LABEL = 'label'),
    (e.LI = 'li'),
    (e.LINK = 'link'),
    (e.LISTING = 'listing'),
    (e.MAIN = 'main'),
    (e.MALIGNMARK = 'malignmark'),
    (e.MARQUEE = 'marquee'),
    (e.MATH = 'math'),
    (e.MENU = 'menu'),
    (e.META = 'meta'),
    (e.MGLYPH = 'mglyph'),
    (e.MI = 'mi'),
    (e.MO = 'mo'),
    (e.MN = 'mn'),
    (e.MS = 'ms'),
    (e.MTEXT = 'mtext'),
    (e.NAV = 'nav'),
    (e.NOBR = 'nobr'),
    (e.NOFRAMES = 'noframes'),
    (e.NOEMBED = 'noembed'),
    (e.NOSCRIPT = 'noscript'),
    (e.OBJECT = 'object'),
    (e.OL = 'ol'),
    (e.OPTGROUP = 'optgroup'),
    (e.OPTION = 'option'),
    (e.P = 'p'),
    (e.PARAM = 'param'),
    (e.PLAINTEXT = 'plaintext'),
    (e.PRE = 'pre'),
    (e.RB = 'rb'),
    (e.RP = 'rp'),
    (e.RT = 'rt'),
    (e.RTC = 'rtc'),
    (e.RUBY = 'ruby'),
    (e.S = 's'),
    (e.SCRIPT = 'script'),
    (e.SECTION = 'section'),
    (e.SELECT = 'select'),
    (e.SOURCE = 'source'),
    (e.SMALL = 'small'),
    (e.SPAN = 'span'),
    (e.STRIKE = 'strike'),
    (e.STRONG = 'strong'),
    (e.STYLE = 'style'),
    (e.SUB = 'sub'),
    (e.SUMMARY = 'summary'),
    (e.SUP = 'sup'),
    (e.TABLE = 'table'),
    (e.TBODY = 'tbody'),
    (e.TEMPLATE = 'template'),
    (e.TEXTAREA = 'textarea'),
    (e.TFOOT = 'tfoot'),
    (e.TD = 'td'),
    (e.TH = 'th'),
    (e.THEAD = 'thead'),
    (e.TITLE = 'title'),
    (e.TR = 'tr'),
    (e.TRACK = 'track'),
    (e.TT = 'tt'),
    (e.U = 'u'),
    (e.UL = 'ul'),
    (e.SVG = 'svg'),
    (e.VAR = 'var'),
    (e.WBR = 'wbr'),
    (e.XMP = 'xmp')
})((Q = Q || (Q = {})))
var d
;(function (e) {
  ;(e[(e.UNKNOWN = 0)] = 'UNKNOWN'),
    (e[(e.A = 1)] = 'A'),
    (e[(e.ADDRESS = 2)] = 'ADDRESS'),
    (e[(e.ANNOTATION_XML = 3)] = 'ANNOTATION_XML'),
    (e[(e.APPLET = 4)] = 'APPLET'),
    (e[(e.AREA = 5)] = 'AREA'),
    (e[(e.ARTICLE = 6)] = 'ARTICLE'),
    (e[(e.ASIDE = 7)] = 'ASIDE'),
    (e[(e.B = 8)] = 'B'),
    (e[(e.BASE = 9)] = 'BASE'),
    (e[(e.BASEFONT = 10)] = 'BASEFONT'),
    (e[(e.BGSOUND = 11)] = 'BGSOUND'),
    (e[(e.BIG = 12)] = 'BIG'),
    (e[(e.BLOCKQUOTE = 13)] = 'BLOCKQUOTE'),
    (e[(e.BODY = 14)] = 'BODY'),
    (e[(e.BR = 15)] = 'BR'),
    (e[(e.BUTTON = 16)] = 'BUTTON'),
    (e[(e.CAPTION = 17)] = 'CAPTION'),
    (e[(e.CENTER = 18)] = 'CENTER'),
    (e[(e.CODE = 19)] = 'CODE'),
    (e[(e.COL = 20)] = 'COL'),
    (e[(e.COLGROUP = 21)] = 'COLGROUP'),
    (e[(e.DD = 22)] = 'DD'),
    (e[(e.DESC = 23)] = 'DESC'),
    (e[(e.DETAILS = 24)] = 'DETAILS'),
    (e[(e.DIALOG = 25)] = 'DIALOG'),
    (e[(e.DIR = 26)] = 'DIR'),
    (e[(e.DIV = 27)] = 'DIV'),
    (e[(e.DL = 28)] = 'DL'),
    (e[(e.DT = 29)] = 'DT'),
    (e[(e.EM = 30)] = 'EM'),
    (e[(e.EMBED = 31)] = 'EMBED'),
    (e[(e.FIELDSET = 32)] = 'FIELDSET'),
    (e[(e.FIGCAPTION = 33)] = 'FIGCAPTION'),
    (e[(e.FIGURE = 34)] = 'FIGURE'),
    (e[(e.FONT = 35)] = 'FONT'),
    (e[(e.FOOTER = 36)] = 'FOOTER'),
    (e[(e.FOREIGN_OBJECT = 37)] = 'FOREIGN_OBJECT'),
    (e[(e.FORM = 38)] = 'FORM'),
    (e[(e.FRAME = 39)] = 'FRAME'),
    (e[(e.FRAMESET = 40)] = 'FRAMESET'),
    (e[(e.H1 = 41)] = 'H1'),
    (e[(e.H2 = 42)] = 'H2'),
    (e[(e.H3 = 43)] = 'H3'),
    (e[(e.H4 = 44)] = 'H4'),
    (e[(e.H5 = 45)] = 'H5'),
    (e[(e.H6 = 46)] = 'H6'),
    (e[(e.HEAD = 47)] = 'HEAD'),
    (e[(e.HEADER = 48)] = 'HEADER'),
    (e[(e.HGROUP = 49)] = 'HGROUP'),
    (e[(e.HR = 50)] = 'HR'),
    (e[(e.HTML = 51)] = 'HTML'),
    (e[(e.I = 52)] = 'I'),
    (e[(e.IMG = 53)] = 'IMG'),
    (e[(e.IMAGE = 54)] = 'IMAGE'),
    (e[(e.INPUT = 55)] = 'INPUT'),
    (e[(e.IFRAME = 56)] = 'IFRAME'),
    (e[(e.KEYGEN = 57)] = 'KEYGEN'),
    (e[(e.LABEL = 58)] = 'LABEL'),
    (e[(e.LI = 59)] = 'LI'),
    (e[(e.LINK = 60)] = 'LINK'),
    (e[(e.LISTING = 61)] = 'LISTING'),
    (e[(e.MAIN = 62)] = 'MAIN'),
    (e[(e.MALIGNMARK = 63)] = 'MALIGNMARK'),
    (e[(e.MARQUEE = 64)] = 'MARQUEE'),
    (e[(e.MATH = 65)] = 'MATH'),
    (e[(e.MENU = 66)] = 'MENU'),
    (e[(e.META = 67)] = 'META'),
    (e[(e.MGLYPH = 68)] = 'MGLYPH'),
    (e[(e.MI = 69)] = 'MI'),
    (e[(e.MO = 70)] = 'MO'),
    (e[(e.MN = 71)] = 'MN'),
    (e[(e.MS = 72)] = 'MS'),
    (e[(e.MTEXT = 73)] = 'MTEXT'),
    (e[(e.NAV = 74)] = 'NAV'),
    (e[(e.NOBR = 75)] = 'NOBR'),
    (e[(e.NOFRAMES = 76)] = 'NOFRAMES'),
    (e[(e.NOEMBED = 77)] = 'NOEMBED'),
    (e[(e.NOSCRIPT = 78)] = 'NOSCRIPT'),
    (e[(e.OBJECT = 79)] = 'OBJECT'),
    (e[(e.OL = 80)] = 'OL'),
    (e[(e.OPTGROUP = 81)] = 'OPTGROUP'),
    (e[(e.OPTION = 82)] = 'OPTION'),
    (e[(e.P = 83)] = 'P'),
    (e[(e.PARAM = 84)] = 'PARAM'),
    (e[(e.PLAINTEXT = 85)] = 'PLAINTEXT'),
    (e[(e.PRE = 86)] = 'PRE'),
    (e[(e.RB = 87)] = 'RB'),
    (e[(e.RP = 88)] = 'RP'),
    (e[(e.RT = 89)] = 'RT'),
    (e[(e.RTC = 90)] = 'RTC'),
    (e[(e.RUBY = 91)] = 'RUBY'),
    (e[(e.S = 92)] = 'S'),
    (e[(e.SCRIPT = 93)] = 'SCRIPT'),
    (e[(e.SECTION = 94)] = 'SECTION'),
    (e[(e.SELECT = 95)] = 'SELECT'),
    (e[(e.SOURCE = 96)] = 'SOURCE'),
    (e[(e.SMALL = 97)] = 'SMALL'),
    (e[(e.SPAN = 98)] = 'SPAN'),
    (e[(e.STRIKE = 99)] = 'STRIKE'),
    (e[(e.STRONG = 100)] = 'STRONG'),
    (e[(e.STYLE = 101)] = 'STYLE'),
    (e[(e.SUB = 102)] = 'SUB'),
    (e[(e.SUMMARY = 103)] = 'SUMMARY'),
    (e[(e.SUP = 104)] = 'SUP'),
    (e[(e.TABLE = 105)] = 'TABLE'),
    (e[(e.TBODY = 106)] = 'TBODY'),
    (e[(e.TEMPLATE = 107)] = 'TEMPLATE'),
    (e[(e.TEXTAREA = 108)] = 'TEXTAREA'),
    (e[(e.TFOOT = 109)] = 'TFOOT'),
    (e[(e.TD = 110)] = 'TD'),
    (e[(e.TH = 111)] = 'TH'),
    (e[(e.THEAD = 112)] = 'THEAD'),
    (e[(e.TITLE = 113)] = 'TITLE'),
    (e[(e.TR = 114)] = 'TR'),
    (e[(e.TRACK = 115)] = 'TRACK'),
    (e[(e.TT = 116)] = 'TT'),
    (e[(e.U = 117)] = 'U'),
    (e[(e.UL = 118)] = 'UL'),
    (e[(e.SVG = 119)] = 'SVG'),
    (e[(e.VAR = 120)] = 'VAR'),
    (e[(e.WBR = 121)] = 'WBR'),
    (e[(e.XMP = 122)] = 'XMP')
})((d = d || (d = {})))
const fk = new Map([
  [Q.A, d.A],
  [Q.ADDRESS, d.ADDRESS],
  [Q.ANNOTATION_XML, d.ANNOTATION_XML],
  [Q.APPLET, d.APPLET],
  [Q.AREA, d.AREA],
  [Q.ARTICLE, d.ARTICLE],
  [Q.ASIDE, d.ASIDE],
  [Q.B, d.B],
  [Q.BASE, d.BASE],
  [Q.BASEFONT, d.BASEFONT],
  [Q.BGSOUND, d.BGSOUND],
  [Q.BIG, d.BIG],
  [Q.BLOCKQUOTE, d.BLOCKQUOTE],
  [Q.BODY, d.BODY],
  [Q.BR, d.BR],
  [Q.BUTTON, d.BUTTON],
  [Q.CAPTION, d.CAPTION],
  [Q.CENTER, d.CENTER],
  [Q.CODE, d.CODE],
  [Q.COL, d.COL],
  [Q.COLGROUP, d.COLGROUP],
  [Q.DD, d.DD],
  [Q.DESC, d.DESC],
  [Q.DETAILS, d.DETAILS],
  [Q.DIALOG, d.DIALOG],
  [Q.DIR, d.DIR],
  [Q.DIV, d.DIV],
  [Q.DL, d.DL],
  [Q.DT, d.DT],
  [Q.EM, d.EM],
  [Q.EMBED, d.EMBED],
  [Q.FIELDSET, d.FIELDSET],
  [Q.FIGCAPTION, d.FIGCAPTION],
  [Q.FIGURE, d.FIGURE],
  [Q.FONT, d.FONT],
  [Q.FOOTER, d.FOOTER],
  [Q.FOREIGN_OBJECT, d.FOREIGN_OBJECT],
  [Q.FORM, d.FORM],
  [Q.FRAME, d.FRAME],
  [Q.FRAMESET, d.FRAMESET],
  [Q.H1, d.H1],
  [Q.H2, d.H2],
  [Q.H3, d.H3],
  [Q.H4, d.H4],
  [Q.H5, d.H5],
  [Q.H6, d.H6],
  [Q.HEAD, d.HEAD],
  [Q.HEADER, d.HEADER],
  [Q.HGROUP, d.HGROUP],
  [Q.HR, d.HR],
  [Q.HTML, d.HTML],
  [Q.I, d.I],
  [Q.IMG, d.IMG],
  [Q.IMAGE, d.IMAGE],
  [Q.INPUT, d.INPUT],
  [Q.IFRAME, d.IFRAME],
  [Q.KEYGEN, d.KEYGEN],
  [Q.LABEL, d.LABEL],
  [Q.LI, d.LI],
  [Q.LINK, d.LINK],
  [Q.LISTING, d.LISTING],
  [Q.MAIN, d.MAIN],
  [Q.MALIGNMARK, d.MALIGNMARK],
  [Q.MARQUEE, d.MARQUEE],
  [Q.MATH, d.MATH],
  [Q.MENU, d.MENU],
  [Q.META, d.META],
  [Q.MGLYPH, d.MGLYPH],
  [Q.MI, d.MI],
  [Q.MO, d.MO],
  [Q.MN, d.MN],
  [Q.MS, d.MS],
  [Q.MTEXT, d.MTEXT],
  [Q.NAV, d.NAV],
  [Q.NOBR, d.NOBR],
  [Q.NOFRAMES, d.NOFRAMES],
  [Q.NOEMBED, d.NOEMBED],
  [Q.NOSCRIPT, d.NOSCRIPT],
  [Q.OBJECT, d.OBJECT],
  [Q.OL, d.OL],
  [Q.OPTGROUP, d.OPTGROUP],
  [Q.OPTION, d.OPTION],
  [Q.P, d.P],
  [Q.PARAM, d.PARAM],
  [Q.PLAINTEXT, d.PLAINTEXT],
  [Q.PRE, d.PRE],
  [Q.RB, d.RB],
  [Q.RP, d.RP],
  [Q.RT, d.RT],
  [Q.RTC, d.RTC],
  [Q.RUBY, d.RUBY],
  [Q.S, d.S],
  [Q.SCRIPT, d.SCRIPT],
  [Q.SECTION, d.SECTION],
  [Q.SELECT, d.SELECT],
  [Q.SOURCE, d.SOURCE],
  [Q.SMALL, d.SMALL],
  [Q.SPAN, d.SPAN],
  [Q.STRIKE, d.STRIKE],
  [Q.STRONG, d.STRONG],
  [Q.STYLE, d.STYLE],
  [Q.SUB, d.SUB],
  [Q.SUMMARY, d.SUMMARY],
  [Q.SUP, d.SUP],
  [Q.TABLE, d.TABLE],
  [Q.TBODY, d.TBODY],
  [Q.TEMPLATE, d.TEMPLATE],
  [Q.TEXTAREA, d.TEXTAREA],
  [Q.TFOOT, d.TFOOT],
  [Q.TD, d.TD],
  [Q.TH, d.TH],
  [Q.THEAD, d.THEAD],
  [Q.TITLE, d.TITLE],
  [Q.TR, d.TR],
  [Q.TRACK, d.TRACK],
  [Q.TT, d.TT],
  [Q.U, d.U],
  [Q.UL, d.UL],
  [Q.SVG, d.SVG],
  [Q.VAR, d.VAR],
  [Q.WBR, d.WBR],
  [Q.XMP, d.XMP],
])
function pu(e) {
  var t
  return (t = fk.get(e)) !== null && t !== void 0 ? t : d.UNKNOWN
}
const ae = d,
  pk = {
    [ee.HTML]: new Set([
      ae.ADDRESS,
      ae.APPLET,
      ae.AREA,
      ae.ARTICLE,
      ae.ASIDE,
      ae.BASE,
      ae.BASEFONT,
      ae.BGSOUND,
      ae.BLOCKQUOTE,
      ae.BODY,
      ae.BR,
      ae.BUTTON,
      ae.CAPTION,
      ae.CENTER,
      ae.COL,
      ae.COLGROUP,
      ae.DD,
      ae.DETAILS,
      ae.DIR,
      ae.DIV,
      ae.DL,
      ae.DT,
      ae.EMBED,
      ae.FIELDSET,
      ae.FIGCAPTION,
      ae.FIGURE,
      ae.FOOTER,
      ae.FORM,
      ae.FRAME,
      ae.FRAMESET,
      ae.H1,
      ae.H2,
      ae.H3,
      ae.H4,
      ae.H5,
      ae.H6,
      ae.HEAD,
      ae.HEADER,
      ae.HGROUP,
      ae.HR,
      ae.HTML,
      ae.IFRAME,
      ae.IMG,
      ae.INPUT,
      ae.LI,
      ae.LINK,
      ae.LISTING,
      ae.MAIN,
      ae.MARQUEE,
      ae.MENU,
      ae.META,
      ae.NAV,
      ae.NOEMBED,
      ae.NOFRAMES,
      ae.NOSCRIPT,
      ae.OBJECT,
      ae.OL,
      ae.P,
      ae.PARAM,
      ae.PLAINTEXT,
      ae.PRE,
      ae.SCRIPT,
      ae.SECTION,
      ae.SELECT,
      ae.SOURCE,
      ae.STYLE,
      ae.SUMMARY,
      ae.TABLE,
      ae.TBODY,
      ae.TD,
      ae.TEMPLATE,
      ae.TEXTAREA,
      ae.TFOOT,
      ae.TH,
      ae.THEAD,
      ae.TITLE,
      ae.TR,
      ae.TRACK,
      ae.UL,
      ae.WBR,
      ae.XMP,
    ]),
    [ee.MATHML]: new Set([ae.MI, ae.MO, ae.MN, ae.MS, ae.MTEXT, ae.ANNOTATION_XML]),
    [ee.SVG]: new Set([ae.TITLE, ae.FOREIGN_OBJECT, ae.DESC]),
    [ee.XLINK]: new Set(),
    [ee.XML]: new Set(),
    [ee.XMLNS]: new Set(),
  }
function tb(e) {
  return e === ae.H1 || e === ae.H2 || e === ae.H3 || e === ae.H4 || e === ae.H5 || e === ae.H6
}
Q.STYLE, Q.SCRIPT, Q.XMP, Q.IFRAME, Q.NOEMBED, Q.NOFRAMES, Q.PLAINTEXT
const hk = new Map([
  [128, 8364],
  [130, 8218],
  [131, 402],
  [132, 8222],
  [133, 8230],
  [134, 8224],
  [135, 8225],
  [136, 710],
  [137, 8240],
  [138, 352],
  [139, 8249],
  [140, 338],
  [142, 381],
  [145, 8216],
  [146, 8217],
  [147, 8220],
  [148, 8221],
  [149, 8226],
  [150, 8211],
  [151, 8212],
  [152, 732],
  [153, 8482],
  [154, 353],
  [155, 8250],
  [156, 339],
  [158, 382],
  [159, 376],
])
var U
;(function (e) {
  ;(e[(e.DATA = 0)] = 'DATA'),
    (e[(e.RCDATA = 1)] = 'RCDATA'),
    (e[(e.RAWTEXT = 2)] = 'RAWTEXT'),
    (e[(e.SCRIPT_DATA = 3)] = 'SCRIPT_DATA'),
    (e[(e.PLAINTEXT = 4)] = 'PLAINTEXT'),
    (e[(e.TAG_OPEN = 5)] = 'TAG_OPEN'),
    (e[(e.END_TAG_OPEN = 6)] = 'END_TAG_OPEN'),
    (e[(e.TAG_NAME = 7)] = 'TAG_NAME'),
    (e[(e.RCDATA_LESS_THAN_SIGN = 8)] = 'RCDATA_LESS_THAN_SIGN'),
    (e[(e.RCDATA_END_TAG_OPEN = 9)] = 'RCDATA_END_TAG_OPEN'),
    (e[(e.RCDATA_END_TAG_NAME = 10)] = 'RCDATA_END_TAG_NAME'),
    (e[(e.RAWTEXT_LESS_THAN_SIGN = 11)] = 'RAWTEXT_LESS_THAN_SIGN'),
    (e[(e.RAWTEXT_END_TAG_OPEN = 12)] = 'RAWTEXT_END_TAG_OPEN'),
    (e[(e.RAWTEXT_END_TAG_NAME = 13)] = 'RAWTEXT_END_TAG_NAME'),
    (e[(e.SCRIPT_DATA_LESS_THAN_SIGN = 14)] = 'SCRIPT_DATA_LESS_THAN_SIGN'),
    (e[(e.SCRIPT_DATA_END_TAG_OPEN = 15)] = 'SCRIPT_DATA_END_TAG_OPEN'),
    (e[(e.SCRIPT_DATA_END_TAG_NAME = 16)] = 'SCRIPT_DATA_END_TAG_NAME'),
    (e[(e.SCRIPT_DATA_ESCAPE_START = 17)] = 'SCRIPT_DATA_ESCAPE_START'),
    (e[(e.SCRIPT_DATA_ESCAPE_START_DASH = 18)] = 'SCRIPT_DATA_ESCAPE_START_DASH'),
    (e[(e.SCRIPT_DATA_ESCAPED = 19)] = 'SCRIPT_DATA_ESCAPED'),
    (e[(e.SCRIPT_DATA_ESCAPED_DASH = 20)] = 'SCRIPT_DATA_ESCAPED_DASH'),
    (e[(e.SCRIPT_DATA_ESCAPED_DASH_DASH = 21)] = 'SCRIPT_DATA_ESCAPED_DASH_DASH'),
    (e[(e.SCRIPT_DATA_ESCAPED_LESS_THAN_SIGN = 22)] = 'SCRIPT_DATA_ESCAPED_LESS_THAN_SIGN'),
    (e[(e.SCRIPT_DATA_ESCAPED_END_TAG_OPEN = 23)] = 'SCRIPT_DATA_ESCAPED_END_TAG_OPEN'),
    (e[(e.SCRIPT_DATA_ESCAPED_END_TAG_NAME = 24)] = 'SCRIPT_DATA_ESCAPED_END_TAG_NAME'),
    (e[(e.SCRIPT_DATA_DOUBLE_ESCAPE_START = 25)] = 'SCRIPT_DATA_DOUBLE_ESCAPE_START'),
    (e[(e.SCRIPT_DATA_DOUBLE_ESCAPED = 26)] = 'SCRIPT_DATA_DOUBLE_ESCAPED'),
    (e[(e.SCRIPT_DATA_DOUBLE_ESCAPED_DASH = 27)] = 'SCRIPT_DATA_DOUBLE_ESCAPED_DASH'),
    (e[(e.SCRIPT_DATA_DOUBLE_ESCAPED_DASH_DASH = 28)] = 'SCRIPT_DATA_DOUBLE_ESCAPED_DASH_DASH'),
    (e[(e.SCRIPT_DATA_DOUBLE_ESCAPED_LESS_THAN_SIGN = 29)] =
      'SCRIPT_DATA_DOUBLE_ESCAPED_LESS_THAN_SIGN'),
    (e[(e.SCRIPT_DATA_DOUBLE_ESCAPE_END = 30)] = 'SCRIPT_DATA_DOUBLE_ESCAPE_END'),
    (e[(e.BEFORE_ATTRIBUTE_NAME = 31)] = 'BEFORE_ATTRIBUTE_NAME'),
    (e[(e.ATTRIBUTE_NAME = 32)] = 'ATTRIBUTE_NAME'),
    (e[(e.AFTER_ATTRIBUTE_NAME = 33)] = 'AFTER_ATTRIBUTE_NAME'),
    (e[(e.BEFORE_ATTRIBUTE_VALUE = 34)] = 'BEFORE_ATTRIBUTE_VALUE'),
    (e[(e.ATTRIBUTE_VALUE_DOUBLE_QUOTED = 35)] = 'ATTRIBUTE_VALUE_DOUBLE_QUOTED'),
    (e[(e.ATTRIBUTE_VALUE_SINGLE_QUOTED = 36)] = 'ATTRIBUTE_VALUE_SINGLE_QUOTED'),
    (e[(e.ATTRIBUTE_VALUE_UNQUOTED = 37)] = 'ATTRIBUTE_VALUE_UNQUOTED'),
    (e[(e.AFTER_ATTRIBUTE_VALUE_QUOTED = 38)] = 'AFTER_ATTRIBUTE_VALUE_QUOTED'),
    (e[(e.SELF_CLOSING_START_TAG = 39)] = 'SELF_CLOSING_START_TAG'),
    (e[(e.BOGUS_COMMENT = 40)] = 'BOGUS_COMMENT'),
    (e[(e.MARKUP_DECLARATION_OPEN = 41)] = 'MARKUP_DECLARATION_OPEN'),
    (e[(e.COMMENT_START = 42)] = 'COMMENT_START'),
    (e[(e.COMMENT_START_DASH = 43)] = 'COMMENT_START_DASH'),
    (e[(e.COMMENT = 44)] = 'COMMENT'),
    (e[(e.COMMENT_LESS_THAN_SIGN = 45)] = 'COMMENT_LESS_THAN_SIGN'),
    (e[(e.COMMENT_LESS_THAN_SIGN_BANG = 46)] = 'COMMENT_LESS_THAN_SIGN_BANG'),
    (e[(e.COMMENT_LESS_THAN_SIGN_BANG_DASH = 47)] = 'COMMENT_LESS_THAN_SIGN_BANG_DASH'),
    (e[(e.COMMENT_LESS_THAN_SIGN_BANG_DASH_DASH = 48)] = 'COMMENT_LESS_THAN_SIGN_BANG_DASH_DASH'),
    (e[(e.COMMENT_END_DASH = 49)] = 'COMMENT_END_DASH'),
    (e[(e.COMMENT_END = 50)] = 'COMMENT_END'),
    (e[(e.COMMENT_END_BANG = 51)] = 'COMMENT_END_BANG'),
    (e[(e.DOCTYPE = 52)] = 'DOCTYPE'),
    (e[(e.BEFORE_DOCTYPE_NAME = 53)] = 'BEFORE_DOCTYPE_NAME'),
    (e[(e.DOCTYPE_NAME = 54)] = 'DOCTYPE_NAME'),
    (e[(e.AFTER_DOCTYPE_NAME = 55)] = 'AFTER_DOCTYPE_NAME'),
    (e[(e.AFTER_DOCTYPE_PUBLIC_KEYWORD = 56)] = 'AFTER_DOCTYPE_PUBLIC_KEYWORD'),
    (e[(e.BEFORE_DOCTYPE_PUBLIC_IDENTIFIER = 57)] = 'BEFORE_DOCTYPE_PUBLIC_IDENTIFIER'),
    (e[(e.DOCTYPE_PUBLIC_IDENTIFIER_DOUBLE_QUOTED = 58)] =
      'DOCTYPE_PUBLIC_IDENTIFIER_DOUBLE_QUOTED'),
    (e[(e.DOCTYPE_PUBLIC_IDENTIFIER_SINGLE_QUOTED = 59)] =
      'DOCTYPE_PUBLIC_IDENTIFIER_SINGLE_QUOTED'),
    (e[(e.AFTER_DOCTYPE_PUBLIC_IDENTIFIER = 60)] = 'AFTER_DOCTYPE_PUBLIC_IDENTIFIER'),
    (e[(e.BETWEEN_DOCTYPE_PUBLIC_AND_SYSTEM_IDENTIFIERS = 61)] =
      'BETWEEN_DOCTYPE_PUBLIC_AND_SYSTEM_IDENTIFIERS'),
    (e[(e.AFTER_DOCTYPE_SYSTEM_KEYWORD = 62)] = 'AFTER_DOCTYPE_SYSTEM_KEYWORD'),
    (e[(e.BEFORE_DOCTYPE_SYSTEM_IDENTIFIER = 63)] = 'BEFORE_DOCTYPE_SYSTEM_IDENTIFIER'),
    (e[(e.DOCTYPE_SYSTEM_IDENTIFIER_DOUBLE_QUOTED = 64)] =
      'DOCTYPE_SYSTEM_IDENTIFIER_DOUBLE_QUOTED'),
    (e[(e.DOCTYPE_SYSTEM_IDENTIFIER_SINGLE_QUOTED = 65)] =
      'DOCTYPE_SYSTEM_IDENTIFIER_SINGLE_QUOTED'),
    (e[(e.AFTER_DOCTYPE_SYSTEM_IDENTIFIER = 66)] = 'AFTER_DOCTYPE_SYSTEM_IDENTIFIER'),
    (e[(e.BOGUS_DOCTYPE = 67)] = 'BOGUS_DOCTYPE'),
    (e[(e.CDATA_SECTION = 68)] = 'CDATA_SECTION'),
    (e[(e.CDATA_SECTION_BRACKET = 69)] = 'CDATA_SECTION_BRACKET'),
    (e[(e.CDATA_SECTION_END = 70)] = 'CDATA_SECTION_END'),
    (e[(e.CHARACTER_REFERENCE = 71)] = 'CHARACTER_REFERENCE'),
    (e[(e.NAMED_CHARACTER_REFERENCE = 72)] = 'NAMED_CHARACTER_REFERENCE'),
    (e[(e.AMBIGUOUS_AMPERSAND = 73)] = 'AMBIGUOUS_AMPERSAND'),
    (e[(e.NUMERIC_CHARACTER_REFERENCE = 74)] = 'NUMERIC_CHARACTER_REFERENCE'),
    (e[(e.HEXADEMICAL_CHARACTER_REFERENCE_START = 75)] = 'HEXADEMICAL_CHARACTER_REFERENCE_START'),
    (e[(e.HEXADEMICAL_CHARACTER_REFERENCE = 76)] = 'HEXADEMICAL_CHARACTER_REFERENCE'),
    (e[(e.DECIMAL_CHARACTER_REFERENCE = 77)] = 'DECIMAL_CHARACTER_REFERENCE'),
    (e[(e.NUMERIC_CHARACTER_REFERENCE_END = 78)] = 'NUMERIC_CHARACTER_REFERENCE_END')
})(U || (U = {}))
const St = {
  DATA: U.DATA,
  RCDATA: U.RCDATA,
  RAWTEXT: U.RAWTEXT,
  SCRIPT_DATA: U.SCRIPT_DATA,
  PLAINTEXT: U.PLAINTEXT,
  CDATA_SECTION: U.CDATA_SECTION,
}
function ys(e) {
  return e >= B.DIGIT_0 && e <= B.DIGIT_9
}
function as(e) {
  return e >= B.LATIN_CAPITAL_A && e <= B.LATIN_CAPITAL_Z
}
function mk(e) {
  return e >= B.LATIN_SMALL_A && e <= B.LATIN_SMALL_Z
}
function jr(e) {
  return mk(e) || as(e)
}
function Bc(e) {
  return jr(e) || ys(e)
}
function rb(e) {
  return e >= B.LATIN_CAPITAL_A && e <= B.LATIN_CAPITAL_F
}
function ib(e) {
  return e >= B.LATIN_SMALL_A && e <= B.LATIN_SMALL_F
}
function dk(e) {
  return ys(e) || rb(e) || ib(e)
}
function Ua(e) {
  return e + 32
}
function nb(e) {
  return e === B.SPACE || e === B.LINE_FEED || e === B.TABULATION || e === B.FORM_FEED
}
function gk(e) {
  return e === B.EQUALS_SIGN || Bc(e)
}
function Hm(e) {
  return nb(e) || e === B.SOLIDUS || e === B.GREATER_THAN_SIGN
}
class bk {
  constructor(t, r) {
    ;(this.options = t),
      (this.handler = r),
      (this.paused = !1),
      (this.inLoop = !1),
      (this.inForeignNode = !1),
      (this.lastStartTagName = ''),
      (this.active = !1),
      (this.state = U.DATA),
      (this.returnState = U.DATA),
      (this.charRefCode = -1),
      (this.consumedAfterSnapshot = -1),
      (this.currentCharacterToken = null),
      (this.currentToken = null),
      (this.currentAttr = { name: '', value: '' }),
      (this.preprocessor = new tk(r)),
      (this.currentLocation = this.getCurrentLocation(-1))
  }
  _err(t) {
    var r, i
    ;(i = (r = this.handler).onParseError) === null ||
      i === void 0 ||
      i.call(r, this.preprocessor.getError(t))
  }
  getCurrentLocation(t) {
    return this.options.sourceCodeLocationInfo
      ? {
          startLine: this.preprocessor.line,
          startCol: this.preprocessor.col - t,
          startOffset: this.preprocessor.offset - t,
          endLine: -1,
          endCol: -1,
          endOffset: -1,
        }
      : null
  }
  _runParsingLoop() {
    if (!this.inLoop) {
      for (this.inLoop = !0; this.active && !this.paused; ) {
        this.consumedAfterSnapshot = 0
        const t = this._consume()
        this._ensureHibernation() || this._callState(t)
      }
      this.inLoop = !1
    }
  }
  pause() {
    this.paused = !0
  }
  resume(t) {
    if (!this.paused) throw new Error('Parser was already resumed')
    ;(this.paused = !1), !this.inLoop && (this._runParsingLoop(), this.paused || t == null || t())
  }
  write(t, r, i) {
    ;(this.active = !0),
      this.preprocessor.write(t, r),
      this._runParsingLoop(),
      this.paused || i == null || i()
  }
  insertHtmlAtCurrentPos(t) {
    ;(this.active = !0), this.preprocessor.insertHtmlAtCurrentPos(t), this._runParsingLoop()
  }
  _ensureHibernation() {
    return this.preprocessor.endOfChunkHit
      ? (this._unconsume(this.consumedAfterSnapshot), (this.active = !1), !0)
      : !1
  }
  _consume() {
    return this.consumedAfterSnapshot++, this.preprocessor.advance()
  }
  _unconsume(t) {
    ;(this.consumedAfterSnapshot -= t), this.preprocessor.retreat(t)
  }
  _reconsumeInState(t, r) {
    ;(this.state = t), this._callState(r)
  }
  _advanceBy(t) {
    this.consumedAfterSnapshot += t
    for (let r = 0; r < t; r++) this.preprocessor.advance()
  }
  _consumeSequenceIfMatch(t, r) {
    return this.preprocessor.startsWith(t, r) ? (this._advanceBy(t.length - 1), !0) : !1
  }
  _createStartTagToken() {
    this.currentToken = {
      type: ke.START_TAG,
      tagName: '',
      tagID: d.UNKNOWN,
      selfClosing: !1,
      ackSelfClosing: !1,
      attrs: [],
      location: this.getCurrentLocation(1),
    }
  }
  _createEndTagToken() {
    this.currentToken = {
      type: ke.END_TAG,
      tagName: '',
      tagID: d.UNKNOWN,
      selfClosing: !1,
      ackSelfClosing: !1,
      attrs: [],
      location: this.getCurrentLocation(2),
    }
  }
  _createCommentToken(t) {
    this.currentToken = { type: ke.COMMENT, data: '', location: this.getCurrentLocation(t) }
  }
  _createDoctypeToken(t) {
    this.currentToken = {
      type: ke.DOCTYPE,
      name: t,
      forceQuirks: !1,
      publicId: null,
      systemId: null,
      location: this.currentLocation,
    }
  }
  _createCharacterToken(t, r) {
    this.currentCharacterToken = { type: t, chars: r, location: this.currentLocation }
  }
  _createAttr(t) {
    ;(this.currentAttr = { name: t, value: '' }),
      (this.currentLocation = this.getCurrentLocation(0))
  }
  _leaveAttrName() {
    var t, r
    const i = this.currentToken
    if (J1(i, this.currentAttr.name) === null) {
      if ((i.attrs.push(this.currentAttr), i.location && this.currentLocation)) {
        const n =
          (t = (r = i.location).attrs) !== null && t !== void 0
            ? t
            : (r.attrs = Object.create(null))
        ;(n[this.currentAttr.name] = this.currentLocation), this._leaveAttrValue()
      }
    } else this._err(J.duplicateAttribute)
  }
  _leaveAttrValue() {
    this.currentLocation &&
      ((this.currentLocation.endLine = this.preprocessor.line),
      (this.currentLocation.endCol = this.preprocessor.col),
      (this.currentLocation.endOffset = this.preprocessor.offset))
  }
  prepareToken(t) {
    this._emitCurrentCharacterToken(t.location),
      (this.currentToken = null),
      t.location &&
        ((t.location.endLine = this.preprocessor.line),
        (t.location.endCol = this.preprocessor.col + 1),
        (t.location.endOffset = this.preprocessor.offset + 1)),
      (this.currentLocation = this.getCurrentLocation(-1))
  }
  emitCurrentTagToken() {
    const t = this.currentToken
    this.prepareToken(t),
      (t.tagID = pu(t.tagName)),
      t.type === ke.START_TAG
        ? ((this.lastStartTagName = t.tagName), this.handler.onStartTag(t))
        : (t.attrs.length > 0 && this._err(J.endTagWithAttributes),
          t.selfClosing && this._err(J.endTagWithTrailingSolidus),
          this.handler.onEndTag(t)),
      this.preprocessor.dropParsedChunk()
  }
  emitCurrentComment(t) {
    this.prepareToken(t), this.handler.onComment(t), this.preprocessor.dropParsedChunk()
  }
  emitCurrentDoctype(t) {
    this.prepareToken(t), this.handler.onDoctype(t), this.preprocessor.dropParsedChunk()
  }
  _emitCurrentCharacterToken(t) {
    if (this.currentCharacterToken) {
      switch (
        (t &&
          this.currentCharacterToken.location &&
          ((this.currentCharacterToken.location.endLine = t.startLine),
          (this.currentCharacterToken.location.endCol = t.startCol),
          (this.currentCharacterToken.location.endOffset = t.startOffset)),
        this.currentCharacterToken.type)
      ) {
        case ke.CHARACTER: {
          this.handler.onCharacter(this.currentCharacterToken)
          break
        }
        case ke.NULL_CHARACTER: {
          this.handler.onNullCharacter(this.currentCharacterToken)
          break
        }
        case ke.WHITESPACE_CHARACTER: {
          this.handler.onWhitespaceCharacter(this.currentCharacterToken)
          break
        }
      }
      this.currentCharacterToken = null
    }
  }
  _emitEOFToken() {
    const t = this.getCurrentLocation(0)
    t && ((t.endLine = t.startLine), (t.endCol = t.startCol), (t.endOffset = t.startOffset)),
      this._emitCurrentCharacterToken(t),
      this.handler.onEof({ type: ke.EOF, location: t }),
      (this.active = !1)
  }
  _appendCharToCurrentCharacterToken(t, r) {
    if (this.currentCharacterToken)
      if (this.currentCharacterToken.type !== t)
        (this.currentLocation = this.getCurrentLocation(0)),
          this._emitCurrentCharacterToken(this.currentLocation),
          this.preprocessor.dropParsedChunk()
      else {
        this.currentCharacterToken.chars += r
        return
      }
    this._createCharacterToken(t, r)
  }
  _emitCodePoint(t) {
    const r = nb(t) ? ke.WHITESPACE_CHARACTER : t === B.NULL ? ke.NULL_CHARACTER : ke.CHARACTER
    this._appendCharToCurrentCharacterToken(r, String.fromCodePoint(t))
  }
  _emitChars(t) {
    this._appendCharToCurrentCharacterToken(ke.CHARACTER, t)
  }
  _matchNamedCharacterReference(t) {
    let r = null,
      i = 0,
      n = !1
    for (
      let s = 0, a = zr[0];
      s >= 0 && ((s = eb(zr, a, s + 1, t)), !(s < 0));
      t = this._consume()
    ) {
      ;(i += 1), (a = zr[s])
      const o = a & dr.VALUE_LENGTH
      if (o) {
        const u = (o >> 14) - 1
        if (
          (t !== B.SEMICOLON &&
          this._isCharacterReferenceInAttribute() &&
          gk(this.preprocessor.peek(1))
            ? ((r = [B.AMPERSAND]), (s += u))
            : ((r =
                u === 0 ? [zr[s] & ~dr.VALUE_LENGTH] : u === 1 ? [zr[++s]] : [zr[++s], zr[++s]]),
              (i = 0),
              (n = t !== B.SEMICOLON)),
          u === 0)
        ) {
          this._consume()
          break
        }
      }
    }
    return (
      this._unconsume(i),
      n && !this.preprocessor.endOfChunkHit && this._err(J.missingSemicolonAfterCharacterReference),
      this._unconsume(1),
      r
    )
  }
  _isCharacterReferenceInAttribute() {
    return (
      this.returnState === U.ATTRIBUTE_VALUE_DOUBLE_QUOTED ||
      this.returnState === U.ATTRIBUTE_VALUE_SINGLE_QUOTED ||
      this.returnState === U.ATTRIBUTE_VALUE_UNQUOTED
    )
  }
  _flushCodePointConsumedAsCharacterReference(t) {
    this._isCharacterReferenceInAttribute()
      ? (this.currentAttr.value += String.fromCodePoint(t))
      : this._emitCodePoint(t)
  }
  _callState(t) {
    switch (this.state) {
      case U.DATA: {
        this._stateData(t)
        break
      }
      case U.RCDATA: {
        this._stateRcdata(t)
        break
      }
      case U.RAWTEXT: {
        this._stateRawtext(t)
        break
      }
      case U.SCRIPT_DATA: {
        this._stateScriptData(t)
        break
      }
      case U.PLAINTEXT: {
        this._statePlaintext(t)
        break
      }
      case U.TAG_OPEN: {
        this._stateTagOpen(t)
        break
      }
      case U.END_TAG_OPEN: {
        this._stateEndTagOpen(t)
        break
      }
      case U.TAG_NAME: {
        this._stateTagName(t)
        break
      }
      case U.RCDATA_LESS_THAN_SIGN: {
        this._stateRcdataLessThanSign(t)
        break
      }
      case U.RCDATA_END_TAG_OPEN: {
        this._stateRcdataEndTagOpen(t)
        break
      }
      case U.RCDATA_END_TAG_NAME: {
        this._stateRcdataEndTagName(t)
        break
      }
      case U.RAWTEXT_LESS_THAN_SIGN: {
        this._stateRawtextLessThanSign(t)
        break
      }
      case U.RAWTEXT_END_TAG_OPEN: {
        this._stateRawtextEndTagOpen(t)
        break
      }
      case U.RAWTEXT_END_TAG_NAME: {
        this._stateRawtextEndTagName(t)
        break
      }
      case U.SCRIPT_DATA_LESS_THAN_SIGN: {
        this._stateScriptDataLessThanSign(t)
        break
      }
      case U.SCRIPT_DATA_END_TAG_OPEN: {
        this._stateScriptDataEndTagOpen(t)
        break
      }
      case U.SCRIPT_DATA_END_TAG_NAME: {
        this._stateScriptDataEndTagName(t)
        break
      }
      case U.SCRIPT_DATA_ESCAPE_START: {
        this._stateScriptDataEscapeStart(t)
        break
      }
      case U.SCRIPT_DATA_ESCAPE_START_DASH: {
        this._stateScriptDataEscapeStartDash(t)
        break
      }
      case U.SCRIPT_DATA_ESCAPED: {
        this._stateScriptDataEscaped(t)
        break
      }
      case U.SCRIPT_DATA_ESCAPED_DASH: {
        this._stateScriptDataEscapedDash(t)
        break
      }
      case U.SCRIPT_DATA_ESCAPED_DASH_DASH: {
        this._stateScriptDataEscapedDashDash(t)
        break
      }
      case U.SCRIPT_DATA_ESCAPED_LESS_THAN_SIGN: {
        this._stateScriptDataEscapedLessThanSign(t)
        break
      }
      case U.SCRIPT_DATA_ESCAPED_END_TAG_OPEN: {
        this._stateScriptDataEscapedEndTagOpen(t)
        break
      }
      case U.SCRIPT_DATA_ESCAPED_END_TAG_NAME: {
        this._stateScriptDataEscapedEndTagName(t)
        break
      }
      case U.SCRIPT_DATA_DOUBLE_ESCAPE_START: {
        this._stateScriptDataDoubleEscapeStart(t)
        break
      }
      case U.SCRIPT_DATA_DOUBLE_ESCAPED: {
        this._stateScriptDataDoubleEscaped(t)
        break
      }
      case U.SCRIPT_DATA_DOUBLE_ESCAPED_DASH: {
        this._stateScriptDataDoubleEscapedDash(t)
        break
      }
      case U.SCRIPT_DATA_DOUBLE_ESCAPED_DASH_DASH: {
        this._stateScriptDataDoubleEscapedDashDash(t)
        break
      }
      case U.SCRIPT_DATA_DOUBLE_ESCAPED_LESS_THAN_SIGN: {
        this._stateScriptDataDoubleEscapedLessThanSign(t)
        break
      }
      case U.SCRIPT_DATA_DOUBLE_ESCAPE_END: {
        this._stateScriptDataDoubleEscapeEnd(t)
        break
      }
      case U.BEFORE_ATTRIBUTE_NAME: {
        this._stateBeforeAttributeName(t)
        break
      }
      case U.ATTRIBUTE_NAME: {
        this._stateAttributeName(t)
        break
      }
      case U.AFTER_ATTRIBUTE_NAME: {
        this._stateAfterAttributeName(t)
        break
      }
      case U.BEFORE_ATTRIBUTE_VALUE: {
        this._stateBeforeAttributeValue(t)
        break
      }
      case U.ATTRIBUTE_VALUE_DOUBLE_QUOTED: {
        this._stateAttributeValueDoubleQuoted(t)
        break
      }
      case U.ATTRIBUTE_VALUE_SINGLE_QUOTED: {
        this._stateAttributeValueSingleQuoted(t)
        break
      }
      case U.ATTRIBUTE_VALUE_UNQUOTED: {
        this._stateAttributeValueUnquoted(t)
        break
      }
      case U.AFTER_ATTRIBUTE_VALUE_QUOTED: {
        this._stateAfterAttributeValueQuoted(t)
        break
      }
      case U.SELF_CLOSING_START_TAG: {
        this._stateSelfClosingStartTag(t)
        break
      }
      case U.BOGUS_COMMENT: {
        this._stateBogusComment(t)
        break
      }
      case U.MARKUP_DECLARATION_OPEN: {
        this._stateMarkupDeclarationOpen(t)
        break
      }
      case U.COMMENT_START: {
        this._stateCommentStart(t)
        break
      }
      case U.COMMENT_START_DASH: {
        this._stateCommentStartDash(t)
        break
      }
      case U.COMMENT: {
        this._stateComment(t)
        break
      }
      case U.COMMENT_LESS_THAN_SIGN: {
        this._stateCommentLessThanSign(t)
        break
      }
      case U.COMMENT_LESS_THAN_SIGN_BANG: {
        this._stateCommentLessThanSignBang(t)
        break
      }
      case U.COMMENT_LESS_THAN_SIGN_BANG_DASH: {
        this._stateCommentLessThanSignBangDash(t)
        break
      }
      case U.COMMENT_LESS_THAN_SIGN_BANG_DASH_DASH: {
        this._stateCommentLessThanSignBangDashDash(t)
        break
      }
      case U.COMMENT_END_DASH: {
        this._stateCommentEndDash(t)
        break
      }
      case U.COMMENT_END: {
        this._stateCommentEnd(t)
        break
      }
      case U.COMMENT_END_BANG: {
        this._stateCommentEndBang(t)
        break
      }
      case U.DOCTYPE: {
        this._stateDoctype(t)
        break
      }
      case U.BEFORE_DOCTYPE_NAME: {
        this._stateBeforeDoctypeName(t)
        break
      }
      case U.DOCTYPE_NAME: {
        this._stateDoctypeName(t)
        break
      }
      case U.AFTER_DOCTYPE_NAME: {
        this._stateAfterDoctypeName(t)
        break
      }
      case U.AFTER_DOCTYPE_PUBLIC_KEYWORD: {
        this._stateAfterDoctypePublicKeyword(t)
        break
      }
      case U.BEFORE_DOCTYPE_PUBLIC_IDENTIFIER: {
        this._stateBeforeDoctypePublicIdentifier(t)
        break
      }
      case U.DOCTYPE_PUBLIC_IDENTIFIER_DOUBLE_QUOTED: {
        this._stateDoctypePublicIdentifierDoubleQuoted(t)
        break
      }
      case U.DOCTYPE_PUBLIC_IDENTIFIER_SINGLE_QUOTED: {
        this._stateDoctypePublicIdentifierSingleQuoted(t)
        break
      }
      case U.AFTER_DOCTYPE_PUBLIC_IDENTIFIER: {
        this._stateAfterDoctypePublicIdentifier(t)
        break
      }
      case U.BETWEEN_DOCTYPE_PUBLIC_AND_SYSTEM_IDENTIFIERS: {
        this._stateBetweenDoctypePublicAndSystemIdentifiers(t)
        break
      }
      case U.AFTER_DOCTYPE_SYSTEM_KEYWORD: {
        this._stateAfterDoctypeSystemKeyword(t)
        break
      }
      case U.BEFORE_DOCTYPE_SYSTEM_IDENTIFIER: {
        this._stateBeforeDoctypeSystemIdentifier(t)
        break
      }
      case U.DOCTYPE_SYSTEM_IDENTIFIER_DOUBLE_QUOTED: {
        this._stateDoctypeSystemIdentifierDoubleQuoted(t)
        break
      }
      case U.DOCTYPE_SYSTEM_IDENTIFIER_SINGLE_QUOTED: {
        this._stateDoctypeSystemIdentifierSingleQuoted(t)
        break
      }
      case U.AFTER_DOCTYPE_SYSTEM_IDENTIFIER: {
        this._stateAfterDoctypeSystemIdentifier(t)
        break
      }
      case U.BOGUS_DOCTYPE: {
        this._stateBogusDoctype(t)
        break
      }
      case U.CDATA_SECTION: {
        this._stateCdataSection(t)
        break
      }
      case U.CDATA_SECTION_BRACKET: {
        this._stateCdataSectionBracket(t)
        break
      }
      case U.CDATA_SECTION_END: {
        this._stateCdataSectionEnd(t)
        break
      }
      case U.CHARACTER_REFERENCE: {
        this._stateCharacterReference(t)
        break
      }
      case U.NAMED_CHARACTER_REFERENCE: {
        this._stateNamedCharacterReference(t)
        break
      }
      case U.AMBIGUOUS_AMPERSAND: {
        this._stateAmbiguousAmpersand(t)
        break
      }
      case U.NUMERIC_CHARACTER_REFERENCE: {
        this._stateNumericCharacterReference(t)
        break
      }
      case U.HEXADEMICAL_CHARACTER_REFERENCE_START: {
        this._stateHexademicalCharacterReferenceStart(t)
        break
      }
      case U.HEXADEMICAL_CHARACTER_REFERENCE: {
        this._stateHexademicalCharacterReference(t)
        break
      }
      case U.DECIMAL_CHARACTER_REFERENCE: {
        this._stateDecimalCharacterReference(t)
        break
      }
      case U.NUMERIC_CHARACTER_REFERENCE_END: {
        this._stateNumericCharacterReferenceEnd(t)
        break
      }
      default:
        throw new Error('Unknown state')
    }
  }
  _stateData(t) {
    switch (t) {
      case B.LESS_THAN_SIGN: {
        this.state = U.TAG_OPEN
        break
      }
      case B.AMPERSAND: {
        ;(this.returnState = U.DATA), (this.state = U.CHARACTER_REFERENCE)
        break
      }
      case B.NULL: {
        this._err(J.unexpectedNullCharacter), this._emitCodePoint(t)
        break
      }
      case B.EOF: {
        this._emitEOFToken()
        break
      }
      default:
        this._emitCodePoint(t)
    }
  }
  _stateRcdata(t) {
    switch (t) {
      case B.AMPERSAND: {
        ;(this.returnState = U.RCDATA), (this.state = U.CHARACTER_REFERENCE)
        break
      }
      case B.LESS_THAN_SIGN: {
        this.state = U.RCDATA_LESS_THAN_SIGN
        break
      }
      case B.NULL: {
        this._err(J.unexpectedNullCharacter), this._emitChars(je)
        break
      }
      case B.EOF: {
        this._emitEOFToken()
        break
      }
      default:
        this._emitCodePoint(t)
    }
  }
  _stateRawtext(t) {
    switch (t) {
      case B.LESS_THAN_SIGN: {
        this.state = U.RAWTEXT_LESS_THAN_SIGN
        break
      }
      case B.NULL: {
        this._err(J.unexpectedNullCharacter), this._emitChars(je)
        break
      }
      case B.EOF: {
        this._emitEOFToken()
        break
      }
      default:
        this._emitCodePoint(t)
    }
  }
  _stateScriptData(t) {
    switch (t) {
      case B.LESS_THAN_SIGN: {
        this.state = U.SCRIPT_DATA_LESS_THAN_SIGN
        break
      }
      case B.NULL: {
        this._err(J.unexpectedNullCharacter), this._emitChars(je)
        break
      }
      case B.EOF: {
        this._emitEOFToken()
        break
      }
      default:
        this._emitCodePoint(t)
    }
  }
  _statePlaintext(t) {
    switch (t) {
      case B.NULL: {
        this._err(J.unexpectedNullCharacter), this._emitChars(je)
        break
      }
      case B.EOF: {
        this._emitEOFToken()
        break
      }
      default:
        this._emitCodePoint(t)
    }
  }
  _stateTagOpen(t) {
    if (jr(t)) this._createStartTagToken(), (this.state = U.TAG_NAME), this._stateTagName(t)
    else
      switch (t) {
        case B.EXCLAMATION_MARK: {
          this.state = U.MARKUP_DECLARATION_OPEN
          break
        }
        case B.SOLIDUS: {
          this.state = U.END_TAG_OPEN
          break
        }
        case B.QUESTION_MARK: {
          this._err(J.unexpectedQuestionMarkInsteadOfTagName),
            this._createCommentToken(1),
            (this.state = U.BOGUS_COMMENT),
            this._stateBogusComment(t)
          break
        }
        case B.EOF: {
          this._err(J.eofBeforeTagName), this._emitChars('<'), this._emitEOFToken()
          break
        }
        default:
          this._err(J.invalidFirstCharacterOfTagName),
            this._emitChars('<'),
            (this.state = U.DATA),
            this._stateData(t)
      }
  }
  _stateEndTagOpen(t) {
    if (jr(t)) this._createEndTagToken(), (this.state = U.TAG_NAME), this._stateTagName(t)
    else
      switch (t) {
        case B.GREATER_THAN_SIGN: {
          this._err(J.missingEndTagName), (this.state = U.DATA)
          break
        }
        case B.EOF: {
          this._err(J.eofBeforeTagName), this._emitChars('</'), this._emitEOFToken()
          break
        }
        default:
          this._err(J.invalidFirstCharacterOfTagName),
            this._createCommentToken(2),
            (this.state = U.BOGUS_COMMENT),
            this._stateBogusComment(t)
      }
  }
  _stateTagName(t) {
    const r = this.currentToken
    switch (t) {
      case B.SPACE:
      case B.LINE_FEED:
      case B.TABULATION:
      case B.FORM_FEED: {
        this.state = U.BEFORE_ATTRIBUTE_NAME
        break
      }
      case B.SOLIDUS: {
        this.state = U.SELF_CLOSING_START_TAG
        break
      }
      case B.GREATER_THAN_SIGN: {
        ;(this.state = U.DATA), this.emitCurrentTagToken()
        break
      }
      case B.NULL: {
        this._err(J.unexpectedNullCharacter), (r.tagName += je)
        break
      }
      case B.EOF: {
        this._err(J.eofInTag), this._emitEOFToken()
        break
      }
      default:
        r.tagName += String.fromCodePoint(as(t) ? Ua(t) : t)
    }
  }
  _stateRcdataLessThanSign(t) {
    t === B.SOLIDUS
      ? (this.state = U.RCDATA_END_TAG_OPEN)
      : (this._emitChars('<'), (this.state = U.RCDATA), this._stateRcdata(t))
  }
  _stateRcdataEndTagOpen(t) {
    jr(t)
      ? ((this.state = U.RCDATA_END_TAG_NAME), this._stateRcdataEndTagName(t))
      : (this._emitChars('</'), (this.state = U.RCDATA), this._stateRcdata(t))
  }
  handleSpecialEndTag(t) {
    if (!this.preprocessor.startsWith(this.lastStartTagName, !1)) return !this._ensureHibernation()
    this._createEndTagToken()
    const r = this.currentToken
    switch (
      ((r.tagName = this.lastStartTagName), this.preprocessor.peek(this.lastStartTagName.length))
    ) {
      case B.SPACE:
      case B.LINE_FEED:
      case B.TABULATION:
      case B.FORM_FEED:
        return (
          this._advanceBy(this.lastStartTagName.length), (this.state = U.BEFORE_ATTRIBUTE_NAME), !1
        )
      case B.SOLIDUS:
        return (
          this._advanceBy(this.lastStartTagName.length), (this.state = U.SELF_CLOSING_START_TAG), !1
        )
      case B.GREATER_THAN_SIGN:
        return (
          this._advanceBy(this.lastStartTagName.length),
          this.emitCurrentTagToken(),
          (this.state = U.DATA),
          !1
        )
      default:
        return !this._ensureHibernation()
    }
  }
  _stateRcdataEndTagName(t) {
    this.handleSpecialEndTag(t) &&
      (this._emitChars('</'), (this.state = U.RCDATA), this._stateRcdata(t))
  }
  _stateRawtextLessThanSign(t) {
    t === B.SOLIDUS
      ? (this.state = U.RAWTEXT_END_TAG_OPEN)
      : (this._emitChars('<'), (this.state = U.RAWTEXT), this._stateRawtext(t))
  }
  _stateRawtextEndTagOpen(t) {
    jr(t)
      ? ((this.state = U.RAWTEXT_END_TAG_NAME), this._stateRawtextEndTagName(t))
      : (this._emitChars('</'), (this.state = U.RAWTEXT), this._stateRawtext(t))
  }
  _stateRawtextEndTagName(t) {
    this.handleSpecialEndTag(t) &&
      (this._emitChars('</'), (this.state = U.RAWTEXT), this._stateRawtext(t))
  }
  _stateScriptDataLessThanSign(t) {
    switch (t) {
      case B.SOLIDUS: {
        this.state = U.SCRIPT_DATA_END_TAG_OPEN
        break
      }
      case B.EXCLAMATION_MARK: {
        ;(this.state = U.SCRIPT_DATA_ESCAPE_START), this._emitChars('<!')
        break
      }
      default:
        this._emitChars('<'), (this.state = U.SCRIPT_DATA), this._stateScriptData(t)
    }
  }
  _stateScriptDataEndTagOpen(t) {
    jr(t)
      ? ((this.state = U.SCRIPT_DATA_END_TAG_NAME), this._stateScriptDataEndTagName(t))
      : (this._emitChars('</'), (this.state = U.SCRIPT_DATA), this._stateScriptData(t))
  }
  _stateScriptDataEndTagName(t) {
    this.handleSpecialEndTag(t) &&
      (this._emitChars('</'), (this.state = U.SCRIPT_DATA), this._stateScriptData(t))
  }
  _stateScriptDataEscapeStart(t) {
    t === B.HYPHEN_MINUS
      ? ((this.state = U.SCRIPT_DATA_ESCAPE_START_DASH), this._emitChars('-'))
      : ((this.state = U.SCRIPT_DATA), this._stateScriptData(t))
  }
  _stateScriptDataEscapeStartDash(t) {
    t === B.HYPHEN_MINUS
      ? ((this.state = U.SCRIPT_DATA_ESCAPED_DASH_DASH), this._emitChars('-'))
      : ((this.state = U.SCRIPT_DATA), this._stateScriptData(t))
  }
  _stateScriptDataEscaped(t) {
    switch (t) {
      case B.HYPHEN_MINUS: {
        ;(this.state = U.SCRIPT_DATA_ESCAPED_DASH), this._emitChars('-')
        break
      }
      case B.LESS_THAN_SIGN: {
        this.state = U.SCRIPT_DATA_ESCAPED_LESS_THAN_SIGN
        break
      }
      case B.NULL: {
        this._err(J.unexpectedNullCharacter), this._emitChars(je)
        break
      }
      case B.EOF: {
        this._err(J.eofInScriptHtmlCommentLikeText), this._emitEOFToken()
        break
      }
      default:
        this._emitCodePoint(t)
    }
  }
  _stateScriptDataEscapedDash(t) {
    switch (t) {
      case B.HYPHEN_MINUS: {
        ;(this.state = U.SCRIPT_DATA_ESCAPED_DASH_DASH), this._emitChars('-')
        break
      }
      case B.LESS_THAN_SIGN: {
        this.state = U.SCRIPT_DATA_ESCAPED_LESS_THAN_SIGN
        break
      }
      case B.NULL: {
        this._err(J.unexpectedNullCharacter),
          (this.state = U.SCRIPT_DATA_ESCAPED),
          this._emitChars(je)
        break
      }
      case B.EOF: {
        this._err(J.eofInScriptHtmlCommentLikeText), this._emitEOFToken()
        break
      }
      default:
        ;(this.state = U.SCRIPT_DATA_ESCAPED), this._emitCodePoint(t)
    }
  }
  _stateScriptDataEscapedDashDash(t) {
    switch (t) {
      case B.HYPHEN_MINUS: {
        this._emitChars('-')
        break
      }
      case B.LESS_THAN_SIGN: {
        this.state = U.SCRIPT_DATA_ESCAPED_LESS_THAN_SIGN
        break
      }
      case B.GREATER_THAN_SIGN: {
        ;(this.state = U.SCRIPT_DATA), this._emitChars('>')
        break
      }
      case B.NULL: {
        this._err(J.unexpectedNullCharacter),
          (this.state = U.SCRIPT_DATA_ESCAPED),
          this._emitChars(je)
        break
      }
      case B.EOF: {
        this._err(J.eofInScriptHtmlCommentLikeText), this._emitEOFToken()
        break
      }
      default:
        ;(this.state = U.SCRIPT_DATA_ESCAPED), this._emitCodePoint(t)
    }
  }
  _stateScriptDataEscapedLessThanSign(t) {
    t === B.SOLIDUS
      ? (this.state = U.SCRIPT_DATA_ESCAPED_END_TAG_OPEN)
      : jr(t)
      ? (this._emitChars('<'),
        (this.state = U.SCRIPT_DATA_DOUBLE_ESCAPE_START),
        this._stateScriptDataDoubleEscapeStart(t))
      : (this._emitChars('<'),
        (this.state = U.SCRIPT_DATA_ESCAPED),
        this._stateScriptDataEscaped(t))
  }
  _stateScriptDataEscapedEndTagOpen(t) {
    jr(t)
      ? ((this.state = U.SCRIPT_DATA_ESCAPED_END_TAG_NAME),
        this._stateScriptDataEscapedEndTagName(t))
      : (this._emitChars('</'),
        (this.state = U.SCRIPT_DATA_ESCAPED),
        this._stateScriptDataEscaped(t))
  }
  _stateScriptDataEscapedEndTagName(t) {
    this.handleSpecialEndTag(t) &&
      (this._emitChars('</'), (this.state = U.SCRIPT_DATA_ESCAPED), this._stateScriptDataEscaped(t))
  }
  _stateScriptDataDoubleEscapeStart(t) {
    if (
      this.preprocessor.startsWith(xt.SCRIPT, !1) &&
      Hm(this.preprocessor.peek(xt.SCRIPT.length))
    ) {
      this._emitCodePoint(t)
      for (let r = 0; r < xt.SCRIPT.length; r++) this._emitCodePoint(this._consume())
      this.state = U.SCRIPT_DATA_DOUBLE_ESCAPED
    } else
      this._ensureHibernation() ||
        ((this.state = U.SCRIPT_DATA_ESCAPED), this._stateScriptDataEscaped(t))
  }
  _stateScriptDataDoubleEscaped(t) {
    switch (t) {
      case B.HYPHEN_MINUS: {
        ;(this.state = U.SCRIPT_DATA_DOUBLE_ESCAPED_DASH), this._emitChars('-')
        break
      }
      case B.LESS_THAN_SIGN: {
        ;(this.state = U.SCRIPT_DATA_DOUBLE_ESCAPED_LESS_THAN_SIGN), this._emitChars('<')
        break
      }
      case B.NULL: {
        this._err(J.unexpectedNullCharacter), this._emitChars(je)
        break
      }
      case B.EOF: {
        this._err(J.eofInScriptHtmlCommentLikeText), this._emitEOFToken()
        break
      }
      default:
        this._emitCodePoint(t)
    }
  }
  _stateScriptDataDoubleEscapedDash(t) {
    switch (t) {
      case B.HYPHEN_MINUS: {
        ;(this.state = U.SCRIPT_DATA_DOUBLE_ESCAPED_DASH_DASH), this._emitChars('-')
        break
      }
      case B.LESS_THAN_SIGN: {
        ;(this.state = U.SCRIPT_DATA_DOUBLE_ESCAPED_LESS_THAN_SIGN), this._emitChars('<')
        break
      }
      case B.NULL: {
        this._err(J.unexpectedNullCharacter),
          (this.state = U.SCRIPT_DATA_DOUBLE_ESCAPED),
          this._emitChars(je)
        break
      }
      case B.EOF: {
        this._err(J.eofInScriptHtmlCommentLikeText), this._emitEOFToken()
        break
      }
      default:
        ;(this.state = U.SCRIPT_DATA_DOUBLE_ESCAPED), this._emitCodePoint(t)
    }
  }
  _stateScriptDataDoubleEscapedDashDash(t) {
    switch (t) {
      case B.HYPHEN_MINUS: {
        this._emitChars('-')
        break
      }
      case B.LESS_THAN_SIGN: {
        ;(this.state = U.SCRIPT_DATA_DOUBLE_ESCAPED_LESS_THAN_SIGN), this._emitChars('<')
        break
      }
      case B.GREATER_THAN_SIGN: {
        ;(this.state = U.SCRIPT_DATA), this._emitChars('>')
        break
      }
      case B.NULL: {
        this._err(J.unexpectedNullCharacter),
          (this.state = U.SCRIPT_DATA_DOUBLE_ESCAPED),
          this._emitChars(je)
        break
      }
      case B.EOF: {
        this._err(J.eofInScriptHtmlCommentLikeText), this._emitEOFToken()
        break
      }
      default:
        ;(this.state = U.SCRIPT_DATA_DOUBLE_ESCAPED), this._emitCodePoint(t)
    }
  }
  _stateScriptDataDoubleEscapedLessThanSign(t) {
    t === B.SOLIDUS
      ? ((this.state = U.SCRIPT_DATA_DOUBLE_ESCAPE_END), this._emitChars('/'))
      : ((this.state = U.SCRIPT_DATA_DOUBLE_ESCAPED), this._stateScriptDataDoubleEscaped(t))
  }
  _stateScriptDataDoubleEscapeEnd(t) {
    if (
      this.preprocessor.startsWith(xt.SCRIPT, !1) &&
      Hm(this.preprocessor.peek(xt.SCRIPT.length))
    ) {
      this._emitCodePoint(t)
      for (let r = 0; r < xt.SCRIPT.length; r++) this._emitCodePoint(this._consume())
      this.state = U.SCRIPT_DATA_ESCAPED
    } else
      this._ensureHibernation() ||
        ((this.state = U.SCRIPT_DATA_DOUBLE_ESCAPED), this._stateScriptDataDoubleEscaped(t))
  }
  _stateBeforeAttributeName(t) {
    switch (t) {
      case B.SPACE:
      case B.LINE_FEED:
      case B.TABULATION:
      case B.FORM_FEED:
        break
      case B.SOLIDUS:
      case B.GREATER_THAN_SIGN:
      case B.EOF: {
        ;(this.state = U.AFTER_ATTRIBUTE_NAME), this._stateAfterAttributeName(t)
        break
      }
      case B.EQUALS_SIGN: {
        this._err(J.unexpectedEqualsSignBeforeAttributeName),
          this._createAttr('='),
          (this.state = U.ATTRIBUTE_NAME)
        break
      }
      default:
        this._createAttr(''), (this.state = U.ATTRIBUTE_NAME), this._stateAttributeName(t)
    }
  }
  _stateAttributeName(t) {
    switch (t) {
      case B.SPACE:
      case B.LINE_FEED:
      case B.TABULATION:
      case B.FORM_FEED:
      case B.SOLIDUS:
      case B.GREATER_THAN_SIGN:
      case B.EOF: {
        this._leaveAttrName(),
          (this.state = U.AFTER_ATTRIBUTE_NAME),
          this._stateAfterAttributeName(t)
        break
      }
      case B.EQUALS_SIGN: {
        this._leaveAttrName(), (this.state = U.BEFORE_ATTRIBUTE_VALUE)
        break
      }
      case B.QUOTATION_MARK:
      case B.APOSTROPHE:
      case B.LESS_THAN_SIGN: {
        this._err(J.unexpectedCharacterInAttributeName),
          (this.currentAttr.name += String.fromCodePoint(t))
        break
      }
      case B.NULL: {
        this._err(J.unexpectedNullCharacter), (this.currentAttr.name += je)
        break
      }
      default:
        this.currentAttr.name += String.fromCodePoint(as(t) ? Ua(t) : t)
    }
  }
  _stateAfterAttributeName(t) {
    switch (t) {
      case B.SPACE:
      case B.LINE_FEED:
      case B.TABULATION:
      case B.FORM_FEED:
        break
      case B.SOLIDUS: {
        this.state = U.SELF_CLOSING_START_TAG
        break
      }
      case B.EQUALS_SIGN: {
        this.state = U.BEFORE_ATTRIBUTE_VALUE
        break
      }
      case B.GREATER_THAN_SIGN: {
        ;(this.state = U.DATA), this.emitCurrentTagToken()
        break
      }
      case B.EOF: {
        this._err(J.eofInTag), this._emitEOFToken()
        break
      }
      default:
        this._createAttr(''), (this.state = U.ATTRIBUTE_NAME), this._stateAttributeName(t)
    }
  }
  _stateBeforeAttributeValue(t) {
    switch (t) {
      case B.SPACE:
      case B.LINE_FEED:
      case B.TABULATION:
      case B.FORM_FEED:
        break
      case B.QUOTATION_MARK: {
        this.state = U.ATTRIBUTE_VALUE_DOUBLE_QUOTED
        break
      }
      case B.APOSTROPHE: {
        this.state = U.ATTRIBUTE_VALUE_SINGLE_QUOTED
        break
      }
      case B.GREATER_THAN_SIGN: {
        this._err(J.missingAttributeValue), (this.state = U.DATA), this.emitCurrentTagToken()
        break
      }
      default:
        ;(this.state = U.ATTRIBUTE_VALUE_UNQUOTED), this._stateAttributeValueUnquoted(t)
    }
  }
  _stateAttributeValueDoubleQuoted(t) {
    switch (t) {
      case B.QUOTATION_MARK: {
        this.state = U.AFTER_ATTRIBUTE_VALUE_QUOTED
        break
      }
      case B.AMPERSAND: {
        ;(this.returnState = U.ATTRIBUTE_VALUE_DOUBLE_QUOTED), (this.state = U.CHARACTER_REFERENCE)
        break
      }
      case B.NULL: {
        this._err(J.unexpectedNullCharacter), (this.currentAttr.value += je)
        break
      }
      case B.EOF: {
        this._err(J.eofInTag), this._emitEOFToken()
        break
      }
      default:
        this.currentAttr.value += String.fromCodePoint(t)
    }
  }
  _stateAttributeValueSingleQuoted(t) {
    switch (t) {
      case B.APOSTROPHE: {
        this.state = U.AFTER_ATTRIBUTE_VALUE_QUOTED
        break
      }
      case B.AMPERSAND: {
        ;(this.returnState = U.ATTRIBUTE_VALUE_SINGLE_QUOTED), (this.state = U.CHARACTER_REFERENCE)
        break
      }
      case B.NULL: {
        this._err(J.unexpectedNullCharacter), (this.currentAttr.value += je)
        break
      }
      case B.EOF: {
        this._err(J.eofInTag), this._emitEOFToken()
        break
      }
      default:
        this.currentAttr.value += String.fromCodePoint(t)
    }
  }
  _stateAttributeValueUnquoted(t) {
    switch (t) {
      case B.SPACE:
      case B.LINE_FEED:
      case B.TABULATION:
      case B.FORM_FEED: {
        this._leaveAttrValue(), (this.state = U.BEFORE_ATTRIBUTE_NAME)
        break
      }
      case B.AMPERSAND: {
        ;(this.returnState = U.ATTRIBUTE_VALUE_UNQUOTED), (this.state = U.CHARACTER_REFERENCE)
        break
      }
      case B.GREATER_THAN_SIGN: {
        this._leaveAttrValue(), (this.state = U.DATA), this.emitCurrentTagToken()
        break
      }
      case B.NULL: {
        this._err(J.unexpectedNullCharacter), (this.currentAttr.value += je)
        break
      }
      case B.QUOTATION_MARK:
      case B.APOSTROPHE:
      case B.LESS_THAN_SIGN:
      case B.EQUALS_SIGN:
      case B.GRAVE_ACCENT: {
        this._err(J.unexpectedCharacterInUnquotedAttributeValue),
          (this.currentAttr.value += String.fromCodePoint(t))
        break
      }
      case B.EOF: {
        this._err(J.eofInTag), this._emitEOFToken()
        break
      }
      default:
        this.currentAttr.value += String.fromCodePoint(t)
    }
  }
  _stateAfterAttributeValueQuoted(t) {
    switch (t) {
      case B.SPACE:
      case B.LINE_FEED:
      case B.TABULATION:
      case B.FORM_FEED: {
        this._leaveAttrValue(), (this.state = U.BEFORE_ATTRIBUTE_NAME)
        break
      }
      case B.SOLIDUS: {
        this._leaveAttrValue(), (this.state = U.SELF_CLOSING_START_TAG)
        break
      }
      case B.GREATER_THAN_SIGN: {
        this._leaveAttrValue(), (this.state = U.DATA), this.emitCurrentTagToken()
        break
      }
      case B.EOF: {
        this._err(J.eofInTag), this._emitEOFToken()
        break
      }
      default:
        this._err(J.missingWhitespaceBetweenAttributes),
          (this.state = U.BEFORE_ATTRIBUTE_NAME),
          this._stateBeforeAttributeName(t)
    }
  }
  _stateSelfClosingStartTag(t) {
    switch (t) {
      case B.GREATER_THAN_SIGN: {
        const r = this.currentToken
        ;(r.selfClosing = !0), (this.state = U.DATA), this.emitCurrentTagToken()
        break
      }
      case B.EOF: {
        this._err(J.eofInTag), this._emitEOFToken()
        break
      }
      default:
        this._err(J.unexpectedSolidusInTag),
          (this.state = U.BEFORE_ATTRIBUTE_NAME),
          this._stateBeforeAttributeName(t)
    }
  }
  _stateBogusComment(t) {
    const r = this.currentToken
    switch (t) {
      case B.GREATER_THAN_SIGN: {
        ;(this.state = U.DATA), this.emitCurrentComment(r)
        break
      }
      case B.EOF: {
        this.emitCurrentComment(r), this._emitEOFToken()
        break
      }
      case B.NULL: {
        this._err(J.unexpectedNullCharacter), (r.data += je)
        break
      }
      default:
        r.data += String.fromCodePoint(t)
    }
  }
  _stateMarkupDeclarationOpen(t) {
    this._consumeSequenceIfMatch(xt.DASH_DASH, !0)
      ? (this._createCommentToken(xt.DASH_DASH.length + 1), (this.state = U.COMMENT_START))
      : this._consumeSequenceIfMatch(xt.DOCTYPE, !1)
      ? ((this.currentLocation = this.getCurrentLocation(xt.DOCTYPE.length + 1)),
        (this.state = U.DOCTYPE))
      : this._consumeSequenceIfMatch(xt.CDATA_START, !0)
      ? this.inForeignNode
        ? (this.state = U.CDATA_SECTION)
        : (this._err(J.cdataInHtmlContent),
          this._createCommentToken(xt.CDATA_START.length + 1),
          (this.currentToken.data = '[CDATA['),
          (this.state = U.BOGUS_COMMENT))
      : this._ensureHibernation() ||
        (this._err(J.incorrectlyOpenedComment),
        this._createCommentToken(2),
        (this.state = U.BOGUS_COMMENT),
        this._stateBogusComment(t))
  }
  _stateCommentStart(t) {
    switch (t) {
      case B.HYPHEN_MINUS: {
        this.state = U.COMMENT_START_DASH
        break
      }
      case B.GREATER_THAN_SIGN: {
        this._err(J.abruptClosingOfEmptyComment), (this.state = U.DATA)
        const r = this.currentToken
        this.emitCurrentComment(r)
        break
      }
      default:
        ;(this.state = U.COMMENT), this._stateComment(t)
    }
  }
  _stateCommentStartDash(t) {
    const r = this.currentToken
    switch (t) {
      case B.HYPHEN_MINUS: {
        this.state = U.COMMENT_END
        break
      }
      case B.GREATER_THAN_SIGN: {
        this._err(J.abruptClosingOfEmptyComment), (this.state = U.DATA), this.emitCurrentComment(r)
        break
      }
      case B.EOF: {
        this._err(J.eofInComment), this.emitCurrentComment(r), this._emitEOFToken()
        break
      }
      default:
        ;(r.data += '-'), (this.state = U.COMMENT), this._stateComment(t)
    }
  }
  _stateComment(t) {
    const r = this.currentToken
    switch (t) {
      case B.HYPHEN_MINUS: {
        this.state = U.COMMENT_END_DASH
        break
      }
      case B.LESS_THAN_SIGN: {
        ;(r.data += '<'), (this.state = U.COMMENT_LESS_THAN_SIGN)
        break
      }
      case B.NULL: {
        this._err(J.unexpectedNullCharacter), (r.data += je)
        break
      }
      case B.EOF: {
        this._err(J.eofInComment), this.emitCurrentComment(r), this._emitEOFToken()
        break
      }
      default:
        r.data += String.fromCodePoint(t)
    }
  }
  _stateCommentLessThanSign(t) {
    const r = this.currentToken
    switch (t) {
      case B.EXCLAMATION_MARK: {
        ;(r.data += '!'), (this.state = U.COMMENT_LESS_THAN_SIGN_BANG)
        break
      }
      case B.LESS_THAN_SIGN: {
        r.data += '<'
        break
      }
      default:
        ;(this.state = U.COMMENT), this._stateComment(t)
    }
  }
  _stateCommentLessThanSignBang(t) {
    t === B.HYPHEN_MINUS
      ? (this.state = U.COMMENT_LESS_THAN_SIGN_BANG_DASH)
      : ((this.state = U.COMMENT), this._stateComment(t))
  }
  _stateCommentLessThanSignBangDash(t) {
    t === B.HYPHEN_MINUS
      ? (this.state = U.COMMENT_LESS_THAN_SIGN_BANG_DASH_DASH)
      : ((this.state = U.COMMENT_END_DASH), this._stateCommentEndDash(t))
  }
  _stateCommentLessThanSignBangDashDash(t) {
    t !== B.GREATER_THAN_SIGN && t !== B.EOF && this._err(J.nestedComment),
      (this.state = U.COMMENT_END),
      this._stateCommentEnd(t)
  }
  _stateCommentEndDash(t) {
    const r = this.currentToken
    switch (t) {
      case B.HYPHEN_MINUS: {
        this.state = U.COMMENT_END
        break
      }
      case B.EOF: {
        this._err(J.eofInComment), this.emitCurrentComment(r), this._emitEOFToken()
        break
      }
      default:
        ;(r.data += '-'), (this.state = U.COMMENT), this._stateComment(t)
    }
  }
  _stateCommentEnd(t) {
    const r = this.currentToken
    switch (t) {
      case B.GREATER_THAN_SIGN: {
        ;(this.state = U.DATA), this.emitCurrentComment(r)
        break
      }
      case B.EXCLAMATION_MARK: {
        this.state = U.COMMENT_END_BANG
        break
      }
      case B.HYPHEN_MINUS: {
        r.data += '-'
        break
      }
      case B.EOF: {
        this._err(J.eofInComment), this.emitCurrentComment(r), this._emitEOFToken()
        break
      }
      default:
        ;(r.data += '--'), (this.state = U.COMMENT), this._stateComment(t)
    }
  }
  _stateCommentEndBang(t) {
    const r = this.currentToken
    switch (t) {
      case B.HYPHEN_MINUS: {
        ;(r.data += '--!'), (this.state = U.COMMENT_END_DASH)
        break
      }
      case B.GREATER_THAN_SIGN: {
        this._err(J.incorrectlyClosedComment), (this.state = U.DATA), this.emitCurrentComment(r)
        break
      }
      case B.EOF: {
        this._err(J.eofInComment), this.emitCurrentComment(r), this._emitEOFToken()
        break
      }
      default:
        ;(r.data += '--!'), (this.state = U.COMMENT), this._stateComment(t)
    }
  }
  _stateDoctype(t) {
    switch (t) {
      case B.SPACE:
      case B.LINE_FEED:
      case B.TABULATION:
      case B.FORM_FEED: {
        this.state = U.BEFORE_DOCTYPE_NAME
        break
      }
      case B.GREATER_THAN_SIGN: {
        ;(this.state = U.BEFORE_DOCTYPE_NAME), this._stateBeforeDoctypeName(t)
        break
      }
      case B.EOF: {
        this._err(J.eofInDoctype), this._createDoctypeToken(null)
        const r = this.currentToken
        ;(r.forceQuirks = !0), this.emitCurrentDoctype(r), this._emitEOFToken()
        break
      }
      default:
        this._err(J.missingWhitespaceBeforeDoctypeName),
          (this.state = U.BEFORE_DOCTYPE_NAME),
          this._stateBeforeDoctypeName(t)
    }
  }
  _stateBeforeDoctypeName(t) {
    if (as(t)) this._createDoctypeToken(String.fromCharCode(Ua(t))), (this.state = U.DOCTYPE_NAME)
    else
      switch (t) {
        case B.SPACE:
        case B.LINE_FEED:
        case B.TABULATION:
        case B.FORM_FEED:
          break
        case B.NULL: {
          this._err(J.unexpectedNullCharacter),
            this._createDoctypeToken(je),
            (this.state = U.DOCTYPE_NAME)
          break
        }
        case B.GREATER_THAN_SIGN: {
          this._err(J.missingDoctypeName), this._createDoctypeToken(null)
          const r = this.currentToken
          ;(r.forceQuirks = !0), this.emitCurrentDoctype(r), (this.state = U.DATA)
          break
        }
        case B.EOF: {
          this._err(J.eofInDoctype), this._createDoctypeToken(null)
          const r = this.currentToken
          ;(r.forceQuirks = !0), this.emitCurrentDoctype(r), this._emitEOFToken()
          break
        }
        default:
          this._createDoctypeToken(String.fromCodePoint(t)), (this.state = U.DOCTYPE_NAME)
      }
  }
  _stateDoctypeName(t) {
    const r = this.currentToken
    switch (t) {
      case B.SPACE:
      case B.LINE_FEED:
      case B.TABULATION:
      case B.FORM_FEED: {
        this.state = U.AFTER_DOCTYPE_NAME
        break
      }
      case B.GREATER_THAN_SIGN: {
        ;(this.state = U.DATA), this.emitCurrentDoctype(r)
        break
      }
      case B.NULL: {
        this._err(J.unexpectedNullCharacter), (r.name += je)
        break
      }
      case B.EOF: {
        this._err(J.eofInDoctype),
          (r.forceQuirks = !0),
          this.emitCurrentDoctype(r),
          this._emitEOFToken()
        break
      }
      default:
        r.name += String.fromCodePoint(as(t) ? Ua(t) : t)
    }
  }
  _stateAfterDoctypeName(t) {
    const r = this.currentToken
    switch (t) {
      case B.SPACE:
      case B.LINE_FEED:
      case B.TABULATION:
      case B.FORM_FEED:
        break
      case B.GREATER_THAN_SIGN: {
        ;(this.state = U.DATA), this.emitCurrentDoctype(r)
        break
      }
      case B.EOF: {
        this._err(J.eofInDoctype),
          (r.forceQuirks = !0),
          this.emitCurrentDoctype(r),
          this._emitEOFToken()
        break
      }
      default:
        this._consumeSequenceIfMatch(xt.PUBLIC, !1)
          ? (this.state = U.AFTER_DOCTYPE_PUBLIC_KEYWORD)
          : this._consumeSequenceIfMatch(xt.SYSTEM, !1)
          ? (this.state = U.AFTER_DOCTYPE_SYSTEM_KEYWORD)
          : this._ensureHibernation() ||
            (this._err(J.invalidCharacterSequenceAfterDoctypeName),
            (r.forceQuirks = !0),
            (this.state = U.BOGUS_DOCTYPE),
            this._stateBogusDoctype(t))
    }
  }
  _stateAfterDoctypePublicKeyword(t) {
    const r = this.currentToken
    switch (t) {
      case B.SPACE:
      case B.LINE_FEED:
      case B.TABULATION:
      case B.FORM_FEED: {
        this.state = U.BEFORE_DOCTYPE_PUBLIC_IDENTIFIER
        break
      }
      case B.QUOTATION_MARK: {
        this._err(J.missingWhitespaceAfterDoctypePublicKeyword),
          (r.publicId = ''),
          (this.state = U.DOCTYPE_PUBLIC_IDENTIFIER_DOUBLE_QUOTED)
        break
      }
      case B.APOSTROPHE: {
        this._err(J.missingWhitespaceAfterDoctypePublicKeyword),
          (r.publicId = ''),
          (this.state = U.DOCTYPE_PUBLIC_IDENTIFIER_SINGLE_QUOTED)
        break
      }
      case B.GREATER_THAN_SIGN: {
        this._err(J.missingDoctypePublicIdentifier),
          (r.forceQuirks = !0),
          (this.state = U.DATA),
          this.emitCurrentDoctype(r)
        break
      }
      case B.EOF: {
        this._err(J.eofInDoctype),
          (r.forceQuirks = !0),
          this.emitCurrentDoctype(r),
          this._emitEOFToken()
        break
      }
      default:
        this._err(J.missingQuoteBeforeDoctypePublicIdentifier),
          (r.forceQuirks = !0),
          (this.state = U.BOGUS_DOCTYPE),
          this._stateBogusDoctype(t)
    }
  }
  _stateBeforeDoctypePublicIdentifier(t) {
    const r = this.currentToken
    switch (t) {
      case B.SPACE:
      case B.LINE_FEED:
      case B.TABULATION:
      case B.FORM_FEED:
        break
      case B.QUOTATION_MARK: {
        ;(r.publicId = ''), (this.state = U.DOCTYPE_PUBLIC_IDENTIFIER_DOUBLE_QUOTED)
        break
      }
      case B.APOSTROPHE: {
        ;(r.publicId = ''), (this.state = U.DOCTYPE_PUBLIC_IDENTIFIER_SINGLE_QUOTED)
        break
      }
      case B.GREATER_THAN_SIGN: {
        this._err(J.missingDoctypePublicIdentifier),
          (r.forceQuirks = !0),
          (this.state = U.DATA),
          this.emitCurrentDoctype(r)
        break
      }
      case B.EOF: {
        this._err(J.eofInDoctype),
          (r.forceQuirks = !0),
          this.emitCurrentDoctype(r),
          this._emitEOFToken()
        break
      }
      default:
        this._err(J.missingQuoteBeforeDoctypePublicIdentifier),
          (r.forceQuirks = !0),
          (this.state = U.BOGUS_DOCTYPE),
          this._stateBogusDoctype(t)
    }
  }
  _stateDoctypePublicIdentifierDoubleQuoted(t) {
    const r = this.currentToken
    switch (t) {
      case B.QUOTATION_MARK: {
        this.state = U.AFTER_DOCTYPE_PUBLIC_IDENTIFIER
        break
      }
      case B.NULL: {
        this._err(J.unexpectedNullCharacter), (r.publicId += je)
        break
      }
      case B.GREATER_THAN_SIGN: {
        this._err(J.abruptDoctypePublicIdentifier),
          (r.forceQuirks = !0),
          this.emitCurrentDoctype(r),
          (this.state = U.DATA)
        break
      }
      case B.EOF: {
        this._err(J.eofInDoctype),
          (r.forceQuirks = !0),
          this.emitCurrentDoctype(r),
          this._emitEOFToken()
        break
      }
      default:
        r.publicId += String.fromCodePoint(t)
    }
  }
  _stateDoctypePublicIdentifierSingleQuoted(t) {
    const r = this.currentToken
    switch (t) {
      case B.APOSTROPHE: {
        this.state = U.AFTER_DOCTYPE_PUBLIC_IDENTIFIER
        break
      }
      case B.NULL: {
        this._err(J.unexpectedNullCharacter), (r.publicId += je)
        break
      }
      case B.GREATER_THAN_SIGN: {
        this._err(J.abruptDoctypePublicIdentifier),
          (r.forceQuirks = !0),
          this.emitCurrentDoctype(r),
          (this.state = U.DATA)
        break
      }
      case B.EOF: {
        this._err(J.eofInDoctype),
          (r.forceQuirks = !0),
          this.emitCurrentDoctype(r),
          this._emitEOFToken()
        break
      }
      default:
        r.publicId += String.fromCodePoint(t)
    }
  }
  _stateAfterDoctypePublicIdentifier(t) {
    const r = this.currentToken
    switch (t) {
      case B.SPACE:
      case B.LINE_FEED:
      case B.TABULATION:
      case B.FORM_FEED: {
        this.state = U.BETWEEN_DOCTYPE_PUBLIC_AND_SYSTEM_IDENTIFIERS
        break
      }
      case B.GREATER_THAN_SIGN: {
        ;(this.state = U.DATA), this.emitCurrentDoctype(r)
        break
      }
      case B.QUOTATION_MARK: {
        this._err(J.missingWhitespaceBetweenDoctypePublicAndSystemIdentifiers),
          (r.systemId = ''),
          (this.state = U.DOCTYPE_SYSTEM_IDENTIFIER_DOUBLE_QUOTED)
        break
      }
      case B.APOSTROPHE: {
        this._err(J.missingWhitespaceBetweenDoctypePublicAndSystemIdentifiers),
          (r.systemId = ''),
          (this.state = U.DOCTYPE_SYSTEM_IDENTIFIER_SINGLE_QUOTED)
        break
      }
      case B.EOF: {
        this._err(J.eofInDoctype),
          (r.forceQuirks = !0),
          this.emitCurrentDoctype(r),
          this._emitEOFToken()
        break
      }
      default:
        this._err(J.missingQuoteBeforeDoctypeSystemIdentifier),
          (r.forceQuirks = !0),
          (this.state = U.BOGUS_DOCTYPE),
          this._stateBogusDoctype(t)
    }
  }
  _stateBetweenDoctypePublicAndSystemIdentifiers(t) {
    const r = this.currentToken
    switch (t) {
      case B.SPACE:
      case B.LINE_FEED:
      case B.TABULATION:
      case B.FORM_FEED:
        break
      case B.GREATER_THAN_SIGN: {
        this.emitCurrentDoctype(r), (this.state = U.DATA)
        break
      }
      case B.QUOTATION_MARK: {
        ;(r.systemId = ''), (this.state = U.DOCTYPE_SYSTEM_IDENTIFIER_DOUBLE_QUOTED)
        break
      }
      case B.APOSTROPHE: {
        ;(r.systemId = ''), (this.state = U.DOCTYPE_SYSTEM_IDENTIFIER_SINGLE_QUOTED)
        break
      }
      case B.EOF: {
        this._err(J.eofInDoctype),
          (r.forceQuirks = !0),
          this.emitCurrentDoctype(r),
          this._emitEOFToken()
        break
      }
      default:
        this._err(J.missingQuoteBeforeDoctypeSystemIdentifier),
          (r.forceQuirks = !0),
          (this.state = U.BOGUS_DOCTYPE),
          this._stateBogusDoctype(t)
    }
  }
  _stateAfterDoctypeSystemKeyword(t) {
    const r = this.currentToken
    switch (t) {
      case B.SPACE:
      case B.LINE_FEED:
      case B.TABULATION:
      case B.FORM_FEED: {
        this.state = U.BEFORE_DOCTYPE_SYSTEM_IDENTIFIER
        break
      }
      case B.QUOTATION_MARK: {
        this._err(J.missingWhitespaceAfterDoctypeSystemKeyword),
          (r.systemId = ''),
          (this.state = U.DOCTYPE_SYSTEM_IDENTIFIER_DOUBLE_QUOTED)
        break
      }
      case B.APOSTROPHE: {
        this._err(J.missingWhitespaceAfterDoctypeSystemKeyword),
          (r.systemId = ''),
          (this.state = U.DOCTYPE_SYSTEM_IDENTIFIER_SINGLE_QUOTED)
        break
      }
      case B.GREATER_THAN_SIGN: {
        this._err(J.missingDoctypeSystemIdentifier),
          (r.forceQuirks = !0),
          (this.state = U.DATA),
          this.emitCurrentDoctype(r)
        break
      }
      case B.EOF: {
        this._err(J.eofInDoctype),
          (r.forceQuirks = !0),
          this.emitCurrentDoctype(r),
          this._emitEOFToken()
        break
      }
      default:
        this._err(J.missingQuoteBeforeDoctypeSystemIdentifier),
          (r.forceQuirks = !0),
          (this.state = U.BOGUS_DOCTYPE),
          this._stateBogusDoctype(t)
    }
  }
  _stateBeforeDoctypeSystemIdentifier(t) {
    const r = this.currentToken
    switch (t) {
      case B.SPACE:
      case B.LINE_FEED:
      case B.TABULATION:
      case B.FORM_FEED:
        break
      case B.QUOTATION_MARK: {
        ;(r.systemId = ''), (this.state = U.DOCTYPE_SYSTEM_IDENTIFIER_DOUBLE_QUOTED)
        break
      }
      case B.APOSTROPHE: {
        ;(r.systemId = ''), (this.state = U.DOCTYPE_SYSTEM_IDENTIFIER_SINGLE_QUOTED)
        break
      }
      case B.GREATER_THAN_SIGN: {
        this._err(J.missingDoctypeSystemIdentifier),
          (r.forceQuirks = !0),
          (this.state = U.DATA),
          this.emitCurrentDoctype(r)
        break
      }
      case B.EOF: {
        this._err(J.eofInDoctype),
          (r.forceQuirks = !0),
          this.emitCurrentDoctype(r),
          this._emitEOFToken()
        break
      }
      default:
        this._err(J.missingQuoteBeforeDoctypeSystemIdentifier),
          (r.forceQuirks = !0),
          (this.state = U.BOGUS_DOCTYPE),
          this._stateBogusDoctype(t)
    }
  }
  _stateDoctypeSystemIdentifierDoubleQuoted(t) {
    const r = this.currentToken
    switch (t) {
      case B.QUOTATION_MARK: {
        this.state = U.AFTER_DOCTYPE_SYSTEM_IDENTIFIER
        break
      }
      case B.NULL: {
        this._err(J.unexpectedNullCharacter), (r.systemId += je)
        break
      }
      case B.GREATER_THAN_SIGN: {
        this._err(J.abruptDoctypeSystemIdentifier),
          (r.forceQuirks = !0),
          this.emitCurrentDoctype(r),
          (this.state = U.DATA)
        break
      }
      case B.EOF: {
        this._err(J.eofInDoctype),
          (r.forceQuirks = !0),
          this.emitCurrentDoctype(r),
          this._emitEOFToken()
        break
      }
      default:
        r.systemId += String.fromCodePoint(t)
    }
  }
  _stateDoctypeSystemIdentifierSingleQuoted(t) {
    const r = this.currentToken
    switch (t) {
      case B.APOSTROPHE: {
        this.state = U.AFTER_DOCTYPE_SYSTEM_IDENTIFIER
        break
      }
      case B.NULL: {
        this._err(J.unexpectedNullCharacter), (r.systemId += je)
        break
      }
      case B.GREATER_THAN_SIGN: {
        this._err(J.abruptDoctypeSystemIdentifier),
          (r.forceQuirks = !0),
          this.emitCurrentDoctype(r),
          (this.state = U.DATA)
        break
      }
      case B.EOF: {
        this._err(J.eofInDoctype),
          (r.forceQuirks = !0),
          this.emitCurrentDoctype(r),
          this._emitEOFToken()
        break
      }
      default:
        r.systemId += String.fromCodePoint(t)
    }
  }
  _stateAfterDoctypeSystemIdentifier(t) {
    const r = this.currentToken
    switch (t) {
      case B.SPACE:
      case B.LINE_FEED:
      case B.TABULATION:
      case B.FORM_FEED:
        break
      case B.GREATER_THAN_SIGN: {
        this.emitCurrentDoctype(r), (this.state = U.DATA)
        break
      }
      case B.EOF: {
        this._err(J.eofInDoctype),
          (r.forceQuirks = !0),
          this.emitCurrentDoctype(r),
          this._emitEOFToken()
        break
      }
      default:
        this._err(J.unexpectedCharacterAfterDoctypeSystemIdentifier),
          (this.state = U.BOGUS_DOCTYPE),
          this._stateBogusDoctype(t)
    }
  }
  _stateBogusDoctype(t) {
    const r = this.currentToken
    switch (t) {
      case B.GREATER_THAN_SIGN: {
        this.emitCurrentDoctype(r), (this.state = U.DATA)
        break
      }
      case B.NULL: {
        this._err(J.unexpectedNullCharacter)
        break
      }
      case B.EOF: {
        this.emitCurrentDoctype(r), this._emitEOFToken()
        break
      }
    }
  }
  _stateCdataSection(t) {
    switch (t) {
      case B.RIGHT_SQUARE_BRACKET: {
        this.state = U.CDATA_SECTION_BRACKET
        break
      }
      case B.EOF: {
        this._err(J.eofInCdata), this._emitEOFToken()
        break
      }
      default:
        this._emitCodePoint(t)
    }
  }
  _stateCdataSectionBracket(t) {
    t === B.RIGHT_SQUARE_BRACKET
      ? (this.state = U.CDATA_SECTION_END)
      : (this._emitChars(']'), (this.state = U.CDATA_SECTION), this._stateCdataSection(t))
  }
  _stateCdataSectionEnd(t) {
    switch (t) {
      case B.GREATER_THAN_SIGN: {
        this.state = U.DATA
        break
      }
      case B.RIGHT_SQUARE_BRACKET: {
        this._emitChars(']')
        break
      }
      default:
        this._emitChars(']]'), (this.state = U.CDATA_SECTION), this._stateCdataSection(t)
    }
  }
  _stateCharacterReference(t) {
    t === B.NUMBER_SIGN
      ? (this.state = U.NUMERIC_CHARACTER_REFERENCE)
      : Bc(t)
      ? ((this.state = U.NAMED_CHARACTER_REFERENCE), this._stateNamedCharacterReference(t))
      : (this._flushCodePointConsumedAsCharacterReference(B.AMPERSAND),
        this._reconsumeInState(this.returnState, t))
  }
  _stateNamedCharacterReference(t) {
    const r = this._matchNamedCharacterReference(t)
    if (!this._ensureHibernation())
      if (r) {
        for (let i = 0; i < r.length; i++) this._flushCodePointConsumedAsCharacterReference(r[i])
        this.state = this.returnState
      } else
        this._flushCodePointConsumedAsCharacterReference(B.AMPERSAND),
          (this.state = U.AMBIGUOUS_AMPERSAND)
  }
  _stateAmbiguousAmpersand(t) {
    Bc(t)
      ? this._flushCodePointConsumedAsCharacterReference(t)
      : (t === B.SEMICOLON && this._err(J.unknownNamedCharacterReference),
        this._reconsumeInState(this.returnState, t))
  }
  _stateNumericCharacterReference(t) {
    ;(this.charRefCode = 0),
      t === B.LATIN_SMALL_X || t === B.LATIN_CAPITAL_X
        ? (this.state = U.HEXADEMICAL_CHARACTER_REFERENCE_START)
        : ys(t)
        ? ((this.state = U.DECIMAL_CHARACTER_REFERENCE), this._stateDecimalCharacterReference(t))
        : (this._err(J.absenceOfDigitsInNumericCharacterReference),
          this._flushCodePointConsumedAsCharacterReference(B.AMPERSAND),
          this._flushCodePointConsumedAsCharacterReference(B.NUMBER_SIGN),
          this._reconsumeInState(this.returnState, t))
  }
  _stateHexademicalCharacterReferenceStart(t) {
    dk(t)
      ? ((this.state = U.HEXADEMICAL_CHARACTER_REFERENCE),
        this._stateHexademicalCharacterReference(t))
      : (this._err(J.absenceOfDigitsInNumericCharacterReference),
        this._flushCodePointConsumedAsCharacterReference(B.AMPERSAND),
        this._flushCodePointConsumedAsCharacterReference(B.NUMBER_SIGN),
        this._unconsume(2),
        (this.state = this.returnState))
  }
  _stateHexademicalCharacterReference(t) {
    rb(t)
      ? (this.charRefCode = this.charRefCode * 16 + t - 55)
      : ib(t)
      ? (this.charRefCode = this.charRefCode * 16 + t - 87)
      : ys(t)
      ? (this.charRefCode = this.charRefCode * 16 + t - 48)
      : t === B.SEMICOLON
      ? (this.state = U.NUMERIC_CHARACTER_REFERENCE_END)
      : (this._err(J.missingSemicolonAfterCharacterReference),
        (this.state = U.NUMERIC_CHARACTER_REFERENCE_END),
        this._stateNumericCharacterReferenceEnd(t))
  }
  _stateDecimalCharacterReference(t) {
    ys(t)
      ? (this.charRefCode = this.charRefCode * 10 + t - 48)
      : t === B.SEMICOLON
      ? (this.state = U.NUMERIC_CHARACTER_REFERENCE_END)
      : (this._err(J.missingSemicolonAfterCharacterReference),
        (this.state = U.NUMERIC_CHARACTER_REFERENCE_END),
        this._stateNumericCharacterReferenceEnd(t))
  }
  _stateNumericCharacterReferenceEnd(t) {
    if (this.charRefCode === B.NULL)
      this._err(J.nullCharacterReference), (this.charRefCode = B.REPLACEMENT_CHARACTER)
    else if (this.charRefCode > 1114111)
      this._err(J.characterReferenceOutsideUnicodeRange),
        (this.charRefCode = B.REPLACEMENT_CHARACTER)
    else if (W1(this.charRefCode))
      this._err(J.surrogateCharacterReference), (this.charRefCode = B.REPLACEMENT_CHARACTER)
    else if (K1(this.charRefCode)) this._err(J.noncharacterCharacterReference)
    else if (Q1(this.charRefCode) || this.charRefCode === B.CARRIAGE_RETURN) {
      this._err(J.controlCharacterReference)
      const r = hk.get(this.charRefCode)
      r !== void 0 && (this.charRefCode = r)
    }
    this._flushCodePointConsumedAsCharacterReference(this.charRefCode),
      this._reconsumeInState(this.returnState, t)
  }
}
const sb = new Set([d.DD, d.DT, d.LI, d.OPTGROUP, d.OPTION, d.P, d.RB, d.RP, d.RT, d.RTC]),
  zm = new Set([...sb, d.CAPTION, d.COLGROUP, d.TBODY, d.TD, d.TFOOT, d.TH, d.THEAD, d.TR]),
  Ha = new Map([
    [d.APPLET, ee.HTML],
    [d.CAPTION, ee.HTML],
    [d.HTML, ee.HTML],
    [d.MARQUEE, ee.HTML],
    [d.OBJECT, ee.HTML],
    [d.TABLE, ee.HTML],
    [d.TD, ee.HTML],
    [d.TEMPLATE, ee.HTML],
    [d.TH, ee.HTML],
    [d.ANNOTATION_XML, ee.MATHML],
    [d.MI, ee.MATHML],
    [d.MN, ee.MATHML],
    [d.MO, ee.MATHML],
    [d.MS, ee.MATHML],
    [d.MTEXT, ee.MATHML],
    [d.DESC, ee.SVG],
    [d.FOREIGN_OBJECT, ee.SVG],
    [d.TITLE, ee.SVG],
  ]),
  yk = [d.H1, d.H2, d.H3, d.H4, d.H5, d.H6],
  _k = [d.TR, d.TEMPLATE, d.HTML],
  vk = [d.TBODY, d.TFOOT, d.THEAD, d.TEMPLATE, d.HTML],
  Ek = [d.TABLE, d.TEMPLATE, d.HTML],
  xk = [d.TD, d.TH]
class Tk {
  get currentTmplContentOrNode() {
    return this._isInTemplate() ? this.treeAdapter.getTemplateContent(this.current) : this.current
  }
  constructor(t, r, i) {
    ;(this.treeAdapter = r),
      (this.handler = i),
      (this.items = []),
      (this.tagIDs = []),
      (this.stackTop = -1),
      (this.tmplCount = 0),
      (this.currentTagId = d.UNKNOWN),
      (this.current = t)
  }
  _indexOf(t) {
    return this.items.lastIndexOf(t, this.stackTop)
  }
  _isInTemplate() {
    return (
      this.currentTagId === d.TEMPLATE && this.treeAdapter.getNamespaceURI(this.current) === ee.HTML
    )
  }
  _updateCurrentElement() {
    ;(this.current = this.items[this.stackTop]), (this.currentTagId = this.tagIDs[this.stackTop])
  }
  push(t, r) {
    this.stackTop++,
      (this.items[this.stackTop] = t),
      (this.current = t),
      (this.tagIDs[this.stackTop] = r),
      (this.currentTagId = r),
      this._isInTemplate() && this.tmplCount++,
      this.handler.onItemPush(t, r, !0)
  }
  pop() {
    const t = this.current
    this.tmplCount > 0 && this._isInTemplate() && this.tmplCount--,
      this.stackTop--,
      this._updateCurrentElement(),
      this.handler.onItemPop(t, !0)
  }
  replace(t, r) {
    const i = this._indexOf(t)
    ;(this.items[i] = r), i === this.stackTop && (this.current = r)
  }
  insertAfter(t, r, i) {
    const n = this._indexOf(t) + 1
    this.items.splice(n, 0, r),
      this.tagIDs.splice(n, 0, i),
      this.stackTop++,
      n === this.stackTop && this._updateCurrentElement(),
      this.handler.onItemPush(this.current, this.currentTagId, n === this.stackTop)
  }
  popUntilTagNamePopped(t) {
    let r = this.stackTop + 1
    do r = this.tagIDs.lastIndexOf(t, r - 1)
    while (r > 0 && this.treeAdapter.getNamespaceURI(this.items[r]) !== ee.HTML)
    this.shortenToLength(r < 0 ? 0 : r)
  }
  shortenToLength(t) {
    for (; this.stackTop >= t; ) {
      const r = this.current
      this.tmplCount > 0 && this._isInTemplate() && (this.tmplCount -= 1),
        this.stackTop--,
        this._updateCurrentElement(),
        this.handler.onItemPop(r, this.stackTop < t)
    }
  }
  popUntilElementPopped(t) {
    const r = this._indexOf(t)
    this.shortenToLength(r < 0 ? 0 : r)
  }
  popUntilPopped(t, r) {
    const i = this._indexOfTagNames(t, r)
    this.shortenToLength(i < 0 ? 0 : i)
  }
  popUntilNumberedHeaderPopped() {
    this.popUntilPopped(yk, ee.HTML)
  }
  popUntilTableCellPopped() {
    this.popUntilPopped(xk, ee.HTML)
  }
  popAllUpToHtmlElement() {
    ;(this.tmplCount = 0), this.shortenToLength(1)
  }
  _indexOfTagNames(t, r) {
    for (let i = this.stackTop; i >= 0; i--)
      if (t.includes(this.tagIDs[i]) && this.treeAdapter.getNamespaceURI(this.items[i]) === r)
        return i
    return -1
  }
  clearBackTo(t, r) {
    const i = this._indexOfTagNames(t, r)
    this.shortenToLength(i + 1)
  }
  clearBackToTableContext() {
    this.clearBackTo(Ek, ee.HTML)
  }
  clearBackToTableBodyContext() {
    this.clearBackTo(vk, ee.HTML)
  }
  clearBackToTableRowContext() {
    this.clearBackTo(_k, ee.HTML)
  }
  remove(t) {
    const r = this._indexOf(t)
    r >= 0 &&
      (r === this.stackTop
        ? this.pop()
        : (this.items.splice(r, 1),
          this.tagIDs.splice(r, 1),
          this.stackTop--,
          this._updateCurrentElement(),
          this.handler.onItemPop(t, !1)))
  }
  tryPeekProperlyNestedBodyElement() {
    return this.stackTop >= 1 && this.tagIDs[1] === d.BODY ? this.items[1] : null
  }
  contains(t) {
    return this._indexOf(t) > -1
  }
  getCommonAncestor(t) {
    const r = this._indexOf(t) - 1
    return r >= 0 ? this.items[r] : null
  }
  isRootHtmlElementCurrent() {
    return this.stackTop === 0 && this.tagIDs[0] === d.HTML
  }
  hasInScope(t) {
    for (let r = this.stackTop; r >= 0; r--) {
      const i = this.tagIDs[r],
        n = this.treeAdapter.getNamespaceURI(this.items[r])
      if (i === t && n === ee.HTML) return !0
      if (Ha.get(i) === n) return !1
    }
    return !0
  }
  hasNumberedHeaderInScope() {
    for (let t = this.stackTop; t >= 0; t--) {
      const r = this.tagIDs[t],
        i = this.treeAdapter.getNamespaceURI(this.items[t])
      if (tb(r) && i === ee.HTML) return !0
      if (Ha.get(r) === i) return !1
    }
    return !0
  }
  hasInListItemScope(t) {
    for (let r = this.stackTop; r >= 0; r--) {
      const i = this.tagIDs[r],
        n = this.treeAdapter.getNamespaceURI(this.items[r])
      if (i === t && n === ee.HTML) return !0
      if (((i === d.UL || i === d.OL) && n === ee.HTML) || Ha.get(i) === n) return !1
    }
    return !0
  }
  hasInButtonScope(t) {
    for (let r = this.stackTop; r >= 0; r--) {
      const i = this.tagIDs[r],
        n = this.treeAdapter.getNamespaceURI(this.items[r])
      if (i === t && n === ee.HTML) return !0
      if ((i === d.BUTTON && n === ee.HTML) || Ha.get(i) === n) return !1
    }
    return !0
  }
  hasInTableScope(t) {
    for (let r = this.stackTop; r >= 0; r--) {
      const i = this.tagIDs[r]
      if (this.treeAdapter.getNamespaceURI(this.items[r]) === ee.HTML) {
        if (i === t) return !0
        if (i === d.TABLE || i === d.TEMPLATE || i === d.HTML) return !1
      }
    }
    return !0
  }
  hasTableBodyContextInTableScope() {
    for (let t = this.stackTop; t >= 0; t--) {
      const r = this.tagIDs[t]
      if (this.treeAdapter.getNamespaceURI(this.items[t]) === ee.HTML) {
        if (r === d.TBODY || r === d.THEAD || r === d.TFOOT) return !0
        if (r === d.TABLE || r === d.HTML) return !1
      }
    }
    return !0
  }
  hasInSelectScope(t) {
    for (let r = this.stackTop; r >= 0; r--) {
      const i = this.tagIDs[r]
      if (this.treeAdapter.getNamespaceURI(this.items[r]) === ee.HTML) {
        if (i === t) return !0
        if (i !== d.OPTION && i !== d.OPTGROUP) return !1
      }
    }
    return !0
  }
  generateImpliedEndTags() {
    for (; sb.has(this.currentTagId); ) this.pop()
  }
  generateImpliedEndTagsThoroughly() {
    for (; zm.has(this.currentTagId); ) this.pop()
  }
  generateImpliedEndTagsWithExclusion(t) {
    for (; this.currentTagId !== t && zm.has(this.currentTagId); ) this.pop()
  }
}
const _l = 3
var rr
;(function (e) {
  ;(e[(e.Marker = 0)] = 'Marker'), (e[(e.Element = 1)] = 'Element')
})((rr = rr || (rr = {})))
const jm = { type: rr.Marker }
class Ak {
  constructor(t) {
    ;(this.treeAdapter = t), (this.entries = []), (this.bookmark = null)
  }
  _getNoahArkConditionCandidates(t, r) {
    const i = [],
      n = r.length,
      s = this.treeAdapter.getTagName(t),
      a = this.treeAdapter.getNamespaceURI(t)
    for (let o = 0; o < this.entries.length; o++) {
      const u = this.entries[o]
      if (u.type === rr.Marker) break
      const { element: c } = u
      if (this.treeAdapter.getTagName(c) === s && this.treeAdapter.getNamespaceURI(c) === a) {
        const f = this.treeAdapter.getAttrList(c)
        f.length === n && i.push({ idx: o, attrs: f })
      }
    }
    return i
  }
  _ensureNoahArkCondition(t) {
    if (this.entries.length < _l) return
    const r = this.treeAdapter.getAttrList(t),
      i = this._getNoahArkConditionCandidates(t, r)
    if (i.length < _l) return
    const n = new Map(r.map((a) => [a.name, a.value]))
    let s = 0
    for (let a = 0; a < i.length; a++) {
      const o = i[a]
      o.attrs.every((u) => n.get(u.name) === u.value) &&
        ((s += 1), s >= _l && this.entries.splice(o.idx, 1))
    }
  }
  insertMarker() {
    this.entries.unshift(jm)
  }
  pushElement(t, r) {
    this._ensureNoahArkCondition(t),
      this.entries.unshift({ type: rr.Element, element: t, token: r })
  }
  insertElementAfterBookmark(t, r) {
    const i = this.entries.indexOf(this.bookmark)
    this.entries.splice(i, 0, { type: rr.Element, element: t, token: r })
  }
  removeEntry(t) {
    const r = this.entries.indexOf(t)
    r >= 0 && this.entries.splice(r, 1)
  }
  clearToLastMarker() {
    const t = this.entries.indexOf(jm)
    t >= 0 ? this.entries.splice(0, t + 1) : (this.entries.length = 0)
  }
  getElementEntryInScopeWithTagName(t) {
    const r = this.entries.find(
      (i) => i.type === rr.Marker || this.treeAdapter.getTagName(i.element) === t
    )
    return r && r.type === rr.Element ? r : null
  }
  getElementEntry(t) {
    return this.entries.find((r) => r.type === rr.Element && r.element === t)
  }
}
function qm(e) {
  return { nodeName: '#text', value: e, parentNode: null }
}
const Ki = {
    createDocument() {
      return { nodeName: '#document', mode: Rt.NO_QUIRKS, childNodes: [] }
    },
    createDocumentFragment() {
      return { nodeName: '#document-fragment', childNodes: [] }
    },
    createElement(e, t, r) {
      return {
        nodeName: e,
        tagName: e,
        attrs: r,
        namespaceURI: t,
        childNodes: [],
        parentNode: null,
      }
    },
    createCommentNode(e) {
      return { nodeName: '#comment', data: e, parentNode: null }
    },
    appendChild(e, t) {
      e.childNodes.push(t), (t.parentNode = e)
    },
    insertBefore(e, t, r) {
      const i = e.childNodes.indexOf(r)
      e.childNodes.splice(i, 0, t), (t.parentNode = e)
    },
    setTemplateContent(e, t) {
      e.content = t
    },
    getTemplateContent(e) {
      return e.content
    },
    setDocumentType(e, t, r, i) {
      const n = e.childNodes.find((s) => s.nodeName === '#documentType')
      if (n) (n.name = t), (n.publicId = r), (n.systemId = i)
      else {
        const s = { nodeName: '#documentType', name: t, publicId: r, systemId: i, parentNode: null }
        Ki.appendChild(e, s)
      }
    },
    setDocumentMode(e, t) {
      e.mode = t
    },
    getDocumentMode(e) {
      return e.mode
    },
    detachNode(e) {
      if (e.parentNode) {
        const t = e.parentNode.childNodes.indexOf(e)
        e.parentNode.childNodes.splice(t, 1), (e.parentNode = null)
      }
    },
    insertText(e, t) {
      if (e.childNodes.length > 0) {
        const r = e.childNodes[e.childNodes.length - 1]
        if (Ki.isTextNode(r)) {
          r.value += t
          return
        }
      }
      Ki.appendChild(e, qm(t))
    },
    insertTextBefore(e, t, r) {
      const i = e.childNodes[e.childNodes.indexOf(r) - 1]
      i && Ki.isTextNode(i) ? (i.value += t) : Ki.insertBefore(e, qm(t), r)
    },
    adoptAttributes(e, t) {
      const r = new Set(e.attrs.map((i) => i.name))
      for (let i = 0; i < t.length; i++) r.has(t[i].name) || e.attrs.push(t[i])
    },
    getFirstChild(e) {
      return e.childNodes[0]
    },
    getChildNodes(e) {
      return e.childNodes
    },
    getParentNode(e) {
      return e.parentNode
    },
    getAttrList(e) {
      return e.attrs
    },
    getTagName(e) {
      return e.tagName
    },
    getNamespaceURI(e) {
      return e.namespaceURI
    },
    getTextNodeContent(e) {
      return e.value
    },
    getCommentNodeContent(e) {
      return e.data
    },
    getDocumentTypeNodeName(e) {
      return e.name
    },
    getDocumentTypeNodePublicId(e) {
      return e.publicId
    },
    getDocumentTypeNodeSystemId(e) {
      return e.systemId
    },
    isTextNode(e) {
      return e.nodeName === '#text'
    },
    isCommentNode(e) {
      return e.nodeName === '#comment'
    },
    isDocumentTypeNode(e) {
      return e.nodeName === '#documentType'
    },
    isElementNode(e) {
      return Object.prototype.hasOwnProperty.call(e, 'tagName')
    },
    setNodeSourceCodeLocation(e, t) {
      e.sourceCodeLocation = t
    },
    getNodeSourceCodeLocation(e) {
      return e.sourceCodeLocation
    },
    updateNodeSourceCodeLocation(e, t) {
      e.sourceCodeLocation = { ...e.sourceCodeLocation, ...t }
    },
  },
  ab = 'html',
  Sk = 'about:legacy-compat',
  Ck = 'http://www.ibm.com/data/dtd/v11/ibmxhtml1-transitional.dtd',
  ob = [
    '+//silmaril//dtd html pro v0r11 19970101//',
    '-//as//dtd html 3.0 aswedit + extensions//',
    '-//advasoft ltd//dtd html 3.0 aswedit + extensions//',
    '-//ietf//dtd html 2.0 level 1//',
    '-//ietf//dtd html 2.0 level 2//',
    '-//ietf//dtd html 2.0 strict level 1//',
    '-//ietf//dtd html 2.0 strict level 2//',
    '-//ietf//dtd html 2.0 strict//',
    '-//ietf//dtd html 2.0//',
    '-//ietf//dtd html 2.1e//',
    '-//ietf//dtd html 3.0//',
    '-//ietf//dtd html 3.2 final//',
    '-//ietf//dtd html 3.2//',
    '-//ietf//dtd html 3//',
    '-//ietf//dtd html level 0//',
    '-//ietf//dtd html level 1//',
    '-//ietf//dtd html level 2//',
    '-//ietf//dtd html level 3//',
    '-//ietf//dtd html strict level 0//',
    '-//ietf//dtd html strict level 1//',
    '-//ietf//dtd html strict level 2//',
    '-//ietf//dtd html strict level 3//',
    '-//ietf//dtd html strict//',
    '-//ietf//dtd html//',
    '-//metrius//dtd metrius presentational//',
    '-//microsoft//dtd internet explorer 2.0 html strict//',
    '-//microsoft//dtd internet explorer 2.0 html//',
    '-//microsoft//dtd internet explorer 2.0 tables//',
    '-//microsoft//dtd internet explorer 3.0 html strict//',
    '-//microsoft//dtd internet explorer 3.0 html//',
    '-//microsoft//dtd internet explorer 3.0 tables//',
    '-//netscape comm. corp.//dtd html//',
    '-//netscape comm. corp.//dtd strict html//',
    "-//o'reilly and associates//dtd html 2.0//",
    "-//o'reilly and associates//dtd html extended 1.0//",
    "-//o'reilly and associates//dtd html extended relaxed 1.0//",
    '-//sq//dtd html 2.0 hotmetal + extensions//',
    '-//softquad software//dtd hotmetal pro 6.0::19990601::extensions to html 4.0//',
    '-//softquad//dtd hotmetal pro 4.0::19971010::extensions to html 4.0//',
    '-//spyglass//dtd html 2.0 extended//',
    '-//sun microsystems corp.//dtd hotjava html//',
    '-//sun microsystems corp.//dtd hotjava strict html//',
    '-//w3c//dtd html 3 1995-03-24//',
    '-//w3c//dtd html 3.2 draft//',
    '-//w3c//dtd html 3.2 final//',
    '-//w3c//dtd html 3.2//',
    '-//w3c//dtd html 3.2s draft//',
    '-//w3c//dtd html 4.0 frameset//',
    '-//w3c//dtd html 4.0 transitional//',
    '-//w3c//dtd html experimental 19960712//',
    '-//w3c//dtd html experimental 970421//',
    '-//w3c//dtd w3 html//',
    '-//w3o//dtd w3 html 3.0//',
    '-//webtechs//dtd mozilla html 2.0//',
    '-//webtechs//dtd mozilla html//',
  ],
  kk = [...ob, '-//w3c//dtd html 4.01 frameset//', '-//w3c//dtd html 4.01 transitional//'],
  wk = new Set([
    '-//w3o//dtd w3 html strict 3.0//en//',
    '-/w3c/dtd html 4.0 transitional/en',
    'html',
  ]),
  ub = ['-//w3c//dtd xhtml 1.0 frameset//', '-//w3c//dtd xhtml 1.0 transitional//'],
  Nk = [...ub, '-//w3c//dtd html 4.01 frameset//', '-//w3c//dtd html 4.01 transitional//']
function $m(e, t) {
  return t.some((r) => e.startsWith(r))
}
function Ok(e) {
  return e.name === ab && e.publicId === null && (e.systemId === null || e.systemId === Sk)
}
function Ik(e) {
  if (e.name !== ab) return Rt.QUIRKS
  const { systemId: t } = e
  if (t && t.toLowerCase() === Ck) return Rt.QUIRKS
  let { publicId: r } = e
  if (r !== null) {
    if (((r = r.toLowerCase()), wk.has(r))) return Rt.QUIRKS
    let i = t === null ? kk : ob
    if ($m(r, i)) return Rt.QUIRKS
    if (((i = t === null ? ub : Nk), $m(r, i))) return Rt.LIMITED_QUIRKS
  }
  return Rt.NO_QUIRKS
}
const Vm = { TEXT_HTML: 'text/html', APPLICATION_XML: 'application/xhtml+xml' },
  Dk = 'definitionurl',
  Rk = 'definitionURL',
  Lk = new Map(
    [
      'attributeName',
      'attributeType',
      'baseFrequency',
      'baseProfile',
      'calcMode',
      'clipPathUnits',
      'diffuseConstant',
      'edgeMode',
      'filterUnits',
      'glyphRef',
      'gradientTransform',
      'gradientUnits',
      'kernelMatrix',
      'kernelUnitLength',
      'keyPoints',
      'keySplines',
      'keyTimes',
      'lengthAdjust',
      'limitingConeAngle',
      'markerHeight',
      'markerUnits',
      'markerWidth',
      'maskContentUnits',
      'maskUnits',
      'numOctaves',
      'pathLength',
      'patternContentUnits',
      'patternTransform',
      'patternUnits',
      'pointsAtX',
      'pointsAtY',
      'pointsAtZ',
      'preserveAlpha',
      'preserveAspectRatio',
      'primitiveUnits',
      'refX',
      'refY',
      'repeatCount',
      'repeatDur',
      'requiredExtensions',
      'requiredFeatures',
      'specularConstant',
      'specularExponent',
      'spreadMethod',
      'startOffset',
      'stdDeviation',
      'stitchTiles',
      'surfaceScale',
      'systemLanguage',
      'tableValues',
      'targetX',
      'targetY',
      'textLength',
      'viewBox',
      'viewTarget',
      'xChannelSelector',
      'yChannelSelector',
      'zoomAndPan',
    ].map((e) => [e.toLowerCase(), e])
  ),
  Pk = new Map([
    ['xlink:actuate', { prefix: 'xlink', name: 'actuate', namespace: ee.XLINK }],
    ['xlink:arcrole', { prefix: 'xlink', name: 'arcrole', namespace: ee.XLINK }],
    ['xlink:href', { prefix: 'xlink', name: 'href', namespace: ee.XLINK }],
    ['xlink:role', { prefix: 'xlink', name: 'role', namespace: ee.XLINK }],
    ['xlink:show', { prefix: 'xlink', name: 'show', namespace: ee.XLINK }],
    ['xlink:title', { prefix: 'xlink', name: 'title', namespace: ee.XLINK }],
    ['xlink:type', { prefix: 'xlink', name: 'type', namespace: ee.XLINK }],
    ['xml:base', { prefix: 'xml', name: 'base', namespace: ee.XML }],
    ['xml:lang', { prefix: 'xml', name: 'lang', namespace: ee.XML }],
    ['xml:space', { prefix: 'xml', name: 'space', namespace: ee.XML }],
    ['xmlns', { prefix: '', name: 'xmlns', namespace: ee.XMLNS }],
    ['xmlns:xlink', { prefix: 'xmlns', name: 'xlink', namespace: ee.XMLNS }],
  ]),
  Bk = new Map(
    [
      'altGlyph',
      'altGlyphDef',
      'altGlyphItem',
      'animateColor',
      'animateMotion',
      'animateTransform',
      'clipPath',
      'feBlend',
      'feColorMatrix',
      'feComponentTransfer',
      'feComposite',
      'feConvolveMatrix',
      'feDiffuseLighting',
      'feDisplacementMap',
      'feDistantLight',
      'feFlood',
      'feFuncA',
      'feFuncB',
      'feFuncG',
      'feFuncR',
      'feGaussianBlur',
      'feImage',
      'feMerge',
      'feMergeNode',
      'feMorphology',
      'feOffset',
      'fePointLight',
      'feSpecularLighting',
      'feSpotLight',
      'feTile',
      'feTurbulence',
      'foreignObject',
      'glyphRef',
      'linearGradient',
      'radialGradient',
      'textPath',
    ].map((e) => [e.toLowerCase(), e])
  ),
  Fk = new Set([
    d.B,
    d.BIG,
    d.BLOCKQUOTE,
    d.BODY,
    d.BR,
    d.CENTER,
    d.CODE,
    d.DD,
    d.DIV,
    d.DL,
    d.DT,
    d.EM,
    d.EMBED,
    d.H1,
    d.H2,
    d.H3,
    d.H4,
    d.H5,
    d.H6,
    d.HEAD,
    d.HR,
    d.I,
    d.IMG,
    d.LI,
    d.LISTING,
    d.MENU,
    d.META,
    d.NOBR,
    d.OL,
    d.P,
    d.PRE,
    d.RUBY,
    d.S,
    d.SMALL,
    d.SPAN,
    d.STRONG,
    d.STRIKE,
    d.SUB,
    d.SUP,
    d.TABLE,
    d.TT,
    d.U,
    d.UL,
    d.VAR,
  ])
function Mk(e) {
  const t = e.tagID
  return (
    (t === d.FONT &&
      e.attrs.some(({ name: i }) => i === si.COLOR || i === si.SIZE || i === si.FACE)) ||
    Fk.has(t)
  )
}
function lb(e) {
  for (let t = 0; t < e.attrs.length; t++)
    if (e.attrs[t].name === Dk) {
      e.attrs[t].name = Rk
      break
    }
}
function cb(e) {
  for (let t = 0; t < e.attrs.length; t++) {
    const r = Lk.get(e.attrs[t].name)
    r != null && (e.attrs[t].name = r)
  }
}
function dp(e) {
  for (let t = 0; t < e.attrs.length; t++) {
    const r = Pk.get(e.attrs[t].name)
    r &&
      ((e.attrs[t].prefix = r.prefix),
      (e.attrs[t].name = r.name),
      (e.attrs[t].namespace = r.namespace))
  }
}
function Uk(e) {
  const t = Bk.get(e.tagName)
  t != null && ((e.tagName = t), (e.tagID = pu(e.tagName)))
}
function Hk(e, t) {
  return t === ee.MATHML && (e === d.MI || e === d.MO || e === d.MN || e === d.MS || e === d.MTEXT)
}
function zk(e, t, r) {
  if (t === ee.MATHML && e === d.ANNOTATION_XML) {
    for (let i = 0; i < r.length; i++)
      if (r[i].name === si.ENCODING) {
        const n = r[i].value.toLowerCase()
        return n === Vm.TEXT_HTML || n === Vm.APPLICATION_XML
      }
  }
  return t === ee.SVG && (e === d.FOREIGN_OBJECT || e === d.DESC || e === d.TITLE)
}
function jk(e, t, r, i) {
  return ((!i || i === ee.HTML) && zk(e, t, r)) || ((!i || i === ee.MATHML) && Hk(e, t))
}
const qk = 'hidden',
  $k = 8,
  Vk = 3
var G
;(function (e) {
  ;(e[(e.INITIAL = 0)] = 'INITIAL'),
    (e[(e.BEFORE_HTML = 1)] = 'BEFORE_HTML'),
    (e[(e.BEFORE_HEAD = 2)] = 'BEFORE_HEAD'),
    (e[(e.IN_HEAD = 3)] = 'IN_HEAD'),
    (e[(e.IN_HEAD_NO_SCRIPT = 4)] = 'IN_HEAD_NO_SCRIPT'),
    (e[(e.AFTER_HEAD = 5)] = 'AFTER_HEAD'),
    (e[(e.IN_BODY = 6)] = 'IN_BODY'),
    (e[(e.TEXT = 7)] = 'TEXT'),
    (e[(e.IN_TABLE = 8)] = 'IN_TABLE'),
    (e[(e.IN_TABLE_TEXT = 9)] = 'IN_TABLE_TEXT'),
    (e[(e.IN_CAPTION = 10)] = 'IN_CAPTION'),
    (e[(e.IN_COLUMN_GROUP = 11)] = 'IN_COLUMN_GROUP'),
    (e[(e.IN_TABLE_BODY = 12)] = 'IN_TABLE_BODY'),
    (e[(e.IN_ROW = 13)] = 'IN_ROW'),
    (e[(e.IN_CELL = 14)] = 'IN_CELL'),
    (e[(e.IN_SELECT = 15)] = 'IN_SELECT'),
    (e[(e.IN_SELECT_IN_TABLE = 16)] = 'IN_SELECT_IN_TABLE'),
    (e[(e.IN_TEMPLATE = 17)] = 'IN_TEMPLATE'),
    (e[(e.AFTER_BODY = 18)] = 'AFTER_BODY'),
    (e[(e.IN_FRAMESET = 19)] = 'IN_FRAMESET'),
    (e[(e.AFTER_FRAMESET = 20)] = 'AFTER_FRAMESET'),
    (e[(e.AFTER_AFTER_BODY = 21)] = 'AFTER_AFTER_BODY'),
    (e[(e.AFTER_AFTER_FRAMESET = 22)] = 'AFTER_AFTER_FRAMESET')
})(G || (G = {}))
const Gk = { startLine: -1, startCol: -1, startOffset: -1, endLine: -1, endCol: -1, endOffset: -1 },
  fb = new Set([d.TABLE, d.TBODY, d.TFOOT, d.THEAD, d.TR]),
  Gm = { scriptingEnabled: !0, sourceCodeLocationInfo: !1, treeAdapter: Ki, onParseError: null }
class Xk {
  constructor(t, r, i = null, n = null) {
    ;(this.fragmentContext = i),
      (this.scriptHandler = n),
      (this.currentToken = null),
      (this.stopped = !1),
      (this.insertionMode = G.INITIAL),
      (this.originalInsertionMode = G.INITIAL),
      (this.headElement = null),
      (this.formElement = null),
      (this.currentNotInHTML = !1),
      (this.tmplInsertionModeStack = []),
      (this.pendingCharacterTokens = []),
      (this.hasNonWhitespacePendingCharacterToken = !1),
      (this.framesetOk = !0),
      (this.skipNextNewLine = !1),
      (this.fosterParentingEnabled = !1),
      (this.options = { ...Gm, ...t }),
      (this.treeAdapter = this.options.treeAdapter),
      (this.onParseError = this.options.onParseError),
      this.onParseError && (this.options.sourceCodeLocationInfo = !0),
      (this.document = r ?? this.treeAdapter.createDocument()),
      (this.tokenizer = new bk(this.options, this)),
      (this.activeFormattingElements = new Ak(this.treeAdapter)),
      (this.fragmentContextID = i ? pu(this.treeAdapter.getTagName(i)) : d.UNKNOWN),
      this._setContextModes(i ?? this.document, this.fragmentContextID),
      (this.openElements = new Tk(this.document, this.treeAdapter, this))
  }
  static parse(t, r) {
    const i = new this(r)
    return i.tokenizer.write(t, !0), i.document
  }
  static getFragmentParser(t, r) {
    const i = { ...Gm, ...r }
    t ?? (t = i.treeAdapter.createElement(Q.TEMPLATE, ee.HTML, []))
    const n = i.treeAdapter.createElement('documentmock', ee.HTML, []),
      s = new this(i, n, t)
    return (
      s.fragmentContextID === d.TEMPLATE && s.tmplInsertionModeStack.unshift(G.IN_TEMPLATE),
      s._initTokenizerForFragmentParsing(),
      s._insertFakeRootElement(),
      s._resetInsertionMode(),
      s._findFormInFragmentContext(),
      s
    )
  }
  getFragment() {
    const t = this.treeAdapter.getFirstChild(this.document),
      r = this.treeAdapter.createDocumentFragment()
    return this._adoptNodes(t, r), r
  }
  _err(t, r, i) {
    var n
    if (!this.onParseError) return
    const s = (n = t.location) !== null && n !== void 0 ? n : Gk,
      a = {
        code: r,
        startLine: s.startLine,
        startCol: s.startCol,
        startOffset: s.startOffset,
        endLine: i ? s.startLine : s.endLine,
        endCol: i ? s.startCol : s.endCol,
        endOffset: i ? s.startOffset : s.endOffset,
      }
    this.onParseError(a)
  }
  onItemPush(t, r, i) {
    var n, s
    ;(s = (n = this.treeAdapter).onItemPush) === null || s === void 0 || s.call(n, t),
      i && this.openElements.stackTop > 0 && this._setContextModes(t, r)
  }
  onItemPop(t, r) {
    var i, n
    if (
      (this.options.sourceCodeLocationInfo && this._setEndLocation(t, this.currentToken),
      (n = (i = this.treeAdapter).onItemPop) === null ||
        n === void 0 ||
        n.call(i, t, this.openElements.current),
      r)
    ) {
      let s, a
      this.openElements.stackTop === 0 && this.fragmentContext
        ? ((s = this.fragmentContext), (a = this.fragmentContextID))
        : ({ current: s, currentTagId: a } = this.openElements),
        this._setContextModes(s, a)
    }
  }
  _setContextModes(t, r) {
    const i = t === this.document || this.treeAdapter.getNamespaceURI(t) === ee.HTML
    ;(this.currentNotInHTML = !i),
      (this.tokenizer.inForeignNode = !i && !this._isIntegrationPoint(r, t))
  }
  _switchToTextParsing(t, r) {
    this._insertElement(t, ee.HTML),
      (this.tokenizer.state = r),
      (this.originalInsertionMode = this.insertionMode),
      (this.insertionMode = G.TEXT)
  }
  switchToPlaintextParsing() {
    ;(this.insertionMode = G.TEXT),
      (this.originalInsertionMode = G.IN_BODY),
      (this.tokenizer.state = St.PLAINTEXT)
  }
  _getAdjustedCurrentElement() {
    return this.openElements.stackTop === 0 && this.fragmentContext
      ? this.fragmentContext
      : this.openElements.current
  }
  _findFormInFragmentContext() {
    let t = this.fragmentContext
    for (; t; ) {
      if (this.treeAdapter.getTagName(t) === Q.FORM) {
        this.formElement = t
        break
      }
      t = this.treeAdapter.getParentNode(t)
    }
  }
  _initTokenizerForFragmentParsing() {
    if (
      !(!this.fragmentContext || this.treeAdapter.getNamespaceURI(this.fragmentContext) !== ee.HTML)
    )
      switch (this.fragmentContextID) {
        case d.TITLE:
        case d.TEXTAREA: {
          this.tokenizer.state = St.RCDATA
          break
        }
        case d.STYLE:
        case d.XMP:
        case d.IFRAME:
        case d.NOEMBED:
        case d.NOFRAMES:
        case d.NOSCRIPT: {
          this.tokenizer.state = St.RAWTEXT
          break
        }
        case d.SCRIPT: {
          this.tokenizer.state = St.SCRIPT_DATA
          break
        }
        case d.PLAINTEXT: {
          this.tokenizer.state = St.PLAINTEXT
          break
        }
      }
  }
  _setDocumentType(t) {
    const r = t.name || '',
      i = t.publicId || '',
      n = t.systemId || ''
    if ((this.treeAdapter.setDocumentType(this.document, r, i, n), t.location)) {
      const a = this.treeAdapter
        .getChildNodes(this.document)
        .find((o) => this.treeAdapter.isDocumentTypeNode(o))
      a && this.treeAdapter.setNodeSourceCodeLocation(a, t.location)
    }
  }
  _attachElementToTree(t, r) {
    if (this.options.sourceCodeLocationInfo) {
      const i = r && { ...r, startTag: r }
      this.treeAdapter.setNodeSourceCodeLocation(t, i)
    }
    if (this._shouldFosterParentOnInsertion()) this._fosterParentElement(t)
    else {
      const i = this.openElements.currentTmplContentOrNode
      this.treeAdapter.appendChild(i, t)
    }
  }
  _appendElement(t, r) {
    const i = this.treeAdapter.createElement(t.tagName, r, t.attrs)
    this._attachElementToTree(i, t.location)
  }
  _insertElement(t, r) {
    const i = this.treeAdapter.createElement(t.tagName, r, t.attrs)
    this._attachElementToTree(i, t.location), this.openElements.push(i, t.tagID)
  }
  _insertFakeElement(t, r) {
    const i = this.treeAdapter.createElement(t, ee.HTML, [])
    this._attachElementToTree(i, null), this.openElements.push(i, r)
  }
  _insertTemplate(t) {
    const r = this.treeAdapter.createElement(t.tagName, ee.HTML, t.attrs),
      i = this.treeAdapter.createDocumentFragment()
    this.treeAdapter.setTemplateContent(r, i),
      this._attachElementToTree(r, t.location),
      this.openElements.push(r, t.tagID),
      this.options.sourceCodeLocationInfo && this.treeAdapter.setNodeSourceCodeLocation(i, null)
  }
  _insertFakeRootElement() {
    const t = this.treeAdapter.createElement(Q.HTML, ee.HTML, [])
    this.options.sourceCodeLocationInfo && this.treeAdapter.setNodeSourceCodeLocation(t, null),
      this.treeAdapter.appendChild(this.openElements.current, t),
      this.openElements.push(t, d.HTML)
  }
  _appendCommentNode(t, r) {
    const i = this.treeAdapter.createCommentNode(t.data)
    this.treeAdapter.appendChild(r, i),
      this.options.sourceCodeLocationInfo &&
        this.treeAdapter.setNodeSourceCodeLocation(i, t.location)
  }
  _insertCharacters(t) {
    let r, i
    if (
      (this._shouldFosterParentOnInsertion()
        ? (({ parent: r, beforeElement: i } = this._findFosterParentingLocation()),
          i
            ? this.treeAdapter.insertTextBefore(r, t.chars, i)
            : this.treeAdapter.insertText(r, t.chars))
        : ((r = this.openElements.currentTmplContentOrNode),
          this.treeAdapter.insertText(r, t.chars)),
      !t.location)
    )
      return
    const n = this.treeAdapter.getChildNodes(r),
      s = i ? n.lastIndexOf(i) : n.length,
      a = n[s - 1]
    if (this.treeAdapter.getNodeSourceCodeLocation(a)) {
      const { endLine: u, endCol: c, endOffset: f } = t.location
      this.treeAdapter.updateNodeSourceCodeLocation(a, { endLine: u, endCol: c, endOffset: f })
    } else
      this.options.sourceCodeLocationInfo &&
        this.treeAdapter.setNodeSourceCodeLocation(a, t.location)
  }
  _adoptNodes(t, r) {
    for (let i = this.treeAdapter.getFirstChild(t); i; i = this.treeAdapter.getFirstChild(t))
      this.treeAdapter.detachNode(i), this.treeAdapter.appendChild(r, i)
  }
  _setEndLocation(t, r) {
    if (this.treeAdapter.getNodeSourceCodeLocation(t) && r.location) {
      const i = r.location,
        n = this.treeAdapter.getTagName(t),
        s =
          r.type === ke.END_TAG && n === r.tagName
            ? { endTag: { ...i }, endLine: i.endLine, endCol: i.endCol, endOffset: i.endOffset }
            : { endLine: i.startLine, endCol: i.startCol, endOffset: i.startOffset }
      this.treeAdapter.updateNodeSourceCodeLocation(t, s)
    }
  }
  shouldProcessStartTagTokenInForeignContent(t) {
    if (!this.currentNotInHTML) return !1
    let r, i
    return (
      this.openElements.stackTop === 0 && this.fragmentContext
        ? ((r = this.fragmentContext), (i = this.fragmentContextID))
        : ({ current: r, currentTagId: i } = this.openElements),
      t.tagID === d.SVG &&
      this.treeAdapter.getTagName(r) === Q.ANNOTATION_XML &&
      this.treeAdapter.getNamespaceURI(r) === ee.MATHML
        ? !1
        : this.tokenizer.inForeignNode ||
          ((t.tagID === d.MGLYPH || t.tagID === d.MALIGNMARK) &&
            !this._isIntegrationPoint(i, r, ee.HTML))
    )
  }
  _processToken(t) {
    switch (t.type) {
      case ke.CHARACTER: {
        this.onCharacter(t)
        break
      }
      case ke.NULL_CHARACTER: {
        this.onNullCharacter(t)
        break
      }
      case ke.COMMENT: {
        this.onComment(t)
        break
      }
      case ke.DOCTYPE: {
        this.onDoctype(t)
        break
      }
      case ke.START_TAG: {
        this._processStartTag(t)
        break
      }
      case ke.END_TAG: {
        this.onEndTag(t)
        break
      }
      case ke.EOF: {
        this.onEof(t)
        break
      }
      case ke.WHITESPACE_CHARACTER: {
        this.onWhitespaceCharacter(t)
        break
      }
    }
  }
  _isIntegrationPoint(t, r, i) {
    const n = this.treeAdapter.getNamespaceURI(r),
      s = this.treeAdapter.getAttrList(r)
    return jk(t, n, s, i)
  }
  _reconstructActiveFormattingElements() {
    const t = this.activeFormattingElements.entries.length
    if (t) {
      const r = this.activeFormattingElements.entries.findIndex(
          (n) => n.type === rr.Marker || this.openElements.contains(n.element)
        ),
        i = r < 0 ? t - 1 : r - 1
      for (let n = i; n >= 0; n--) {
        const s = this.activeFormattingElements.entries[n]
        this._insertElement(s.token, this.treeAdapter.getNamespaceURI(s.element)),
          (s.element = this.openElements.current)
      }
    }
  }
  _closeTableCell() {
    this.openElements.generateImpliedEndTags(),
      this.openElements.popUntilTableCellPopped(),
      this.activeFormattingElements.clearToLastMarker(),
      (this.insertionMode = G.IN_ROW)
  }
  _closePElement() {
    this.openElements.generateImpliedEndTagsWithExclusion(d.P),
      this.openElements.popUntilTagNamePopped(d.P)
  }
  _resetInsertionMode() {
    for (let t = this.openElements.stackTop; t >= 0; t--)
      switch (
        t === 0 && this.fragmentContext ? this.fragmentContextID : this.openElements.tagIDs[t]
      ) {
        case d.TR: {
          this.insertionMode = G.IN_ROW
          return
        }
        case d.TBODY:
        case d.THEAD:
        case d.TFOOT: {
          this.insertionMode = G.IN_TABLE_BODY
          return
        }
        case d.CAPTION: {
          this.insertionMode = G.IN_CAPTION
          return
        }
        case d.COLGROUP: {
          this.insertionMode = G.IN_COLUMN_GROUP
          return
        }
        case d.TABLE: {
          this.insertionMode = G.IN_TABLE
          return
        }
        case d.BODY: {
          this.insertionMode = G.IN_BODY
          return
        }
        case d.FRAMESET: {
          this.insertionMode = G.IN_FRAMESET
          return
        }
        case d.SELECT: {
          this._resetInsertionModeForSelect(t)
          return
        }
        case d.TEMPLATE: {
          this.insertionMode = this.tmplInsertionModeStack[0]
          return
        }
        case d.HTML: {
          this.insertionMode = this.headElement ? G.AFTER_HEAD : G.BEFORE_HEAD
          return
        }
        case d.TD:
        case d.TH: {
          if (t > 0) {
            this.insertionMode = G.IN_CELL
            return
          }
          break
        }
        case d.HEAD: {
          if (t > 0) {
            this.insertionMode = G.IN_HEAD
            return
          }
          break
        }
      }
    this.insertionMode = G.IN_BODY
  }
  _resetInsertionModeForSelect(t) {
    if (t > 0)
      for (let r = t - 1; r > 0; r--) {
        const i = this.openElements.tagIDs[r]
        if (i === d.TEMPLATE) break
        if (i === d.TABLE) {
          this.insertionMode = G.IN_SELECT_IN_TABLE
          return
        }
      }
    this.insertionMode = G.IN_SELECT
  }
  _isElementCausesFosterParenting(t) {
    return fb.has(t)
  }
  _shouldFosterParentOnInsertion() {
    return (
      this.fosterParentingEnabled &&
      this._isElementCausesFosterParenting(this.openElements.currentTagId)
    )
  }
  _findFosterParentingLocation() {
    for (let t = this.openElements.stackTop; t >= 0; t--) {
      const r = this.openElements.items[t]
      switch (this.openElements.tagIDs[t]) {
        case d.TEMPLATE: {
          if (this.treeAdapter.getNamespaceURI(r) === ee.HTML)
            return { parent: this.treeAdapter.getTemplateContent(r), beforeElement: null }
          break
        }
        case d.TABLE: {
          const i = this.treeAdapter.getParentNode(r)
          return i
            ? { parent: i, beforeElement: r }
            : { parent: this.openElements.items[t - 1], beforeElement: null }
        }
      }
    }
    return { parent: this.openElements.items[0], beforeElement: null }
  }
  _fosterParentElement(t) {
    const r = this._findFosterParentingLocation()
    r.beforeElement
      ? this.treeAdapter.insertBefore(r.parent, t, r.beforeElement)
      : this.treeAdapter.appendChild(r.parent, t)
  }
  _isSpecialElement(t, r) {
    const i = this.treeAdapter.getNamespaceURI(t)
    return pk[i].has(r)
  }
  onCharacter(t) {
    if (((this.skipNextNewLine = !1), this.tokenizer.inForeignNode)) {
      TN(this, t)
      return
    }
    switch (this.insertionMode) {
      case G.INITIAL: {
        Qn(this, t)
        break
      }
      case G.BEFORE_HTML: {
        _s(this, t)
        break
      }
      case G.BEFORE_HEAD: {
        vs(this, t)
        break
      }
      case G.IN_HEAD: {
        Es(this, t)
        break
      }
      case G.IN_HEAD_NO_SCRIPT: {
        xs(this, t)
        break
      }
      case G.AFTER_HEAD: {
        Ts(this, t)
        break
      }
      case G.IN_BODY:
      case G.IN_CAPTION:
      case G.IN_CELL:
      case G.IN_TEMPLATE: {
        hb(this, t)
        break
      }
      case G.TEXT:
      case G.IN_SELECT:
      case G.IN_SELECT_IN_TABLE: {
        this._insertCharacters(t)
        break
      }
      case G.IN_TABLE:
      case G.IN_TABLE_BODY:
      case G.IN_ROW: {
        vl(this, t)
        break
      }
      case G.IN_TABLE_TEXT: {
        _b(this, t)
        break
      }
      case G.IN_COLUMN_GROUP: {
        Uo(this, t)
        break
      }
      case G.AFTER_BODY: {
        Ho(this, t)
        break
      }
      case G.AFTER_AFTER_BODY: {
        io(this, t)
        break
      }
    }
  }
  onNullCharacter(t) {
    if (((this.skipNextNewLine = !1), this.tokenizer.inForeignNode)) {
      xN(this, t)
      return
    }
    switch (this.insertionMode) {
      case G.INITIAL: {
        Qn(this, t)
        break
      }
      case G.BEFORE_HTML: {
        _s(this, t)
        break
      }
      case G.BEFORE_HEAD: {
        vs(this, t)
        break
      }
      case G.IN_HEAD: {
        Es(this, t)
        break
      }
      case G.IN_HEAD_NO_SCRIPT: {
        xs(this, t)
        break
      }
      case G.AFTER_HEAD: {
        Ts(this, t)
        break
      }
      case G.TEXT: {
        this._insertCharacters(t)
        break
      }
      case G.IN_TABLE:
      case G.IN_TABLE_BODY:
      case G.IN_ROW: {
        vl(this, t)
        break
      }
      case G.IN_COLUMN_GROUP: {
        Uo(this, t)
        break
      }
      case G.AFTER_BODY: {
        Ho(this, t)
        break
      }
      case G.AFTER_AFTER_BODY: {
        io(this, t)
        break
      }
    }
  }
  onComment(t) {
    if (((this.skipNextNewLine = !1), this.currentNotInHTML)) {
      Fc(this, t)
      return
    }
    switch (this.insertionMode) {
      case G.INITIAL:
      case G.BEFORE_HTML:
      case G.BEFORE_HEAD:
      case G.IN_HEAD:
      case G.IN_HEAD_NO_SCRIPT:
      case G.AFTER_HEAD:
      case G.IN_BODY:
      case G.IN_TABLE:
      case G.IN_CAPTION:
      case G.IN_COLUMN_GROUP:
      case G.IN_TABLE_BODY:
      case G.IN_ROW:
      case G.IN_CELL:
      case G.IN_SELECT:
      case G.IN_SELECT_IN_TABLE:
      case G.IN_TEMPLATE:
      case G.IN_FRAMESET:
      case G.AFTER_FRAMESET: {
        Fc(this, t)
        break
      }
      case G.IN_TABLE_TEXT: {
        Kn(this, t)
        break
      }
      case G.AFTER_BODY: {
        ew(this, t)
        break
      }
      case G.AFTER_AFTER_BODY:
      case G.AFTER_AFTER_FRAMESET: {
        tw(this, t)
        break
      }
    }
  }
  onDoctype(t) {
    switch (((this.skipNextNewLine = !1), this.insertionMode)) {
      case G.INITIAL: {
        rw(this, t)
        break
      }
      case G.BEFORE_HEAD:
      case G.IN_HEAD:
      case G.IN_HEAD_NO_SCRIPT:
      case G.AFTER_HEAD: {
        this._err(t, J.misplacedDoctype)
        break
      }
      case G.IN_TABLE_TEXT: {
        Kn(this, t)
        break
      }
    }
  }
  onStartTag(t) {
    ;(this.skipNextNewLine = !1),
      (this.currentToken = t),
      this._processStartTag(t),
      t.selfClosing &&
        !t.ackSelfClosing &&
        this._err(t, J.nonVoidHtmlElementStartTagWithTrailingSolidus)
  }
  _processStartTag(t) {
    this.shouldProcessStartTagTokenInForeignContent(t)
      ? AN(this, t)
      : this._startTagOutsideForeignContent(t)
  }
  _startTagOutsideForeignContent(t) {
    switch (this.insertionMode) {
      case G.INITIAL: {
        Qn(this, t)
        break
      }
      case G.BEFORE_HTML: {
        iw(this, t)
        break
      }
      case G.BEFORE_HEAD: {
        sw(this, t)
        break
      }
      case G.IN_HEAD: {
        or(this, t)
        break
      }
      case G.IN_HEAD_NO_SCRIPT: {
        uw(this, t)
        break
      }
      case G.AFTER_HEAD: {
        cw(this, t)
        break
      }
      case G.IN_BODY: {
        dt(this, t)
        break
      }
      case G.IN_TABLE: {
        In(this, t)
        break
      }
      case G.IN_TABLE_TEXT: {
        Kn(this, t)
        break
      }
      case G.IN_CAPTION: {
        aN(this, t)
        break
      }
      case G.IN_COLUMN_GROUP: {
        yp(this, t)
        break
      }
      case G.IN_TABLE_BODY: {
        du(this, t)
        break
      }
      case G.IN_ROW: {
        gu(this, t)
        break
      }
      case G.IN_CELL: {
        lN(this, t)
        break
      }
      case G.IN_SELECT: {
        xb(this, t)
        break
      }
      case G.IN_SELECT_IN_TABLE: {
        fN(this, t)
        break
      }
      case G.IN_TEMPLATE: {
        hN(this, t)
        break
      }
      case G.AFTER_BODY: {
        dN(this, t)
        break
      }
      case G.IN_FRAMESET: {
        gN(this, t)
        break
      }
      case G.AFTER_FRAMESET: {
        yN(this, t)
        break
      }
      case G.AFTER_AFTER_BODY: {
        vN(this, t)
        break
      }
      case G.AFTER_AFTER_FRAMESET: {
        EN(this, t)
        break
      }
    }
  }
  onEndTag(t) {
    ;(this.skipNextNewLine = !1),
      (this.currentToken = t),
      this.currentNotInHTML ? SN(this, t) : this._endTagOutsideForeignContent(t)
  }
  _endTagOutsideForeignContent(t) {
    switch (this.insertionMode) {
      case G.INITIAL: {
        Qn(this, t)
        break
      }
      case G.BEFORE_HTML: {
        nw(this, t)
        break
      }
      case G.BEFORE_HEAD: {
        aw(this, t)
        break
      }
      case G.IN_HEAD: {
        ow(this, t)
        break
      }
      case G.IN_HEAD_NO_SCRIPT: {
        lw(this, t)
        break
      }
      case G.AFTER_HEAD: {
        fw(this, t)
        break
      }
      case G.IN_BODY: {
        mu(this, t)
        break
      }
      case G.TEXT: {
        Qw(this, t)
        break
      }
      case G.IN_TABLE: {
        js(this, t)
        break
      }
      case G.IN_TABLE_TEXT: {
        Kn(this, t)
        break
      }
      case G.IN_CAPTION: {
        oN(this, t)
        break
      }
      case G.IN_COLUMN_GROUP: {
        uN(this, t)
        break
      }
      case G.IN_TABLE_BODY: {
        Mc(this, t)
        break
      }
      case G.IN_ROW: {
        Eb(this, t)
        break
      }
      case G.IN_CELL: {
        cN(this, t)
        break
      }
      case G.IN_SELECT: {
        Tb(this, t)
        break
      }
      case G.IN_SELECT_IN_TABLE: {
        pN(this, t)
        break
      }
      case G.IN_TEMPLATE: {
        mN(this, t)
        break
      }
      case G.AFTER_BODY: {
        Sb(this, t)
        break
      }
      case G.IN_FRAMESET: {
        bN(this, t)
        break
      }
      case G.AFTER_FRAMESET: {
        _N(this, t)
        break
      }
      case G.AFTER_AFTER_BODY: {
        io(this, t)
        break
      }
    }
  }
  onEof(t) {
    switch (this.insertionMode) {
      case G.INITIAL: {
        Qn(this, t)
        break
      }
      case G.BEFORE_HTML: {
        _s(this, t)
        break
      }
      case G.BEFORE_HEAD: {
        vs(this, t)
        break
      }
      case G.IN_HEAD: {
        Es(this, t)
        break
      }
      case G.IN_HEAD_NO_SCRIPT: {
        xs(this, t)
        break
      }
      case G.AFTER_HEAD: {
        Ts(this, t)
        break
      }
      case G.IN_BODY:
      case G.IN_TABLE:
      case G.IN_CAPTION:
      case G.IN_COLUMN_GROUP:
      case G.IN_TABLE_BODY:
      case G.IN_ROW:
      case G.IN_CELL:
      case G.IN_SELECT:
      case G.IN_SELECT_IN_TABLE: {
        bb(this, t)
        break
      }
      case G.TEXT: {
        Kw(this, t)
        break
      }
      case G.IN_TABLE_TEXT: {
        Kn(this, t)
        break
      }
      case G.IN_TEMPLATE: {
        Ab(this, t)
        break
      }
      case G.AFTER_BODY:
      case G.IN_FRAMESET:
      case G.AFTER_FRAMESET:
      case G.AFTER_AFTER_BODY:
      case G.AFTER_AFTER_FRAMESET: {
        bp(this, t)
        break
      }
    }
  }
  onWhitespaceCharacter(t) {
    if (
      this.skipNextNewLine &&
      ((this.skipNextNewLine = !1), t.chars.charCodeAt(0) === B.LINE_FEED)
    ) {
      if (t.chars.length === 1) return
      t.chars = t.chars.substr(1)
    }
    if (this.tokenizer.inForeignNode) {
      this._insertCharacters(t)
      return
    }
    switch (this.insertionMode) {
      case G.IN_HEAD:
      case G.IN_HEAD_NO_SCRIPT:
      case G.AFTER_HEAD:
      case G.TEXT:
      case G.IN_COLUMN_GROUP:
      case G.IN_SELECT:
      case G.IN_SELECT_IN_TABLE:
      case G.IN_FRAMESET:
      case G.AFTER_FRAMESET: {
        this._insertCharacters(t)
        break
      }
      case G.IN_BODY:
      case G.IN_CAPTION:
      case G.IN_CELL:
      case G.IN_TEMPLATE:
      case G.AFTER_BODY:
      case G.AFTER_AFTER_BODY:
      case G.AFTER_AFTER_FRAMESET: {
        pb(this, t)
        break
      }
      case G.IN_TABLE:
      case G.IN_TABLE_BODY:
      case G.IN_ROW: {
        vl(this, t)
        break
      }
      case G.IN_TABLE_TEXT: {
        yb(this, t)
        break
      }
    }
  }
}
function Yk(e, t) {
  let r = e.activeFormattingElements.getElementEntryInScopeWithTagName(t.tagName)
  return (
    r
      ? e.openElements.contains(r.element)
        ? e.openElements.hasInScope(t.tagID) || (r = null)
        : (e.activeFormattingElements.removeEntry(r), (r = null))
      : gb(e, t),
    r
  )
}
function Wk(e, t) {
  let r = null,
    i = e.openElements.stackTop
  for (; i >= 0; i--) {
    const n = e.openElements.items[i]
    if (n === t.element) break
    e._isSpecialElement(n, e.openElements.tagIDs[i]) && (r = n)
  }
  return (
    r || (e.openElements.shortenToLength(i < 0 ? 0 : i), e.activeFormattingElements.removeEntry(t)),
    r
  )
}
function Qk(e, t, r) {
  let i = t,
    n = e.openElements.getCommonAncestor(t)
  for (let s = 0, a = n; a !== r; s++, a = n) {
    n = e.openElements.getCommonAncestor(a)
    const o = e.activeFormattingElements.getElementEntry(a),
      u = o && s >= Vk
    !o || u
      ? (u && e.activeFormattingElements.removeEntry(o), e.openElements.remove(a))
      : ((a = Kk(e, o)),
        i === t && (e.activeFormattingElements.bookmark = o),
        e.treeAdapter.detachNode(i),
        e.treeAdapter.appendChild(a, i),
        (i = a))
  }
  return i
}
function Kk(e, t) {
  const r = e.treeAdapter.getNamespaceURI(t.element),
    i = e.treeAdapter.createElement(t.token.tagName, r, t.token.attrs)
  return e.openElements.replace(t.element, i), (t.element = i), i
}
function Jk(e, t, r) {
  const i = e.treeAdapter.getTagName(t),
    n = pu(i)
  if (e._isElementCausesFosterParenting(n)) e._fosterParentElement(r)
  else {
    const s = e.treeAdapter.getNamespaceURI(t)
    n === d.TEMPLATE && s === ee.HTML && (t = e.treeAdapter.getTemplateContent(t)),
      e.treeAdapter.appendChild(t, r)
  }
}
function Zk(e, t, r) {
  const i = e.treeAdapter.getNamespaceURI(r.element),
    { token: n } = r,
    s = e.treeAdapter.createElement(n.tagName, i, n.attrs)
  e._adoptNodes(t, s),
    e.treeAdapter.appendChild(t, s),
    e.activeFormattingElements.insertElementAfterBookmark(s, n),
    e.activeFormattingElements.removeEntry(r),
    e.openElements.remove(r.element),
    e.openElements.insertAfter(t, s, n.tagID)
}
function gp(e, t) {
  for (let r = 0; r < $k; r++) {
    const i = Yk(e, t)
    if (!i) break
    const n = Wk(e, i)
    if (!n) break
    e.activeFormattingElements.bookmark = i
    const s = Qk(e, n, i.element),
      a = e.openElements.getCommonAncestor(i.element)
    e.treeAdapter.detachNode(s), a && Jk(e, a, s), Zk(e, n, i)
  }
}
function Fc(e, t) {
  e._appendCommentNode(t, e.openElements.currentTmplContentOrNode)
}
function ew(e, t) {
  e._appendCommentNode(t, e.openElements.items[0])
}
function tw(e, t) {
  e._appendCommentNode(t, e.document)
}
function bp(e, t) {
  if (((e.stopped = !0), t.location)) {
    const r = e.fragmentContext ? 0 : 2
    for (let i = e.openElements.stackTop; i >= r; i--) e._setEndLocation(e.openElements.items[i], t)
    if (!e.fragmentContext && e.openElements.stackTop >= 0) {
      const i = e.openElements.items[0],
        n = e.treeAdapter.getNodeSourceCodeLocation(i)
      if (n && !n.endTag && (e._setEndLocation(i, t), e.openElements.stackTop >= 1)) {
        const s = e.openElements.items[1],
          a = e.treeAdapter.getNodeSourceCodeLocation(s)
        a && !a.endTag && e._setEndLocation(s, t)
      }
    }
  }
}
function rw(e, t) {
  e._setDocumentType(t)
  const r = t.forceQuirks ? Rt.QUIRKS : Ik(t)
  Ok(t) || e._err(t, J.nonConformingDoctype),
    e.treeAdapter.setDocumentMode(e.document, r),
    (e.insertionMode = G.BEFORE_HTML)
}
function Qn(e, t) {
  e._err(t, J.missingDoctype, !0),
    e.treeAdapter.setDocumentMode(e.document, Rt.QUIRKS),
    (e.insertionMode = G.BEFORE_HTML),
    e._processToken(t)
}
function iw(e, t) {
  t.tagID === d.HTML ? (e._insertElement(t, ee.HTML), (e.insertionMode = G.BEFORE_HEAD)) : _s(e, t)
}
function nw(e, t) {
  const r = t.tagID
  ;(r === d.HTML || r === d.HEAD || r === d.BODY || r === d.BR) && _s(e, t)
}
function _s(e, t) {
  e._insertFakeRootElement(), (e.insertionMode = G.BEFORE_HEAD), e._processToken(t)
}
function sw(e, t) {
  switch (t.tagID) {
    case d.HTML: {
      dt(e, t)
      break
    }
    case d.HEAD: {
      e._insertElement(t, ee.HTML),
        (e.headElement = e.openElements.current),
        (e.insertionMode = G.IN_HEAD)
      break
    }
    default:
      vs(e, t)
  }
}
function aw(e, t) {
  const r = t.tagID
  r === d.HEAD || r === d.BODY || r === d.HTML || r === d.BR
    ? vs(e, t)
    : e._err(t, J.endTagWithoutMatchingOpenElement)
}
function vs(e, t) {
  e._insertFakeElement(Q.HEAD, d.HEAD),
    (e.headElement = e.openElements.current),
    (e.insertionMode = G.IN_HEAD),
    e._processToken(t)
}
function or(e, t) {
  switch (t.tagID) {
    case d.HTML: {
      dt(e, t)
      break
    }
    case d.BASE:
    case d.BASEFONT:
    case d.BGSOUND:
    case d.LINK:
    case d.META: {
      e._appendElement(t, ee.HTML), (t.ackSelfClosing = !0)
      break
    }
    case d.TITLE: {
      e._switchToTextParsing(t, St.RCDATA)
      break
    }
    case d.NOSCRIPT: {
      e.options.scriptingEnabled
        ? e._switchToTextParsing(t, St.RAWTEXT)
        : (e._insertElement(t, ee.HTML), (e.insertionMode = G.IN_HEAD_NO_SCRIPT))
      break
    }
    case d.NOFRAMES:
    case d.STYLE: {
      e._switchToTextParsing(t, St.RAWTEXT)
      break
    }
    case d.SCRIPT: {
      e._switchToTextParsing(t, St.SCRIPT_DATA)
      break
    }
    case d.TEMPLATE: {
      e._insertTemplate(t),
        e.activeFormattingElements.insertMarker(),
        (e.framesetOk = !1),
        (e.insertionMode = G.IN_TEMPLATE),
        e.tmplInsertionModeStack.unshift(G.IN_TEMPLATE)
      break
    }
    case d.HEAD: {
      e._err(t, J.misplacedStartTagForHeadElement)
      break
    }
    default:
      Es(e, t)
  }
}
function ow(e, t) {
  switch (t.tagID) {
    case d.HEAD: {
      e.openElements.pop(), (e.insertionMode = G.AFTER_HEAD)
      break
    }
    case d.BODY:
    case d.BR:
    case d.HTML: {
      Es(e, t)
      break
    }
    case d.TEMPLATE: {
      qi(e, t)
      break
    }
    default:
      e._err(t, J.endTagWithoutMatchingOpenElement)
  }
}
function qi(e, t) {
  e.openElements.tmplCount > 0
    ? (e.openElements.generateImpliedEndTagsThoroughly(),
      e.openElements.currentTagId !== d.TEMPLATE &&
        e._err(t, J.closingOfElementWithOpenChildElements),
      e.openElements.popUntilTagNamePopped(d.TEMPLATE),
      e.activeFormattingElements.clearToLastMarker(),
      e.tmplInsertionModeStack.shift(),
      e._resetInsertionMode())
    : e._err(t, J.endTagWithoutMatchingOpenElement)
}
function Es(e, t) {
  e.openElements.pop(), (e.insertionMode = G.AFTER_HEAD), e._processToken(t)
}
function uw(e, t) {
  switch (t.tagID) {
    case d.HTML: {
      dt(e, t)
      break
    }
    case d.BASEFONT:
    case d.BGSOUND:
    case d.HEAD:
    case d.LINK:
    case d.META:
    case d.NOFRAMES:
    case d.STYLE: {
      or(e, t)
      break
    }
    case d.NOSCRIPT: {
      e._err(t, J.nestedNoscriptInHead)
      break
    }
    default:
      xs(e, t)
  }
}
function lw(e, t) {
  switch (t.tagID) {
    case d.NOSCRIPT: {
      e.openElements.pop(), (e.insertionMode = G.IN_HEAD)
      break
    }
    case d.BR: {
      xs(e, t)
      break
    }
    default:
      e._err(t, J.endTagWithoutMatchingOpenElement)
  }
}
function xs(e, t) {
  const r = t.type === ke.EOF ? J.openElementsLeftAfterEof : J.disallowedContentInNoscriptInHead
  e._err(t, r), e.openElements.pop(), (e.insertionMode = G.IN_HEAD), e._processToken(t)
}
function cw(e, t) {
  switch (t.tagID) {
    case d.HTML: {
      dt(e, t)
      break
    }
    case d.BODY: {
      e._insertElement(t, ee.HTML), (e.framesetOk = !1), (e.insertionMode = G.IN_BODY)
      break
    }
    case d.FRAMESET: {
      e._insertElement(t, ee.HTML), (e.insertionMode = G.IN_FRAMESET)
      break
    }
    case d.BASE:
    case d.BASEFONT:
    case d.BGSOUND:
    case d.LINK:
    case d.META:
    case d.NOFRAMES:
    case d.SCRIPT:
    case d.STYLE:
    case d.TEMPLATE:
    case d.TITLE: {
      e._err(t, J.abandonedHeadElementChild),
        e.openElements.push(e.headElement, d.HEAD),
        or(e, t),
        e.openElements.remove(e.headElement)
      break
    }
    case d.HEAD: {
      e._err(t, J.misplacedStartTagForHeadElement)
      break
    }
    default:
      Ts(e, t)
  }
}
function fw(e, t) {
  switch (t.tagID) {
    case d.BODY:
    case d.HTML:
    case d.BR: {
      Ts(e, t)
      break
    }
    case d.TEMPLATE: {
      qi(e, t)
      break
    }
    default:
      e._err(t, J.endTagWithoutMatchingOpenElement)
  }
}
function Ts(e, t) {
  e._insertFakeElement(Q.BODY, d.BODY), (e.insertionMode = G.IN_BODY), hu(e, t)
}
function hu(e, t) {
  switch (t.type) {
    case ke.CHARACTER: {
      hb(e, t)
      break
    }
    case ke.WHITESPACE_CHARACTER: {
      pb(e, t)
      break
    }
    case ke.COMMENT: {
      Fc(e, t)
      break
    }
    case ke.START_TAG: {
      dt(e, t)
      break
    }
    case ke.END_TAG: {
      mu(e, t)
      break
    }
    case ke.EOF: {
      bb(e, t)
      break
    }
  }
}
function pb(e, t) {
  e._reconstructActiveFormattingElements(), e._insertCharacters(t)
}
function hb(e, t) {
  e._reconstructActiveFormattingElements(), e._insertCharacters(t), (e.framesetOk = !1)
}
function pw(e, t) {
  e.openElements.tmplCount === 0 && e.treeAdapter.adoptAttributes(e.openElements.items[0], t.attrs)
}
function hw(e, t) {
  const r = e.openElements.tryPeekProperlyNestedBodyElement()
  r &&
    e.openElements.tmplCount === 0 &&
    ((e.framesetOk = !1), e.treeAdapter.adoptAttributes(r, t.attrs))
}
function mw(e, t) {
  const r = e.openElements.tryPeekProperlyNestedBodyElement()
  e.framesetOk &&
    r &&
    (e.treeAdapter.detachNode(r),
    e.openElements.popAllUpToHtmlElement(),
    e._insertElement(t, ee.HTML),
    (e.insertionMode = G.IN_FRAMESET))
}
function dw(e, t) {
  e.openElements.hasInButtonScope(d.P) && e._closePElement(), e._insertElement(t, ee.HTML)
}
function gw(e, t) {
  e.openElements.hasInButtonScope(d.P) && e._closePElement(),
    tb(e.openElements.currentTagId) && e.openElements.pop(),
    e._insertElement(t, ee.HTML)
}
function bw(e, t) {
  e.openElements.hasInButtonScope(d.P) && e._closePElement(),
    e._insertElement(t, ee.HTML),
    (e.skipNextNewLine = !0),
    (e.framesetOk = !1)
}
function yw(e, t) {
  const r = e.openElements.tmplCount > 0
  ;(!e.formElement || r) &&
    (e.openElements.hasInButtonScope(d.P) && e._closePElement(),
    e._insertElement(t, ee.HTML),
    r || (e.formElement = e.openElements.current))
}
function _w(e, t) {
  e.framesetOk = !1
  const r = t.tagID
  for (let i = e.openElements.stackTop; i >= 0; i--) {
    const n = e.openElements.tagIDs[i]
    if ((r === d.LI && n === d.LI) || ((r === d.DD || r === d.DT) && (n === d.DD || n === d.DT))) {
      e.openElements.generateImpliedEndTagsWithExclusion(n), e.openElements.popUntilTagNamePopped(n)
      break
    }
    if (
      n !== d.ADDRESS &&
      n !== d.DIV &&
      n !== d.P &&
      e._isSpecialElement(e.openElements.items[i], n)
    )
      break
  }
  e.openElements.hasInButtonScope(d.P) && e._closePElement(), e._insertElement(t, ee.HTML)
}
function vw(e, t) {
  e.openElements.hasInButtonScope(d.P) && e._closePElement(),
    e._insertElement(t, ee.HTML),
    (e.tokenizer.state = St.PLAINTEXT)
}
function Ew(e, t) {
  e.openElements.hasInScope(d.BUTTON) &&
    (e.openElements.generateImpliedEndTags(), e.openElements.popUntilTagNamePopped(d.BUTTON)),
    e._reconstructActiveFormattingElements(),
    e._insertElement(t, ee.HTML),
    (e.framesetOk = !1)
}
function xw(e, t) {
  const r = e.activeFormattingElements.getElementEntryInScopeWithTagName(Q.A)
  r && (gp(e, t), e.openElements.remove(r.element), e.activeFormattingElements.removeEntry(r)),
    e._reconstructActiveFormattingElements(),
    e._insertElement(t, ee.HTML),
    e.activeFormattingElements.pushElement(e.openElements.current, t)
}
function Tw(e, t) {
  e._reconstructActiveFormattingElements(),
    e._insertElement(t, ee.HTML),
    e.activeFormattingElements.pushElement(e.openElements.current, t)
}
function Aw(e, t) {
  e._reconstructActiveFormattingElements(),
    e.openElements.hasInScope(d.NOBR) && (gp(e, t), e._reconstructActiveFormattingElements()),
    e._insertElement(t, ee.HTML),
    e.activeFormattingElements.pushElement(e.openElements.current, t)
}
function Sw(e, t) {
  e._reconstructActiveFormattingElements(),
    e._insertElement(t, ee.HTML),
    e.activeFormattingElements.insertMarker(),
    (e.framesetOk = !1)
}
function Cw(e, t) {
  e.treeAdapter.getDocumentMode(e.document) !== Rt.QUIRKS &&
    e.openElements.hasInButtonScope(d.P) &&
    e._closePElement(),
    e._insertElement(t, ee.HTML),
    (e.framesetOk = !1),
    (e.insertionMode = G.IN_TABLE)
}
function mb(e, t) {
  e._reconstructActiveFormattingElements(),
    e._appendElement(t, ee.HTML),
    (e.framesetOk = !1),
    (t.ackSelfClosing = !0)
}
function db(e) {
  const t = J1(e, si.TYPE)
  return t != null && t.toLowerCase() === qk
}
function kw(e, t) {
  e._reconstructActiveFormattingElements(),
    e._appendElement(t, ee.HTML),
    db(t) || (e.framesetOk = !1),
    (t.ackSelfClosing = !0)
}
function ww(e, t) {
  e._appendElement(t, ee.HTML), (t.ackSelfClosing = !0)
}
function Nw(e, t) {
  e.openElements.hasInButtonScope(d.P) && e._closePElement(),
    e._appendElement(t, ee.HTML),
    (e.framesetOk = !1),
    (t.ackSelfClosing = !0)
}
function Ow(e, t) {
  ;(t.tagName = Q.IMG), (t.tagID = d.IMG), mb(e, t)
}
function Iw(e, t) {
  e._insertElement(t, ee.HTML),
    (e.skipNextNewLine = !0),
    (e.tokenizer.state = St.RCDATA),
    (e.originalInsertionMode = e.insertionMode),
    (e.framesetOk = !1),
    (e.insertionMode = G.TEXT)
}
function Dw(e, t) {
  e.openElements.hasInButtonScope(d.P) && e._closePElement(),
    e._reconstructActiveFormattingElements(),
    (e.framesetOk = !1),
    e._switchToTextParsing(t, St.RAWTEXT)
}
function Rw(e, t) {
  ;(e.framesetOk = !1), e._switchToTextParsing(t, St.RAWTEXT)
}
function Xm(e, t) {
  e._switchToTextParsing(t, St.RAWTEXT)
}
function Lw(e, t) {
  e._reconstructActiveFormattingElements(),
    e._insertElement(t, ee.HTML),
    (e.framesetOk = !1),
    (e.insertionMode =
      e.insertionMode === G.IN_TABLE ||
      e.insertionMode === G.IN_CAPTION ||
      e.insertionMode === G.IN_TABLE_BODY ||
      e.insertionMode === G.IN_ROW ||
      e.insertionMode === G.IN_CELL
        ? G.IN_SELECT_IN_TABLE
        : G.IN_SELECT)
}
function Pw(e, t) {
  e.openElements.currentTagId === d.OPTION && e.openElements.pop(),
    e._reconstructActiveFormattingElements(),
    e._insertElement(t, ee.HTML)
}
function Bw(e, t) {
  e.openElements.hasInScope(d.RUBY) && e.openElements.generateImpliedEndTags(),
    e._insertElement(t, ee.HTML)
}
function Fw(e, t) {
  e.openElements.hasInScope(d.RUBY) && e.openElements.generateImpliedEndTagsWithExclusion(d.RTC),
    e._insertElement(t, ee.HTML)
}
function Mw(e, t) {
  e._reconstructActiveFormattingElements(),
    lb(t),
    dp(t),
    t.selfClosing ? e._appendElement(t, ee.MATHML) : e._insertElement(t, ee.MATHML),
    (t.ackSelfClosing = !0)
}
function Uw(e, t) {
  e._reconstructActiveFormattingElements(),
    cb(t),
    dp(t),
    t.selfClosing ? e._appendElement(t, ee.SVG) : e._insertElement(t, ee.SVG),
    (t.ackSelfClosing = !0)
}
function Ym(e, t) {
  e._reconstructActiveFormattingElements(), e._insertElement(t, ee.HTML)
}
function dt(e, t) {
  switch (t.tagID) {
    case d.I:
    case d.S:
    case d.B:
    case d.U:
    case d.EM:
    case d.TT:
    case d.BIG:
    case d.CODE:
    case d.FONT:
    case d.SMALL:
    case d.STRIKE:
    case d.STRONG: {
      Tw(e, t)
      break
    }
    case d.A: {
      xw(e, t)
      break
    }
    case d.H1:
    case d.H2:
    case d.H3:
    case d.H4:
    case d.H5:
    case d.H6: {
      gw(e, t)
      break
    }
    case d.P:
    case d.DL:
    case d.OL:
    case d.UL:
    case d.DIV:
    case d.DIR:
    case d.NAV:
    case d.MAIN:
    case d.MENU:
    case d.ASIDE:
    case d.CENTER:
    case d.FIGURE:
    case d.FOOTER:
    case d.HEADER:
    case d.HGROUP:
    case d.DIALOG:
    case d.DETAILS:
    case d.ADDRESS:
    case d.ARTICLE:
    case d.SECTION:
    case d.SUMMARY:
    case d.FIELDSET:
    case d.BLOCKQUOTE:
    case d.FIGCAPTION: {
      dw(e, t)
      break
    }
    case d.LI:
    case d.DD:
    case d.DT: {
      _w(e, t)
      break
    }
    case d.BR:
    case d.IMG:
    case d.WBR:
    case d.AREA:
    case d.EMBED:
    case d.KEYGEN: {
      mb(e, t)
      break
    }
    case d.HR: {
      Nw(e, t)
      break
    }
    case d.RB:
    case d.RTC: {
      Bw(e, t)
      break
    }
    case d.RT:
    case d.RP: {
      Fw(e, t)
      break
    }
    case d.PRE:
    case d.LISTING: {
      bw(e, t)
      break
    }
    case d.XMP: {
      Dw(e, t)
      break
    }
    case d.SVG: {
      Uw(e, t)
      break
    }
    case d.HTML: {
      pw(e, t)
      break
    }
    case d.BASE:
    case d.LINK:
    case d.META:
    case d.STYLE:
    case d.TITLE:
    case d.SCRIPT:
    case d.BGSOUND:
    case d.BASEFONT:
    case d.TEMPLATE: {
      or(e, t)
      break
    }
    case d.BODY: {
      hw(e, t)
      break
    }
    case d.FORM: {
      yw(e, t)
      break
    }
    case d.NOBR: {
      Aw(e, t)
      break
    }
    case d.MATH: {
      Mw(e, t)
      break
    }
    case d.TABLE: {
      Cw(e, t)
      break
    }
    case d.INPUT: {
      kw(e, t)
      break
    }
    case d.PARAM:
    case d.TRACK:
    case d.SOURCE: {
      ww(e, t)
      break
    }
    case d.IMAGE: {
      Ow(e, t)
      break
    }
    case d.BUTTON: {
      Ew(e, t)
      break
    }
    case d.APPLET:
    case d.OBJECT:
    case d.MARQUEE: {
      Sw(e, t)
      break
    }
    case d.IFRAME: {
      Rw(e, t)
      break
    }
    case d.SELECT: {
      Lw(e, t)
      break
    }
    case d.OPTION:
    case d.OPTGROUP: {
      Pw(e, t)
      break
    }
    case d.NOEMBED: {
      Xm(e, t)
      break
    }
    case d.FRAMESET: {
      mw(e, t)
      break
    }
    case d.TEXTAREA: {
      Iw(e, t)
      break
    }
    case d.NOSCRIPT: {
      e.options.scriptingEnabled ? Xm(e, t) : Ym(e, t)
      break
    }
    case d.PLAINTEXT: {
      vw(e, t)
      break
    }
    case d.COL:
    case d.TH:
    case d.TD:
    case d.TR:
    case d.HEAD:
    case d.FRAME:
    case d.TBODY:
    case d.TFOOT:
    case d.THEAD:
    case d.CAPTION:
    case d.COLGROUP:
      break
    default:
      Ym(e, t)
  }
}
function Hw(e, t) {
  if (
    e.openElements.hasInScope(d.BODY) &&
    ((e.insertionMode = G.AFTER_BODY), e.options.sourceCodeLocationInfo)
  ) {
    const r = e.openElements.tryPeekProperlyNestedBodyElement()
    r && e._setEndLocation(r, t)
  }
}
function zw(e, t) {
  e.openElements.hasInScope(d.BODY) && ((e.insertionMode = G.AFTER_BODY), Sb(e, t))
}
function jw(e, t) {
  const r = t.tagID
  e.openElements.hasInScope(r) &&
    (e.openElements.generateImpliedEndTags(), e.openElements.popUntilTagNamePopped(r))
}
function qw(e) {
  const t = e.openElements.tmplCount > 0,
    { formElement: r } = e
  t || (e.formElement = null),
    (r || t) &&
      e.openElements.hasInScope(d.FORM) &&
      (e.openElements.generateImpliedEndTags(),
      t ? e.openElements.popUntilTagNamePopped(d.FORM) : r && e.openElements.remove(r))
}
function $w(e) {
  e.openElements.hasInButtonScope(d.P) || e._insertFakeElement(Q.P, d.P), e._closePElement()
}
function Vw(e) {
  e.openElements.hasInListItemScope(d.LI) &&
    (e.openElements.generateImpliedEndTagsWithExclusion(d.LI),
    e.openElements.popUntilTagNamePopped(d.LI))
}
function Gw(e, t) {
  const r = t.tagID
  e.openElements.hasInScope(r) &&
    (e.openElements.generateImpliedEndTagsWithExclusion(r), e.openElements.popUntilTagNamePopped(r))
}
function Xw(e) {
  e.openElements.hasNumberedHeaderInScope() &&
    (e.openElements.generateImpliedEndTags(), e.openElements.popUntilNumberedHeaderPopped())
}
function Yw(e, t) {
  const r = t.tagID
  e.openElements.hasInScope(r) &&
    (e.openElements.generateImpliedEndTags(),
    e.openElements.popUntilTagNamePopped(r),
    e.activeFormattingElements.clearToLastMarker())
}
function Ww(e) {
  e._reconstructActiveFormattingElements(),
    e._insertFakeElement(Q.BR, d.BR),
    e.openElements.pop(),
    (e.framesetOk = !1)
}
function gb(e, t) {
  const r = t.tagName,
    i = t.tagID
  for (let n = e.openElements.stackTop; n > 0; n--) {
    const s = e.openElements.items[n],
      a = e.openElements.tagIDs[n]
    if (i === a && (i !== d.UNKNOWN || e.treeAdapter.getTagName(s) === r)) {
      e.openElements.generateImpliedEndTagsWithExclusion(i),
        e.openElements.stackTop >= n && e.openElements.shortenToLength(n)
      break
    }
    if (e._isSpecialElement(s, a)) break
  }
}
function mu(e, t) {
  switch (t.tagID) {
    case d.A:
    case d.B:
    case d.I:
    case d.S:
    case d.U:
    case d.EM:
    case d.TT:
    case d.BIG:
    case d.CODE:
    case d.FONT:
    case d.NOBR:
    case d.SMALL:
    case d.STRIKE:
    case d.STRONG: {
      gp(e, t)
      break
    }
    case d.P: {
      $w(e)
      break
    }
    case d.DL:
    case d.UL:
    case d.OL:
    case d.DIR:
    case d.DIV:
    case d.NAV:
    case d.PRE:
    case d.MAIN:
    case d.MENU:
    case d.ASIDE:
    case d.BUTTON:
    case d.CENTER:
    case d.FIGURE:
    case d.FOOTER:
    case d.HEADER:
    case d.HGROUP:
    case d.DIALOG:
    case d.ADDRESS:
    case d.ARTICLE:
    case d.DETAILS:
    case d.SECTION:
    case d.SUMMARY:
    case d.LISTING:
    case d.FIELDSET:
    case d.BLOCKQUOTE:
    case d.FIGCAPTION: {
      jw(e, t)
      break
    }
    case d.LI: {
      Vw(e)
      break
    }
    case d.DD:
    case d.DT: {
      Gw(e, t)
      break
    }
    case d.H1:
    case d.H2:
    case d.H3:
    case d.H4:
    case d.H5:
    case d.H6: {
      Xw(e)
      break
    }
    case d.BR: {
      Ww(e)
      break
    }
    case d.BODY: {
      Hw(e, t)
      break
    }
    case d.HTML: {
      zw(e, t)
      break
    }
    case d.FORM: {
      qw(e)
      break
    }
    case d.APPLET:
    case d.OBJECT:
    case d.MARQUEE: {
      Yw(e, t)
      break
    }
    case d.TEMPLATE: {
      qi(e, t)
      break
    }
    default:
      gb(e, t)
  }
}
function bb(e, t) {
  e.tmplInsertionModeStack.length > 0 ? Ab(e, t) : bp(e, t)
}
function Qw(e, t) {
  var r
  t.tagID === d.SCRIPT &&
    ((r = e.scriptHandler) === null || r === void 0 || r.call(e, e.openElements.current)),
    e.openElements.pop(),
    (e.insertionMode = e.originalInsertionMode)
}
function Kw(e, t) {
  e._err(t, J.eofInElementThatCanContainOnlyText),
    e.openElements.pop(),
    (e.insertionMode = e.originalInsertionMode),
    e.onEof(t)
}
function vl(e, t) {
  if (fb.has(e.openElements.currentTagId))
    switch (
      ((e.pendingCharacterTokens.length = 0),
      (e.hasNonWhitespacePendingCharacterToken = !1),
      (e.originalInsertionMode = e.insertionMode),
      (e.insertionMode = G.IN_TABLE_TEXT),
      t.type)
    ) {
      case ke.CHARACTER: {
        _b(e, t)
        break
      }
      case ke.WHITESPACE_CHARACTER: {
        yb(e, t)
        break
      }
    }
  else ca(e, t)
}
function Jw(e, t) {
  e.openElements.clearBackToTableContext(),
    e.activeFormattingElements.insertMarker(),
    e._insertElement(t, ee.HTML),
    (e.insertionMode = G.IN_CAPTION)
}
function Zw(e, t) {
  e.openElements.clearBackToTableContext(),
    e._insertElement(t, ee.HTML),
    (e.insertionMode = G.IN_COLUMN_GROUP)
}
function eN(e, t) {
  e.openElements.clearBackToTableContext(),
    e._insertFakeElement(Q.COLGROUP, d.COLGROUP),
    (e.insertionMode = G.IN_COLUMN_GROUP),
    yp(e, t)
}
function tN(e, t) {
  e.openElements.clearBackToTableContext(),
    e._insertElement(t, ee.HTML),
    (e.insertionMode = G.IN_TABLE_BODY)
}
function rN(e, t) {
  e.openElements.clearBackToTableContext(),
    e._insertFakeElement(Q.TBODY, d.TBODY),
    (e.insertionMode = G.IN_TABLE_BODY),
    du(e, t)
}
function iN(e, t) {
  e.openElements.hasInTableScope(d.TABLE) &&
    (e.openElements.popUntilTagNamePopped(d.TABLE), e._resetInsertionMode(), e._processStartTag(t))
}
function nN(e, t) {
  db(t) ? e._appendElement(t, ee.HTML) : ca(e, t), (t.ackSelfClosing = !0)
}
function sN(e, t) {
  !e.formElement &&
    e.openElements.tmplCount === 0 &&
    (e._insertElement(t, ee.HTML), (e.formElement = e.openElements.current), e.openElements.pop())
}
function In(e, t) {
  switch (t.tagID) {
    case d.TD:
    case d.TH:
    case d.TR: {
      rN(e, t)
      break
    }
    case d.STYLE:
    case d.SCRIPT:
    case d.TEMPLATE: {
      or(e, t)
      break
    }
    case d.COL: {
      eN(e, t)
      break
    }
    case d.FORM: {
      sN(e, t)
      break
    }
    case d.TABLE: {
      iN(e, t)
      break
    }
    case d.TBODY:
    case d.TFOOT:
    case d.THEAD: {
      tN(e, t)
      break
    }
    case d.INPUT: {
      nN(e, t)
      break
    }
    case d.CAPTION: {
      Jw(e, t)
      break
    }
    case d.COLGROUP: {
      Zw(e, t)
      break
    }
    default:
      ca(e, t)
  }
}
function js(e, t) {
  switch (t.tagID) {
    case d.TABLE: {
      e.openElements.hasInTableScope(d.TABLE) &&
        (e.openElements.popUntilTagNamePopped(d.TABLE), e._resetInsertionMode())
      break
    }
    case d.TEMPLATE: {
      qi(e, t)
      break
    }
    case d.BODY:
    case d.CAPTION:
    case d.COL:
    case d.COLGROUP:
    case d.HTML:
    case d.TBODY:
    case d.TD:
    case d.TFOOT:
    case d.TH:
    case d.THEAD:
    case d.TR:
      break
    default:
      ca(e, t)
  }
}
function ca(e, t) {
  const r = e.fosterParentingEnabled
  ;(e.fosterParentingEnabled = !0), hu(e, t), (e.fosterParentingEnabled = r)
}
function yb(e, t) {
  e.pendingCharacterTokens.push(t)
}
function _b(e, t) {
  e.pendingCharacterTokens.push(t), (e.hasNonWhitespacePendingCharacterToken = !0)
}
function Kn(e, t) {
  let r = 0
  if (e.hasNonWhitespacePendingCharacterToken)
    for (; r < e.pendingCharacterTokens.length; r++) ca(e, e.pendingCharacterTokens[r])
  else
    for (; r < e.pendingCharacterTokens.length; r++)
      e._insertCharacters(e.pendingCharacterTokens[r])
  ;(e.insertionMode = e.originalInsertionMode), e._processToken(t)
}
const vb = new Set([d.CAPTION, d.COL, d.COLGROUP, d.TBODY, d.TD, d.TFOOT, d.TH, d.THEAD, d.TR])
function aN(e, t) {
  const r = t.tagID
  vb.has(r)
    ? e.openElements.hasInTableScope(d.CAPTION) &&
      (e.openElements.generateImpliedEndTags(),
      e.openElements.popUntilTagNamePopped(d.CAPTION),
      e.activeFormattingElements.clearToLastMarker(),
      (e.insertionMode = G.IN_TABLE),
      In(e, t))
    : dt(e, t)
}
function oN(e, t) {
  const r = t.tagID
  switch (r) {
    case d.CAPTION:
    case d.TABLE: {
      e.openElements.hasInTableScope(d.CAPTION) &&
        (e.openElements.generateImpliedEndTags(),
        e.openElements.popUntilTagNamePopped(d.CAPTION),
        e.activeFormattingElements.clearToLastMarker(),
        (e.insertionMode = G.IN_TABLE),
        r === d.TABLE && js(e, t))
      break
    }
    case d.BODY:
    case d.COL:
    case d.COLGROUP:
    case d.HTML:
    case d.TBODY:
    case d.TD:
    case d.TFOOT:
    case d.TH:
    case d.THEAD:
    case d.TR:
      break
    default:
      mu(e, t)
  }
}
function yp(e, t) {
  switch (t.tagID) {
    case d.HTML: {
      dt(e, t)
      break
    }
    case d.COL: {
      e._appendElement(t, ee.HTML), (t.ackSelfClosing = !0)
      break
    }
    case d.TEMPLATE: {
      or(e, t)
      break
    }
    default:
      Uo(e, t)
  }
}
function uN(e, t) {
  switch (t.tagID) {
    case d.COLGROUP: {
      e.openElements.currentTagId === d.COLGROUP &&
        (e.openElements.pop(), (e.insertionMode = G.IN_TABLE))
      break
    }
    case d.TEMPLATE: {
      qi(e, t)
      break
    }
    case d.COL:
      break
    default:
      Uo(e, t)
  }
}
function Uo(e, t) {
  e.openElements.currentTagId === d.COLGROUP &&
    (e.openElements.pop(), (e.insertionMode = G.IN_TABLE), e._processToken(t))
}
function du(e, t) {
  switch (t.tagID) {
    case d.TR: {
      e.openElements.clearBackToTableBodyContext(),
        e._insertElement(t, ee.HTML),
        (e.insertionMode = G.IN_ROW)
      break
    }
    case d.TH:
    case d.TD: {
      e.openElements.clearBackToTableBodyContext(),
        e._insertFakeElement(Q.TR, d.TR),
        (e.insertionMode = G.IN_ROW),
        gu(e, t)
      break
    }
    case d.CAPTION:
    case d.COL:
    case d.COLGROUP:
    case d.TBODY:
    case d.TFOOT:
    case d.THEAD: {
      e.openElements.hasTableBodyContextInTableScope() &&
        (e.openElements.clearBackToTableBodyContext(),
        e.openElements.pop(),
        (e.insertionMode = G.IN_TABLE),
        In(e, t))
      break
    }
    default:
      In(e, t)
  }
}
function Mc(e, t) {
  const r = t.tagID
  switch (t.tagID) {
    case d.TBODY:
    case d.TFOOT:
    case d.THEAD: {
      e.openElements.hasInTableScope(r) &&
        (e.openElements.clearBackToTableBodyContext(),
        e.openElements.pop(),
        (e.insertionMode = G.IN_TABLE))
      break
    }
    case d.TABLE: {
      e.openElements.hasTableBodyContextInTableScope() &&
        (e.openElements.clearBackToTableBodyContext(),
        e.openElements.pop(),
        (e.insertionMode = G.IN_TABLE),
        js(e, t))
      break
    }
    case d.BODY:
    case d.CAPTION:
    case d.COL:
    case d.COLGROUP:
    case d.HTML:
    case d.TD:
    case d.TH:
    case d.TR:
      break
    default:
      js(e, t)
  }
}
function gu(e, t) {
  switch (t.tagID) {
    case d.TH:
    case d.TD: {
      e.openElements.clearBackToTableRowContext(),
        e._insertElement(t, ee.HTML),
        (e.insertionMode = G.IN_CELL),
        e.activeFormattingElements.insertMarker()
      break
    }
    case d.CAPTION:
    case d.COL:
    case d.COLGROUP:
    case d.TBODY:
    case d.TFOOT:
    case d.THEAD:
    case d.TR: {
      e.openElements.hasInTableScope(d.TR) &&
        (e.openElements.clearBackToTableRowContext(),
        e.openElements.pop(),
        (e.insertionMode = G.IN_TABLE_BODY),
        du(e, t))
      break
    }
    default:
      In(e, t)
  }
}
function Eb(e, t) {
  switch (t.tagID) {
    case d.TR: {
      e.openElements.hasInTableScope(d.TR) &&
        (e.openElements.clearBackToTableRowContext(),
        e.openElements.pop(),
        (e.insertionMode = G.IN_TABLE_BODY))
      break
    }
    case d.TABLE: {
      e.openElements.hasInTableScope(d.TR) &&
        (e.openElements.clearBackToTableRowContext(),
        e.openElements.pop(),
        (e.insertionMode = G.IN_TABLE_BODY),
        Mc(e, t))
      break
    }
    case d.TBODY:
    case d.TFOOT:
    case d.THEAD: {
      ;(e.openElements.hasInTableScope(t.tagID) || e.openElements.hasInTableScope(d.TR)) &&
        (e.openElements.clearBackToTableRowContext(),
        e.openElements.pop(),
        (e.insertionMode = G.IN_TABLE_BODY),
        Mc(e, t))
      break
    }
    case d.BODY:
    case d.CAPTION:
    case d.COL:
    case d.COLGROUP:
    case d.HTML:
    case d.TD:
    case d.TH:
      break
    default:
      js(e, t)
  }
}
function lN(e, t) {
  const r = t.tagID
  vb.has(r)
    ? (e.openElements.hasInTableScope(d.TD) || e.openElements.hasInTableScope(d.TH)) &&
      (e._closeTableCell(), gu(e, t))
    : dt(e, t)
}
function cN(e, t) {
  const r = t.tagID
  switch (r) {
    case d.TD:
    case d.TH: {
      e.openElements.hasInTableScope(r) &&
        (e.openElements.generateImpliedEndTags(),
        e.openElements.popUntilTagNamePopped(r),
        e.activeFormattingElements.clearToLastMarker(),
        (e.insertionMode = G.IN_ROW))
      break
    }
    case d.TABLE:
    case d.TBODY:
    case d.TFOOT:
    case d.THEAD:
    case d.TR: {
      e.openElements.hasInTableScope(r) && (e._closeTableCell(), Eb(e, t))
      break
    }
    case d.BODY:
    case d.CAPTION:
    case d.COL:
    case d.COLGROUP:
    case d.HTML:
      break
    default:
      mu(e, t)
  }
}
function xb(e, t) {
  switch (t.tagID) {
    case d.HTML: {
      dt(e, t)
      break
    }
    case d.OPTION: {
      e.openElements.currentTagId === d.OPTION && e.openElements.pop(), e._insertElement(t, ee.HTML)
      break
    }
    case d.OPTGROUP: {
      e.openElements.currentTagId === d.OPTION && e.openElements.pop(),
        e.openElements.currentTagId === d.OPTGROUP && e.openElements.pop(),
        e._insertElement(t, ee.HTML)
      break
    }
    case d.INPUT:
    case d.KEYGEN:
    case d.TEXTAREA:
    case d.SELECT: {
      e.openElements.hasInSelectScope(d.SELECT) &&
        (e.openElements.popUntilTagNamePopped(d.SELECT),
        e._resetInsertionMode(),
        t.tagID !== d.SELECT && e._processStartTag(t))
      break
    }
    case d.SCRIPT:
    case d.TEMPLATE: {
      or(e, t)
      break
    }
  }
}
function Tb(e, t) {
  switch (t.tagID) {
    case d.OPTGROUP: {
      e.openElements.stackTop > 0 &&
        e.openElements.currentTagId === d.OPTION &&
        e.openElements.tagIDs[e.openElements.stackTop - 1] === d.OPTGROUP &&
        e.openElements.pop(),
        e.openElements.currentTagId === d.OPTGROUP && e.openElements.pop()
      break
    }
    case d.OPTION: {
      e.openElements.currentTagId === d.OPTION && e.openElements.pop()
      break
    }
    case d.SELECT: {
      e.openElements.hasInSelectScope(d.SELECT) &&
        (e.openElements.popUntilTagNamePopped(d.SELECT), e._resetInsertionMode())
      break
    }
    case d.TEMPLATE: {
      qi(e, t)
      break
    }
  }
}
function fN(e, t) {
  const r = t.tagID
  r === d.CAPTION ||
  r === d.TABLE ||
  r === d.TBODY ||
  r === d.TFOOT ||
  r === d.THEAD ||
  r === d.TR ||
  r === d.TD ||
  r === d.TH
    ? (e.openElements.popUntilTagNamePopped(d.SELECT),
      e._resetInsertionMode(),
      e._processStartTag(t))
    : xb(e, t)
}
function pN(e, t) {
  const r = t.tagID
  r === d.CAPTION ||
  r === d.TABLE ||
  r === d.TBODY ||
  r === d.TFOOT ||
  r === d.THEAD ||
  r === d.TR ||
  r === d.TD ||
  r === d.TH
    ? e.openElements.hasInTableScope(r) &&
      (e.openElements.popUntilTagNamePopped(d.SELECT), e._resetInsertionMode(), e.onEndTag(t))
    : Tb(e, t)
}
function hN(e, t) {
  switch (t.tagID) {
    case d.BASE:
    case d.BASEFONT:
    case d.BGSOUND:
    case d.LINK:
    case d.META:
    case d.NOFRAMES:
    case d.SCRIPT:
    case d.STYLE:
    case d.TEMPLATE:
    case d.TITLE: {
      or(e, t)
      break
    }
    case d.CAPTION:
    case d.COLGROUP:
    case d.TBODY:
    case d.TFOOT:
    case d.THEAD: {
      ;(e.tmplInsertionModeStack[0] = G.IN_TABLE), (e.insertionMode = G.IN_TABLE), In(e, t)
      break
    }
    case d.COL: {
      ;(e.tmplInsertionModeStack[0] = G.IN_COLUMN_GROUP),
        (e.insertionMode = G.IN_COLUMN_GROUP),
        yp(e, t)
      break
    }
    case d.TR: {
      ;(e.tmplInsertionModeStack[0] = G.IN_TABLE_BODY),
        (e.insertionMode = G.IN_TABLE_BODY),
        du(e, t)
      break
    }
    case d.TD:
    case d.TH: {
      ;(e.tmplInsertionModeStack[0] = G.IN_ROW), (e.insertionMode = G.IN_ROW), gu(e, t)
      break
    }
    default:
      ;(e.tmplInsertionModeStack[0] = G.IN_BODY), (e.insertionMode = G.IN_BODY), dt(e, t)
  }
}
function mN(e, t) {
  t.tagID === d.TEMPLATE && qi(e, t)
}
function Ab(e, t) {
  e.openElements.tmplCount > 0
    ? (e.openElements.popUntilTagNamePopped(d.TEMPLATE),
      e.activeFormattingElements.clearToLastMarker(),
      e.tmplInsertionModeStack.shift(),
      e._resetInsertionMode(),
      e.onEof(t))
    : bp(e, t)
}
function dN(e, t) {
  t.tagID === d.HTML ? dt(e, t) : Ho(e, t)
}
function Sb(e, t) {
  var r
  if (t.tagID === d.HTML) {
    if (
      (e.fragmentContext || (e.insertionMode = G.AFTER_AFTER_BODY),
      e.options.sourceCodeLocationInfo && e.openElements.tagIDs[0] === d.HTML)
    ) {
      e._setEndLocation(e.openElements.items[0], t)
      const i = e.openElements.items[1]
      i &&
        !(
          !((r = e.treeAdapter.getNodeSourceCodeLocation(i)) === null || r === void 0) && r.endTag
        ) &&
        e._setEndLocation(i, t)
    }
  } else Ho(e, t)
}
function Ho(e, t) {
  ;(e.insertionMode = G.IN_BODY), hu(e, t)
}
function gN(e, t) {
  switch (t.tagID) {
    case d.HTML: {
      dt(e, t)
      break
    }
    case d.FRAMESET: {
      e._insertElement(t, ee.HTML)
      break
    }
    case d.FRAME: {
      e._appendElement(t, ee.HTML), (t.ackSelfClosing = !0)
      break
    }
    case d.NOFRAMES: {
      or(e, t)
      break
    }
  }
}
function bN(e, t) {
  t.tagID === d.FRAMESET &&
    !e.openElements.isRootHtmlElementCurrent() &&
    (e.openElements.pop(),
    !e.fragmentContext &&
      e.openElements.currentTagId !== d.FRAMESET &&
      (e.insertionMode = G.AFTER_FRAMESET))
}
function yN(e, t) {
  switch (t.tagID) {
    case d.HTML: {
      dt(e, t)
      break
    }
    case d.NOFRAMES: {
      or(e, t)
      break
    }
  }
}
function _N(e, t) {
  t.tagID === d.HTML && (e.insertionMode = G.AFTER_AFTER_FRAMESET)
}
function vN(e, t) {
  t.tagID === d.HTML ? dt(e, t) : io(e, t)
}
function io(e, t) {
  ;(e.insertionMode = G.IN_BODY), hu(e, t)
}
function EN(e, t) {
  switch (t.tagID) {
    case d.HTML: {
      dt(e, t)
      break
    }
    case d.NOFRAMES: {
      or(e, t)
      break
    }
  }
}
function xN(e, t) {
  ;(t.chars = je), e._insertCharacters(t)
}
function TN(e, t) {
  e._insertCharacters(t), (e.framesetOk = !1)
}
function Cb(e) {
  for (
    ;
    e.treeAdapter.getNamespaceURI(e.openElements.current) !== ee.HTML &&
    !e._isIntegrationPoint(e.openElements.currentTagId, e.openElements.current);

  )
    e.openElements.pop()
}
function AN(e, t) {
  if (Mk(t)) Cb(e), e._startTagOutsideForeignContent(t)
  else {
    const r = e._getAdjustedCurrentElement(),
      i = e.treeAdapter.getNamespaceURI(r)
    i === ee.MATHML ? lb(t) : i === ee.SVG && (Uk(t), cb(t)),
      dp(t),
      t.selfClosing ? e._appendElement(t, i) : e._insertElement(t, i),
      (t.ackSelfClosing = !0)
  }
}
function SN(e, t) {
  if (t.tagID === d.P || t.tagID === d.BR) {
    Cb(e), e._endTagOutsideForeignContent(t)
    return
  }
  for (let r = e.openElements.stackTop; r > 0; r--) {
    const i = e.openElements.items[r]
    if (e.treeAdapter.getNamespaceURI(i) === ee.HTML) {
      e._endTagOutsideForeignContent(t)
      break
    }
    const n = e.treeAdapter.getTagName(i)
    if (n.toLowerCase() === t.tagName) {
      ;(t.tagName = n), e.openElements.shortenToLength(r)
      break
    }
  }
}
Q.AREA,
  Q.BASE,
  Q.BASEFONT,
  Q.BGSOUND,
  Q.BR,
  Q.COL,
  Q.EMBED,
  Q.FRAME,
  Q.HR,
  Q.IMG,
  Q.INPUT,
  Q.KEYGEN,
  Q.LINK,
  Q.META,
  Q.PARAM,
  Q.SOURCE,
  Q.TRACK,
  Q.WBR
function CN(e, t, r) {
  typeof e == 'string' && ((r = t), (t = e), (e = null))
  const i = Xk.getFragmentParser(e, r)
  return i.tokenizer.write(t, !0), i.getFragment()
}
const Wm = /[#.]/g
function kN(e, t) {
  const r = e || '',
    i = {}
  let n = 0,
    s,
    a
  for (; n < r.length; ) {
    Wm.lastIndex = n
    const o = Wm.exec(r),
      u = r.slice(n, o ? o.index : r.length)
    u &&
      (s
        ? s === '#'
          ? (i.id = u)
          : Array.isArray(i.className)
          ? i.className.push(u)
          : (i.className = [u])
        : (a = u),
      (n += u.length)),
      o && ((s = o[0]), n++)
  }
  return { type: 'element', tagName: a || t || 'div', properties: i, children: [] }
}
const wN = new Set(['button', 'menu', 'reset', 'submit']),
  Uc = {}.hasOwnProperty
function kb(e, t, r) {
  const i = r && DN(r)
  function n(s, a, ...o) {
    let u = -1,
      c
    if (s == null) {
      c = { type: 'root', children: [] }
      const f = a
      o.unshift(f)
    } else if (
      ((c = kN(s, t)),
      (c.tagName = c.tagName.toLowerCase()),
      i && Uc.call(i, c.tagName) && (c.tagName = i[c.tagName]),
      NN(a, c.tagName))
    ) {
      let f
      for (f in a) Uc.call(a, f) && ON(e, c.properties, f, a[f])
    } else o.unshift(a)
    for (; ++u < o.length; ) Hc(c.children, o[u])
    return (
      c.type === 'element' &&
        c.tagName === 'template' &&
        ((c.content = { type: 'root', children: c.children }), (c.children = [])),
      c
    )
  }
  return n
}
function NN(e, t) {
  return e == null || typeof e != 'object' || Array.isArray(e)
    ? !1
    : t === 'input' || !e.type || typeof e.type != 'string'
    ? !0
    : 'children' in e && Array.isArray(e.children)
    ? !1
    : t === 'button'
    ? wN.has(e.type.toLowerCase())
    : !('value' in e)
}
function ON(e, t, r, i) {
  const n = fp(e, r)
  let s = -1,
    a
  if (i != null) {
    if (typeof i == 'number') {
      if (Number.isNaN(i)) return
      a = i
    } else
      typeof i == 'boolean'
        ? (a = i)
        : typeof i == 'string'
        ? n.spaceSeparated
          ? (a = Dm(i))
          : n.commaSeparated
          ? (a = Im(i))
          : n.commaOrSpaceSeparated
          ? (a = Dm(Im(i).join(' ')))
          : (a = Qm(n, n.property, i))
        : Array.isArray(i)
        ? (a = i.concat())
        : (a = n.property === 'style' ? IN(i) : String(i))
    if (Array.isArray(a)) {
      const o = []
      for (; ++s < a.length; ) {
        const u = Qm(n, n.property, a[s])
        o[s] = u
      }
      a = o
    }
    if (n.property === 'className' && Array.isArray(t.className)) {
      const o = a
      a = t.className.concat(o)
    }
    t[n.property] = a
  }
}
function Hc(e, t) {
  let r = -1
  if (t != null)
    if (typeof t == 'string' || typeof t == 'number') e.push({ type: 'text', value: String(t) })
    else if (Array.isArray(t)) for (; ++r < t.length; ) Hc(e, t[r])
    else if (typeof t == 'object' && 'type' in t) t.type === 'root' ? Hc(e, t.children) : e.push(t)
    else throw new Error('Expected node, nodes, or string, got `' + t + '`')
}
function Qm(e, t, r) {
  if (typeof r == 'string') {
    if (e.number && r && !Number.isNaN(Number(r))) return Number(r)
    if ((e.boolean || e.overloadedBoolean) && (r === '' || zs(r) === zs(t))) return !0
  }
  return r
}
function IN(e) {
  const t = []
  let r
  for (r in e) Uc.call(e, r) && t.push([r, e[r]].join(': '))
  return t.join('; ')
}
function DN(e) {
  const t = {}
  let r = -1
  for (; ++r < e.length; ) t[e[r].toLowerCase()] = e[r]
  return t
}
const RN = [
    'altGlyph',
    'altGlyphDef',
    'altGlyphItem',
    'animateColor',
    'animateMotion',
    'animateTransform',
    'clipPath',
    'feBlend',
    'feColorMatrix',
    'feComponentTransfer',
    'feComposite',
    'feConvolveMatrix',
    'feDiffuseLighting',
    'feDisplacementMap',
    'feDistantLight',
    'feDropShadow',
    'feFlood',
    'feFuncA',
    'feFuncB',
    'feFuncG',
    'feFuncR',
    'feGaussianBlur',
    'feImage',
    'feMerge',
    'feMergeNode',
    'feMorphology',
    'feOffset',
    'fePointLight',
    'feSpecularLighting',
    'feSpotLight',
    'feTile',
    'feTurbulence',
    'foreignObject',
    'glyphRef',
    'linearGradient',
    'radialGradient',
    'solidColor',
    'textArea',
    'textPath',
  ],
  LN = kb(cu, 'div'),
  PN = kb(oa, 'g', RN),
  El = /\r?\n|\r/g
function BN(e) {
  const t = String(e),
    r = []
  for (El.lastIndex = 0; El.test(t); ) r.push(El.lastIndex)
  return r.push(t.length + 1), { toPoint: i, toOffset: n }
  function i(s) {
    let a = -1
    if (typeof s == 'number' && s > -1 && s < r[r.length - 1]) {
      for (; ++a < r.length; )
        if (r[a] > s) return { line: a + 1, column: s - (a > 0 ? r[a - 1] : 0) + 1, offset: s }
    }
  }
  function n(s) {
    const a = s && s.line,
      o = s && s.column
    if (
      typeof a == 'number' &&
      typeof o == 'number' &&
      !Number.isNaN(a) &&
      !Number.isNaN(o) &&
      a - 1 in r
    ) {
      const u = (r[a - 2] || 0) + o - 1 || 0
      if (u > -1 && u < r[r.length - 1]) return u
    }
  }
}
const FN = {
    html: 'http://www.w3.org/1999/xhtml',
    mathml: 'http://www.w3.org/1998/Math/MathML',
    svg: 'http://www.w3.org/2000/svg',
    xlink: 'http://www.w3.org/1999/xlink',
    xml: 'http://www.w3.org/XML/1998/namespace',
    xmlns: 'http://www.w3.org/2000/xmlns/',
  },
  wb = {}.hasOwnProperty,
  MN = Object.prototype
function UN(e, t) {
  const r = t || {}
  return _p(
    {
      file: r.file || void 0,
      location: !1,
      schema: r.space === 'svg' ? oa : cu,
      verbose: r.verbose || !1,
    },
    e
  )
}
function _p(e, t) {
  let r
  switch (t.nodeName) {
    case '#comment': {
      const i = t
      return (r = { type: 'comment', value: i.data }), no(e, i, r), r
    }
    case '#document':
    case '#document-fragment': {
      const i = t,
        n = 'mode' in i ? i.mode === 'quirks' || i.mode === 'limited-quirks' : !1
      if (
        ((r = { type: 'root', children: Nb(e, t.childNodes), data: { quirksMode: n } }),
        e.file && e.location)
      ) {
        const s = String(e.file),
          a = BN(s),
          o = a.toPoint(0),
          u = a.toPoint(s.length)
        r.position = { start: o, end: u }
      }
      return r
    }
    case '#documentType': {
      const i = t
      return (r = { type: 'doctype' }), no(e, i, r), r
    }
    case '#text': {
      const i = t
      return (r = { type: 'text', value: i.value }), no(e, i, r), r
    }
    default:
      return (r = HN(e, t)), r
  }
}
function Nb(e, t) {
  let r = -1
  const i = []
  for (; ++r < t.length; ) {
    const n = _p(e, t[r])
    i.push(n)
  }
  return i
}
function HN(e, t) {
  const r = e.schema
  e.schema = t.namespaceURI === FN.svg ? oa : cu
  let i = -1
  const n = {}
  for (; ++i < t.attrs.length; ) {
    const o = t.attrs[i],
      u = (o.prefix ? o.prefix + ':' : '') + o.name
    wb.call(MN, u) || (n[u] = o.value)
  }
  const a = (e.schema.space === 'svg' ? PN : LN)(t.tagName, n, Nb(e, t.childNodes))
  if ((no(e, t, a), a.tagName === 'template')) {
    const o = t,
      u = o.sourceCodeLocation,
      c = u && u.startTag && pn(u.startTag),
      f = u && u.endTag && pn(u.endTag),
      h = _p(e, o.content)
    c && f && e.file && (h.position = { start: c.end, end: f.start }), (a.content = h)
  }
  return (e.schema = r), a
}
function no(e, t, r) {
  if ('sourceCodeLocation' in t && t.sourceCodeLocation && e.file) {
    const i = zN(e, r, t.sourceCodeLocation)
    i && ((e.location = !0), (r.position = i))
  }
}
function zN(e, t, r) {
  const i = pn(r)
  if (t.type === 'element') {
    const n = t.children[t.children.length - 1]
    if (
      (i &&
        !r.endTag &&
        n &&
        n.position &&
        n.position.end &&
        (i.end = Object.assign({}, n.position.end)),
      e.verbose)
    ) {
      const s = {}
      let a
      if (r.attrs)
        for (a in r.attrs) wb.call(r.attrs, a) && (s[fp(e.schema, a).property] = pn(r.attrs[a]))
      r.startTag
      const o = pn(r.startTag),
        u = r.endTag ? pn(r.endTag) : void 0,
        c = { opening: o }
      u && (c.closing = u), (c.properties = s), (t.data = { position: c })
    }
  }
  return i
}
function pn(e) {
  const t = Km({ line: e.startLine, column: e.startCol, offset: e.startOffset }),
    r = Km({ line: e.endLine, column: e.endCol, offset: e.endOffset })
  return t || r ? { start: t, end: r } : void 0
}
function Km(e) {
  return e.line && e.column ? e : void 0
}
const vi = (e) => {
    const t = CN(e)
    return UN(t).children[0]
  },
  jN = (e, t, r, i, n, s, a, o, u) => {
    const { inlineClass: c, linkCitations: f } = a,
      h = `${i}-${n}`,
      m = e
        .processCitationCluster(
          {
            citationID: h,
            citationItems: r,
            properties:
              t === 'in-text'
                ? { noteIndex: 0, mode: o ? 'composite' : '' }
                : { noteIndex: n, mode: o ? 'composite' : '' },
          },
          s.length > 0 ? s : [],
          []
        )[1]
        .find((b) => b[2] === h)[1],
      v = `citation--${r.map((b) => b.id.toLowerCase()).join('--')}--${n}`
    if (t === 'note')
      return [
        m,
        vi(
          `<span class="${(c ?? []).join(
            ' '
          )}" id=${v}><sup><a href="#cite-fn-${n}" id="cite-fnref-${n}" data-footnote-ref aria-describedby="footnote-label">${n}</a></sup></span>`
        ),
      ]
    if (f && u === 'numeric') {
      let b = 0
      const S = r.map((_) => _.id),
        g = m.replace(/\d+/g, function (_) {
          const y = `<a href="#bib-${S[b].toLowerCase()}">${_}</a>`
          return b++, y
        })
      return [m, vi(`<span class="${(c ?? []).join(' ')}" id=${v}>${g}</span>`)]
    } else if (f && u === 'author-date')
      if (r.length === 1) {
        const b = o
          ? `<a href="#bib-${r[0].id.toLowerCase()}">${m}</a>`
          : `${m.slice(0, 1)}<a href="#bib-${r[0].id.toLowerCase()}">${m.slice(1, -1)}</a>${m.slice(
              -1
            )}`
        return [m, vi(`<span class="${(c ?? []).join(' ')}" id=${v}>${b}</span>`)]
      } else {
        const b = r.map((y) => y.id),
          S = YC(e, b, e.opt.sort_citations),
          g = []
        let _ = m
        for (const [y, x] of S.entries()) {
          const D = x.id
          let C = x.ambig
          y > 0 && QC(S[y - 1], x) && _.indexOf(C) === -1 && (C = x.ref.issued.year.toString())
          const H = _.indexOf(C),
            [T, k] = WC(_, H)
          g.push(T)
          const O = `<a href="#bib-${D.toLowerCase()}">${k.substring(0, C.length)}</a>`
          g.push(O), (_ = k.substr(C.length))
        }
        return (
          g.push(_), [m, vi(`<span class="${(c ?? []).join(' ')}" id=${v}>${g.join('')}</span>`)]
        )
      }
    else return [m, vi(`<span class="${(c ?? []).join(' ')}" id=${v}>${m}</span>`)]
  },
  qN = (e) => {
    const [t, r] = e.makeBibliography(),
      i =
        `<div id="refs" class="references csl-bib-body">
` +
        r.join('') +
        '</div>',
      n = vi(i)
    return (
      n.children
        .filter((s) => {
          var a, o
          return (o = (a = s.properties) == null ? void 0 : a.className) == null
            ? void 0
            : o.includes('csl-entry')
        })
        .forEach((s, a) => {
          const o = t.entry_ids[a][0].toLowerCase()
          ;(s.properties = s.properties || {}), (s.properties.id = 'bib-' + o)
        }),
      n
    )
  },
  $N = (e, t, r) => {
    const i = {
      type: 'element',
      tagName: 'ol',
      properties: {},
      children: [
        {
          type: 'text',
          value: `
`,
        },
      ],
    }
    let n
    r && (n = r.children.filter((a) => a.type == 'element').find((a) => a.tagName === 'ol'))
    for (const [a, o] of t.entries()) {
      const { type: u, oldId: c } = o
      if (u === 'citation')
        i.children.push({
          type: 'element',
          tagName: 'li',
          properties: { id: `user-content-fn-${a + 1}` },
          children: [
            {
              type: 'element',
              tagName: 'p',
              properties: {},
              children: [
                vi(`<span>${e[c]}</span>`),
                {
                  type: 'element',
                  tagName: 'a',
                  properties: {
                    href: `#user-content-fnref-${a + 1}`,
                    dataFootnoteBackref: !0,
                    className: ['data-footnote-backref'],
                    ariaLabel: 'Back to content',
                  },
                  children: [{ type: 'text', value: '' }],
                },
              ],
            },
            {
              type: 'text',
              value: `
`,
            },
          ],
        })
      else if (u === 'existing') {
        const f = n.children.find(
          (p) => p.tagName === 'li' && p.properties.id === `user-content-fn-${c}`
        )
        f.properties.id = `user-content-fn-${a + 1}`
        const h = f.children[1].children.find((p) => p.tagName === 'a')
        ;(h.properties.href = `#user-content-fnref-${a + 1}`), i.children.push(f)
      }
    }
    return {
      type: 'element',
      tagName: 'section',
      properties: { dataFootnotes: !0, className: ['footnotes'] },
      children: [
        {
          type: 'element',
          tagName: 'h2',
          properties: { className: ['sr-only'], id: 'footnote-label' },
          children: [{ type: 'text', value: 'Footnotes' }],
        },
        {
          type: 'text',
          value: `
`,
        },
        i,
      ],
    }
  },
  VN = 'apa',
  GN = ['div', 'p', 'span', 'li', 'td', 'th'],
  Jm = 'CITATION',
  XN =
    (e) =>
    (t = {}) =>
    async (r, i) => {
      var x, D, C
      let n = await $C(t, i)
      if (!n) return
      let s
      const a =
          t.csl ||
          ((D = (x = i == null ? void 0 : i.data) == null ? void 0 : x.frontmatter) == null
            ? void 0
            : D.csl) ||
          VN,
        o = t.lang || 'en-US',
        u = e.plugins.config.get('@csl'),
        c = await VC(e, a, t.path),
        f = await GC(e, o, t.path)
      if (la(n)) s = await (await Y1(n)).text()
      else if (ua) s = await mp(n)
      else throw new Error('Cannot read non valid bibliography URL in node env.')
      const h = new e(s),
        p = h.data.map((H) => H.id),
        m = [],
        v = {}
      let b = 1
      const S = u.engine(h.data, c, f, 'html'),
        g = S.opt.xclass,
        _ = XC(S)
      if (
        (fn(r, 'text', (H, T, k) => {
          const O = H.value.match(UC)
          if (!O || ('tagName' in k && !GN.includes(k.tagName))) return
          let N = O.index,
            M = O.index + O[0].length
          O[2] !== void 0 && N--
          const V = []
          N !== 0 && V.push({ type: 'text', value: H.value.slice(0, N) })
          const [j, R] = zC(O)
          for (const P of j) if (!p.includes(P.id)) return
          const [$, L] = jN(S, g, j, Jm, b, m, t, R, _)
          ;(v[b] = $),
            m.push([`${Jm}-${b}`, 0]),
            (b = b + 1),
            V.push(L),
            M < H.value.length && V.push({ type: 'text', value: H.value.slice(M) }),
            (k.children = [...k.children.slice(0, T), ...V, ...k.children.slice(T + 1)])
        }),
        t.noCite && S.updateItems(t.noCite.map((H) => H.replace('@', ''))),
        S.registry.mylist.length >= 1 &&
          (!t.suppressBibliography || ((C = t.inlineBibClass) == null ? void 0 : C.length) > 0))
      ) {
        const H = qN(S)
        let T = !1
        const k = {}
        H.children
          .filter((O) => {
            var N, M
            return (M = (N = O.properties) == null ? void 0 : N.className) == null
              ? void 0
              : M.includes('csl-entry')
          })
          .forEach((O) => {
            const N = O.properties.id.split('-').slice(1).join('-')
            ;(k[N] = { ...O }), (k[N].properties = { id: 'inlinebib-' + N })
          }),
          fn(r, 'element', (O, N, M) => {
            var V, j, R
            if (
              ((V = t.inlineBibClass) == null ? void 0 : V.length) > 0 &&
              (R = (j = O.properties) == null ? void 0 : j.id) != null &&
              R.toString().startsWith('citation-')
            ) {
              const [, ...$] = O.properties.id.toString().split('--'),
                L = $.pop(),
                P = {
                  type: 'element',
                  tagName: 'div',
                  properties: {
                    className: t.inlineBibClass,
                    id: `inlineBib--${$.join('--')}--${L}`,
                  },
                  children: $.map((Y) => {
                    const w = k[Y]
                    return (w.properties = { class: 'inline-entry', id: `inline--${Y}--${L}` }), w
                  }),
                }
              M.children.push(P)
            }
            !t.suppressBibliography &&
              (O.tagName === 'p' || O.tagName === 'div') &&
              O.children.length >= 1 &&
              O.children[0].type === 'text' &&
              O.children[0].value === '[^ref]' &&
              ((M.children[N] = H), (T = !0))
          }),
          !t.suppressBibliography && !T && r.children.push(H)
      }
      let y
      if (
        (fn(r, 'element', (H, T, k) => {
          H.tagName === 'section' &&
            H.properties.dataFootnotes &&
            ((y = H), k.children.splice(T, 1))
        }),
        g === 'note' && Object.keys(v).length > 0)
      ) {
        let H = [],
          T = 1
        fn(r, 'element', (O) => {
          if (O.tagName === 'sup' && O.children[0].type === 'element') {
            let N = O.children[0]
            if (N.tagName === 'a') {
              const { href: M, id: V } = N.properties
              if (M.includes('fn') && V.includes('fnref')) {
                const j = M.split('-').pop()
                H.push({ type: M.includes('cite') ? 'citation' : 'existing', oldId: j }),
                  (N.properties.href = `#user-content-fn-${T}`),
                  (N.properties.id = `user-content-fnref-${T}`),
                  (N.children[0].value = T.toString()),
                  (T += 1)
              }
            }
          }
        })
        const k = $N(v, H, y)
        r.children.push(k)
      } else y && r.children.push(y)
    }
function YN() {
  return this.log.length
}
function WN(e = 1) {
  if (e <= 0 || e > this.currentVersion()) return null
  {
    const [t, r] = this.log[e - 1],
      i = new li(JSON.parse(t), JSON.parse(r))
    return (i.log = this.log.slice(0, e)), i
  }
}
function QN(e = 1) {
  return this.retrieveVersion(this.currentVersion() - e)
}
function KN() {
  return this.retrieveVersion(this.currentVersion())
}
function JN() {
  return this.log.push([JSON.stringify(this.data), JSON.stringify(this._options)]), this
}
const ZN = Object.freeze(
    Object.defineProperty(
      {
        __proto__: null,
        currentVersion: YN,
        retrieveLastVersion: KN,
        retrieveVersion: WN,
        save: JN,
        undo: QN,
      },
      Symbol.toStringTag,
      { value: 'Module' }
    )
  ),
  Zm = ['real', 'string'],
  ed = ['json', 'html', 'string', 'rtf'],
  td = ['csl', 'bibtex', 'bibtxt', 'citation-*', 'ris', 'ndjson'],
  rd = ['string', 'function']
function bu(e) {
  if (typeof e != 'object') throw new TypeError('Options not an object!')
  const { format: t, type: r, style: i, lang: n, append: s, prepend: a } = e
  if (t && !Zm.includes(t)) throw new TypeError(`Option format ("${t}") should be one of: ${Zm}`)
  if (r && !ed.includes(r)) throw new TypeError(`Option type ("${r}") should be one of: ${ed}`)
  if (i && !td.includes(i) && !/^citation/.test(i))
    throw new TypeError(`Option style ("${i}") should be one of: ${td}`)
  if (n && typeof n != 'string')
    throw new TypeError(`Option lang should be a string, but is a ${typeof n}`)
  if (a && !rd.includes(typeof a))
    throw new TypeError(`Option prepend should be a string or a function, but is a ${typeof a}`)
  if (s && !rd.includes(typeof s))
    throw new TypeError(`Option append should be a string or a function, but is a ${typeof s}`)
  if (/^citation/.test(i) && r === 'json')
    throw new Error(`Combination type/style of json/citation-* is not valid: ${r}/${i}`)
  return !0
}
function e3(e) {
  if (typeof e != 'object') throw new TypeError('Options should be an object')
  if (e.output) bu(e.output)
  else {
    if (e.maxChainLength && typeof e.maxChainLength != 'number')
      throw new TypeError('Option maxChainLength should be a number')
    if (e.forceType && typeof e.forceType != 'string')
      throw new TypeError('Option forceType should be a string')
    if (e.generateGraph != null && typeof e.generateGraph != 'boolean')
      throw new TypeError('Option generateGraph should be a boolean')
    if (e.strict != null && typeof e.strict != 'boolean')
      throw new TypeError('Option strict should be a boolean')
    if (e.target != null && typeof e.target != 'string')
      throw new TypeError('Option target should be a boolean')
  }
  return !0
}
const t3 = { format: 'real', type: 'json', style: 'csl', lang: 'en-US' }
function r3(e, t) {
  return bu(e), t && this.save(), Object.assign(this._options, e), this
}
const i3 = Object.freeze(
  Object.defineProperty({ __proto__: null, defaultOptions: t3, options: r3 }, Symbol.toStringTag, {
    value: 'Module',
  })
)
function zc(e) {
  switch (e) {
    case void 0:
      return 'Undefined'
    case null:
      return 'Null'
    default:
      return e.constructor.name
  }
}
function Ob(e) {
  switch (typeof e) {
    case 'string':
      return 'String'
    case 'object':
      if (Array.isArray(e)) return 'Array'
      if (zc(e) === 'Object') return 'SimpleObject'
      if (zc(e) !== 'Null') return 'ComplexObject'
    default:
      return 'Primitive'
  }
}
const n3 = Object.freeze(
  Object.defineProperty({ __proto__: null, dataTypeOf: Ob, typeOf: zc }, Symbol.toStringTag, {
    value: 'Module',
  })
)
function Ib(e, t) {
  if (e._graph) {
    const r = t.findIndex(({ type: i }) => i === '@else/list+object')
    r !== -1 && t.splice(r + 1, 0, ...e._graph.slice(0, -1))
  }
  return (e._graph = t), e
}
function Db(e) {
  return delete e._graph, e
}
const s3 = Object.freeze(
    Object.defineProperty(
      { __proto__: null, applyGraph: Ib, removeGraph: Db },
      Symbol.toStringTag,
      { value: 'Module' }
    )
  ),
  Ft = {
    _output(e, t, r) {
      this._log.push(t, r),
        !(this._levels.indexOf(e) < this._levels.indexOf(this.level)) && this._console.log(t, ...r)
    },
    _console: null,
    _log: [],
    _levels: ['http', 'debug', 'unmapped', 'info', 'warn', 'error', 'silent'],
    level: 'silent',
  }
for (const e of Ft._levels) Ft[e] = (t, ...r) => Ft._output(e, t, r)
typeof console.Console == 'function'
  ? (Ft._console = new console.Console(process.stderr))
  : (Ft._console = console)
const _r = {},
  Li = {},
  Gi = {}
function id(e, t) {
  switch (t) {
    case 'Array':
      return e.length === 0 || e.every((r) => Pi(r) === '@csl/object')
        ? '@csl/list+object'
        : '@else/list+object'
    case 'SimpleObject':
    case 'ComplexObject':
      return '@csl/object'
    default:
      return '@invalid'
  }
}
function Rb(e = [], t) {
  for (const r of e) if (_r[r].predicate(t)) return Rb(_r[r].extensions, t) || r
}
function Pi(e) {
  const t = Ob(e)
  return t === 'Array' && e.length === 0 ? id(e, t) : Rb(Li[t], e) || id(e, t)
}
function Lb(e, { dataType: t, predicate: r, extends: i }) {
  let n = []
  e in Gi &&
    ((n = Gi[e]),
    delete Gi[e],
    Ft.debug('[core]', `Subclasses "${n}" finally registered to parent type "${e}"`))
  const s = { predicate: r, extensions: n }
  if (((_r[e] = s), i)) {
    const a = _r[i]
    a
      ? a.extensions.push(e)
      : (Gi[i] || (Gi[i] = []),
        Gi[i].push(e),
        Ft.debug('[core]', `Subclass "${e}" is waiting on parent type "${i}"`))
  } else (Li[t] || (Li[t] = [])).push(e)
}
function a3(e) {
  return Object.prototype.hasOwnProperty.call(_r, e)
}
function Pb(e) {
  delete _r[e],
    [
      ...Object.keys(Li).map((r) => Li[r]),
      ...Object.keys(_r)
        .map((r) => _r[r].extensions)
        .filter((r) => r.length > 0),
    ].forEach((r) => {
      const i = r.indexOf(e)
      i > -1 && r.splice(i, 1)
    })
}
function o3() {
  return Object.keys(_r)
}
function u3() {
  const e = (t) => ({ name: t, children: _r[t].extensions.map(e) })
  return {
    name: 'Type tree',
    children: Object.keys(Li).map((t) => ({ name: t, children: Li[t].map(e) })),
  }
}
const Bb = /^(?:@(.+?))(?:\/(?:(.+?)\+)?(?:(.+)))?$/
class Fb {
  constructor(t) {
    Bp(this, 'validDataTypes', ['String', 'Array', 'SimpleObject', 'ComplexObject', 'Primitive'])
    this.data = t
  }
  validateDataType() {
    const t = this.data.dataType
    if (t && !this.validDataTypes.includes(t))
      throw new RangeError(`dataType was ${t}; expected one of ${this.validDataTypes}`)
  }
  validateParseType() {
    const t = this.data.predicate
    if (t && !(t instanceof RegExp || typeof t == 'function'))
      throw new TypeError(`predicate was ${typeof t}; expected RegExp or function`)
  }
  validateTokenList() {
    const t = this.data.tokenList
    if (t && typeof t != 'object')
      throw new TypeError(`tokenList was ${typeof t}; expected object or RegExp`)
  }
  validatePropertyConstraint() {
    const t = this.data.propertyConstraint
    if (t && typeof t != 'object')
      throw new TypeError(`propertyConstraint was ${typeof t}; expected array or object`)
  }
  validateElementConstraint() {
    const t = this.data.elementConstraint
    if (t && typeof t != 'string')
      throw new TypeError(`elementConstraint was ${typeof t}; expected string`)
  }
  validateExtends() {
    const t = this.data.extends
    if (t && typeof t != 'string') throw new TypeError(`extends was ${typeof t}; expected string`)
  }
  validate() {
    if (this.data === null || typeof this.data != 'object')
      throw new TypeError(`typeParser was ${typeof this.data}; expected object`)
    this.validateDataType(),
      this.validateParseType(),
      this.validateTokenList(),
      this.validatePropertyConstraint(),
      this.validateElementConstraint(),
      this.validateExtends()
  }
  parseTokenList() {
    let t = this.data.tokenList
    if (t) t instanceof RegExp && (t = { token: t })
    else return []
    const { token: r, split: i = /\s+/, trim: n = !0, every: s = !0 } = t,
      a = (c) => (n ? c.trim() : c),
      o = s ? 'every' : 'some'
    return [
      (c) =>
        a(c)
          .split(i)
          [o]((f) => r.test(f)),
    ]
  }
  parsePropertyConstraint() {
    return [].concat(this.data.propertyConstraint || []).map(({ props: r, match: i, value: n }) => {
      switch (((r = [].concat(r)), i)) {
        case 'any':
        case 'some':
          return (s) => r.some((a) => a in s && (!n || n(s[a])))
        case 'none':
          return (s) => !r.some((a) => a in s && (!n || n(s[a])))
        case 'every':
        default:
          return (s) => r.every((a) => a in s && (!n || n(s[a])))
      }
    })
  }
  parseElementConstraint() {
    const t = this.data.elementConstraint
    return t ? [(r) => r.every((i) => Pi(i) === t)] : []
  }
  parsePredicate() {
    return this.data.predicate instanceof RegExp
      ? [this.data.predicate.test.bind(this.data.predicate)]
      : this.data.predicate
      ? [this.data.predicate]
      : []
  }
  getCombinedPredicate() {
    const t = [
      ...this.parsePredicate(),
      ...this.parseTokenList(),
      ...this.parsePropertyConstraint(),
      ...this.parseElementConstraint(),
    ]
    return t.length === 0 ? () => !0 : t.length === 1 ? t[0] : (r) => t.every((i) => i(r))
  }
  getDataType() {
    return this.data.dataType
      ? this.data.dataType
      : this.data.predicate instanceof RegExp || this.data.tokenList
      ? 'String'
      : this.data.elementConstraint
      ? 'Array'
      : 'Primitive'
  }
  get dataType() {
    return this.getDataType()
  }
  get predicate() {
    return this.getCombinedPredicate()
  }
  get extends() {
    return this.data.extends
  }
}
class jc {
  constructor(t, { async: r } = {}) {
    ;(this.parser = t), (this.async = r)
  }
  validate() {
    const t = this.parser
    if (typeof t != 'function') throw new TypeError(`parser was ${typeof t}; expected function`)
  }
}
class Mb {
  constructor(t, r = {}) {
    ;(this.format = t),
      r.parseType && (this.typeParser = new Fb(r.parseType)),
      r.parse && (this.dataParser = new jc(r.parse, { async: !1 })),
      r.parseAsync && (this.asyncDataParser = new jc(r.parseAsync, { async: !0 }))
  }
  validateFormat() {
    const t = this.format
    if (!Bb.test(t)) throw new TypeError(`format name was "${t}"; didn't match expected pattern`)
  }
  validate() {
    this.validateFormat(),
      this.typeParser && this.typeParser.validate(),
      this.dataParser && this.dataParser.validate(),
      this.asyncDataParser && this.asyncDataParser.validate()
  }
}
const l3 = Object.freeze(
  Object.defineProperty(
    { __proto__: null, DataParser: jc, FormatParser: Mb, TypeParser: Fb },
    Symbol.toStringTag,
    { value: 'Module' }
  )
)
var yu = {},
  gr = {}
Object.defineProperty(gr, '__esModule', { value: !0 })
gr.default = gr.parse = gr.types = gr.scope = void 0
function nd(e, t) {
  return p3(e) || f3(e, t) || c3()
}
function c3() {
  throw new TypeError('Invalid attempt to destructure non-iterable instance')
}
function f3(e, t) {
  var r = [],
    i = !0,
    n = !1,
    s = void 0
  try {
    for (
      var a = e[Symbol.iterator](), o;
      !(i = (o = a.next()).done) && (r.push(o.value), !(t && r.length === t));
      i = !0
    );
  } catch (u) {
    ;(n = !0), (s = u)
  } finally {
    try {
      !i && a.return != null && a.return()
    } finally {
      if (n) throw s
    }
  }
  return r
}
function p3(e) {
  if (Array.isArray(e)) return e
}
const Ub = (e) => e.replace(/$|( )|(?!^)(?=[A-Z])/g, '\\.?$1'),
  vp = (e) => `(?:${e.join('|')})\\b`,
  Ep = (e, t) => new RegExp(`(?:^| )(${e}$)`, t),
  h3 = [
    'mr',
    'mrs',
    'ms',
    'miss',
    'dr',
    'herr',
    'monsieur',
    'hr',
    'frau',
    'a v m',
    'admiraal',
    'admiral',
    'air cdre',
    'air commodore',
    'air marshal',
    'air vice marshal',
    'alderman',
    'alhaji',
    'ambassador',
    'baron',
    'barones',
    'brig',
    'brig gen',
    'brig general',
    'brigadier',
    'brigadier general',
    'brother',
    'canon',
    'capt',
    'captain',
    'cardinal',
    'cdr',
    'chief',
    'cik',
    'cmdr',
    'coach',
    'col',
    'col dr',
    'colonel',
    'commandant',
    'commander',
    'commissioner',
    'commodore',
    'comte',
    'comtessa',
    'congressman',
    'conseiller',
    'consul',
    'conte',
    'contessa',
    'corporal',
    'councillor',
    'count',
    'countess',
    'crown prince',
    'crown princess',
    'dame',
    'datin',
    'dato',
    'datuk',
    'datuk seri',
    'deacon',
    'deaconess',
    'dean',
    'dhr',
    'dipl ing',
    'doctor',
    'dott',
    'dott sa',
    'dr',
    'dr ing',
    'dra',
    'drs',
    'embajador',
    'embajadora',
    'en',
    'encik',
    'eng',
    'eur ing',
    'exma sra',
    'exmo sr',
    'f o',
    'father',
    'first lieutient',
    'first officer',
    'flt lieut',
    'flying officer',
    'fr',
    'frau',
    'fraulein',
    'fru',
    'gen',
    'generaal',
    'general',
    'governor',
    'graaf',
    'gravin',
    'group captain',
    'grp capt',
    'h e dr',
    'h h',
    'h m',
    'h r h',
    'hajah',
    'haji',
    'hajim',
    'her highness',
    'her majesty',
    'herr',
    'high chief',
    'his highness',
    'his holiness',
    'his majesty',
    'hon',
    'hr',
    'hra',
    'ing',
    'ir',
    'jonkheer',
    'judge',
    'justice',
    'khun ying',
    'kolonel',
    'lady',
    'lcda',
    'lic',
    'lieut',
    'lieut cdr',
    'lieut col',
    'lieut gen',
    'lord',
    'm',
    'm l',
    'm r',
    'madame',
    'mademoiselle',
    'maj gen',
    'major',
    'master',
    'mevrouw',
    'miss',
    'mlle',
    'mme',
    'monsieur',
    'monsignor',
    'mr',
    'mrs',
    'ms',
    'mstr',
    'nti',
    'pastor',
    'president',
    'prince',
    'princess',
    'princesse',
    'prinses',
    'prof',
    'prof dr',
    'prof sir',
    'professor',
    'puan',
    'puan sri',
    'rabbi',
    'rear admiral',
    'rev',
    'rev canon',
    'rev dr',
    'rev mother',
    'reverend',
    'rva',
    'senator',
    'sergeant',
    'sheikh',
    'sheikha',
    'sig',
    'sig na',
    'sig ra',
    'sir',
    'sister',
    'sqn ldr',
    'sr',
    'sr d',
    'sra',
    'srta',
    'sultan',
    'tan sri',
    'tan sri dato',
    'tengku',
    'teuku',
    'than puying',
    'the hon dr',
    'the hon justice',
    'the hon miss',
    'the hon mr',
    'the hon mrs',
    'the hon ms',
    'the hon sir',
    'the very rev',
    'toh puan',
    'tun',
    'vice admiral',
    'viscount',
    'viscountess',
    'wg cdr',
  ],
  m3 = [
    'I',
    'II',
    'III',
    'IV',
    'V',
    'Senior',
    'Junior',
    'Jr',
    'Sr',
    'PhD',
    'Ph\\.D',
    'APR',
    'RPh',
    'PE',
    'MD',
    'MA',
    'DMD',
    'CME',
    'BVM',
    'CFRE',
    'CLU',
    'CPA',
    'CSC',
    'CSJ',
    'DC',
    'DD',
    'DDS',
    'DO',
    'DVM',
    'EdD',
    'Esq',
    'JD',
    'LLD',
    'OD',
    'OSB',
    'PC',
    'Ret',
    'RGS',
    'RN',
    'RNC',
    'SHCJ',
    'SJ',
    'SNJM',
    'SSMO',
    'USA',
    'USAF',
    'USAFR',
    'USAR',
    'USCG',
    'USMC',
    'USMCR',
    'USN',
    'USNR',
  ],
  d3 = [
    'Vere',
    'Von',
    'Van',
    'De',
    'Del',
    'Della',
    'Di',
    'Da',
    'Pietro',
    'Vanden',
    'Du',
    'St.',
    'St',
    'La',
    'Lo',
    'Ter',
    'O',
    "O'",
    'Mac',
    'Fitz',
  ],
  g3 = vp(h3.map(Ub)),
  qc = vp(m3.map(Ub)),
  b3 = vp(d3),
  y3 = new RegExp(`^((?:${g3} )*)(.*)$`, 'i'),
  _3 = Ep(`(?:${qc}, )*(?:${qc})`, 'i'),
  v3 = Ep(
    `${
      /(?:[A-Z\xC0-\xD6\xD8-\xDE\u0100\u0102\u0104\u0106\u0108\u010A\u010C\u010E\u0110\u0112\u0114\u0116\u0118\u011A\u011C\u011E\u0120\u0122\u0124\u0126\u0128\u012A\u012C\u012E\u0130\u0132\u0134\u0136\u0139\u013B\u013D\u013F\u0141\u0143\u0145\u0147\u014A\u014C\u014E\u0150\u0152\u0154\u0156\u0158\u015A\u015C\u015E\u0160\u0162\u0164\u0166\u0168\u016A\u016C\u016E\u0170\u0172\u0174\u0176\u0178\u0179\u017B\u017D\u0181\u0182\u0184\u0186\u0187\u0189-\u018B\u018E-\u0191\u0193\u0194\u0196-\u0198\u019C\u019D\u019F\u01A0\u01A2\u01A4\u01A6\u01A7\u01A9\u01AC\u01AE\u01AF\u01B1-\u01B3\u01B5\u01B7\u01B8\u01BC\u01C4\u01C7\u01CA\u01CD\u01CF\u01D1\u01D3\u01D5\u01D7\u01D9\u01DB\u01DE\u01E0\u01E2\u01E4\u01E6\u01E8\u01EA\u01EC\u01EE\u01F1\u01F4\u01F6-\u01F8\u01FA\u01FC\u01FE\u0200\u0202\u0204\u0206\u0208\u020A\u020C\u020E\u0210\u0212\u0214\u0216\u0218\u021A\u021C\u021E\u0220\u0222\u0224\u0226\u0228\u022A\u022C\u022E\u0230\u0232\u023A\u023B\u023D\u023E\u0241\u0243-\u0246\u0248\u024A\u024C\u024E\u0370\u0372\u0376\u037F\u0386\u0388-\u038A\u038C\u038E\u038F\u0391-\u03A1\u03A3-\u03AB\u03CF\u03D2-\u03D4\u03D8\u03DA\u03DC\u03DE\u03E0\u03E2\u03E4\u03E6\u03E8\u03EA\u03EC\u03EE\u03F4\u03F7\u03F9\u03FA\u03FD-\u042F\u0460\u0462\u0464\u0466\u0468\u046A\u046C\u046E\u0470\u0472\u0474\u0476\u0478\u047A\u047C\u047E\u0480\u048A\u048C\u048E\u0490\u0492\u0494\u0496\u0498\u049A\u049C\u049E\u04A0\u04A2\u04A4\u04A6\u04A8\u04AA\u04AC\u04AE\u04B0\u04B2\u04B4\u04B6\u04B8\u04BA\u04BC\u04BE\u04C0\u04C1\u04C3\u04C5\u04C7\u04C9\u04CB\u04CD\u04D0\u04D2\u04D4\u04D6\u04D8\u04DA\u04DC\u04DE\u04E0\u04E2\u04E4\u04E6\u04E8\u04EA\u04EC\u04EE\u04F0\u04F2\u04F4\u04F6\u04F8\u04FA\u04FC\u04FE\u0500\u0502\u0504\u0506\u0508\u050A\u050C\u050E\u0510\u0512\u0514\u0516\u0518\u051A\u051C\u051E\u0520\u0522\u0524\u0526\u0528\u052A\u052C\u052E\u0531-\u0556\u10A0-\u10C5\u10C7\u10CD\u13A0-\u13F5\u1C90-\u1CBA\u1CBD-\u1CBF\u1E00\u1E02\u1E04\u1E06\u1E08\u1E0A\u1E0C\u1E0E\u1E10\u1E12\u1E14\u1E16\u1E18\u1E1A\u1E1C\u1E1E\u1E20\u1E22\u1E24\u1E26\u1E28\u1E2A\u1E2C\u1E2E\u1E30\u1E32\u1E34\u1E36\u1E38\u1E3A\u1E3C\u1E3E\u1E40\u1E42\u1E44\u1E46\u1E48\u1E4A\u1E4C\u1E4E\u1E50\u1E52\u1E54\u1E56\u1E58\u1E5A\u1E5C\u1E5E\u1E60\u1E62\u1E64\u1E66\u1E68\u1E6A\u1E6C\u1E6E\u1E70\u1E72\u1E74\u1E76\u1E78\u1E7A\u1E7C\u1E7E\u1E80\u1E82\u1E84\u1E86\u1E88\u1E8A\u1E8C\u1E8E\u1E90\u1E92\u1E94\u1E9E\u1EA0\u1EA2\u1EA4\u1EA6\u1EA8\u1EAA\u1EAC\u1EAE\u1EB0\u1EB2\u1EB4\u1EB6\u1EB8\u1EBA\u1EBC\u1EBE\u1EC0\u1EC2\u1EC4\u1EC6\u1EC8\u1ECA\u1ECC\u1ECE\u1ED0\u1ED2\u1ED4\u1ED6\u1ED8\u1EDA\u1EDC\u1EDE\u1EE0\u1EE2\u1EE4\u1EE6\u1EE8\u1EEA\u1EEC\u1EEE\u1EF0\u1EF2\u1EF4\u1EF6\u1EF8\u1EFA\u1EFC\u1EFE\u1F08-\u1F0F\u1F18-\u1F1D\u1F28-\u1F2F\u1F38-\u1F3F\u1F48-\u1F4D\u1F59\u1F5B\u1F5D\u1F5F\u1F68-\u1F6F\u1FB8-\u1FBB\u1FC8-\u1FCB\u1FD8-\u1FDB\u1FE8-\u1FEC\u1FF8-\u1FFB\u2102\u2107\u210B-\u210D\u2110-\u2112\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u2130-\u2133\u213E\u213F\u2145\u2160-\u216F\u2183\u24B6-\u24CF\u2C00-\u2C2E\u2C60\u2C62-\u2C64\u2C67\u2C69\u2C6B\u2C6D-\u2C70\u2C72\u2C75\u2C7E-\u2C80\u2C82\u2C84\u2C86\u2C88\u2C8A\u2C8C\u2C8E\u2C90\u2C92\u2C94\u2C96\u2C98\u2C9A\u2C9C\u2C9E\u2CA0\u2CA2\u2CA4\u2CA6\u2CA8\u2CAA\u2CAC\u2CAE\u2CB0\u2CB2\u2CB4\u2CB6\u2CB8\u2CBA\u2CBC\u2CBE\u2CC0\u2CC2\u2CC4\u2CC6\u2CC8\u2CCA\u2CCC\u2CCE\u2CD0\u2CD2\u2CD4\u2CD6\u2CD8\u2CDA\u2CDC\u2CDE\u2CE0\u2CE2\u2CEB\u2CED\u2CF2\uA640\uA642\uA644\uA646\uA648\uA64A\uA64C\uA64E\uA650\uA652\uA654\uA656\uA658\uA65A\uA65C\uA65E\uA660\uA662\uA664\uA666\uA668\uA66A\uA66C\uA680\uA682\uA684\uA686\uA688\uA68A\uA68C\uA68E\uA690\uA692\uA694\uA696\uA698\uA69A\uA722\uA724\uA726\uA728\uA72A\uA72C\uA72E\uA732\uA734\uA736\uA738\uA73A\uA73C\uA73E\uA740\uA742\uA744\uA746\uA748\uA74A\uA74C\uA74E\uA750\uA752\uA754\uA756\uA758\uA75A\uA75C\uA75E\uA760\uA762\uA764\uA766\uA768\uA76A\uA76C\uA76E\uA779\uA77B\uA77D\uA77E\uA780\uA782\uA784\uA786\uA78B\uA78D\uA790\uA792\uA796\uA798\uA79A\uA79C\uA79E\uA7A0\uA7A2\uA7A4\uA7A6\uA7A8\uA7AA-\uA7AE\uA7B0-\uA7B4\uA7B6\uA7B8\uFF21-\uFF3A]|\uD801[\uDC00-\uDC27\uDCB0-\uDCD3]|\uD803[\uDC80-\uDCB2]|\uD806[\uDCA0-\uDCBF]|\uD81B[\uDE40-\uDE5F]|\uD835[\uDC00-\uDC19\uDC34-\uDC4D\uDC68-\uDC81\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB5\uDCD0-\uDCE9\uDD04\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD38\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD6C-\uDD85\uDDA0-\uDDB9\uDDD4-\uDDED\uDE08-\uDE21\uDE3C-\uDE55\uDE70-\uDE89\uDEA8-\uDEC0\uDEE2-\uDEFA\uDF1C-\uDF34\uDF56-\uDF6E\uDF90-\uDFA8\uDFCA]|\uD83A[\uDD00-\uDD21]|\uD83C[\uDD30-\uDD49\uDD50-\uDD69\uDD70-\uDD89])/
        .source
    }.*`
  ),
  E3 = Ep(
    `(?:${
      /(?:[a-z\xAA\xB5\xBA\xDF-\xF6\xF8-\xFF\u0101\u0103\u0105\u0107\u0109\u010B\u010D\u010F\u0111\u0113\u0115\u0117\u0119\u011B\u011D\u011F\u0121\u0123\u0125\u0127\u0129\u012B\u012D\u012F\u0131\u0133\u0135\u0137\u0138\u013A\u013C\u013E\u0140\u0142\u0144\u0146\u0148\u0149\u014B\u014D\u014F\u0151\u0153\u0155\u0157\u0159\u015B\u015D\u015F\u0161\u0163\u0165\u0167\u0169\u016B\u016D\u016F\u0171\u0173\u0175\u0177\u017A\u017C\u017E-\u0180\u0183\u0185\u0188\u018C\u018D\u0192\u0195\u0199-\u019B\u019E\u01A1\u01A3\u01A5\u01A8\u01AA\u01AB\u01AD\u01B0\u01B4\u01B6\u01B9\u01BA\u01BD-\u01BF\u01C6\u01C9\u01CC\u01CE\u01D0\u01D2\u01D4\u01D6\u01D8\u01DA\u01DC\u01DD\u01DF\u01E1\u01E3\u01E5\u01E7\u01E9\u01EB\u01ED\u01EF\u01F0\u01F3\u01F5\u01F9\u01FB\u01FD\u01FF\u0201\u0203\u0205\u0207\u0209\u020B\u020D\u020F\u0211\u0213\u0215\u0217\u0219\u021B\u021D\u021F\u0221\u0223\u0225\u0227\u0229\u022B\u022D\u022F\u0231\u0233-\u0239\u023C\u023F\u0240\u0242\u0247\u0249\u024B\u024D\u024F-\u0293\u0295-\u02B8\u02C0\u02C1\u02E0-\u02E4\u0345\u0371\u0373\u0377\u037A-\u037D\u0390\u03AC-\u03CE\u03D0\u03D1\u03D5-\u03D7\u03D9\u03DB\u03DD\u03DF\u03E1\u03E3\u03E5\u03E7\u03E9\u03EB\u03ED\u03EF-\u03F3\u03F5\u03F8\u03FB\u03FC\u0430-\u045F\u0461\u0463\u0465\u0467\u0469\u046B\u046D\u046F\u0471\u0473\u0475\u0477\u0479\u047B\u047D\u047F\u0481\u048B\u048D\u048F\u0491\u0493\u0495\u0497\u0499\u049B\u049D\u049F\u04A1\u04A3\u04A5\u04A7\u04A9\u04AB\u04AD\u04AF\u04B1\u04B3\u04B5\u04B7\u04B9\u04BB\u04BD\u04BF\u04C2\u04C4\u04C6\u04C8\u04CA\u04CC\u04CE\u04CF\u04D1\u04D3\u04D5\u04D7\u04D9\u04DB\u04DD\u04DF\u04E1\u04E3\u04E5\u04E7\u04E9\u04EB\u04ED\u04EF\u04F1\u04F3\u04F5\u04F7\u04F9\u04FB\u04FD\u04FF\u0501\u0503\u0505\u0507\u0509\u050B\u050D\u050F\u0511\u0513\u0515\u0517\u0519\u051B\u051D\u051F\u0521\u0523\u0525\u0527\u0529\u052B\u052D\u052F\u0560-\u0588\u10D0-\u10FA\u10FD-\u10FF\u13F8-\u13FD\u1C80-\u1C88\u1D00-\u1DBF\u1E01\u1E03\u1E05\u1E07\u1E09\u1E0B\u1E0D\u1E0F\u1E11\u1E13\u1E15\u1E17\u1E19\u1E1B\u1E1D\u1E1F\u1E21\u1E23\u1E25\u1E27\u1E29\u1E2B\u1E2D\u1E2F\u1E31\u1E33\u1E35\u1E37\u1E39\u1E3B\u1E3D\u1E3F\u1E41\u1E43\u1E45\u1E47\u1E49\u1E4B\u1E4D\u1E4F\u1E51\u1E53\u1E55\u1E57\u1E59\u1E5B\u1E5D\u1E5F\u1E61\u1E63\u1E65\u1E67\u1E69\u1E6B\u1E6D\u1E6F\u1E71\u1E73\u1E75\u1E77\u1E79\u1E7B\u1E7D\u1E7F\u1E81\u1E83\u1E85\u1E87\u1E89\u1E8B\u1E8D\u1E8F\u1E91\u1E93\u1E95-\u1E9D\u1E9F\u1EA1\u1EA3\u1EA5\u1EA7\u1EA9\u1EAB\u1EAD\u1EAF\u1EB1\u1EB3\u1EB5\u1EB7\u1EB9\u1EBB\u1EBD\u1EBF\u1EC1\u1EC3\u1EC5\u1EC7\u1EC9\u1ECB\u1ECD\u1ECF\u1ED1\u1ED3\u1ED5\u1ED7\u1ED9\u1EDB\u1EDD\u1EDF\u1EE1\u1EE3\u1EE5\u1EE7\u1EE9\u1EEB\u1EED\u1EEF\u1EF1\u1EF3\u1EF5\u1EF7\u1EF9\u1EFB\u1EFD\u1EFF-\u1F07\u1F10-\u1F15\u1F20-\u1F27\u1F30-\u1F37\u1F40-\u1F45\u1F50-\u1F57\u1F60-\u1F67\u1F70-\u1F7D\u1F80-\u1F87\u1F90-\u1F97\u1FA0-\u1FA7\u1FB0-\u1FB4\u1FB6\u1FB7\u1FBE\u1FC2-\u1FC4\u1FC6\u1FC7\u1FD0-\u1FD3\u1FD6\u1FD7\u1FE0-\u1FE7\u1FF2-\u1FF4\u1FF6\u1FF7\u2071\u207F\u2090-\u209C\u210A\u210E\u210F\u2113\u212F\u2134\u2139\u213C\u213D\u2146-\u2149\u214E\u2170-\u217F\u2184\u24D0-\u24E9\u2C30-\u2C5E\u2C61\u2C65\u2C66\u2C68\u2C6A\u2C6C\u2C71\u2C73\u2C74\u2C76-\u2C7D\u2C81\u2C83\u2C85\u2C87\u2C89\u2C8B\u2C8D\u2C8F\u2C91\u2C93\u2C95\u2C97\u2C99\u2C9B\u2C9D\u2C9F\u2CA1\u2CA3\u2CA5\u2CA7\u2CA9\u2CAB\u2CAD\u2CAF\u2CB1\u2CB3\u2CB5\u2CB7\u2CB9\u2CBB\u2CBD\u2CBF\u2CC1\u2CC3\u2CC5\u2CC7\u2CC9\u2CCB\u2CCD\u2CCF\u2CD1\u2CD3\u2CD5\u2CD7\u2CD9\u2CDB\u2CDD\u2CDF\u2CE1\u2CE3\u2CE4\u2CEC\u2CEE\u2CF3\u2D00-\u2D25\u2D27\u2D2D\uA641\uA643\uA645\uA647\uA649\uA64B\uA64D\uA64F\uA651\uA653\uA655\uA657\uA659\uA65B\uA65D\uA65F\uA661\uA663\uA665\uA667\uA669\uA66B\uA66D\uA681\uA683\uA685\uA687\uA689\uA68B\uA68D\uA68F\uA691\uA693\uA695\uA697\uA699\uA69B-\uA69D\uA723\uA725\uA727\uA729\uA72B\uA72D\uA72F-\uA731\uA733\uA735\uA737\uA739\uA73B\uA73D\uA73F\uA741\uA743\uA745\uA747\uA749\uA74B\uA74D\uA74F\uA751\uA753\uA755\uA757\uA759\uA75B\uA75D\uA75F\uA761\uA763\uA765\uA767\uA769\uA76B\uA76D\uA76F-\uA778\uA77A\uA77C\uA77F\uA781\uA783\uA785\uA787\uA78C\uA78E\uA791\uA793-\uA795\uA797\uA799\uA79B\uA79D\uA79F\uA7A1\uA7A3\uA7A5\uA7A7\uA7A9\uA7AF\uA7B5\uA7B7\uA7B9\uA7F8-\uA7FA\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABBF\uFB00-\uFB06\uFB13-\uFB17\uFF41-\uFF5A]|\uD801[\uDC28-\uDC4F\uDCD8-\uDCFB]|\uD803[\uDCC0-\uDCF2]|\uD806[\uDCC0-\uDCDF]|\uD81B[\uDE60-\uDE7F]|\uD835[\uDC1A-\uDC33\uDC4E-\uDC54\uDC56-\uDC67\uDC82-\uDC9B\uDCB6-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDCCF\uDCEA-\uDD03\uDD1E-\uDD37\uDD52-\uDD6B\uDD86-\uDD9F\uDDBA-\uDDD3\uDDEE-\uDE07\uDE22-\uDE3B\uDE56-\uDE6F\uDE8A-\uDEA5\uDEC2-\uDEDA\uDEDC-\uDEE1\uDEFC-\uDF14\uDF16-\uDF1B\uDF36-\uDF4E\uDF50-\uDF55\uDF70-\uDF88\uDF8A-\uDF8F\uDFAA-\uDFC2\uDFC4-\uDFC9\uDFCB]|\uD83A[\uDD22-\uDD43])/
        .source
    }.*|${b3}.*|\\S*)`
  ),
  x3 = function (t = '') {
    typeof t != 'string' && (t = t + '')
    let r = '',
      i = '',
      n = ''
    if (/[^.], /.test(t)) {
      const v = t.split(', ')
      n = v.shift()
      const b = RegExp(qc).exec(v.join(', '))
      ;(r = v.splice(b && b.index !== 0 ? 0 : -1, 1)[0]), (i = v.join(', '))
    } else {
      const v = t.split(_3, 2),
        b = v.shift().split(E3, 2)
      ;(r = b[0]), (n = b[1]), (i = v.pop())
    }
    const s = r.match(y3),
      a = nd(s, 3),
      o = a[1],
      u = a[2],
      c = i,
      f = n.split(v3, 2).reverse(),
      h = nd(f, 2),
      p = h[0],
      m = h[1]
    if (!u && p) return p.includes(' ') ? { literal: p } : { family: p }
    if (p) {
      const v = {
        'dropping-particle': o,
        given: u,
        suffix: c,
        'non-dropping-particle': m,
        family: p,
      }
      return (
        Object.keys(v).forEach((b) => {
          v[b] || delete v[b]
        }),
        v
      )
    } else return { literal: t }
  }
gr.default = gr.parse = x3
const T3 = '@name'
gr.scope = T3
const A3 = '@name'
gr.types = A3
var _u = {}
Object.defineProperty(_u, '__esModule', { value: !0 })
_u.default = void 0
const xl = ['dropping-particle', 'given'],
  Tl = ['suffix'],
  sd = ['non-dropping-particle', 'family'],
  S3 = function (t, r = !1) {
    const i = (n) =>
      n
        .map((s) => t[s] || '')
        .filter(Boolean)
        .join(' ')
    if (t.literal) return t.literal
    if (r) {
      const n = i(Tl) ? `, ${i(Tl)}` : '',
        s = i(xl) ? `, ${i(xl)}` : ''
      return i(sd) + n + s
    } else return `${i([...xl, ...Tl, ...sd])}`
  }
var C3 = S3
_u.default = C3
;(function (e) {
  Object.defineProperty(e, '__esModule', { value: !0 }),
    Object.defineProperty(e, 'parse', {
      enumerable: !0,
      get: function () {
        return t.default
      },
    }),
    Object.defineProperty(e, 'format', {
      enumerable: !0,
      get: function () {
        return r.default
      },
    })
  var t = i(gr),
    r = i(_u)
  function i(n) {
    return n && n.__esModule ? n : { default: n }
  }
})(yu)
const k3 = 1,
  Le = 2,
  qr = 3,
  Hb = 4,
  Al = {
    article: !0,
    'article-journal': !0,
    'article-magazine': !0,
    'article-newspaper': !0,
    bill: !0,
    book: !0,
    broadcast: !0,
    chapter: !0,
    classic: !0,
    collection: !0,
    dataset: !0,
    document: !0,
    entry: !0,
    'entry-dictionary': !0,
    'entry-encyclopedia': !0,
    event: !0,
    figure: !0,
    graphic: !0,
    hearing: !0,
    interview: !0,
    legal_case: !0,
    legislation: !0,
    manuscript: !0,
    map: !0,
    motion_picture: !0,
    musical_score: !0,
    pamphlet: !0,
    'paper-conference': !0,
    patent: !0,
    performance: !0,
    periodical: !0,
    personal_communication: !0,
    post: !0,
    'post-weblog': !0,
    regulation: !0,
    report: !0,
    review: !0,
    'review-book': !0,
    software: !0,
    song: !0,
    speech: !0,
    standard: !0,
    thesis: !0,
    treaty: !0,
    webpage: !0,
    'journal-article': 'article-journal',
    'book-chapter': 'chapter',
    'posted-content': 'manuscript',
    'proceedings-article': 'paper-conference',
  },
  ad = {
    author: Le,
    chair: Le,
    'collection-editor': Le,
    compiler: Le,
    composer: Le,
    'container-author': Le,
    contributor: Le,
    curator: Le,
    director: Le,
    editor: Le,
    'editorial-director': Le,
    'executive-producer': Le,
    guest: Le,
    host: Le,
    interviewer: Le,
    illustrator: Le,
    narrator: Le,
    organizer: Le,
    'original-author': Le,
    performer: Le,
    producer: Le,
    'reviewed-author': Le,
    recipient: Le,
    'script-writer': Le,
    'series-creator': Le,
    translator: Le,
    accessed: qr,
    'available-date': qr,
    container: qr,
    'event-date': qr,
    issued: qr,
    'original-date': qr,
    submitted: qr,
    type: Hb,
    categories: 'object',
    custom: 'object',
    id: ['string', 'number'],
    language: 'string',
    journalAbbreviation: 'string',
    shortTitle: 'string',
    abstract: 'string',
    annote: 'string',
    archive: 'string',
    archive_collection: 'string',
    archive_location: 'string',
    'archive-place': 'string',
    authority: 'string',
    'call-number': 'string',
    'chapter-number': 'string',
    'citation-number': 'string',
    'citation-key': 'string',
    'citation-label': 'string',
    'collection-number': 'string',
    'collection-title': 'string',
    'container-title': 'string',
    'container-title-short': 'string',
    dimensions: 'string',
    division: 'string',
    DOI: 'string',
    edition: ['string', 'number'],
    event: 'string',
    'event-title': 'string',
    'event-place': 'string',
    'first-reference-note-number': 'string',
    genre: 'string',
    ISBN: 'string',
    ISSN: 'string',
    issue: ['string', 'number'],
    jurisdiction: 'string',
    keyword: 'string',
    locator: 'string',
    medium: 'string',
    note: 'string',
    number: ['string', 'number'],
    'number-of-pages': 'string',
    'number-of-volumes': ['string', 'number'],
    'original-publisher': 'string',
    'original-publisher-place': 'string',
    'original-title': 'string',
    page: 'string',
    'page-first': 'string',
    'part-number': ['string', 'number'],
    'part-title': 'string',
    PMCID: 'string',
    PMID: 'string',
    printing: 'string',
    publisher: 'string',
    'publisher-place': 'string',
    references: 'string',
    'reviewed-title': 'string',
    'reviewed-genre': 'string',
    scale: 'string',
    section: 'string',
    source: 'string',
    status: 'string',
    supplement: ['string', 'number'],
    title: 'string',
    'title-short': 'string',
    URL: 'string',
    version: 'string',
    volume: ['string', 'number'],
    'volume-title': 'string',
    'volume-title-short': 'string',
    'year-suffix': 'string',
  }
function zb(e, t) {
  if (typeof e == 'object' && e !== null && (e.literal || e.given || e.family)) return e
  if (t) {
    if (typeof e == 'string') return yu.parse(e)
  } else return
}
function w3(e, t) {
  if (e instanceof Array) {
    const r = e.map((i) => zb(i, t)).filter(Boolean)
    return r.length ? r : void 0
  }
}
function Sl(e, t) {
  return e.every((r) => typeof r == 'number')
    ? e
    : !t || e.some((r) => isNaN(parseInt(r)))
    ? void 0
    : e.map((r) => parseInt(r))
}
function N3(e, t) {
  const r = 'date-parts'
  if (!(typeof e != 'object' || e === null)) {
    if (e[r] instanceof Array && e[r].every((i) => i instanceof Array)) {
      const i = e[r].map((n) => Sl(n, t)).filter(Boolean)
      return i.length ? { ...e, 'date-parts': i } : void 0
    } else if (e instanceof Array && e.every((i) => i[r] instanceof Array)) {
      const i = e.map((n) => Sl(n[r], t)).filter(Boolean)
      return i.length ? { 'date-parts': i } : void 0
    } else if (e[r] instanceof Array) {
      const i = Sl(e[r], t)
      return i && { 'date-parts': [i] }
    } else if ('literal' in e || 'raw' in e) return e
  }
}
function O3(e, t) {
  return (e = xp('language', e, t)), Al[e] === !0 ? e : t && e in Al ? Al[e] : void 0
}
function xp(e, t, r) {
  const i = [].concat(ad[e])
  switch (ad[e]) {
    case k3:
      return zb(t, r)
    case Le:
      return w3(t, r)
    case qr:
      return N3(t, r)
    case Hb:
      return O3(t, r)
  }
  if (r) {
    if (typeof t == 'string' && i.includes('number') && !i.includes('string') && !isNaN(+t))
      return parseFloat(t)
    if (typeof t == 'number' && i.includes('string') && !i.includes('number')) return t.toString()
    if (Array.isArray(t) && t.length) return xp(e, t[0], r)
  }
  if (i.includes(typeof t)) return t
}
function jb(e, t = !0) {
  return e.map(function (r) {
    const i = {}
    for (const n in r) {
      const s = xp(n, r[n], t)
      s !== void 0 && (i[n] = s)
    }
    return i
  })
}
const I3 = Object.freeze(
  Object.defineProperty({ __proto__: null, clean: jb }, Symbol.toStringTag, { value: 'Module' })
)
function qb(e) {
  return Array.isArray(e)
    ? e.map(qb)
    : ((e = { ...e }),
      'event' in e && ((e['event-title'] = e.event), delete e.event),
      e.type === 'book' && 'version' in e && (e.type = 'software'),
      e)
}
function qs(e) {
  return Array.isArray(e)
    ? e.map(qs)
    : ((e = { ...e }),
      'event-title' in e && ((e.event = e['event-title']), delete e['event-title']),
      e.type === 'software' && (e.type = 'book'),
      e)
}
function Bi(e, t = new Set()) {
  if (typeof e != 'object' || e === null || (e.constructor !== Object && e.constructor !== Array))
    return e
  if (t.has(e)) throw new TypeError('Recursively copying circular structure')
  t.add(e)
  let r
  if (e.constructor === Array) r = e.map((i) => Bi(i, t))
  else {
    const i = {}
    for (const n in e) i[n] = Bi(e[n], t)
    r = i
  }
  return t.delete(e), r
}
var $b = {},
  vu = {}
vu.byteLength = L3
vu.toByteArray = B3
vu.fromByteArray = U3
var mr = [],
  qt = [],
  D3 = typeof Uint8Array < 'u' ? Uint8Array : Array,
  Cl = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'
for (var Xi = 0, R3 = Cl.length; Xi < R3; ++Xi) (mr[Xi] = Cl[Xi]), (qt[Cl.charCodeAt(Xi)] = Xi)
qt['-'.charCodeAt(0)] = 62
qt['_'.charCodeAt(0)] = 63
function Vb(e) {
  var t = e.length
  if (t % 4 > 0) throw new Error('Invalid string. Length must be a multiple of 4')
  var r = e.indexOf('=')
  r === -1 && (r = t)
  var i = r === t ? 0 : 4 - (r % 4)
  return [r, i]
}
function L3(e) {
  var t = Vb(e),
    r = t[0],
    i = t[1]
  return ((r + i) * 3) / 4 - i
}
function P3(e, t, r) {
  return ((t + r) * 3) / 4 - r
}
function B3(e) {
  var t,
    r = Vb(e),
    i = r[0],
    n = r[1],
    s = new D3(P3(e, i, n)),
    a = 0,
    o = n > 0 ? i - 4 : i,
    u
  for (u = 0; u < o; u += 4)
    (t =
      (qt[e.charCodeAt(u)] << 18) |
      (qt[e.charCodeAt(u + 1)] << 12) |
      (qt[e.charCodeAt(u + 2)] << 6) |
      qt[e.charCodeAt(u + 3)]),
      (s[a++] = (t >> 16) & 255),
      (s[a++] = (t >> 8) & 255),
      (s[a++] = t & 255)
  return (
    n === 2 &&
      ((t = (qt[e.charCodeAt(u)] << 2) | (qt[e.charCodeAt(u + 1)] >> 4)), (s[a++] = t & 255)),
    n === 1 &&
      ((t =
        (qt[e.charCodeAt(u)] << 10) |
        (qt[e.charCodeAt(u + 1)] << 4) |
        (qt[e.charCodeAt(u + 2)] >> 2)),
      (s[a++] = (t >> 8) & 255),
      (s[a++] = t & 255)),
    s
  )
}
function F3(e) {
  return mr[(e >> 18) & 63] + mr[(e >> 12) & 63] + mr[(e >> 6) & 63] + mr[e & 63]
}
function M3(e, t, r) {
  for (var i, n = [], s = t; s < r; s += 3)
    (i = ((e[s] << 16) & 16711680) + ((e[s + 1] << 8) & 65280) + (e[s + 2] & 255)), n.push(F3(i))
  return n.join('')
}
function U3(e) {
  for (var t, r = e.length, i = r % 3, n = [], s = 16383, a = 0, o = r - i; a < o; a += s)
    n.push(M3(e, a, a + s > o ? o : a + s))
  return (
    i === 1
      ? ((t = e[r - 1]), n.push(mr[t >> 2] + mr[(t << 4) & 63] + '=='))
      : i === 2 &&
        ((t = (e[r - 2] << 8) + e[r - 1]),
        n.push(mr[t >> 10] + mr[(t >> 4) & 63] + mr[(t << 2) & 63] + '=')),
    n.join('')
  )
}
var Tp = {}
/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */ Tp.read =
  function (e, t, r, i, n) {
    var s,
      a,
      o = n * 8 - i - 1,
      u = (1 << o) - 1,
      c = u >> 1,
      f = -7,
      h = r ? n - 1 : 0,
      p = r ? -1 : 1,
      m = e[t + h]
    for (
      h += p, s = m & ((1 << -f) - 1), m >>= -f, f += o;
      f > 0;
      s = s * 256 + e[t + h], h += p, f -= 8
    );
    for (a = s & ((1 << -f) - 1), s >>= -f, f += i; f > 0; a = a * 256 + e[t + h], h += p, f -= 8);
    if (s === 0) s = 1 - c
    else {
      if (s === u) return a ? NaN : (m ? -1 : 1) * (1 / 0)
      ;(a = a + Math.pow(2, i)), (s = s - c)
    }
    return (m ? -1 : 1) * a * Math.pow(2, s - i)
  }
Tp.write = function (e, t, r, i, n, s) {
  var a,
    o,
    u,
    c = s * 8 - n - 1,
    f = (1 << c) - 1,
    h = f >> 1,
    p = n === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0,
    m = i ? 0 : s - 1,
    v = i ? 1 : -1,
    b = t < 0 || (t === 0 && 1 / t < 0) ? 1 : 0
  for (
    t = Math.abs(t),
      isNaN(t) || t === 1 / 0
        ? ((o = isNaN(t) ? 1 : 0), (a = f))
        : ((a = Math.floor(Math.log(t) / Math.LN2)),
          t * (u = Math.pow(2, -a)) < 1 && (a--, (u *= 2)),
          a + h >= 1 ? (t += p / u) : (t += p * Math.pow(2, 1 - h)),
          t * u >= 2 && (a++, (u /= 2)),
          a + h >= f
            ? ((o = 0), (a = f))
            : a + h >= 1
            ? ((o = (t * u - 1) * Math.pow(2, n)), (a = a + h))
            : ((o = t * Math.pow(2, h - 1) * Math.pow(2, n)), (a = 0)));
    n >= 8;
    e[r + m] = o & 255, m += v, o /= 256, n -= 8
  );
  for (a = (a << n) | o, c += n; c > 0; e[r + m] = a & 255, m += v, a /= 256, c -= 8);
  e[r + m - v] |= b * 128
}
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */ ;(function (e) {
  var t = vu,
    r = Tp,
    i =
      typeof Symbol == 'function' && typeof Symbol.for == 'function'
        ? Symbol.for('nodejs.util.inspect.custom')
        : null
  ;(e.Buffer = o), (e.SlowBuffer = _), (e.INSPECT_MAX_BYTES = 50)
  var n = 2147483647
  ;(e.kMaxLength = n),
    (o.TYPED_ARRAY_SUPPORT = s()),
    !o.TYPED_ARRAY_SUPPORT &&
      typeof console < 'u' &&
      typeof console.error == 'function' &&
      console.error(
        'This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support.'
      )
  function s() {
    try {
      var F = new Uint8Array(1),
        E = {
          foo: function () {
            return 42
          },
        }
      return (
        Object.setPrototypeOf(E, Uint8Array.prototype), Object.setPrototypeOf(F, E), F.foo() === 42
      )
    } catch {
      return !1
    }
  }
  Object.defineProperty(o.prototype, 'parent', {
    enumerable: !0,
    get: function () {
      if (o.isBuffer(this)) return this.buffer
    },
  }),
    Object.defineProperty(o.prototype, 'offset', {
      enumerable: !0,
      get: function () {
        if (o.isBuffer(this)) return this.byteOffset
      },
    })
  function a(F) {
    if (F > n) throw new RangeError('The value "' + F + '" is invalid for option "size"')
    var E = new Uint8Array(F)
    return Object.setPrototypeOf(E, o.prototype), E
  }
  function o(F, E, A) {
    if (typeof F == 'number') {
      if (typeof E == 'string')
        throw new TypeError('The "string" argument must be of type string. Received type number')
      return h(F)
    }
    return u(F, E, A)
  }
  o.poolSize = 8192
  function u(F, E, A) {
    if (typeof F == 'string') return p(F, E)
    if (ArrayBuffer.isView(F)) return v(F)
    if (F == null)
      throw new TypeError(
        'The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type ' +
          typeof F
      )
    if (
      Ne(F, ArrayBuffer) ||
      (F && Ne(F.buffer, ArrayBuffer)) ||
      (typeof SharedArrayBuffer < 'u' &&
        (Ne(F, SharedArrayBuffer) || (F && Ne(F.buffer, SharedArrayBuffer))))
    )
      return b(F, E, A)
    if (typeof F == 'number')
      throw new TypeError('The "value" argument must not be of type number. Received type number')
    var z = F.valueOf && F.valueOf()
    if (z != null && z !== F) return o.from(z, E, A)
    var W = S(F)
    if (W) return W
    if (
      typeof Symbol < 'u' &&
      Symbol.toPrimitive != null &&
      typeof F[Symbol.toPrimitive] == 'function'
    )
      return o.from(F[Symbol.toPrimitive]('string'), E, A)
    throw new TypeError(
      'The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type ' +
        typeof F
    )
  }
  ;(o.from = function (F, E, A) {
    return u(F, E, A)
  }),
    Object.setPrototypeOf(o.prototype, Uint8Array.prototype),
    Object.setPrototypeOf(o, Uint8Array)
  function c(F) {
    if (typeof F != 'number') throw new TypeError('"size" argument must be of type number')
    if (F < 0) throw new RangeError('The value "' + F + '" is invalid for option "size"')
  }
  function f(F, E, A) {
    return (
      c(F),
      F <= 0 ? a(F) : E !== void 0 ? (typeof A == 'string' ? a(F).fill(E, A) : a(F).fill(E)) : a(F)
    )
  }
  o.alloc = function (F, E, A) {
    return f(F, E, A)
  }
  function h(F) {
    return c(F), a(F < 0 ? 0 : g(F) | 0)
  }
  ;(o.allocUnsafe = function (F) {
    return h(F)
  }),
    (o.allocUnsafeSlow = function (F) {
      return h(F)
    })
  function p(F, E) {
    if (((typeof E != 'string' || E === '') && (E = 'utf8'), !o.isEncoding(E)))
      throw new TypeError('Unknown encoding: ' + E)
    var A = y(F, E) | 0,
      z = a(A),
      W = z.write(F, E)
    return W !== A && (z = z.slice(0, W)), z
  }
  function m(F) {
    for (var E = F.length < 0 ? 0 : g(F.length) | 0, A = a(E), z = 0; z < E; z += 1)
      A[z] = F[z] & 255
    return A
  }
  function v(F) {
    if (Ne(F, Uint8Array)) {
      var E = new Uint8Array(F)
      return b(E.buffer, E.byteOffset, E.byteLength)
    }
    return m(F)
  }
  function b(F, E, A) {
    if (E < 0 || F.byteLength < E) throw new RangeError('"offset" is outside of buffer bounds')
    if (F.byteLength < E + (A || 0)) throw new RangeError('"length" is outside of buffer bounds')
    var z
    return (
      E === void 0 && A === void 0
        ? (z = new Uint8Array(F))
        : A === void 0
        ? (z = new Uint8Array(F, E))
        : (z = new Uint8Array(F, E, A)),
      Object.setPrototypeOf(z, o.prototype),
      z
    )
  }
  function S(F) {
    if (o.isBuffer(F)) {
      var E = g(F.length) | 0,
        A = a(E)
      return A.length === 0 || F.copy(A, 0, 0, E), A
    }
    if (F.length !== void 0) return typeof F.length != 'number' || Oe(F.length) ? a(0) : m(F)
    if (F.type === 'Buffer' && Array.isArray(F.data)) return m(F.data)
  }
  function g(F) {
    if (F >= n)
      throw new RangeError(
        'Attempt to allocate Buffer larger than maximum size: 0x' + n.toString(16) + ' bytes'
      )
    return F | 0
  }
  function _(F) {
    return +F != F && (F = 0), o.alloc(+F)
  }
  ;(o.isBuffer = function (E) {
    return E != null && E._isBuffer === !0 && E !== o.prototype
  }),
    (o.compare = function (E, A) {
      if (
        (Ne(E, Uint8Array) && (E = o.from(E, E.offset, E.byteLength)),
        Ne(A, Uint8Array) && (A = o.from(A, A.offset, A.byteLength)),
        !o.isBuffer(E) || !o.isBuffer(A))
      )
        throw new TypeError('The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array')
      if (E === A) return 0
      for (var z = E.length, W = A.length, te = 0, ne = Math.min(z, W); te < ne; ++te)
        if (E[te] !== A[te]) {
          ;(z = E[te]), (W = A[te])
          break
        }
      return z < W ? -1 : W < z ? 1 : 0
    }),
    (o.isEncoding = function (E) {
      switch (String(E).toLowerCase()) {
        case 'hex':
        case 'utf8':
        case 'utf-8':
        case 'ascii':
        case 'latin1':
        case 'binary':
        case 'base64':
        case 'ucs2':
        case 'ucs-2':
        case 'utf16le':
        case 'utf-16le':
          return !0
        default:
          return !1
      }
    }),
    (o.concat = function (E, A) {
      if (!Array.isArray(E)) throw new TypeError('"list" argument must be an Array of Buffers')
      if (E.length === 0) return o.alloc(0)
      var z
      if (A === void 0) for (A = 0, z = 0; z < E.length; ++z) A += E[z].length
      var W = o.allocUnsafe(A),
        te = 0
      for (z = 0; z < E.length; ++z) {
        var ne = E[z]
        if (Ne(ne, Uint8Array))
          te + ne.length > W.length
            ? o.from(ne).copy(W, te)
            : Uint8Array.prototype.set.call(W, ne, te)
        else if (o.isBuffer(ne)) ne.copy(W, te)
        else throw new TypeError('"list" argument must be an Array of Buffers')
        te += ne.length
      }
      return W
    })
  function y(F, E) {
    if (o.isBuffer(F)) return F.length
    if (ArrayBuffer.isView(F) || Ne(F, ArrayBuffer)) return F.byteLength
    if (typeof F != 'string')
      throw new TypeError(
        'The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' +
          typeof F
      )
    var A = F.length,
      z = arguments.length > 2 && arguments[2] === !0
    if (!z && A === 0) return 0
    for (var W = !1; ; )
      switch (E) {
        case 'ascii':
        case 'latin1':
        case 'binary':
          return A
        case 'utf8':
        case 'utf-8':
          return ce(F).length
        case 'ucs2':
        case 'ucs-2':
        case 'utf16le':
        case 'utf-16le':
          return A * 2
        case 'hex':
          return A >>> 1
        case 'base64':
          return me(F).length
        default:
          if (W) return z ? -1 : ce(F).length
          ;(E = ('' + E).toLowerCase()), (W = !0)
      }
  }
  o.byteLength = y
  function x(F, E, A) {
    var z = !1
    if (
      ((E === void 0 || E < 0) && (E = 0),
      E > this.length ||
        ((A === void 0 || A > this.length) && (A = this.length), A <= 0) ||
        ((A >>>= 0), (E >>>= 0), A <= E))
    )
      return ''
    for (F || (F = 'utf8'); ; )
      switch (F) {
        case 'hex':
          return Y(this, E, A)
        case 'utf8':
        case 'utf-8':
          return j(this, E, A)
        case 'ascii':
          return L(this, E, A)
        case 'latin1':
        case 'binary':
          return P(this, E, A)
        case 'base64':
          return V(this, E, A)
        case 'ucs2':
        case 'ucs-2':
        case 'utf16le':
        case 'utf-16le':
          return w(this, E, A)
        default:
          if (z) throw new TypeError('Unknown encoding: ' + F)
          ;(F = (F + '').toLowerCase()), (z = !0)
      }
  }
  o.prototype._isBuffer = !0
  function D(F, E, A) {
    var z = F[E]
    ;(F[E] = F[A]), (F[A] = z)
  }
  ;(o.prototype.swap16 = function () {
    var E = this.length
    if (E % 2 !== 0) throw new RangeError('Buffer size must be a multiple of 16-bits')
    for (var A = 0; A < E; A += 2) D(this, A, A + 1)
    return this
  }),
    (o.prototype.swap32 = function () {
      var E = this.length
      if (E % 4 !== 0) throw new RangeError('Buffer size must be a multiple of 32-bits')
      for (var A = 0; A < E; A += 4) D(this, A, A + 3), D(this, A + 1, A + 2)
      return this
    }),
    (o.prototype.swap64 = function () {
      var E = this.length
      if (E % 8 !== 0) throw new RangeError('Buffer size must be a multiple of 64-bits')
      for (var A = 0; A < E; A += 8)
        D(this, A, A + 7), D(this, A + 1, A + 6), D(this, A + 2, A + 5), D(this, A + 3, A + 4)
      return this
    }),
    (o.prototype.toString = function () {
      var E = this.length
      return E === 0 ? '' : arguments.length === 0 ? j(this, 0, E) : x.apply(this, arguments)
    }),
    (o.prototype.toLocaleString = o.prototype.toString),
    (o.prototype.equals = function (E) {
      if (!o.isBuffer(E)) throw new TypeError('Argument must be a Buffer')
      return this === E ? !0 : o.compare(this, E) === 0
    }),
    (o.prototype.inspect = function () {
      var E = '',
        A = e.INSPECT_MAX_BYTES
      return (
        (E = this.toString('hex', 0, A)
          .replace(/(.{2})/g, '$1 ')
          .trim()),
        this.length > A && (E += ' ... '),
        '<Buffer ' + E + '>'
      )
    }),
    i && (o.prototype[i] = o.prototype.inspect),
    (o.prototype.compare = function (E, A, z, W, te) {
      if ((Ne(E, Uint8Array) && (E = o.from(E, E.offset, E.byteLength)), !o.isBuffer(E)))
        throw new TypeError(
          'The "target" argument must be one of type Buffer or Uint8Array. Received type ' +
            typeof E
        )
      if (
        (A === void 0 && (A = 0),
        z === void 0 && (z = E ? E.length : 0),
        W === void 0 && (W = 0),
        te === void 0 && (te = this.length),
        A < 0 || z > E.length || W < 0 || te > this.length)
      )
        throw new RangeError('out of range index')
      if (W >= te && A >= z) return 0
      if (W >= te) return -1
      if (A >= z) return 1
      if (((A >>>= 0), (z >>>= 0), (W >>>= 0), (te >>>= 0), this === E)) return 0
      for (
        var ne = te - W,
          Te = z - A,
          De = Math.min(ne, Te),
          K = this.slice(W, te),
          se = E.slice(A, z),
          pe = 0;
        pe < De;
        ++pe
      )
        if (K[pe] !== se[pe]) {
          ;(ne = K[pe]), (Te = se[pe])
          break
        }
      return ne < Te ? -1 : Te < ne ? 1 : 0
    })
  function C(F, E, A, z, W) {
    if (F.length === 0) return -1
    if (
      (typeof A == 'string'
        ? ((z = A), (A = 0))
        : A > 2147483647
        ? (A = 2147483647)
        : A < -2147483648 && (A = -2147483648),
      (A = +A),
      Oe(A) && (A = W ? 0 : F.length - 1),
      A < 0 && (A = F.length + A),
      A >= F.length)
    ) {
      if (W) return -1
      A = F.length - 1
    } else if (A < 0)
      if (W) A = 0
      else return -1
    if ((typeof E == 'string' && (E = o.from(E, z)), o.isBuffer(E)))
      return E.length === 0 ? -1 : H(F, E, A, z, W)
    if (typeof E == 'number')
      return (
        (E = E & 255),
        typeof Uint8Array.prototype.indexOf == 'function'
          ? W
            ? Uint8Array.prototype.indexOf.call(F, E, A)
            : Uint8Array.prototype.lastIndexOf.call(F, E, A)
          : H(F, [E], A, z, W)
      )
    throw new TypeError('val must be string, number or Buffer')
  }
  function H(F, E, A, z, W) {
    var te = 1,
      ne = F.length,
      Te = E.length
    if (
      z !== void 0 &&
      ((z = String(z).toLowerCase()),
      z === 'ucs2' || z === 'ucs-2' || z === 'utf16le' || z === 'utf-16le')
    ) {
      if (F.length < 2 || E.length < 2) return -1
      ;(te = 2), (ne /= 2), (Te /= 2), (A /= 2)
    }
    function De(Ce, ze) {
      return te === 1 ? Ce[ze] : Ce.readUInt16BE(ze * te)
    }
    var K
    if (W) {
      var se = -1
      for (K = A; K < ne; K++)
        if (De(F, K) === De(E, se === -1 ? 0 : K - se)) {
          if ((se === -1 && (se = K), K - se + 1 === Te)) return se * te
        } else se !== -1 && (K -= K - se), (se = -1)
    } else
      for (A + Te > ne && (A = ne - Te), K = A; K >= 0; K--) {
        for (var pe = !0, ve = 0; ve < Te; ve++)
          if (De(F, K + ve) !== De(E, ve)) {
            pe = !1
            break
          }
        if (pe) return K
      }
    return -1
  }
  ;(o.prototype.includes = function (E, A, z) {
    return this.indexOf(E, A, z) !== -1
  }),
    (o.prototype.indexOf = function (E, A, z) {
      return C(this, E, A, z, !0)
    }),
    (o.prototype.lastIndexOf = function (E, A, z) {
      return C(this, E, A, z, !1)
    })
  function T(F, E, A, z) {
    A = Number(A) || 0
    var W = F.length - A
    z ? ((z = Number(z)), z > W && (z = W)) : (z = W)
    var te = E.length
    z > te / 2 && (z = te / 2)
    for (var ne = 0; ne < z; ++ne) {
      var Te = parseInt(E.substr(ne * 2, 2), 16)
      if (Oe(Te)) return ne
      F[A + ne] = Te
    }
    return ne
  }
  function k(F, E, A, z) {
    return be(ce(E, F.length - A), F, A, z)
  }
  function O(F, E, A, z) {
    return be(fe(E), F, A, z)
  }
  function N(F, E, A, z) {
    return be(me(E), F, A, z)
  }
  function M(F, E, A, z) {
    return be(ge(E, F.length - A), F, A, z)
  }
  ;(o.prototype.write = function (E, A, z, W) {
    if (A === void 0) (W = 'utf8'), (z = this.length), (A = 0)
    else if (z === void 0 && typeof A == 'string') (W = A), (z = this.length), (A = 0)
    else if (isFinite(A))
      (A = A >>> 0),
        isFinite(z) ? ((z = z >>> 0), W === void 0 && (W = 'utf8')) : ((W = z), (z = void 0))
    else throw new Error('Buffer.write(string, encoding, offset[, length]) is no longer supported')
    var te = this.length - A
    if (
      ((z === void 0 || z > te) && (z = te), (E.length > 0 && (z < 0 || A < 0)) || A > this.length)
    )
      throw new RangeError('Attempt to write outside buffer bounds')
    W || (W = 'utf8')
    for (var ne = !1; ; )
      switch (W) {
        case 'hex':
          return T(this, E, A, z)
        case 'utf8':
        case 'utf-8':
          return k(this, E, A, z)
        case 'ascii':
        case 'latin1':
        case 'binary':
          return O(this, E, A, z)
        case 'base64':
          return N(this, E, A, z)
        case 'ucs2':
        case 'ucs-2':
        case 'utf16le':
        case 'utf-16le':
          return M(this, E, A, z)
        default:
          if (ne) throw new TypeError('Unknown encoding: ' + W)
          ;(W = ('' + W).toLowerCase()), (ne = !0)
      }
  }),
    (o.prototype.toJSON = function () {
      return { type: 'Buffer', data: Array.prototype.slice.call(this._arr || this, 0) }
    })
  function V(F, E, A) {
    return E === 0 && A === F.length ? t.fromByteArray(F) : t.fromByteArray(F.slice(E, A))
  }
  function j(F, E, A) {
    A = Math.min(F.length, A)
    for (var z = [], W = E; W < A; ) {
      var te = F[W],
        ne = null,
        Te = te > 239 ? 4 : te > 223 ? 3 : te > 191 ? 2 : 1
      if (W + Te <= A) {
        var De, K, se, pe
        switch (Te) {
          case 1:
            te < 128 && (ne = te)
            break
          case 2:
            ;(De = F[W + 1]),
              (De & 192) === 128 && ((pe = ((te & 31) << 6) | (De & 63)), pe > 127 && (ne = pe))
            break
          case 3:
            ;(De = F[W + 1]),
              (K = F[W + 2]),
              (De & 192) === 128 &&
                (K & 192) === 128 &&
                ((pe = ((te & 15) << 12) | ((De & 63) << 6) | (K & 63)),
                pe > 2047 && (pe < 55296 || pe > 57343) && (ne = pe))
            break
          case 4:
            ;(De = F[W + 1]),
              (K = F[W + 2]),
              (se = F[W + 3]),
              (De & 192) === 128 &&
                (K & 192) === 128 &&
                (se & 192) === 128 &&
                ((pe = ((te & 15) << 18) | ((De & 63) << 12) | ((K & 63) << 6) | (se & 63)),
                pe > 65535 && pe < 1114112 && (ne = pe))
        }
      }
      ne === null
        ? ((ne = 65533), (Te = 1))
        : ne > 65535 &&
          ((ne -= 65536), z.push(((ne >>> 10) & 1023) | 55296), (ne = 56320 | (ne & 1023))),
        z.push(ne),
        (W += Te)
    }
    return $(z)
  }
  var R = 4096
  function $(F) {
    var E = F.length
    if (E <= R) return String.fromCharCode.apply(String, F)
    for (var A = '', z = 0; z < E; ) A += String.fromCharCode.apply(String, F.slice(z, (z += R)))
    return A
  }
  function L(F, E, A) {
    var z = ''
    A = Math.min(F.length, A)
    for (var W = E; W < A; ++W) z += String.fromCharCode(F[W] & 127)
    return z
  }
  function P(F, E, A) {
    var z = ''
    A = Math.min(F.length, A)
    for (var W = E; W < A; ++W) z += String.fromCharCode(F[W])
    return z
  }
  function Y(F, E, A) {
    var z = F.length
    ;(!E || E < 0) && (E = 0), (!A || A < 0 || A > z) && (A = z)
    for (var W = '', te = E; te < A; ++te) W += _e[F[te]]
    return W
  }
  function w(F, E, A) {
    for (var z = F.slice(E, A), W = '', te = 0; te < z.length - 1; te += 2)
      W += String.fromCharCode(z[te] + z[te + 1] * 256)
    return W
  }
  o.prototype.slice = function (E, A) {
    var z = this.length
    ;(E = ~~E),
      (A = A === void 0 ? z : ~~A),
      E < 0 ? ((E += z), E < 0 && (E = 0)) : E > z && (E = z),
      A < 0 ? ((A += z), A < 0 && (A = 0)) : A > z && (A = z),
      A < E && (A = E)
    var W = this.subarray(E, A)
    return Object.setPrototypeOf(W, o.prototype), W
  }
  function q(F, E, A) {
    if (F % 1 !== 0 || F < 0) throw new RangeError('offset is not uint')
    if (F + E > A) throw new RangeError('Trying to access beyond buffer length')
  }
  ;(o.prototype.readUintLE = o.prototype.readUIntLE =
    function (E, A, z) {
      ;(E = E >>> 0), (A = A >>> 0), z || q(E, A, this.length)
      for (var W = this[E], te = 1, ne = 0; ++ne < A && (te *= 256); ) W += this[E + ne] * te
      return W
    }),
    (o.prototype.readUintBE = o.prototype.readUIntBE =
      function (E, A, z) {
        ;(E = E >>> 0), (A = A >>> 0), z || q(E, A, this.length)
        for (var W = this[E + --A], te = 1; A > 0 && (te *= 256); ) W += this[E + --A] * te
        return W
      }),
    (o.prototype.readUint8 = o.prototype.readUInt8 =
      function (E, A) {
        return (E = E >>> 0), A || q(E, 1, this.length), this[E]
      }),
    (o.prototype.readUint16LE = o.prototype.readUInt16LE =
      function (E, A) {
        return (E = E >>> 0), A || q(E, 2, this.length), this[E] | (this[E + 1] << 8)
      }),
    (o.prototype.readUint16BE = o.prototype.readUInt16BE =
      function (E, A) {
        return (E = E >>> 0), A || q(E, 2, this.length), (this[E] << 8) | this[E + 1]
      }),
    (o.prototype.readUint32LE = o.prototype.readUInt32LE =
      function (E, A) {
        return (
          (E = E >>> 0),
          A || q(E, 4, this.length),
          (this[E] | (this[E + 1] << 8) | (this[E + 2] << 16)) + this[E + 3] * 16777216
        )
      }),
    (o.prototype.readUint32BE = o.prototype.readUInt32BE =
      function (E, A) {
        return (
          (E = E >>> 0),
          A || q(E, 4, this.length),
          this[E] * 16777216 + ((this[E + 1] << 16) | (this[E + 2] << 8) | this[E + 3])
        )
      }),
    (o.prototype.readIntLE = function (E, A, z) {
      ;(E = E >>> 0), (A = A >>> 0), z || q(E, A, this.length)
      for (var W = this[E], te = 1, ne = 0; ++ne < A && (te *= 256); ) W += this[E + ne] * te
      return (te *= 128), W >= te && (W -= Math.pow(2, 8 * A)), W
    }),
    (o.prototype.readIntBE = function (E, A, z) {
      ;(E = E >>> 0), (A = A >>> 0), z || q(E, A, this.length)
      for (var W = A, te = 1, ne = this[E + --W]; W > 0 && (te *= 256); ) ne += this[E + --W] * te
      return (te *= 128), ne >= te && (ne -= Math.pow(2, 8 * A)), ne
    }),
    (o.prototype.readInt8 = function (E, A) {
      return (
        (E = E >>> 0), A || q(E, 1, this.length), this[E] & 128 ? (255 - this[E] + 1) * -1 : this[E]
      )
    }),
    (o.prototype.readInt16LE = function (E, A) {
      ;(E = E >>> 0), A || q(E, 2, this.length)
      var z = this[E] | (this[E + 1] << 8)
      return z & 32768 ? z | 4294901760 : z
    }),
    (o.prototype.readInt16BE = function (E, A) {
      ;(E = E >>> 0), A || q(E, 2, this.length)
      var z = this[E + 1] | (this[E] << 8)
      return z & 32768 ? z | 4294901760 : z
    }),
    (o.prototype.readInt32LE = function (E, A) {
      return (
        (E = E >>> 0),
        A || q(E, 4, this.length),
        this[E] | (this[E + 1] << 8) | (this[E + 2] << 16) | (this[E + 3] << 24)
      )
    }),
    (o.prototype.readInt32BE = function (E, A) {
      return (
        (E = E >>> 0),
        A || q(E, 4, this.length),
        (this[E] << 24) | (this[E + 1] << 16) | (this[E + 2] << 8) | this[E + 3]
      )
    }),
    (o.prototype.readFloatLE = function (E, A) {
      return (E = E >>> 0), A || q(E, 4, this.length), r.read(this, E, !0, 23, 4)
    }),
    (o.prototype.readFloatBE = function (E, A) {
      return (E = E >>> 0), A || q(E, 4, this.length), r.read(this, E, !1, 23, 4)
    }),
    (o.prototype.readDoubleLE = function (E, A) {
      return (E = E >>> 0), A || q(E, 8, this.length), r.read(this, E, !0, 52, 8)
    }),
    (o.prototype.readDoubleBE = function (E, A) {
      return (E = E >>> 0), A || q(E, 8, this.length), r.read(this, E, !1, 52, 8)
    })
  function X(F, E, A, z, W, te) {
    if (!o.isBuffer(F)) throw new TypeError('"buffer" argument must be a Buffer instance')
    if (E > W || E < te) throw new RangeError('"value" argument is out of bounds')
    if (A + z > F.length) throw new RangeError('Index out of range')
  }
  ;(o.prototype.writeUintLE = o.prototype.writeUIntLE =
    function (E, A, z, W) {
      if (((E = +E), (A = A >>> 0), (z = z >>> 0), !W)) {
        var te = Math.pow(2, 8 * z) - 1
        X(this, E, A, z, te, 0)
      }
      var ne = 1,
        Te = 0
      for (this[A] = E & 255; ++Te < z && (ne *= 256); ) this[A + Te] = (E / ne) & 255
      return A + z
    }),
    (o.prototype.writeUintBE = o.prototype.writeUIntBE =
      function (E, A, z, W) {
        if (((E = +E), (A = A >>> 0), (z = z >>> 0), !W)) {
          var te = Math.pow(2, 8 * z) - 1
          X(this, E, A, z, te, 0)
        }
        var ne = z - 1,
          Te = 1
        for (this[A + ne] = E & 255; --ne >= 0 && (Te *= 256); ) this[A + ne] = (E / Te) & 255
        return A + z
      }),
    (o.prototype.writeUint8 = o.prototype.writeUInt8 =
      function (E, A, z) {
        return (E = +E), (A = A >>> 0), z || X(this, E, A, 1, 255, 0), (this[A] = E & 255), A + 1
      }),
    (o.prototype.writeUint16LE = o.prototype.writeUInt16LE =
      function (E, A, z) {
        return (
          (E = +E),
          (A = A >>> 0),
          z || X(this, E, A, 2, 65535, 0),
          (this[A] = E & 255),
          (this[A + 1] = E >>> 8),
          A + 2
        )
      }),
    (o.prototype.writeUint16BE = o.prototype.writeUInt16BE =
      function (E, A, z) {
        return (
          (E = +E),
          (A = A >>> 0),
          z || X(this, E, A, 2, 65535, 0),
          (this[A] = E >>> 8),
          (this[A + 1] = E & 255),
          A + 2
        )
      }),
    (o.prototype.writeUint32LE = o.prototype.writeUInt32LE =
      function (E, A, z) {
        return (
          (E = +E),
          (A = A >>> 0),
          z || X(this, E, A, 4, 4294967295, 0),
          (this[A + 3] = E >>> 24),
          (this[A + 2] = E >>> 16),
          (this[A + 1] = E >>> 8),
          (this[A] = E & 255),
          A + 4
        )
      }),
    (o.prototype.writeUint32BE = o.prototype.writeUInt32BE =
      function (E, A, z) {
        return (
          (E = +E),
          (A = A >>> 0),
          z || X(this, E, A, 4, 4294967295, 0),
          (this[A] = E >>> 24),
          (this[A + 1] = E >>> 16),
          (this[A + 2] = E >>> 8),
          (this[A + 3] = E & 255),
          A + 4
        )
      }),
    (o.prototype.writeIntLE = function (E, A, z, W) {
      if (((E = +E), (A = A >>> 0), !W)) {
        var te = Math.pow(2, 8 * z - 1)
        X(this, E, A, z, te - 1, -te)
      }
      var ne = 0,
        Te = 1,
        De = 0
      for (this[A] = E & 255; ++ne < z && (Te *= 256); )
        E < 0 && De === 0 && this[A + ne - 1] !== 0 && (De = 1),
          (this[A + ne] = (((E / Te) >> 0) - De) & 255)
      return A + z
    }),
    (o.prototype.writeIntBE = function (E, A, z, W) {
      if (((E = +E), (A = A >>> 0), !W)) {
        var te = Math.pow(2, 8 * z - 1)
        X(this, E, A, z, te - 1, -te)
      }
      var ne = z - 1,
        Te = 1,
        De = 0
      for (this[A + ne] = E & 255; --ne >= 0 && (Te *= 256); )
        E < 0 && De === 0 && this[A + ne + 1] !== 0 && (De = 1),
          (this[A + ne] = (((E / Te) >> 0) - De) & 255)
      return A + z
    }),
    (o.prototype.writeInt8 = function (E, A, z) {
      return (
        (E = +E),
        (A = A >>> 0),
        z || X(this, E, A, 1, 127, -128),
        E < 0 && (E = 255 + E + 1),
        (this[A] = E & 255),
        A + 1
      )
    }),
    (o.prototype.writeInt16LE = function (E, A, z) {
      return (
        (E = +E),
        (A = A >>> 0),
        z || X(this, E, A, 2, 32767, -32768),
        (this[A] = E & 255),
        (this[A + 1] = E >>> 8),
        A + 2
      )
    }),
    (o.prototype.writeInt16BE = function (E, A, z) {
      return (
        (E = +E),
        (A = A >>> 0),
        z || X(this, E, A, 2, 32767, -32768),
        (this[A] = E >>> 8),
        (this[A + 1] = E & 255),
        A + 2
      )
    }),
    (o.prototype.writeInt32LE = function (E, A, z) {
      return (
        (E = +E),
        (A = A >>> 0),
        z || X(this, E, A, 4, 2147483647, -2147483648),
        (this[A] = E & 255),
        (this[A + 1] = E >>> 8),
        (this[A + 2] = E >>> 16),
        (this[A + 3] = E >>> 24),
        A + 4
      )
    }),
    (o.prototype.writeInt32BE = function (E, A, z) {
      return (
        (E = +E),
        (A = A >>> 0),
        z || X(this, E, A, 4, 2147483647, -2147483648),
        E < 0 && (E = 4294967295 + E + 1),
        (this[A] = E >>> 24),
        (this[A + 1] = E >>> 16),
        (this[A + 2] = E >>> 8),
        (this[A + 3] = E & 255),
        A + 4
      )
    })
  function I(F, E, A, z, W, te) {
    if (A + z > F.length) throw new RangeError('Index out of range')
    if (A < 0) throw new RangeError('Index out of range')
  }
  function re(F, E, A, z, W) {
    return (E = +E), (A = A >>> 0), W || I(F, E, A, 4), r.write(F, E, A, z, 23, 4), A + 4
  }
  ;(o.prototype.writeFloatLE = function (E, A, z) {
    return re(this, E, A, !0, z)
  }),
    (o.prototype.writeFloatBE = function (E, A, z) {
      return re(this, E, A, !1, z)
    })
  function ie(F, E, A, z, W) {
    return (E = +E), (A = A >>> 0), W || I(F, E, A, 8), r.write(F, E, A, z, 52, 8), A + 8
  }
  ;(o.prototype.writeDoubleLE = function (E, A, z) {
    return ie(this, E, A, !0, z)
  }),
    (o.prototype.writeDoubleBE = function (E, A, z) {
      return ie(this, E, A, !1, z)
    }),
    (o.prototype.copy = function (E, A, z, W) {
      if (!o.isBuffer(E)) throw new TypeError('argument should be a Buffer')
      if (
        (z || (z = 0),
        !W && W !== 0 && (W = this.length),
        A >= E.length && (A = E.length),
        A || (A = 0),
        W > 0 && W < z && (W = z),
        W === z || E.length === 0 || this.length === 0)
      )
        return 0
      if (A < 0) throw new RangeError('targetStart out of bounds')
      if (z < 0 || z >= this.length) throw new RangeError('Index out of range')
      if (W < 0) throw new RangeError('sourceEnd out of bounds')
      W > this.length && (W = this.length), E.length - A < W - z && (W = E.length - A + z)
      var te = W - z
      return (
        this === E && typeof Uint8Array.prototype.copyWithin == 'function'
          ? this.copyWithin(A, z, W)
          : Uint8Array.prototype.set.call(E, this.subarray(z, W), A),
        te
      )
    }),
    (o.prototype.fill = function (E, A, z, W) {
      if (typeof E == 'string') {
        if (
          (typeof A == 'string'
            ? ((W = A), (A = 0), (z = this.length))
            : typeof z == 'string' && ((W = z), (z = this.length)),
          W !== void 0 && typeof W != 'string')
        )
          throw new TypeError('encoding must be a string')
        if (typeof W == 'string' && !o.isEncoding(W)) throw new TypeError('Unknown encoding: ' + W)
        if (E.length === 1) {
          var te = E.charCodeAt(0)
          ;((W === 'utf8' && te < 128) || W === 'latin1') && (E = te)
        }
      } else typeof E == 'number' ? (E = E & 255) : typeof E == 'boolean' && (E = Number(E))
      if (A < 0 || this.length < A || this.length < z) throw new RangeError('Out of range index')
      if (z <= A) return this
      ;(A = A >>> 0), (z = z === void 0 ? this.length : z >>> 0), E || (E = 0)
      var ne
      if (typeof E == 'number') for (ne = A; ne < z; ++ne) this[ne] = E
      else {
        var Te = o.isBuffer(E) ? E : o.from(E, W),
          De = Te.length
        if (De === 0) throw new TypeError('The value "' + E + '" is invalid for argument "value"')
        for (ne = 0; ne < z - A; ++ne) this[ne + A] = Te[ne % De]
      }
      return this
    })
  var Z = /[^+/0-9A-Za-z-_]/g
  function oe(F) {
    if (((F = F.split('=')[0]), (F = F.trim().replace(Z, '')), F.length < 2)) return ''
    for (; F.length % 4 !== 0; ) F = F + '='
    return F
  }
  function ce(F, E) {
    E = E || 1 / 0
    for (var A, z = F.length, W = null, te = [], ne = 0; ne < z; ++ne) {
      if (((A = F.charCodeAt(ne)), A > 55295 && A < 57344)) {
        if (!W) {
          if (A > 56319) {
            ;(E -= 3) > -1 && te.push(239, 191, 189)
            continue
          } else if (ne + 1 === z) {
            ;(E -= 3) > -1 && te.push(239, 191, 189)
            continue
          }
          W = A
          continue
        }
        if (A < 56320) {
          ;(E -= 3) > -1 && te.push(239, 191, 189), (W = A)
          continue
        }
        A = (((W - 55296) << 10) | (A - 56320)) + 65536
      } else W && (E -= 3) > -1 && te.push(239, 191, 189)
      if (((W = null), A < 128)) {
        if ((E -= 1) < 0) break
        te.push(A)
      } else if (A < 2048) {
        if ((E -= 2) < 0) break
        te.push((A >> 6) | 192, (A & 63) | 128)
      } else if (A < 65536) {
        if ((E -= 3) < 0) break
        te.push((A >> 12) | 224, ((A >> 6) & 63) | 128, (A & 63) | 128)
      } else if (A < 1114112) {
        if ((E -= 4) < 0) break
        te.push((A >> 18) | 240, ((A >> 12) & 63) | 128, ((A >> 6) & 63) | 128, (A & 63) | 128)
      } else throw new Error('Invalid code point')
    }
    return te
  }
  function fe(F) {
    for (var E = [], A = 0; A < F.length; ++A) E.push(F.charCodeAt(A) & 255)
    return E
  }
  function ge(F, E) {
    for (var A, z, W, te = [], ne = 0; ne < F.length && !((E -= 2) < 0); ++ne)
      (A = F.charCodeAt(ne)), (z = A >> 8), (W = A % 256), te.push(W), te.push(z)
    return te
  }
  function me(F) {
    return t.toByteArray(oe(F))
  }
  function be(F, E, A, z) {
    for (var W = 0; W < z && !(W + A >= E.length || W >= F.length); ++W) E[W + A] = F[W]
    return W
  }
  function Ne(F, E) {
    return (
      F instanceof E ||
      (F != null &&
        F.constructor != null &&
        F.constructor.name != null &&
        F.constructor.name === E.name)
    )
  }
  function Oe(F) {
    return F !== F
  }
  var _e = (function () {
    for (var F = '0123456789abcdef', E = new Array(256), A = 0; A < 16; ++A)
      for (var z = A * 16, W = 0; W < 16; ++W) E[z + W] = F[A] + F[W]
    return E
  })()
})($b)
const { Buffer: fa } = $b
function Lr(...e) {
  const t = new Lr.Request(...e),
    r = new XMLHttpRequest()
  ;(r.withCredentials = t.credentials === 'include'),
    (r.timeout = t[de].timeout),
    r.open(t.method, t.url, !1)
  let i = !1
  try {
    r.responseType = 'arraybuffer'
  } catch {
    r.overrideMimeType('text/plain; charset=x-user-defined'), (i = !0)
  }
  for (const o of t.headers) r.setRequestHeader(...o)
  r.send(t.body || null)
  let n = r.getAllResponseHeaders()
  n =
    n &&
    n
      .split(
        `\r
`
      )
      .filter(Boolean)
      .map((o) => o.split(': ', 2))
  let s = r.response
  if (i) {
    const o = fa.alloc(s.length)
    for (let u = 0; u < s.length; u++) o[u] = s.charCodeAt(u) & 255
    s = o
  }
  const a = new Lr.Response(s, { headers: n, status: r.status, statusText: r.statusText })
  return (a[de].url = r.responseURL), (a[de].redirected = r.responseURL !== t.url), a
}
const de = Symbol('SyncFetch Internals'),
  H3 = ['mode', 'cache', 'redirect', 'referrer', 'integrity'],
  z3 = {
    100: 'Continue',
    101: 'Switching Protocols',
    200: 'OK',
    201: 'Created',
    202: 'Accepted',
    203: 'Non-Authoritative Information',
    204: 'No Content',
    205: 'Reset Content',
    206: 'Partial Content',
    300: 'Multiple Choices',
    301: 'Moved Permanently',
    302: 'Found',
    303: 'See Other',
    304: 'Not Modified',
    305: 'Use Proxy',
    307: 'Temporary Redirect',
    400: 'Bad Request',
    401: 'Unauthorized',
    402: 'Payment Required',
    403: 'Forbidden',
    404: 'Not Found',
    405: 'Method Not Allowed',
    406: 'Not Acceptable',
    407: 'Proxy Authentication Required',
    408: 'Request Timeout',
    409: 'Conflict',
    410: 'Gone',
    411: 'Length Required',
    412: 'Precondition Failed',
    413: 'Payload Too Large',
    414: 'URI Too Long',
    415: 'Unsupported Media Type',
    416: 'Range Not Satisfiable',
    417: 'Expectation Failed',
    426: 'Upgrade Required',
    500: 'Internal Server Error',
    501: 'Not Implemented',
    502: 'Bad Gateway',
    503: 'Service Unavailable',
    504: 'Gateway Timeout',
    505: 'HTTP Version Not Supported',
  }
class $s {
  constructor(t, r = {}) {
    for (const i of H3) if (i in r) throw new TypeError(`option ${i} not supported`)
    if (r.credentials === 'same-origin')
      throw new TypeError("option credentials with value 'same-origin' not supported")
    if (
      ((this[de] = {
        method: r.method || 'GET',
        headers: new Lr.Headers(r.headers),
        body: r.body ? fa.from(r.body) : null,
        credentials: r.credentials || 'omit',
        timeout: r.timeout || 0,
      }),
      typeof t == 'string')
    )
      this[de].url = t
    else if (t instanceof $s)
      (this[de].url = t.url),
        r.method || (this[de].method = t.method),
        r.headers || (this[de].headers = t.headers),
        r.body || (this[de].body = t[de].body),
        r.credentials || (this[de].credentials = t.credentials)
    else throw new TypeError('Request input should be a URL string or a Request object')
  }
  get cache() {
    return 'default'
  }
  get credentials() {
    return this[de].credentials
  }
  get destination() {
    return ''
  }
  get headers() {
    return this[de].headers
  }
  get integrity() {
    return ''
  }
  get method() {
    return this[de].method
  }
  get mode() {
    return 'cors'
  }
  get priority() {
    return 'auto'
  }
  get redirect() {
    return 'follow'
  }
  get referrer() {
    return 'about:client'
  }
  get referrerPolicy() {
    return ''
  }
  get url() {
    return this[de].url
  }
  clone() {
    return Ap(this), new $s(this.url, this[de])
  }
}
class Eu {
  constructor(t, r = {}) {
    this[de] = {
      body: t ? fa.from(t) : null,
      bodyUsed: !1,
      headers: new Lr.Headers(r.headers),
      status: r.status,
      statusText: r.statusText,
    }
  }
  get headers() {
    return this[de].headers
  }
  get ok() {
    const t = this[de].status
    return t >= 200 && t < 300
  }
  get redirected() {
    return this[de].redirected
  }
  get status() {
    return this[de].status
  }
  get statusText() {
    return this[de].statusText
  }
  get url() {
    return this[de].url
  }
  clone() {
    return this.redirect(this[de].url, this[de].status)
  }
  redirect(t, r) {
    Ap(this)
    const i = new Eu(this[de].body, {
      headers: this[de].headers,
      status: r || this[de].status,
      statusText: z3[r] || this[de].statusText,
    })
    return (i[de].url = t || this[de].url), (i[de].redirected = this[de].redirected), i
  }
}
class Vs {
  constructor(t) {
    this[de] = { body: fa.from(t), bodyUsed: !1 }
  }
  get bodyUsed() {
    return this[de].bodyUsed
  }
  static mixin(t) {
    for (const r of Object.getOwnPropertyNames(Vs.prototype)) {
      if (r === 'constructor') continue
      const i = Object.getOwnPropertyDescriptor(Vs.prototype, r)
      Object.defineProperty(t, r, { ...i, enumerable: !0 })
    }
  }
  arrayBuffer() {
    const t = Jn(this)
    return t.buffer.slice(t.byteOffset, t.byteOffset + t.byteLength)
  }
  blob() {
    const t = this.headers && this.headers.get('content-type')
    return new Blob([Jn(this)], t && { type: t })
  }
  text() {
    return Jn(this).toString()
  }
  json() {
    try {
      return JSON.parse(Jn(this).toString())
    } catch (t) {
      throw new TypeError(
        `invalid json response body at ${this.url} reason: ${t.message}`,
        'invalid-json'
      )
    }
  }
  buffer() {
    return Jn(this).clone()
  }
}
function Ap(e) {
  if (e.bodyUsed) throw new TypeError(`body used already for: ${e.url}`)
}
function Jn(e) {
  return Ap(e), (e[de].bodyUsed = !0), e[de].body || fa.alloc(0)
}
Vs.mixin($s.prototype)
Vs.mixin(Eu.prototype)
let j3 = class {
  constructor(t) {
    if (t instanceof Lr.Headers) this[de] = { ...t[de] }
    else if (((this[de] = {}), Array.isArray(t))) for (const [r, i] of t) this.append(r, i)
    else if (typeof t == 'object') for (const r in t) this.set(r, t[r])
  }
  append(t, r) {
    ;(t = t.toLowerCase()), this[de][t] || (this[de][t] = []), this[de][t].push(r)
  }
  delete(t) {
    delete this[de][t.toLowerCase()]
  }
  set(t, r) {
    this[de][t.toLowerCase()] = [r]
  }
  entries() {
    const t = []
    for (const r in this[de]) for (const i of this[de][r]) t.push([r, i])
    return t
  }
  get(t) {
    return (t = t.toLowerCase()), t in this[de] ? this[de][t].join(', ') : null
  }
  keys() {
    return Object.keys(this[de])
  }
  has(t) {
    return t.toLowerCase() in this[de]
  }
  values() {
    const t = []
    for (const r in this[de]) for (const i of this[de][r]) t.push(i)
    return t
  }
  *[Symbol.iterator]() {
    for (const t in this[de]) for (const r of this[de][t]) yield [t, r]
  }
}
Lr.Headers = j3
Lr.Request = $s
Lr.Response = Eu
var q3 = Lr
const Gb = ci(q3)
var $c = { exports: {} }
;(function (e, t) {
  ;(function (r) {
    function i(n) {
      var s = (n && n.Promise) || r.Promise,
        a = (n && n.XMLHttpRequest) || r.XMLHttpRequest
      return (function () {
        var o = Object.create(r, { fetch: { value: void 0, writable: !0 } })
        return (
          (function (u, c) {
            c(t)
          })(this, function (u) {
            var c = (typeof o < 'u' && o) || (typeof self < 'u' && self) || (typeof c < 'u' && c),
              f = {
                searchParams: 'URLSearchParams' in c,
                iterable: 'Symbol' in c && 'iterator' in Symbol,
                blob:
                  'FileReader' in c &&
                  'Blob' in c &&
                  (function () {
                    try {
                      return new Blob(), !0
                    } catch {
                      return !1
                    }
                  })(),
                formData: 'FormData' in c,
                arrayBuffer: 'ArrayBuffer' in c,
              }
            function h(L) {
              return L && DataView.prototype.isPrototypeOf(L)
            }
            if (f.arrayBuffer)
              var p = [
                  '[object Int8Array]',
                  '[object Uint8Array]',
                  '[object Uint8ClampedArray]',
                  '[object Int16Array]',
                  '[object Uint16Array]',
                  '[object Int32Array]',
                  '[object Uint32Array]',
                  '[object Float32Array]',
                  '[object Float64Array]',
                ],
                m =
                  ArrayBuffer.isView ||
                  function (L) {
                    return L && p.indexOf(Object.prototype.toString.call(L)) > -1
                  }
            function v(L) {
              if (
                (typeof L != 'string' && (L = String(L)),
                /[^a-z0-9\-#$%&'*+.^_`|~!]/i.test(L) || L === '')
              )
                throw new TypeError('Invalid character in header field name')
              return L.toLowerCase()
            }
            function b(L) {
              return typeof L != 'string' && (L = String(L)), L
            }
            function S(L) {
              var P = {
                next: function () {
                  var Y = L.shift()
                  return { done: Y === void 0, value: Y }
                },
              }
              return (
                f.iterable &&
                  (P[Symbol.iterator] = function () {
                    return P
                  }),
                P
              )
            }
            function g(L) {
              ;(this.map = {}),
                L instanceof g
                  ? L.forEach(function (P, Y) {
                      this.append(Y, P)
                    }, this)
                  : Array.isArray(L)
                  ? L.forEach(function (P) {
                      this.append(P[0], P[1])
                    }, this)
                  : L &&
                    Object.getOwnPropertyNames(L).forEach(function (P) {
                      this.append(P, L[P])
                    }, this)
            }
            ;(g.prototype.append = function (L, P) {
              ;(L = v(L)), (P = b(P))
              var Y = this.map[L]
              this.map[L] = Y ? Y + ', ' + P : P
            }),
              (g.prototype.delete = function (L) {
                delete this.map[v(L)]
              }),
              (g.prototype.get = function (L) {
                return (L = v(L)), this.has(L) ? this.map[L] : null
              }),
              (g.prototype.has = function (L) {
                return this.map.hasOwnProperty(v(L))
              }),
              (g.prototype.set = function (L, P) {
                this.map[v(L)] = b(P)
              }),
              (g.prototype.forEach = function (L, P) {
                for (var Y in this.map)
                  this.map.hasOwnProperty(Y) && L.call(P, this.map[Y], Y, this)
              }),
              (g.prototype.keys = function () {
                var L = []
                return (
                  this.forEach(function (P, Y) {
                    L.push(Y)
                  }),
                  S(L)
                )
              }),
              (g.prototype.values = function () {
                var L = []
                return (
                  this.forEach(function (P) {
                    L.push(P)
                  }),
                  S(L)
                )
              }),
              (g.prototype.entries = function () {
                var L = []
                return (
                  this.forEach(function (P, Y) {
                    L.push([Y, P])
                  }),
                  S(L)
                )
              }),
              f.iterable && (g.prototype[Symbol.iterator] = g.prototype.entries)
            function _(L) {
              if (L.bodyUsed) return s.reject(new TypeError('Already read'))
              L.bodyUsed = !0
            }
            function y(L) {
              return new s(function (P, Y) {
                ;(L.onload = function () {
                  P(L.result)
                }),
                  (L.onerror = function () {
                    Y(L.error)
                  })
              })
            }
            function x(L) {
              var P = new FileReader(),
                Y = y(P)
              return P.readAsArrayBuffer(L), Y
            }
            function D(L) {
              var P = new FileReader(),
                Y = y(P)
              return P.readAsText(L), Y
            }
            function C(L) {
              for (var P = new Uint8Array(L), Y = new Array(P.length), w = 0; w < P.length; w++)
                Y[w] = String.fromCharCode(P[w])
              return Y.join('')
            }
            function H(L) {
              if (L.slice) return L.slice(0)
              var P = new Uint8Array(L.byteLength)
              return P.set(new Uint8Array(L)), P.buffer
            }
            function T() {
              return (
                (this.bodyUsed = !1),
                (this._initBody = function (L) {
                  ;(this.bodyUsed = this.bodyUsed),
                    (this._bodyInit = L),
                    L
                      ? typeof L == 'string'
                        ? (this._bodyText = L)
                        : f.blob && Blob.prototype.isPrototypeOf(L)
                        ? (this._bodyBlob = L)
                        : f.formData && FormData.prototype.isPrototypeOf(L)
                        ? (this._bodyFormData = L)
                        : f.searchParams && URLSearchParams.prototype.isPrototypeOf(L)
                        ? (this._bodyText = L.toString())
                        : f.arrayBuffer && f.blob && h(L)
                        ? ((this._bodyArrayBuffer = H(L.buffer)),
                          (this._bodyInit = new Blob([this._bodyArrayBuffer])))
                        : f.arrayBuffer && (ArrayBuffer.prototype.isPrototypeOf(L) || m(L))
                        ? (this._bodyArrayBuffer = H(L))
                        : (this._bodyText = L = Object.prototype.toString.call(L))
                      : (this._bodyText = ''),
                    this.headers.get('content-type') ||
                      (typeof L == 'string'
                        ? this.headers.set('content-type', 'text/plain;charset=UTF-8')
                        : this._bodyBlob && this._bodyBlob.type
                        ? this.headers.set('content-type', this._bodyBlob.type)
                        : f.searchParams &&
                          URLSearchParams.prototype.isPrototypeOf(L) &&
                          this.headers.set(
                            'content-type',
                            'application/x-www-form-urlencoded;charset=UTF-8'
                          ))
                }),
                f.blob &&
                  ((this.blob = function () {
                    var L = _(this)
                    if (L) return L
                    if (this._bodyBlob) return s.resolve(this._bodyBlob)
                    if (this._bodyArrayBuffer) return s.resolve(new Blob([this._bodyArrayBuffer]))
                    if (this._bodyFormData) throw new Error('could not read FormData body as blob')
                    return s.resolve(new Blob([this._bodyText]))
                  }),
                  (this.arrayBuffer = function () {
                    if (this._bodyArrayBuffer) {
                      var L = _(this)
                      return (
                        L ||
                        (ArrayBuffer.isView(this._bodyArrayBuffer)
                          ? s.resolve(
                              this._bodyArrayBuffer.buffer.slice(
                                this._bodyArrayBuffer.byteOffset,
                                this._bodyArrayBuffer.byteOffset + this._bodyArrayBuffer.byteLength
                              )
                            )
                          : s.resolve(this._bodyArrayBuffer))
                      )
                    } else return this.blob().then(x)
                  })),
                (this.text = function () {
                  var L = _(this)
                  if (L) return L
                  if (this._bodyBlob) return D(this._bodyBlob)
                  if (this._bodyArrayBuffer) return s.resolve(C(this._bodyArrayBuffer))
                  if (this._bodyFormData) throw new Error('could not read FormData body as text')
                  return s.resolve(this._bodyText)
                }),
                f.formData &&
                  (this.formData = function () {
                    return this.text().then(M)
                  }),
                (this.json = function () {
                  return this.text().then(JSON.parse)
                }),
                this
              )
            }
            var k = ['DELETE', 'GET', 'HEAD', 'OPTIONS', 'POST', 'PUT']
            function O(L) {
              var P = L.toUpperCase()
              return k.indexOf(P) > -1 ? P : L
            }
            function N(L, P) {
              if (!(this instanceof N))
                throw new TypeError(
                  'Please use the "new" operator, this DOM object constructor cannot be called as a function.'
                )
              P = P || {}
              var Y = P.body
              if (L instanceof N) {
                if (L.bodyUsed) throw new TypeError('Already read')
                ;(this.url = L.url),
                  (this.credentials = L.credentials),
                  P.headers || (this.headers = new g(L.headers)),
                  (this.method = L.method),
                  (this.mode = L.mode),
                  (this.signal = L.signal),
                  !Y && L._bodyInit != null && ((Y = L._bodyInit), (L.bodyUsed = !0))
              } else this.url = String(L)
              if (
                ((this.credentials = P.credentials || this.credentials || 'same-origin'),
                (P.headers || !this.headers) && (this.headers = new g(P.headers)),
                (this.method = O(P.method || this.method || 'GET')),
                (this.mode = P.mode || this.mode || null),
                (this.signal = P.signal || this.signal),
                (this.referrer = null),
                (this.method === 'GET' || this.method === 'HEAD') && Y)
              )
                throw new TypeError('Body not allowed for GET or HEAD requests')
              if (
                (this._initBody(Y),
                (this.method === 'GET' || this.method === 'HEAD') &&
                  (P.cache === 'no-store' || P.cache === 'no-cache'))
              ) {
                var w = /([?&])_=[^&]*/
                if (w.test(this.url)) this.url = this.url.replace(w, '$1_=' + new Date().getTime())
                else {
                  var q = /\?/
                  this.url += (q.test(this.url) ? '&' : '?') + '_=' + new Date().getTime()
                }
              }
            }
            N.prototype.clone = function () {
              return new N(this, { body: this._bodyInit })
            }
            function M(L) {
              var P = new FormData()
              return (
                L.trim()
                  .split('&')
                  .forEach(function (Y) {
                    if (Y) {
                      var w = Y.split('='),
                        q = w.shift().replace(/\+/g, ' '),
                        X = w.join('=').replace(/\+/g, ' ')
                      P.append(decodeURIComponent(q), decodeURIComponent(X))
                    }
                  }),
                P
              )
            }
            function V(L) {
              var P = new g(),
                Y = L.replace(/\r?\n[\t ]+/g, ' ')
              return (
                Y.split('\r')
                  .map(function (w) {
                    return w.indexOf(`
`) === 0
                      ? w.substr(1, w.length)
                      : w
                  })
                  .forEach(function (w) {
                    var q = w.split(':'),
                      X = q.shift().trim()
                    if (X) {
                      var I = q.join(':').trim()
                      P.append(X, I)
                    }
                  }),
                P
              )
            }
            T.call(N.prototype)
            function j(L, P) {
              if (!(this instanceof j))
                throw new TypeError(
                  'Please use the "new" operator, this DOM object constructor cannot be called as a function.'
                )
              P || (P = {}),
                (this.type = 'default'),
                (this.status = P.status === void 0 ? 200 : P.status),
                (this.ok = this.status >= 200 && this.status < 300),
                (this.statusText = 'statusText' in P ? P.statusText : ''),
                (this.headers = new g(P.headers)),
                (this.url = P.url || ''),
                this._initBody(L)
            }
            T.call(j.prototype),
              (j.prototype.clone = function () {
                return new j(this._bodyInit, {
                  status: this.status,
                  statusText: this.statusText,
                  headers: new g(this.headers),
                  url: this.url,
                })
              }),
              (j.error = function () {
                var L = new j(null, { status: 0, statusText: '' })
                return (L.type = 'error'), L
              })
            var R = [301, 302, 303, 307, 308]
            ;(j.redirect = function (L, P) {
              if (R.indexOf(P) === -1) throw new RangeError('Invalid status code')
              return new j(null, { status: P, headers: { location: L } })
            }),
              (u.DOMException = c.DOMException)
            try {
              new u.DOMException()
            } catch {
              ;(u.DOMException = function (P, Y) {
                ;(this.message = P), (this.name = Y)
                var w = Error(P)
                this.stack = w.stack
              }),
                (u.DOMException.prototype = Object.create(Error.prototype)),
                (u.DOMException.prototype.constructor = u.DOMException)
            }
            function $(L, P) {
              return new s(function (Y, w) {
                var q = new N(L, P)
                if (q.signal && q.signal.aborted)
                  return w(new u.DOMException('Aborted', 'AbortError'))
                var X = new a()
                function I() {
                  X.abort()
                }
                ;(X.onload = function () {
                  var ie = {
                    status: X.status,
                    statusText: X.statusText,
                    headers: V(X.getAllResponseHeaders() || ''),
                  }
                  ie.url = 'responseURL' in X ? X.responseURL : ie.headers.get('X-Request-URL')
                  var Z = 'response' in X ? X.response : X.responseText
                  setTimeout(function () {
                    Y(new j(Z, ie))
                  }, 0)
                }),
                  (X.onerror = function () {
                    setTimeout(function () {
                      w(new TypeError('Network request failed'))
                    }, 0)
                  }),
                  (X.ontimeout = function () {
                    setTimeout(function () {
                      w(new TypeError('Network request failed'))
                    }, 0)
                  }),
                  (X.onabort = function () {
                    setTimeout(function () {
                      w(new u.DOMException('Aborted', 'AbortError'))
                    }, 0)
                  })
                function re(ie) {
                  try {
                    return ie === '' && c.location.href ? c.location.href : ie
                  } catch {
                    return ie
                  }
                }
                X.open(q.method, re(q.url), !0),
                  q.credentials === 'include'
                    ? (X.withCredentials = !0)
                    : q.credentials === 'omit' && (X.withCredentials = !1),
                  'responseType' in X &&
                    (f.blob
                      ? (X.responseType = 'blob')
                      : f.arrayBuffer &&
                        q.headers.get('Content-Type') &&
                        q.headers.get('Content-Type').indexOf('application/octet-stream') !== -1 &&
                        (X.responseType = 'arraybuffer')),
                  P && typeof P.headers == 'object' && !(P.headers instanceof g)
                    ? Object.getOwnPropertyNames(P.headers).forEach(function (ie) {
                        X.setRequestHeader(ie, b(P.headers[ie]))
                      })
                    : q.headers.forEach(function (ie, Z) {
                        X.setRequestHeader(Z, ie)
                      }),
                  q.signal &&
                    (q.signal.addEventListener('abort', I),
                    (X.onreadystatechange = function () {
                      X.readyState === 4 && q.signal.removeEventListener('abort', I)
                    })),
                  X.send(typeof q._bodyInit > 'u' ? null : q._bodyInit)
              })
            }
            ;($.polyfill = !0),
              c.fetch || ((c.fetch = $), (c.Headers = g), (c.Request = N), (c.Response = j)),
              (u.Headers = g),
              (u.Request = N),
              (u.Response = j),
              (u.fetch = $),
              Object.defineProperty(u, '__esModule', { value: !0 })
          }),
          {
            fetch: o.fetch,
            Headers: o.Headers,
            Request: o.Request,
            Response: o.Response,
            DOMException: o.DOMException,
          }
        )
      })()
    }
    e.exports = i
  })(typeof globalThis < 'u' ? globalThis : typeof self < 'u' ? self : mn)
})($c, $c.exports)
var $3 = $c.exports
const V3 = ci($3),
  { fetch: G3, Headers: X3 } = V3(),
  Y3 = typeof location < 'u' && typeof document < 'u'
let W3 = 'Citation.js/0.65'
function Xb(e) {
  const t = {},
    r = e instanceof X3 || e instanceof Gb.Headers ? Array.from(e) : Object.entries(e)
  for (const [i, n] of r) t[i.toLowerCase()] = n.toString()
  return t
}
function Yb(e = {}) {
  const t = { headers: { accept: '*/*' }, method: 'GET', checkContentType: e.checkContentType }
  if ((Y3 || (t.headers['user-agent'] = W3), e.body)) {
    t.method = 'POST'
    const r = typeof e.body != 'string'
    ;(t.body = r ? JSON.stringify(e.body) : e.body),
      (t.headers['content-type'] = r ? 'application/json' : 'text/plain')
  }
  return e.headers && Object.assign(t.headers, Xb(e.headers)), t
}
function Q3(e, t) {
  if (!e.accept || e.accept === '*/*' || !t['content-type']) return !0
  const [r, i] = t['content-type'].split(';')[0].trim().split('/')
  return e.accept
    .split(',')
    .map((n) => n.split(';')[0].trim().split('/'))
    .some(([n, s]) => (n === r || n === '*') && (s === i || s === '*'))
}
function Wb(e, t) {
  const { status: r, headers: i } = e
  let n
  if (
    (r >= 400
      ? (n = new Error(`Server responded with status code ${r}`))
      : t.checkContentType === !0 &&
        !Q3(t.headers, Xb(i)) &&
        (n = new Error(`Server responded with content-type ${i.get('content-type')}`)),
    n)
  )
    throw ((n.status = r), (n.headers = i), (n.body = e.body), n)
  return e
}
function K3(e, t) {
  const r = Yb(t)
  return Ft.http('[core]', r.method, e, r), Wb(Gb(e, r), r).text()
}
async function J3(e, t) {
  const r = Yb(t)
  return (
    Ft.http('[core]', r.method, e, r),
    G3(e, r)
      .then((i) => Wb(i, r))
      .then((i) => i.text())
  )
}
function Qb(e, t) {
  let r
  for (; r === void 0 || e.includes(r); ) r = `${t}${Math.random().toString().slice(2)}`
  return r
}
class xu {
  constructor(t = {}) {
    this.data = t
  }
  set(t, r) {
    return (this.data[t] = r), this
  }
  add(...t) {
    return this.set(...t)
  }
  delete(t) {
    return delete this.data[t], this
  }
  remove(...t) {
    return this.delete(...t)
  }
  get(t) {
    return this.data[t]
  }
  has(t) {
    return Object.prototype.hasOwnProperty.call(this.data, t)
  }
  list() {
    return Object.keys(this.data)
  }
}
class Kb {
  constructor(t, r) {
    ;(this.rules = t), (this.defaultState = r), (this.mainRule = Object.keys(t)[0]), (this.log = [])
  }
  parse(t, r) {
    return (
      (this.lexer = t),
      (this.token = this.lexer.next()),
      (this.state = Bi(this.defaultState)),
      (this.log = []),
      this.consumeRule(r || this.mainRule)
    )
  }
  matchEndOfFile() {
    return !this.token
  }
  matchToken(t) {
    return this.token && t === this.token.type
  }
  consumeToken(t, r) {
    const i = this.token
    if (!t || (i && i.type === t)) return (this.token = this.lexer.next()), i
    if (r) return
    {
      const n = i ? `"${i.type}"` : 'EOF',
        s = new SyntaxError(this.lexer.formatError(i, `expected "${t}", got ${n}`))
      throw ((s.message += ` (${this.log.join('->')})`), s)
    }
  }
  consumeRule(t) {
    this.log.push(t)
    const r = this.rules[t].call(this)
    return this.log.pop(), r
  }
}
function Z3(e) {
  return function (r) {
    return typeof e == 'boolean'
      ? e
      : Object.keys(e).every((i) => {
          const n = e[i]
          return n === !0
            ? i in r
            : n === !1
            ? !(i in r)
            : typeof n == 'function'
            ? n(r[i])
            : Array.isArray(n)
            ? n.includes(r[i])
            : r[i] === n
        })
  }
}
function eO(e, t) {
  let r, i, n, s
  if (typeof e == 'string') r = i = e
  else if (e)
    (r = t ? e.target : e.source),
      (i = t ? e.source : e.target),
      e.convert && (n = t ? e.convert.toSource : e.convert.toTarget),
      e.when && ((s = t ? e.when.target : e.when.source), s != null && (s = Z3(s)))
  else return null
  return (
    (r = [].concat(r).filter(Boolean)),
    (i = [].concat(i).filter(Boolean)),
    { inputProp: r, outputProp: i, convert: n, condition: s }
  )
}
function od(e, t) {
  return (
    (t = t === Pr.CONVERT_TO_SOURCE),
    (e = e.map((r) => eO(r, t)).filter(Boolean)),
    function (i) {
      const n = {}
      for (const { inputProp: s, outputProp: a, convert: o, condition: u } of e) {
        if (a.length === 0) continue
        if (u && !u(i)) continue
        if (s.length !== 0 && s.every((f) => !(f in i))) continue
        let c = s.map((f) => i[f])
        if (o)
          try {
            const f = o.apply(i, c)
            c = a.length === 1 ? [f] : f
          } catch (f) {
            throw new Error(`Failed to convert ${s} to ${a}`, { cause: f })
          }
        a.forEach((f, h) => {
          const p = c[h]
          p !== void 0 && (n[f] = p)
        })
      }
      return n
    }
  )
}
class Pr {
  constructor(t) {
    ;(this.convertToSource = od(t, Pr.CONVERT_TO_SOURCE)),
      (this.convertToTarget = od(t, Pr.CONVERT_TO_TARGET))
  }
}
Pr.CONVERT_TO_SOURCE = Symbol('convert to source')
Pr.CONVERT_TO_TARGET = Symbol('convert to target')
function tO(e) {
  return e
    .reduce((t, r) => {
      const i = t[t.length - 1]
      return i && i.type === r.type ? (i.count = i.count + 1 || 2) : t.push(r), t
    }, [])
    .map((t) => (t.count > 1 ? t.count + 'x ' : '') + t.type)
    .join(' -> ')
}
class Jb {
  constructor(t, r = {}) {
    ;(this.options = Object.assign(
      {
        generateGraph: !0,
        forceType: Pi(t),
        maxChainLength: 10,
        strict: !0,
        target: '@csl/list+object',
      },
      r
    )),
      (this.type = this.options.forceType),
      (this.data = typeof t == 'object' ? Bi(t) : t),
      (this.graph = [{ type: this.type, data: t }]),
      (this.iteration = 0)
  }
  iterate() {
    if (this.iteration !== 0) {
      const t = ey(this.type)
      t && t.outputs ? (this.type = t.outputs) : (this.type = Pi(this.data)),
        this.graph.push({ type: this.type })
    }
    return this.error || this.type === this.options.target
      ? !1
      : this.iteration >= this.options.maxChainLength
      ? ((this.error = new RangeError(
          `Max. number of parsing iterations reached (${tO(this.graph)})`
        )),
        !1)
      : (this.iteration++, !0)
  }
  end() {
    if (this.error) {
      if ((Ft.error('[core]', this.error.message), this.options.strict !== !1)) throw this.error
      return []
    } else
      return this.options.target === '@csl/list+object'
        ? qb(this.data).map(this.options.generateGraph ? (t) => Ib(t, this.graph) : Db)
        : this.data
  }
}
const Sp = (...e) => {
    const t = new Jb(...e)
    for (; t.iterate(); )
      try {
        t.data = Tu(t.data, t.type)
      } catch (r) {
        t.error = r
      }
    return t.end()
  },
  rO = (e) => {
    const t = Pi(e),
      r = t.match(/array|object/) ? Bi(e) : e
    return Tu(r, t)
  },
  Cp = async (...e) => {
    const t = new Jb(...e)
    for (; t.iterate(); )
      t.data = await kp(t.data, t.type).catch((r) => {
        t.error = r
      })
    return t.end()
  },
  iO = async (e) => {
    const t = Pi(e),
      r = t.match(/array|object/) ? Bi(e) : e
    return kp(r, t)
  },
  Dn = {},
  Rn = {},
  Vc = {
    '@csl/object': (e) => [e],
    '@csl/list+object': (e) => e,
    '@else/list+object': (e) => e.map(Sp).flat(),
    '@invalid': () => {
      throw new Error('This format is not supported or recognized')
    },
  },
  Gc = { '@else/list+object': async (e) => (await Promise.all(e.map(Cp))).flat() }
function Tu(e, t) {
  if (typeof Dn[t] == 'function') return Dn[t](e)
  if (typeof Vc[t] == 'function') return Vc[t](e)
  throw new TypeError(`No synchronous parser found for ${t}`)
}
async function kp(e, t) {
  if (typeof Rn[t] == 'function') return Rn[t](e)
  if (typeof Gc[t] == 'function') return Gc[t](e)
  if (Zb(t, !1)) return Tu(e, t)
  throw new TypeError(`No parser found for ${t}`)
}
function Xc(e, { parser: t, async: r }) {
  r ? (Rn[e] = t) : (Dn[e] = t)
}
function Zb(e, t) {
  return t ? Rn[e] || Gc[e] : Dn[e] || Vc[e]
}
function Yc(e, t) {
  delete (t ? Rn : Dn)[e]
}
function nO(e) {
  return Object.keys(e ? Rn : Dn)
}
const Fi = {}
function sO(e, t) {
  const r = new Mb(e, t)
  r.validate()
  const i = Fi[e] || (Fi[e] = {})
  r.typeParser && (Lb(e, r.typeParser), (i.type = !0)),
    r.dataParser && (Xc(e, r.dataParser), (i.data = !0)),
    r.asyncDataParser && (Xc(e, r.asyncDataParser), (i.asyncData = !0)),
    t.outputs && (i.outputs = t.outputs)
}
function ey(e) {
  return Fi[e]
}
function aO(e) {
  const t = Fi[e]
  t && (t.type && Pb(e), t.data && Yc(e), t.asyncData && Yc(e, !0), delete Fi[e])
}
function oO(e) {
  return e in Fi
}
function uO() {
  return Object.keys(Fi)
}
const lO = Object.assign({}, n3, s3, l3, I3),
  ty = Object.freeze(
    Object.defineProperty(
      {
        __proto__: null,
        add: sO,
        addDataParser: Xc,
        addTypeParser: Lb,
        chain: Sp,
        chainAsync: Cp,
        chainLink: rO,
        chainLinkAsync: iO,
        data: Tu,
        dataAsync: kp,
        get: ey,
        has: oO,
        hasDataParser: Zb,
        hasTypeParser: a3,
        list: uO,
        listDataParser: nO,
        listTypeParser: o3,
        remove: aO,
        removeDataParser: Yc,
        removeTypeParser: Pb,
        treeTypeParser: u3,
        type: Pi,
        typeMatcher: Bb,
        util: lO,
      },
      Symbol.toStringTag,
      { value: 'Module' }
    )
  )
function cO(e, t = {}, r = !1) {
  return (
    (t === !0 || r === !0) && this.save(),
    this.data.push(...Sp(e, t)),
    this.data
      .filter((i) => !Object.prototype.hasOwnProperty.call(i, 'id'))
      .forEach((i) => {
        i.id = Qb(this.getIds(), 'temp_id_')
      }),
    this
  )
}
async function fO(e, t = {}, r = !1) {
  return (
    (t === !0 || r === !0) && this.save(),
    this.data.push(...(await Cp(e, t))),
    this.data
      .filter((i) => !Object.prototype.hasOwnProperty.call(i, 'id'))
      .forEach((i) => {
        i.id = Qb(this.getIds(), 'temp_id_')
      }),
    this
  )
}
function pO(e, t = {}, r = !1) {
  return (
    (t === !0 || r === !0) && this.save(),
    (this.data = []),
    typeof t != 'boolean' ? this.add(e, t) : this.add(e)
  )
}
async function hO(e, t = {}, r = !1) {
  return (
    (t === !0 || r === !0) && this.save(),
    (this.data = []),
    typeof t != 'boolean' ? this.addAsync(e, t) : this.addAsync(e)
  )
}
function mO(e) {
  return e && this.save(), (this.data = []), (this._options = {}), this
}
const dO = Object.freeze(
  Object.defineProperty(
    { __proto__: null, add: cO, addAsync: fO, reset: mO, set: pO, setAsync: hO },
    Symbol.toStringTag,
    { value: 'Module' }
  )
)
function ry(e) {
  if ('citation-label' in e) return e['citation-label']
  let t = ''
  return (
    e.author && (t += e.author[0].family || e.author[0].literal),
    e.issued &&
      e.issued['date-parts'] &&
      e.issued['date-parts'][0] &&
      (t += e.issued['date-parts'][0][0]),
    e['year-suffix']
      ? (t += e['year-suffix'])
      : e.title && (t += e.title.replace(/<\/?.*?>/g, '').match(/^(?:(?:the|a|an)\s+)?(\S+)/i)[1]),
    t
  )
}
const gO = {
  label(e) {
    return e.reduce((t, r) => ((t[r.id] = ry(r)), t), {})
  },
}
function ud(e, t, r = t === 'label') {
  let i = r ? ry(e) : e[t]
  switch (t) {
    case 'author':
    case 'editor':
      return i.map((n) => n.literal || n.family || yu.format(n))
    case 'accessed':
    case 'issued':
      return i['date-parts'][0]
    case 'page':
      return i.split('-').map((n) => parseInt(n))
    case 'edition':
    case 'issue':
    case 'volume':
      return (i = parseInt(i)), isNaN(i) ? -1 / 0 : i
    default:
      return i || -1 / 0
  }
}
function bO(e, t, r, i = /^!/.test(r)) {
  r = r.replace(/^!/, '')
  const n = ud(e, r),
    s = ud(t, r)
  return (i ? -1 : 1) * (n > s ? 1 : n < s ? -1 : 0)
}
function yO(...e) {
  return (t, r) => {
    const i = e.slice()
    let n = 0
    for (; !n && i.length; ) n = bO(t, r, i.shift())
    return n
  }
}
function _O(e = [], t) {
  return t && this.save(), this.data.sort(typeof e == 'function' ? e : yO(...e, 'label')), this
}
const vO = Object.freeze(
  Object.defineProperty({ __proto__: null, sort: _O }, Symbol.toStringTag, { value: 'Module' })
)
function EO(e, t, r) {
  typeof t == 'function' && !r && ((r = t), (t = void 0))
  const i = li().setAsync(e, t)
  if (typeof r == 'function') {
    i.then(r)
    return
  } else return i
}
const xO = Object.freeze(
  Object.defineProperty(
    { __proto__: null, async: EO, validateOptions: e3, validateOutputOptions: bu },
    Symbol.toStringTag,
    { value: 'Module' }
  )
)
function TO(e, t) {
  if (typeof e != 'string')
    throw new TypeError(`Invalid output format name, expected string, got ${typeof e}`)
  if (typeof t != 'function')
    throw new TypeError(`Invalid formatter, expected function, got ${typeof t}`)
}
const Mi = new xu()
function AO(e, t) {
  TO(e, t), Mi.set(e, t)
}
function SO(e) {
  Mi.remove(e)
}
function CO(e) {
  return Mi.has(e)
}
function kO() {
  return Mi.list()
}
function iy(e, t, ...r) {
  if (!Mi.has(e)) throw new Error(`Output format "${e}" unavailable`)
  return Mi.get(e)(t, ...r)
}
const ny = Object.freeze(
  Object.defineProperty(
    { __proto__: null, add: AO, format: iy, has: CO, list: kO, register: Mi, remove: SO },
    Symbol.toStringTag,
    { value: 'Module' }
  )
)
function wO() {
  return this.data.map((e) => e.id)
}
function NO(e, ...t) {
  return iy(e, jb(this.data), ...t)
}
function OO(e = {}) {
  bu(e)
  const t = Object.assign({}, this.defaultOptions, this._options.output, e),
    { type: r, style: i } = t,
    [n, s] = i.split('-'),
    a = n === 'citation' ? 'bibliography' : n === 'csl' ? 'data' : n,
    o = r === 'string' ? 'text' : r === 'json' ? 'object' : r
  let u
  switch (a) {
    case 'bibliography': {
      const { lang: h, append: p, prepend: m } = t
      u = { template: s, lang: h, format: o, append: p, prepend: m }
      break
    }
    case 'data':
    case 'bibtex':
    case 'bibtxt':
    case 'ndjson':
    case 'ris':
      u = { type: o }
      break
    default:
      throw new Error(`Invalid style "${a}"`)
  }
  const c = this.format(a, Object.assign(u, e._newOptions)),
    { format: f } = t
  if (
    f === 'real' &&
    o === 'html' &&
    typeof document < 'u' &&
    typeof document.createElement == 'function'
  ) {
    const h = document.createElement('div')
    return (h.innerHTML = c), h.firstChild
  } else return f === 'string' && typeof c == 'object' ? JSON.stringify(c) : c
}
const IO = Object.freeze(
  Object.defineProperty({ __proto__: null, format: NO, get: OO, getIds: wO }, Symbol.toStringTag, {
    value: 'Module',
  })
)
function li(e, t = {}) {
  return this instanceof li
    ? ((this._options = t),
      (this.log = []),
      (this.data = []),
      this.set(e, t),
      this.options(t),
      this)
    : new li(e, t)
}
Object.assign(li.prototype, ZN, i3, dO, vO, IO)
li.prototype[Symbol.iterator] = function* () {
  yield* this.data
}
Object.assign(li, xO)
function DO(e, t) {
  if (typeof e != 'string')
    throw new TypeError(`Invalid dict name, expected string, got ${typeof e}`)
  if (typeof t != 'object') throw new TypeError(`Invalid dict, expected object, got ${typeof t}`)
  for (const r in t) {
    const i = t[r]
    if (!Array.isArray(i) || i.some((n) => typeof n != 'string'))
      throw new TypeError(`Invalid dict entry "${r}", expected array of strings`)
  }
}
const Ui = new xu({
  html: {
    bibliographyContainer: ['<div class="csl-bib-body">', '</div>'],
    entry: ['<div class="csl-entry">', '</div>'],
    list: ['<ul style="list-style-type:none">', '</ul>'],
    listItem: ['<li>', '</li>'],
  },
  text: {
    bibliographyContainer: [
      '',
      `
`,
    ],
    entry: [
      '',
      `
`,
    ],
    list: [
      `
`,
      '',
    ],
    listItem: [
      '	',
      `
`,
    ],
  },
})
function RO(e, t) {
  DO(e, t), Ui.set(e, t)
}
function LO(e) {
  Ui.remove(e)
}
function sy(e) {
  return Ui.has(e)
}
function PO() {
  return Ui.list()
}
function wp(e) {
  if (!Ui.has(e)) throw new Error(`Dict "${e}" unavailable`)
  return Ui.get(e)
}
const BO = {
    wr_start: '<div class="csl-bib-body">',
    wr_end: '</div>',
    en_start: '<div class="csl-entry">',
    en_end: '</div>',
    ul_start: '<ul style="list-style-type:none">',
    ul_end: '</ul>',
    li_start: '<li>',
    li_end: '</li>',
  },
  FO = {
    wr_start: '',
    wr_end: `
`,
    en_start: '',
    en_end: `
`,
    ul_start: `
`,
    ul_end: '',
    li_start: '	',
    li_end: `
`,
  },
  ay = Object.freeze(
    Object.defineProperty(
      {
        __proto__: null,
        add: RO,
        get: wp,
        has: sy,
        htmlDict: BO,
        list: PO,
        register: Ui,
        remove: LO,
        textDict: FO,
      },
      Symbol.toStringTag,
      { value: 'Module' }
    )
  ),
  pa = {}
function MO(e, t) {
  pa[e] = t
}
function UO(e) {
  return pa[e]
}
function HO(e) {
  return Object.prototype.hasOwnProperty.call(pa, e)
}
function zO(e) {
  delete pa[e]
}
function jO() {
  return Object.keys(pa)
}
const oy = Object.freeze(
    Object.defineProperty(
      { __proto__: null, add: MO, get: UO, has: HO, list: jO, remove: zO },
      Symbol.toStringTag,
      { value: 'Module' }
    )
  ),
  Wc = { input: ty, output: ny, dict: ay, config: oy },
  Gs = {}
function ha(e, t = {}) {
  const r = (Gs[e] = {})
  for (const i in t) {
    if (i === 'config') {
      ;(r.config = { [e]: t.config }), Wc.config.add(e, t.config)
      continue
    }
    const n = (r[i] = {}),
      s = t[i]
    for (const a in s) {
      const o = s[a]
      ;(n[a] = !0), Wc[i].add(a, o)
    }
  }
}
function qO(e) {
  const t = Gs[e]
  for (const r in t) {
    const i = t[r]
    for (const n in i) Wc[r].remove(n)
  }
  delete Gs[e]
}
function $O(e) {
  return e in Gs
}
function VO() {
  return Object.keys(Gs)
}
const GO = Object.freeze(
  Object.defineProperty(
    {
      __proto__: null,
      add: ha,
      config: oy,
      dict: ay,
      has: $O,
      input: ty,
      list: VO,
      output: ny,
      remove: qO,
    },
    Symbol.toStringTag,
    { value: 'Module' }
  )
)
function kl() {
  return []
}
const XO = [
  [/((?:\[|:|,)\s*)'((?:\\'|[^'])*?[^\\])?'(?=\s*(?:\]|}|,))/g, '$1"$2"'],
  [
    /((?:(?:"|]|}|\/[gmiuys]|\.|(?:\d|\.|-)*\d)\s*,|{)\s*)(?:"([^":\n]+?)"|'([^":\n]+?)'|([^":\n]+?))(\s*):/g,
    '$1"$2$3$4"$5:',
  ],
]
function YO(e) {
  if (typeof e != 'string') return JSON.parse(e)
  try {
    return JSON.parse(e)
  } catch {
    return (
      Ft.debug('[plugin-common]', 'Invalid JSON, switching to experimental parser'),
      XO.forEach(([r, i]) => {
        e = e.replace(r, i)
      }),
      JSON.parse(e)
    )
  }
}
function WO(e) {
  return e.val() || e.text() || e.html()
}
function QO(e) {
  return e.value || e.textContent
}
const KO = '@else',
  JO = {
    '@empty/text': { parse: kl, parseType: { dataType: 'String', predicate: (e) => e === '' } },
    '@empty/whitespace+text': { parse: kl, parseType: { dataType: 'String', predicate: /^\s+$/ } },
    '@empty': { parse: kl, parseType: { dataType: 'Primitive', predicate: (e) => e == null } },
    '@else/json': {
      parse: YO,
      parseType: { dataType: 'String', predicate: /^\s*(\{[\S\s]*\}|\[[\S\s]*\])\s*$/ },
    },
    '@else/url': {
      parse: K3,
      parseAsync: J3,
      parseType: {
        dataType: 'String',
        predicate: /^https?:\/\/(([\w-]+\.)*[\w-]+)(:\d+)?(\/[^?/]*)*(\?[^#]*)?(#.*)?$/i,
      },
    },
    '@else/jquery': {
      parse: WO,
      parseType: {
        dataType: 'ComplexObject',
        predicate(e) {
          return typeof jQuery < 'u' && e instanceof jQuery
        },
      },
    },
    '@else/html': {
      parse: QO,
      parseType: {
        dataType: 'ComplexObject',
        predicate(e) {
          return typeof HTMLElement < 'u' && e instanceof HTMLElement
        },
      },
    },
  }
function uy(e, t, r) {
  return e + (t < r.length - 1 ? ',' : '')
}
function ly(e, t) {
  const r = Array.isArray(e)
  let i
  return (
    r
      ? (i = e.map((n) => ld(n, t)))
      : (i = Object.keys(e)
          .filter((n) => JSON.stringify(e[n]))
          .map((n) => `"${n}": ${ld(e[n], t)}`)),
    (i = i.map(uy).map((n) => t.listItem.join(n))),
    (i = t.list.join(i.join(''))),
    r ? `[${i}]` : `{${i}}`
  )
}
function ld(e, t) {
  return typeof e == 'object' && e !== null
    ? e.length === 0
      ? '[]'
      : Object.keys(e).length === 0
      ? '{}'
      : ly(e, t)
    : JSON.stringify(e)
}
function ZO(e, t) {
  let r = e.map((i) => ly(i, t))
  return (
    (r = r.map(uy).map((i) => t.entry.join(i))),
    (r = r.join('')),
    t.bibliographyContainer.join(`[${r}]`)
  )
}
const eI = {
    data(e, { type: t, format: r = t || 'text', version: i = '1.0.2' } = {}) {
      return (
        i < '1.0.2' && (e = qs(e)),
        r === 'object'
          ? Bi(e)
          : r === 'text'
          ? JSON.stringify(e, null, 2)
          : (Ft.warn(
              '[core]',
              'This feature (JSON output with special formatting) is unstable. See https://github.com/larsgw/citation.js/issues/144'
            ),
            ZO(e, wp(r)))
      )
    },
    ndjson(e, { version: t = '1.0.2' } = {}) {
      return (
        t < '1.0.2' && (e = qs(e)),
        e.map((r) => JSON.stringify(r)).join(`
`)
      )
    },
  },
  tI = Object.assign({}, eI, gO)
ha(KO, { input: JO, output: tI })
var Xs = {},
  Au = {}
Object.defineProperty(Au, '__esModule', { value: !0 })
Au.default = void 0
function Ln(e, t) {
  return sI(e) || nI(e, t) || iI(e, t) || rI()
}
function rI() {
  throw new TypeError(`Invalid attempt to destructure non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`)
}
function iI(e, t) {
  if (e) {
    if (typeof e == 'string') return cd(e, t)
    var r = Object.prototype.toString.call(e).slice(8, -1)
    if ((r === 'Object' && e.constructor && (r = e.constructor.name), r === 'Map' || r === 'Set'))
      return Array.from(e)
    if (r === 'Arguments' || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r)) return cd(e, t)
  }
}
function cd(e, t) {
  ;(t == null || t > e.length) && (t = e.length)
  for (var r = 0, i = new Array(t); r < t; r++) i[r] = e[r]
  return i
}
function nI(e, t) {
  var r = e == null ? null : (typeof Symbol < 'u' && e[Symbol.iterator]) || e['@@iterator']
  if (r != null) {
    var i = [],
      n = !0,
      s = !1,
      a,
      o
    try {
      for (
        r = r.call(e);
        !(n = (a = r.next()).done) && (i.push(a.value), !(t && i.length === t));
        n = !0
      );
    } catch (u) {
      ;(s = !0), (o = u)
    } finally {
      try {
        !n && r.return != null && r.return()
      } finally {
        if (s) throw o
      }
    }
    return i
  }
}
function sI(e) {
  if (Array.isArray(e)) return e
}
const aI = {
    jan: 1,
    feb: 2,
    mar: 3,
    apr: 4,
    may: 5,
    jun: 6,
    jul: 7,
    aug: 8,
    sep: 9,
    oct: 10,
    nov: 11,
    dec: 12,
  },
  oI = / (?:to|[-/]) | ?(?:--|[]) ?/,
  fd = /^(\d{4}-\d{2}-\d{2})\/(\d{4}-\d{2}-\d{2})$/
function Ai(e) {
  return aI[e.toLowerCase().slice(0, 3)]
}
function uI(e) {
  const t = new Date(e)
  return typeof e == 'number' && !isNaN(t.valueOf())
    ? [t.getFullYear(), t.getMonth() + 1, t.getDate()]
    : null
}
const lI = function (t) {
    const r = /^(\d{4}|[-+]\d{6,})-(\d{2})(?:-(\d{2}))?/
    if (typeof t != 'string' || !r.test(t)) return null
    const i = t.match(r),
      n = Ln(i, 4),
      s = n[1],
      a = n[2],
      o = n[3]
    return +a ? (+o ? [s, a, o] : [s, a]) : [s]
  },
  cI = function (t) {
    const r = /^(?:[a-z]{3},\s*)?(\d{1,2}) ([a-z]{3}) (\d{4,})/i
    if (typeof t != 'string' || !r.test(t)) return null
    let i = t.match(r),
      n = Ln(i, 4),
      s = n[1],
      a = n[2],
      o = n[3]
    return (a = Ai(a)), a ? [o, a, s] : null
  }
function fI(e) {
  const t = /^(\d{1,2})\/(\d{1,2})\/(\d{2}(?:\d{2})?)/
  if (typeof e != 'string' || !t.test(e)) return null
  const r = e.match(t),
    i = Ln(r, 4),
    n = i[1],
    s = i[2],
    a = i[3]
  return new Date(a, n, s).getMonth() === parseInt(n) ? [a, n, s] : null
}
function pI(e) {
  const t = /^(\d{1,2})[ .\-/](\d{1,2}|[a-z]{3,10})[ .\-/](-?\d+)/i,
    r = /^(-?\d+)[ .\-/](\d{1,2}|[a-z]{3,10})[ .\-/](\d{1,2})/i
  let i, n, s
  if (typeof e != 'string') return null
  if (t.test(e)) {
    var a = e.match(t),
      o = Ln(a, 4)
    ;(s = o[1]), (n = o[2]), (i = o[3])
  } else if (r.test(e)) {
    var u = e.match(r),
      c = Ln(u, 4)
    ;(i = c[1]), (n = c[2]), (s = c[3])
  } else return null
  if (Ai(n)) n = Ai(n)
  else if (isNaN(n)) return null
  return [i, n, s]
}
function hI(e) {
  const t = /^([a-z]{3,10}|-?\d+)[^\w-]+([a-z]{3,10}|-?\d+)$/i
  if (typeof e == 'string' && t.test(e)) {
    const r = e.match(t).slice(1, 3)
    let i
    if (Ai(r[1])) i = Ai(r.pop())
    else if (Ai(r[0])) i = Ai(r.shift())
    else {
      if (r.some(isNaN) || r.every((s) => +s < 0)) return null
      ;+r[0] < 0 || (+r[0] > +r[1] && +r[1] > 0) ? (i = r.pop()) : (i = r.shift())
    }
    return [r.pop(), i]
  } else return null
}
function mI(e) {
  if (typeof e != 'string') return null
  const t = e.match(/^(\d+) ?(a\.?d\.?|b\.?c\.?)$/i)
  if (t) {
    const r = t.slice(1),
      i = Ln(r, 2),
      n = i[0],
      s = i[1]
    return [n * (s.toLowerCase()[0] === 'a' ? 1 : -1)]
  } else return /^-?\d+$/.test(e) ? [e] : null
}
function dI(e) {
  const t = uI(e) || lI(e) || cI(e) || fI(e) || pI(e) || hI(e) || mI(e)
  return t && t.map((r) => parseInt(r))
}
function gI(e) {
  return fd.test(e) ? e.match(fd).slice(1, 3) : e.split(oI)
}
function bI(e, t) {
  const r = [],
    i = typeof e == 'string' && gI(e)
  t ? r.push(e, t) : i && i.length === 2 ? r.push(...i) : r.push(e)
  const n = r.map(dI)
  return n.filter(Boolean).length === r.length ? { 'date-parts': n } : { raw: t ? r.join('/') : e }
}
var yI = bI
Au.default = yI
var Su = {}
Object.defineProperty(Su, '__esModule', { value: !0 })
Su.default = void 0
function wl(e, t, r) {
  if (e.length >= t) return e
  for (; e.length < t; ) e = r + e
  return e.slice(-t)
}
const _I = function (t, r = '-') {
  if (!t['date-parts']) return t.raw
  const i = t['date-parts'][0].map((n) => n.toString())
  switch (i.length) {
    case 3:
      i[2] = wl(i[2], 2, '0')
    case 2:
      i[1] = wl(i[1], 2, '0')
    case 1:
      i[0] = wl(i[0], 4, '0')
      break
  }
  return i.join(r)
}
var vI = _I
Su.default = vI
;(function (e) {
  Object.defineProperty(e, '__esModule', { value: !0 }),
    Object.defineProperty(e, 'format', {
      enumerable: !0,
      get: function () {
        return r.default
      },
    }),
    Object.defineProperty(e, 'parse', {
      enumerable: !0,
      get: function () {
        return t.default
      },
    })
  var t = i(Au),
    r = i(Su)
  function i(n) {
    return n && n.__esModule ? n : { default: n }
  }
})(Xs)
function Nl(e) {
  const { firstname: t, lastname: r, firstName: i = t, lastName: n = r } = e
  if (i && n) return { given: i, family: n }
  if (e.name) return yu.parse(e.name)
}
const EI = ['PMID', 'PMCID', 'DOI', 'ISBN'],
  xI = ['ISSN']
function pd(e, t) {
  const r = {}
  for (const i in e) {
    const n = i.toUpperCase()
    t.includes(n) && (r[n] = e[i])
  }
  if (e.identifier)
    for (let { id: i, type: n = '' } of e.identifier)
      (n = n.toUpperCase()), t.includes(n) && (r[n] = i)
  return r
}
const TI = {
  article: 'article',
  book: 'book',
  booklet: 'book',
  proceedings: 'book',
  mastersthesis: 'thesis',
  inbook: 'chapter',
  incollection: 'chapter',
  conference: 'paper-conference',
  inproceedings: 'paper-conference',
  manual: 'report',
  misc: 'document',
  online: 'website',
  patent: 'patent',
  phdthesis: 'thesis',
  techreport: 'report',
  unpublished: 'manuscript',
}
function AI() {
  return { type: 'article-journal' }
}
function cy(e) {
  const t = { type: TI[e.type] || 'document', title: e.title }
  if (
    (e.author && (t.author = e.author.map(Nl).filter(Boolean)),
    e.editor && (t.editor = e.editor.map(Nl).filter(Boolean)),
    e.reviewer &&
      (e.author && (t['reviewed-author'] = t.author),
      (t.author = e.reviewer.map(Nl).filter(Boolean))),
    Array.isArray(e.keywords)
      ? (t.keyword = e.keywords.join())
      : e.keywords && (t.keyword = e.keywords),
    e.publisher && (t.publisher = e.publisher.name || e.publisher),
    e.date && e.date.published
      ? (t.issued = Xs.parse(e.date.published))
      : e.year && (t.issued = { 'date-parts': [[+e.year]] }),
    e.date && e.date.submitted && (t.submitted = Xs.parse(e.date.submitted)),
    e.journal)
  ) {
    const r = e.journal
    r.name && (t['container-title'] = r.name),
      r.volume && (t.volume = r.volume),
      r.issue && (t.issue = r.issue),
      Object.assign(t, pd(r, xI)),
      r.firstpage && (t['page-first'] = r.firstpage),
      r.pages
        ? (t.page = r.pages.replace('--', '-'))
        : r.firstpage && r.lastpage && (t.page = r.firstpage + '-' + r.lastpage)
  }
  return (
    e.link && typeof e.link[0] == 'object' && (t.URL = e.link[0].url),
    Object.assign(t, pd(e, EI)),
    e.cid ? (t.id = e.cid) : t.DOI && (t.id = t.DOI),
    t
  )
}
const SI = function (e) {
    return Object.assign(cy(e), AI())
  },
  CI = function (e) {
    return cy(e)
  },
  kI = ['fulltext_html', 'fulltext_xml', 'fulltext_pdf'],
  wI = ['name', 'lastname', 'lastName', 'firstname', 'firstName'],
  NI = '@bibjson',
  OI = {
    '@bibjson/quickscrape+record+object': {
      parse: SI,
      parseType: {
        propertyConstraint: {
          props: 'link',
          value(e) {
            return kI.some((t) => e.find(({ type: r }) => r === t))
          },
        },
        extends: '@bibjson/record+object',
      },
    },
    '@bibjson/record+object': {
      parse: CI,
      parseType: {
        dataType: 'SimpleObject',
        propertyConstraint: [
          { props: 'title' },
          {
            props: ['author', 'editor'],
            match: 'some',
            value(e) {
              return Array.isArray(e) && e[0] && wI.some((t) => t in e[0])
            },
          },
        ],
      },
    },
    '@bibjson/collection+object': {
      parse(e) {
        return e.records
      },
      parseType: {
        dataType: 'SimpleObject',
        propertyConstraint: [
          {
            props: 'metadata',
            value(e) {
              return 'collection' in e
            },
          },
          {
            props: 'records',
            value(e) {
              return Array.isArray(e)
            },
          },
        ],
      },
    },
  }
ha(NI, { input: OI })
var fy = { exports: {} }
;(function (e) {
  ;(function (t, r) {
    e.exports ? (e.exports = r()) : (t.moo = r())
  })(mn, function () {
    var t = Object.prototype.hasOwnProperty,
      r = Object.prototype.toString,
      i = typeof new RegExp().sticky == 'boolean'
    function n(N) {
      return N && r.call(N) === '[object RegExp]'
    }
    function s(N) {
      return N && typeof N == 'object' && !n(N) && !Array.isArray(N)
    }
    function a(N) {
      return N.replace(/[-\/\\^$*+?.()|[\]{}]/g, '\\$&')
    }
    function o(N) {
      var M = new RegExp('|' + N)
      return M.exec('').length - 1
    }
    function u(N) {
      return '(' + N + ')'
    }
    function c(N) {
      if (!N.length) return '(?!)'
      var M = N.map(function (V) {
        return '(?:' + V + ')'
      }).join('|')
      return '(?:' + M + ')'
    }
    function f(N) {
      if (typeof N == 'string') return '(?:' + a(N) + ')'
      if (n(N)) {
        if (N.ignoreCase) throw new Error('RegExp /i flag not allowed')
        if (N.global) throw new Error('RegExp /g flag is implied')
        if (N.sticky) throw new Error('RegExp /y flag is implied')
        if (N.multiline) throw new Error('RegExp /m flag is implied')
        return N.source
      } else throw new Error('Not a pattern: ' + N)
    }
    function h(N, M) {
      return N.length > M ? N : Array(M - N.length + 1).join(' ') + N
    }
    function p(N, M) {
      for (var V = N.length, j = 0; ; ) {
        var R = N.lastIndexOf(
          `
`,
          V - 1
        )
        if (R === -1 || (j++, (V = R), j === M) || V === 0) break
      }
      var $ = j < M ? 0 : V + 1
      return N.substring($).split(`
`)
    }
    function m(N) {
      for (var M = Object.getOwnPropertyNames(N), V = [], j = 0; j < M.length; j++) {
        var R = M[j],
          $ = N[R],
          L = [].concat($)
        if (R === 'include') {
          for (var P = 0; P < L.length; P++) V.push({ include: L[P] })
          continue
        }
        var Y = []
        L.forEach(function (w) {
          s(w) ? (Y.length && V.push(b(R, Y)), V.push(b(R, w)), (Y = [])) : Y.push(w)
        }),
          Y.length && V.push(b(R, Y))
      }
      return V
    }
    function v(N) {
      for (var M = [], V = 0; V < N.length; V++) {
        var j = N[V]
        if (j.include) {
          for (var R = [].concat(j.include), $ = 0; $ < R.length; $++) M.push({ include: R[$] })
          continue
        }
        if (!j.type) throw new Error('Rule has no type: ' + JSON.stringify(j))
        M.push(b(j.type, j))
      }
      return M
    }
    function b(N, M) {
      if ((s(M) || (M = { match: M }), M.include))
        throw new Error('Matching rules cannot also include states')
      var V = {
        defaultType: N,
        lineBreaks: !!M.error || !!M.fallback,
        pop: !1,
        next: null,
        push: null,
        error: !1,
        fallback: !1,
        value: null,
        type: null,
        shouldThrow: !1,
      }
      for (var j in M) t.call(M, j) && (V[j] = M[j])
      if (typeof V.type == 'string' && N !== V.type)
        throw new Error(
          "Type transform cannot be a string (type '" + V.type + "' for token '" + N + "')"
        )
      var R = V.match
      return (
        (V.match = Array.isArray(R) ? R : R ? [R] : []),
        V.match.sort(function ($, L) {
          return n($) && n(L) ? 0 : n(L) ? -1 : n($) ? 1 : L.length - $.length
        }),
        V
      )
    }
    function S(N) {
      return Array.isArray(N) ? v(N) : m(N)
    }
    var g = b('error', { lineBreaks: !0, shouldThrow: !0 })
    function _(N, M) {
      for (
        var V = null, j = Object.create(null), R = !0, $ = null, L = [], P = [], Y = 0;
        Y < N.length;
        Y++
      )
        N[Y].fallback && (R = !1)
      for (var Y = 0; Y < N.length; Y++) {
        var w = N[Y]
        if (w.include) throw new Error('Inheritance is not allowed in stateless lexers')
        if (w.error || w.fallback) {
          if (V)
            throw !w.fallback == !V.fallback
              ? new Error(
                  'Multiple ' +
                    (w.fallback ? 'fallback' : 'error') +
                    " rules not allowed (for token '" +
                    w.defaultType +
                    "')"
                )
              : new Error(
                  "fallback and error are mutually exclusive (for token '" + w.defaultType + "')"
                )
          V = w
        }
        var q = w.match.slice()
        if (R)
          for (; q.length && typeof q[0] == 'string' && q[0].length === 1; ) {
            var X = q.shift()
            j[X.charCodeAt(0)] = w
          }
        if (w.pop || w.push || w.next) {
          if (!M)
            throw new Error(
              "State-switching options are not allowed in stateless lexers (for token '" +
                w.defaultType +
                "')"
            )
          if (w.fallback)
            throw new Error(
              "State-switching options are not allowed on fallback tokens (for token '" +
                w.defaultType +
                "')"
            )
        }
        if (q.length !== 0) {
          ;(R = !1), L.push(w)
          for (var I = 0; I < q.length; I++) {
            var re = q[I]
            if (n(re)) {
              if ($ === null) $ = re.unicode
              else if ($ !== re.unicode && w.fallback === !1)
                throw new Error('If one rule is /u then all must be')
            }
          }
          var ie = c(q.map(f)),
            Z = new RegExp(ie)
          if (Z.test('')) throw new Error('RegExp matches empty string: ' + Z)
          var oe = o(ie)
          if (oe > 0)
            throw new Error(
              'RegExp has capture groups: ' +
                Z +
                `
Use (?:  ) instead`
            )
          if (
            !w.lineBreaks &&
            Z.test(`
`)
          )
            throw new Error('Rule should declare lineBreaks: ' + Z)
          P.push(u(ie))
        }
      }
      var ce = V && V.fallback,
        fe = i && !ce ? 'ym' : 'gm',
        ge = i || ce ? '' : '|'
      $ === !0 && (fe += 'u')
      var me = new RegExp(c(P) + ge, fe)
      return { regexp: me, groups: L, fast: j, error: V || g }
    }
    function y(N) {
      var M = _(S(N))
      return new H({ start: M }, 'start')
    }
    function x(N, M, V) {
      var j = N && (N.push || N.next)
      if (j && !V[j])
        throw new Error(
          "Missing state '" + j + "' (in token '" + N.defaultType + "' of state '" + M + "')"
        )
      if (N && N.pop && +N.pop != 1)
        throw new Error("pop must be 1 (in token '" + N.defaultType + "' of state '" + M + "')")
    }
    function D(N, M) {
      var V = N.$all ? S(N.$all) : []
      delete N.$all
      var j = Object.getOwnPropertyNames(N)
      M || (M = j[0])
      for (var R = Object.create(null), $ = 0; $ < j.length; $++) {
        var L = j[$]
        R[L] = S(N[L]).concat(V)
      }
      for (var $ = 0; $ < j.length; $++)
        for (var L = j[$], P = R[L], Y = Object.create(null), w = 0; w < P.length; w++) {
          var q = P[w]
          if (q.include) {
            var X = [w, 1]
            if (q.include !== L && !Y[q.include]) {
              Y[q.include] = !0
              var I = R[q.include]
              if (!I)
                throw new Error(
                  "Cannot include nonexistent state '" + q.include + "' (in state '" + L + "')"
                )
              for (var re = 0; re < I.length; re++) {
                var ie = I[re]
                P.indexOf(ie) === -1 && X.push(ie)
              }
            }
            P.splice.apply(P, X), w--
          }
        }
      for (var Z = Object.create(null), $ = 0; $ < j.length; $++) {
        var L = j[$]
        Z[L] = _(R[L], !0)
      }
      for (var $ = 0; $ < j.length; $++) {
        for (var oe = j[$], ce = Z[oe], fe = ce.groups, w = 0; w < fe.length; w++) x(fe[w], oe, Z)
        for (var ge = Object.getOwnPropertyNames(ce.fast), w = 0; w < ge.length; w++)
          x(ce.fast[ge[w]], oe, Z)
      }
      return new H(Z, M)
    }
    function C(N) {
      for (
        var M = typeof Map < 'u',
          V = M ? new Map() : Object.create(null),
          j = Object.getOwnPropertyNames(N),
          R = 0;
        R < j.length;
        R++
      ) {
        var $ = j[R],
          L = N[$],
          P = Array.isArray(L) ? L : [L]
        P.forEach(function (Y) {
          if (typeof Y != 'string')
            throw new Error("keyword must be string (in keyword '" + $ + "')")
          M ? V.set(Y, $) : (V[Y] = $)
        })
      }
      return function (Y) {
        return M ? V.get(Y) : V[Y]
      }
    }
    var H = function (N, M) {
      ;(this.startState = M), (this.states = N), (this.buffer = ''), (this.stack = []), this.reset()
    }
    ;(H.prototype.reset = function (N, M) {
      return (
        (this.buffer = N || ''),
        (this.index = 0),
        (this.line = M ? M.line : 1),
        (this.col = M ? M.col : 1),
        (this.queuedToken = M ? M.queuedToken : null),
        (this.queuedText = M ? M.queuedText : ''),
        (this.queuedThrow = M ? M.queuedThrow : null),
        this.setState(M ? M.state : this.startState),
        (this.stack = M && M.stack ? M.stack.slice() : []),
        this
      )
    }),
      (H.prototype.save = function () {
        return {
          line: this.line,
          col: this.col,
          state: this.state,
          stack: this.stack.slice(),
          queuedToken: this.queuedToken,
          queuedText: this.queuedText,
          queuedThrow: this.queuedThrow,
        }
      }),
      (H.prototype.setState = function (N) {
        if (!(!N || this.state === N)) {
          this.state = N
          var M = this.states[N]
          ;(this.groups = M.groups),
            (this.error = M.error),
            (this.re = M.regexp),
            (this.fast = M.fast)
        }
      }),
      (H.prototype.popState = function () {
        this.setState(this.stack.pop())
      }),
      (H.prototype.pushState = function (N) {
        this.stack.push(this.state), this.setState(N)
      })
    var T = i
      ? function (N, M) {
          return N.exec(M)
        }
      : function (N, M) {
          var V = N.exec(M)
          return V[0].length === 0 ? null : V
        }
    H.prototype._getGroup = function (N) {
      for (var M = this.groups.length, V = 0; V < M; V++)
        if (N[V + 1] !== void 0) return this.groups[V]
      throw new Error('Cannot find token type for matched text')
    }
    function k() {
      return this.value
    }
    if (
      ((H.prototype.next = function () {
        var N = this.index
        if (this.queuedGroup) {
          var M = this._token(this.queuedGroup, this.queuedText, N)
          return (this.queuedGroup = null), (this.queuedText = ''), M
        }
        var V = this.buffer
        if (N !== V.length) {
          var L = this.fast[V.charCodeAt(N)]
          if (L) return this._token(L, V.charAt(N), N)
          var j = this.re
          j.lastIndex = N
          var R = T(j, V),
            $ = this.error
          if (R == null) return this._token($, V.slice(N, V.length), N)
          var L = this._getGroup(R),
            P = R[0]
          return $.fallback && R.index !== N
            ? ((this.queuedGroup = L),
              (this.queuedText = P),
              this._token($, V.slice(N, R.index), N))
            : this._token(L, P, N)
        }
      }),
      (H.prototype._token = function (N, M, V) {
        var j = 0
        if (N.lineBreaks) {
          var R = /\n/g,
            $ = 1
          if (
            M ===
            `
`
          )
            j = 1
          else for (; R.exec(M); ) j++, ($ = R.lastIndex)
        }
        var L = {
            type: (typeof N.type == 'function' && N.type(M)) || N.defaultType,
            value: typeof N.value == 'function' ? N.value(M) : M,
            text: M,
            toString: k,
            offset: V,
            lineBreaks: j,
            line: this.line,
            col: this.col,
          },
          P = M.length
        if (
          ((this.index += P),
          (this.line += j),
          j !== 0 ? (this.col = P - $ + 1) : (this.col += P),
          N.shouldThrow)
        ) {
          var Y = new Error(this.formatError(L, 'invalid syntax'))
          throw Y
        }
        return (
          N.pop
            ? this.popState()
            : N.push
            ? this.pushState(N.push)
            : N.next && this.setState(N.next),
          L
        )
      }),
      typeof Symbol < 'u' && Symbol.iterator)
    ) {
      var O = function (N) {
        this.lexer = N
      }
      ;(O.prototype.next = function () {
        var N = this.lexer.next()
        return { value: N, done: !N }
      }),
        (O.prototype[Symbol.iterator] = function () {
          return this
        }),
        (H.prototype[Symbol.iterator] = function () {
          return new O(this)
        })
    }
    return (
      (H.prototype.formatError = function (N, M) {
        if (N == null)
          var V = this.buffer.slice(this.index),
            N = {
              text: V,
              offset: this.index,
              lineBreaks:
                V.indexOf(`
`) === -1
                  ? 0
                  : 1,
              line: this.line,
              col: this.col,
            }
        var j = 2,
          R = Math.max(N.line - j, 1),
          $ = N.line + j,
          L = String($).length,
          P = p(this.buffer, this.line - N.line + j + 1).slice(0, 5),
          Y = []
        Y.push(M + ' at line ' + N.line + ' col ' + N.col + ':'), Y.push('')
        for (var w = 0; w < P.length; w++) {
          var q = P[w],
            X = R + w
          Y.push(h(String(X), L) + '  ' + q), X === N.line && Y.push(h('', L + N.col + 1) + '^')
        }
        return Y.join(`
`)
      }),
      (H.prototype.clone = function () {
        return new H(this.states, this.state)
      }),
      (H.prototype.has = function (N) {
        return !0
      }),
      {
        compile: y,
        states: D,
        error: Object.freeze({ error: !0 }),
        fallback: Object.freeze({ fallback: !0 }),
        keywords: C,
      }
    )
  })
})(fy)
var II = fy.exports
const Np = ci(II),
  DI = {
    biblatex: {
      article: ['author', 'title', 'journaltitle', ['year', 'date']],
      book: ['author', 'title', ['year', 'date']],
      mvbook: ['author', 'title', ['year', 'date']],
      inbook: ['author', 'title', 'booktitle', ['year', 'date']],
      booklet: [['author', 'editor'], 'title', ['year', 'date']],
      collection: ['editor', 'title', ['year', 'date']],
      mvcollection: ['editor', 'title', ['year', 'date']],
      incollection: ['author', 'title', 'booktitle', ['year', 'date']],
      dataset: [['author', 'editor'], 'title', ['year', 'date']],
      online: [['author', 'editor'], 'title', ['year', 'date'], ['doi', 'eprint', 'url']],
      patent: ['author', 'title', 'number', ['year', 'date']],
      periodical: ['editor', 'title', ['year', 'date']],
      proceedings: ['title', ['year', 'date']],
      mvproceedings: ['title', ['year', 'date']],
      inproceedings: ['author', 'title', 'booktitle', ['year', 'date']],
      report: ['author', 'title', 'type', 'institution', ['year', 'date']],
      thesis: ['author', 'title', 'type', 'institution', ['year', 'date']],
      unpublished: ['author', 'title', ['year', 'date']],
      conference: ['author', 'title', 'booktitle', ['year', 'date']],
      electronic: [['author', 'editor'], 'title', ['year', 'date'], ['doi', 'eprint', 'url']],
      mastersthesis: ['author', 'title', 'institution', ['year', 'date']],
      phdthesis: ['author', 'title', 'institution', ['year', 'date']],
      techreport: ['author', 'title', 'institution', ['year', 'date']],
      www: [['author', 'editor'], 'title', ['year', 'date'], ['doi', 'eprint', 'url']],
    },
    bibtex: {
      article: ['author', 'title', 'journal', 'year'],
      book: [['author', 'editor'], 'title', 'publisher', 'year'],
      booklet: ['title'],
      inbook: [['author', 'editor'], 'title', ['chapter', 'pages'], 'publisher', 'year'],
      incollection: ['author', 'title', 'booktitle', 'publisher', 'year'],
      inproceedings: ['author', 'title', 'booktitle', 'year'],
      mastersthesis: ['author', 'title', 'school', 'year'],
      phdthesis: ['author', 'title', 'school', 'year'],
      proceedings: ['title', 'year'],
      techreport: ['author', 'title', 'institution', 'year'],
      unpublished: ['author', 'title', 'note'],
    },
  },
  RI = {
    abstract: ['field', 'literal'],
    addendum: ['field', 'literal'],
    afterword: ['list', 'name'],
    annotation: ['field', 'literal'],
    annotator: ['list', 'name'],
    author: ['list', 'name'],
    authortype: ['field', 'key'],
    bookauthor: ['list', 'name'],
    bookpagination: ['field', 'key'],
    booksubtitle: ['field', 'literal'],
    booktitle: ['field', 'title'],
    booktitleaddon: ['field', 'literal'],
    chapter: ['field', 'literal'],
    commentator: ['list', 'name'],
    date: ['field', 'date'],
    doi: ['field', 'verbatim'],
    edition: ['field', 'literal'],
    editor: ['list', 'name'],
    editora: ['list', 'name'],
    editorb: ['list', 'name'],
    editorc: ['list', 'name'],
    editortype: ['field', 'key'],
    editoratype: ['field', 'key'],
    editorbtype: ['field', 'key'],
    editorctype: ['field', 'key'],
    eid: ['field', 'literal'],
    entrysubtype: ['field', 'literal'],
    eprint: ['field', 'verbatim'],
    eprintclass: ['field', 'literal'],
    eprinttype: ['field', 'literal'],
    eventdate: ['field', 'date'],
    eventtitle: ['field', 'title'],
    eventtitleaddon: ['field', 'literal'],
    file: ['field', 'verbatim'],
    foreword: ['list', 'name'],
    holder: ['list', 'name'],
    howpublished: ['field', 'literal'],
    indextitle: ['field', 'literal'],
    institution: ['list', 'literal'],
    introduction: ['list', 'name'],
    isan: ['field', 'literal'],
    isbn: ['field', 'literal'],
    ismn: ['field', 'literal'],
    isrn: ['field', 'literal'],
    issn: ['field', 'literal'],
    issue: ['field', 'literal'],
    issuesubtitle: ['field', 'literal'],
    issuetitle: ['field', 'literal'],
    iswc: ['field', 'literal'],
    journalsubtitle: ['field', 'literal'],
    journaltitle: ['field', 'literal'],
    label: ['field', 'literal'],
    language: ['list', 'key'],
    library: ['field', 'literal'],
    location: ['list', 'literal'],
    mainsubtitle: ['field', 'literal'],
    maintitle: ['field', 'title'],
    maintitleaddon: ['field', 'literal'],
    month: ['field', 'literal'],
    nameaddon: ['field', 'literal'],
    note: ['field', 'literal'],
    number: ['field', 'literal'],
    organization: ['list', 'literal'],
    origdate: ['field', 'date'],
    origlanguage: ['list', 'key'],
    origlocation: ['list', 'literal'],
    origpublisher: ['list', 'literal'],
    origtitle: ['field', 'title'],
    pages: ['field', 'range'],
    pagetotal: ['field', 'literal'],
    pagination: ['field', 'key'],
    part: ['field', 'literal'],
    publisher: ['list', 'literal'],
    pubstate: ['field', 'key'],
    reprinttitle: ['field', 'literal'],
    series: ['field', 'title'],
    shortauthor: ['list', 'name'],
    shorteditor: ['list', 'name'],
    shorthand: ['field', 'literal'],
    shorthandintro: ['field', 'literal'],
    shortjournal: ['field', 'literal'],
    shortseries: ['field', 'literal'],
    shorttitle: ['field', 'title'],
    subtitle: ['field', 'literal'],
    title: ['field', 'title'],
    titleaddon: ['field', 'literal'],
    translator: ['list', 'name'],
    type: ['field', 'title'],
    url: ['field', 'uri'],
    urldate: ['field', 'date'],
    venue: ['field', 'literal'],
    version: ['field', 'literal'],
    volume: ['field', 'integer'],
    volumes: ['field', 'integer'],
    year: ['field', 'literal'],
    crossref: ['field', 'entry key'],
    entryset: ['separated', 'literal'],
    execute: ['field', 'code'],
    gender: ['field', 'gender'],
    langid: ['field', 'identifier'],
    langidopts: ['field', 'literal'],
    ids: ['separated', 'entry key'],
    indexsorttitle: ['field', 'literal'],
    keywords: ['separated', 'literal'],
    options: ['separated', 'options'],
    presort: ['field', 'string'],
    related: ['separated', 'literal'],
    relatedoptions: ['separated', 'literal'],
    relatedtype: ['field', 'identifier'],
    relatedstring: ['field', 'literal'],
    sortkey: ['field', 'literal'],
    sortname: ['list', 'name'],
    sortshorthand: ['field', 'literal'],
    sorttitle: ['field', 'literal'],
    sortyear: ['field', 'integer'],
    xdata: ['separated', 'entry key'],
    xref: ['field', 'entry key'],
    namea: ['list', 'name'],
    nameb: ['list', 'name'],
    namec: ['list', 'name'],
    nameatype: ['field', 'key'],
    namebtype: ['field', 'key'],
    namectype: ['field', 'key'],
    lista: ['list', 'literal'],
    listb: ['list', 'literal'],
    listc: ['list', 'literal'],
    listd: ['list', 'literal'],
    liste: ['list', 'literal'],
    listf: ['list', 'literal'],
    usera: ['field', 'literal'],
    userb: ['field', 'literal'],
    userc: ['field', 'literal'],
    userd: ['field', 'literal'],
    usere: ['field', 'literal'],
    userf: ['field', 'literal'],
    verba: ['field', 'literal'],
    verbb: ['field', 'literal'],
    verbc: ['field', 'literal'],
    address: ['list', 'literal'],
    annote: ['field', 'literal'],
    archiveprefix: ['field', 'literal'],
    journal: ['field', 'literal'],
    key: ['field', 'literal'],
    pdf: ['field', 'verbatim'],
    primaryclass: ['field', 'literal'],
    school: ['list', 'literal'],
    numpages: ['field', 'integer'],
    pmid: ['field', 'literal'],
    pmcid: ['field', 'literal'],
  },
  py = {
    diacritics: {
      '`': '',
      "'": '',
      '^': '',
      '~': '',
      '=': '',
      u: '',
      '.': '',
      '"': '',
      r: '',
      H: '',
      v: '',
      b: '',
      d: '',
      c: '',
      k: '',
      t: '',
      textcommabelow: '',
    },
    commands: {
      textquotesingle: "'",
      textasciigrave: '`',
      textquotedbl: '"',
      textdollar: '$',
      textless: '<',
      textgreater: '>',
      textbackslash: '\\',
      textasciicircum: '^',
      textunderscore: '_',
      textbraceleft: '{',
      textbar: '|',
      textbraceright: '}',
      textasciitilde: '~',
      textexclamdown: '',
      textcent: '',
      textsterling: '',
      textcurrency: '',
      textyen: '',
      textbrokenbar: '',
      textsection: '',
      textasciidieresis: '',
      textcopyright: '',
      textordfeminine: '',
      guillemetleft: '',
      guillemotleft: '',
      textlnot: '',
      textregistered: '',
      textasciimacron: '',
      textdegree: '',
      textpm: '',
      texttwosuperior: '',
      textthreesuperior: '',
      textasciiacute: '',
      textmu: '',
      textparagraph: '',
      textperiodcentered: '',
      textonesuperior: '',
      textordmasculine: '',
      guillemetright: '',
      guillemotright: '',
      textonequarter: '',
      textonehalf: '',
      textthreequarters: '',
      textquestiondown: '',
      AE: '',
      DH: '',
      texttimes: '',
      O: '',
      TH: '',
      ss: '',
      ae: '',
      dh: '',
      textdiv: '',
      o: '',
      th: '',
      DJ: '',
      dj: '',
      i: '',
      IJ: '',
      ij: '',
      L: '',
      l: '',
      NG: '',
      ng: '',
      OE: '',
      oe: '',
      textflorin: '',
      j: '',
      textasciicaron: '',
      textasciibreve: '',
      textacutedbl: '',
      textgravedbl: '',
      texttildelow: '',
      textbaht: '',
      SS: '',
      textcompwordmark: '',
      textendash: '',
      textemdash: '',
      textbardbl: '',
      textquoteleft: '',
      textquoteright: '',
      quotesinglbase: '',
      textquotedblleft: '',
      textquotedblright: '',
      quotedblbase: '',
      textdagger: '',
      textdaggerdbl: '',
      textbullet: '',
      textellipsis: '',
      textperthousand: '',
      textpertenthousand: '',
      guilsinglleft: '',
      guilsinglright: '',
      textreferencemark: '',
      textinterrobang: '',
      textfractionsolidus: '',
      textlquill: '',
      textrquill: '',
      textdiscount: '',
      textcolonmonetary: '',
      textlira: '',
      textnaira: '',
      textwon: '',
      textdong: '',
      texteuro: '',
      textpeso: '',
      textcelsius: '',
      textnumero: '',
      textcircledP: '',
      textrecipe: '',
      textservicemark: '',
      texttrademark: '',
      textohm: '',
      textmho: '',
      textestimated: '',
      textleftarrow: '',
      textuparrow: '',
      textrightarrow: '',
      textdownarrow: '',
      textminus: '',
      Hwithstroke: '',
      hwithstroke: '',
      textasteriskcentered: '',
      textsurd: '',
      textlangle: '',
      textrangle: '',
      textblank: '',
      textvisiblespace: '',
      textopenbullet: '',
      textbigcircle: '',
      textmusicalnote: '',
      textmarried: '',
      textdivorced: '',
      textinterrobangdown: '',
      textcommabelow: null,
      copyright: '',
      Gamma: '',
      Delta: '',
      Theta: '',
      Lambda: '',
      Xi: '',
      Pi: '',
      Sigma: '',
      Phi: '',
      Psi: '',
      Omega: '',
      alpha: '',
      beta: '',
      gamma: '',
      delta: '',
      varepsilon: '',
      zeta: '',
      eta: '',
      theta: '',
      iota: '',
      kappa: '',
      lambda: '',
      mu: '',
      nu: '',
      xi: '',
      pi: '',
      rho: '',
      varsigma: '',
      sigma: '',
      tau: '',
      upsilon: '',
      varphi: '',
      chi: '',
      psi: '',
      omega: '',
      vartheta: '',
      Upsilon: '',
      phi: '',
      varpi: '',
      varrho: '',
      epsilon: '',
    },
  },
  Op = DI,
  zo = RI,
  Ys = py.diacritics,
  Ws = py.commands,
  hy = {
    jan: '01',
    feb: '02',
    mar: '03',
    apr: '04',
    may: '05',
    jun: '06',
    jul: '07',
    aug: '08',
    sep: '09',
    oct: '10',
    nov: '11',
    dec: '12',
    acmcs: 'ACM Computing Surveys',
    acta: 'Acta Informatica',
    cacm: 'Communications of the ACM',
    ibmjrd: 'IBM Journal of Research and Development',
    ibmsj: 'IBM Systems Journal',
    ieeese: 'IEEE Transactions on Software Engineering',
    ieeetc: 'IEEE Transactions on Computers',
    ieeetcad: 'IEEE Transactions on Computer-Aided Design of Integrated Circuits',
    ipl: 'Information Processing Letters',
    jacm: 'Journal of the ACM',
    jcss: 'Journal of Computer and System Sciences',
    scp: 'Science of Computer Programming',
    sicomp: 'SIAM Journal on Computing',
    tocs: 'ACM Transactions on Computer Systems',
    tods: 'ACM Transactions on Database Systems',
    tog: 'ACM Transactions on Graphics',
    toms: 'ACM Transactions on Mathematical Software',
    toois: 'ACM Transactions on Office Information Systems',
    toplas: 'ACM Transactions on Programming Languages and Systems',
    tcs: 'Theoretical Computer Science',
  },
  so = {
    it: 'italics',
    itshape: 'italics',
    sl: 'italics',
    slshape: 'italics',
    em: 'italics',
    bf: 'bold',
    bfseries: 'bold',
    sc: 'smallcaps',
    scshape: 'smallcaps',
    rm: void 0,
    sf: void 0,
    tt: void 0,
  },
  Qc = {
    textit: 'italics',
    textsl: 'italics',
    emph: 'italics',
    mkbibitalic: 'italics',
    mkbibemph: 'italics',
    textbf: 'bold',
    strong: 'bold',
    mkbibbold: 'bold',
    textsc: 'smallcaps',
    textsuperscript: 'superscript',
    textsubscript: 'subscript',
    enquote: 'quotes',
    mkbibquote: 'quotes',
    textmd: void 0,
    textrm: void 0,
    textsf: void 0,
    texttt: void 0,
    textup: void 0,
  },
  jo = {
    italics: ['<i>', '</i>'],
    bold: ['<b>', '</b>'],
    superscript: ['<sup>', '</sup>'],
    subscript: ['<sub>', '</sub>'],
    smallcaps: ['<span style="font-variant:small-caps;">', '</span>'],
    nocase: ['<span class="nocase">', '</span>'],
    quotes: ['', ''],
  },
  Kc = {
    ElsevierGlyph(e) {
      return String.fromCharCode(parseInt(e, 16))
    },
    href(e, t) {
      return e
    },
    url(e) {
      return e
    },
  },
  my = /---?|''|``|~/g,
  Qs = { '--': '', '---': '', '``': '', "''": '', '~': '' },
  ao = { '^': 'superscript', sp: 'superscript', _: 'subscript', sb: 'subscript', mathrm: void 0 },
  Jc = {
    '^': {
      0: '',
      1: '',
      2: '',
      3: '',
      4: '',
      5: '',
      6: '',
      7: '',
      8: '',
      9: '',
      '+': '',
      '-': '',
      '=': '',
      '(': '',
      ')': '',
      i: '',
      n: '',
    },
    _: {
      0: '',
      1: '',
      2: '',
      3: '',
      4: '',
      5: '',
      6: '',
      7: '',
      8: '',
      9: '',
      '+': '',
      '-': '',
      '=': '',
      '(': '',
      ')': '',
      a: '',
      e: '',
      o: '',
      x: '',
      : '',
      h: '',
      k: '',
      l: '',
      m: '',
      n: '',
      s: '',
      p: '',
      t: '',
    },
  },
  dy = [
    'american',
    'british',
    'canadian',
    'english',
    'australian',
    'newzealand',
    'usenglish',
    'ukenglish',
    'en',
    'eng',
    'en-au',
    'en-bz',
    'en-ca',
    'en-cb',
    'en-gb',
    'en-ie',
    'en-jm',
    'en-nz',
    'en-ph',
    'en-tt',
    'en-us',
    'en-za',
    'en-zw',
    'anglais',
  ],
  LI = Object.freeze(
    Object.defineProperty(
      {
        __proto__: null,
        argumentCommands: Kc,
        commands: Ws,
        defaultStrings: hy,
        diacritics: Ys,
        fieldTypes: zo,
        formatting: jo,
        formattingCommands: Qc,
        formattingEnvs: so,
        ligaturePattern: my,
        ligatures: Qs,
        mathScriptFormatting: ao,
        mathScripts: Jc,
        required: Op,
        sentenceCaseLanguages: dy,
      },
      Symbol.toStringTag,
      { value: 'Module' }
    )
  ),
  hd = /[a-zA-Z_][a-zA-Z0-9_:-]*/,
  za = { comment: /%.*/, whitespace: { match: /\s+/, lineBreaks: !0 } },
  PI = Np.states({
    main: {
      junk: { match: /@[cC][oO][mM][mM][eE][nN][tT].+|[^@]+/, lineBreaks: !0 },
      at: { match: '@', push: 'entry' },
    },
    entry: {
      ...za,
      otherEntryType: {
        match: /[sS][tT][rR][iI][nN][gG]|[pP][rR][eE][aA][mM][bB][lL][eE]/,
        next: 'otherEntryContents',
      },
      dataEntryType: { match: hd, next: 'dataEntryContents' },
    },
    otherEntryContents: { ...za, lbrace: { match: /[{(]/, next: 'fields' } },
    dataEntryContents: {
      ...za,
      lbrace: { match: /[{(]/, next: 'dataEntryContents' },
      label: /[^,\s]+/,
      comma: { match: ',', next: 'fields' },
    },
    fields: {
      ...za,
      identifier: hd,
      number: /-?\d+/,
      hash: '#',
      equals: '=',
      comma: ',',
      quote: { match: '"', push: 'quotedLiteral' },
      lbrace: { match: '{', push: 'bracedLiteral' },
      rbrace: { match: /[})]/, pop: !0 },
    },
    quotedLiteral: {
      lbrace: { match: '{', push: 'bracedLiteral' },
      quote: { match: '"', pop: !0 },
      text: { match: /(?:\\[\\{]|[^{"])+/, lineBreaks: !0 },
    },
    bracedLiteral: {
      lbrace: { match: '{', push: 'bracedLiteral' },
      rbrace: { match: '}', pop: !0 },
      text: { match: /(?:\\[\\{}]|[^{}])+/, lineBreaks: !0 },
    },
  }),
  BI = { '(': ')', '{': '}' },
  FI = new Kb(
    {
      Main() {
        const e = []
        for (;;) {
          for (; this.matchToken('junk'); ) this.consumeToken('junk')
          if (this.matchEndOfFile()) break
          e.push(this.consumeRule('Entry'))
        }
        return e.filter(Boolean)
      },
      _() {
        let e
        for (; e !== this.token; )
          (e = this.token), this.consumeToken('whitespace', !0), this.consumeToken('comment', !0)
      },
      Entry() {
        this.consumeToken('at'), this.consumeRule('_')
        const e = (
          this.matchToken('otherEntryType')
            ? this.consumeToken('otherEntryType')
            : this.consumeToken('dataEntryType')
        ).value.toLowerCase()
        this.consumeRule('_')
        const t = this.consumeToken('lbrace').value
        this.consumeRule('_')
        let r
        if (e === 'string') {
          const [n, s] = this.consumeRule('Field')
          this.state.strings[n] = s
        } else if (e === 'preamble') this.consumeRule('Expression')
        else {
          const n = this.consumeToken('label').value
          this.consumeRule('_'), this.consumeToken('comma'), this.consumeRule('_')
          const s = this.consumeRule('EntryBody')
          r = { type: e, label: n, properties: s }
        }
        this.consumeRule('_')
        const i = this.consumeToken('rbrace').value
        return (
          i !== BI[t] &&
            Ft.warn('[plugin-bibtex]', `entry started with "${t}", but ends with "${i}"`),
          r
        )
      },
      EntryBody() {
        const e = {}
        for (; this.matchToken('identifier'); ) {
          const [t, r] = this.consumeRule('Field')
          if (((e[t] = r), this.consumeRule('_'), this.consumeToken('comma', !0)))
            this.consumeRule('_')
          else break
        }
        return e
      },
      Field() {
        const e = this.consumeToken('identifier').value.toLowerCase()
        this.consumeRule('_'), this.consumeToken('equals'), this.consumeRule('_')
        const t = this.consumeRule('Expression')
        return [e, t]
      },
      Expression() {
        let e = this.consumeRule('ExpressionPart')
        for (this.consumeRule('_'); this.matchToken('hash'); )
          this.consumeToken('hash'),
            this.consumeRule('_'),
            (e += this.consumeRule('ExpressionPart').toString()),
            this.consumeRule('_')
        return e
      },
      ExpressionPart() {
        return this.matchToken('identifier')
          ? this.state.strings[this.consumeToken('identifier').value.toLowerCase()] || ''
          : this.matchToken('number')
          ? parseInt(this.consumeToken('number'))
          : this.matchToken('quote')
          ? this.consumeRule('QuoteString')
          : this.consumeRule('BracketString')
      },
      QuoteString() {
        let e = ''
        for (this.consumeToken('quote'); !this.matchToken('quote'); ) e += this.consumeRule('Text')
        return this.consumeToken('quote'), e
      },
      BracketString() {
        let e = ''
        for (this.consumeToken('lbrace'); !this.matchToken('rbrace'); )
          e += this.consumeRule('Text')
        return this.consumeToken('rbrace'), e
      },
      Text() {
        return this.matchToken('lbrace')
          ? `{${this.consumeRule('BracketString')}}`
          : this.consumeToken('text').value
      },
    },
    { strings: hy }
  )
function md(e) {
  return FI.parse(PI.reset(e))
}
const oo = {
    splitEntries: /\n\s*(?=\[)/g,
    parseEntry: /^\[(.+?)\]\s*(?:\n([\s\S]+))?$/,
    splitPairs: /((?=.)\s)*\n\s*/g,
    splitPair: /:(.*)/,
  },
  MI = (e) => {
    const [, t, r] = e.match(oo.parseEntry) || []
    if (!t || !r) return {}
    {
      const i = { type: 'book', label: t, properties: {} }
      return (
        r
          .trim()
          .split(oo.splitPairs)
          .filter((n) => n)
          .forEach((n) => {
            let [s, a] = n.split(oo.splitPair)
            a &&
              ((s = s.trim()), (a = a.trim()), s === 'type' ? (i.type = a) : (i.properties[s] = a))
          }),
        i
      )
    }
  },
  UI = (e) => e.trim().split(oo.splitEntries).map(MI),
  Zc = {
    source: {
      article: 'article-journal',
      book: 'book',
      mvbook: 'book',
      inbook: 'chapter',
      bookinbook: 'book',
      booklet: 'book',
      collection: 'book',
      mvcollection: 'book',
      incollection: 'chapter',
      dataset: 'dataset',
      online: 'webpage',
      patent: 'patent',
      periodical: 'article-journal',
      proceedings: 'book',
      mvproceedings: 'book',
      inproceedings: 'paper-conference',
      reference: 'book',
      mvreference: 'book',
      inreference: 'entry',
      report: 'report',
      software: 'book',
      thesis: 'thesis',
      unpublished: 'manuscript',
      artwork: 'graphic',
      audio: 'song',
      image: 'figure',
      jurisdiction: 'legal_case',
      legislation: 'legislation',
      legal: 'treaty',
      letter: 'personal_communication',
      movie: 'motion_picture',
      music: 'musical_score',
      review: 'review',
      video: 'motion_picture',
      conference: 'paper-conference',
      electronic: 'webpage',
      mastersthesis: 'thesis',
      phdthesis: 'thesis',
      techreport: 'report',
      www: 'webpage',
    },
    target: {
      article: 'article',
      'article-journal': 'article',
      'article-magazine': 'article',
      'article-newspaper': 'article',
      bill: 'legislation',
      book: 'book',
      broadcast: 'audio',
      chapter: 'inbook',
      dataset: 'dataset',
      entry: 'inreference',
      'entry-dictionary': 'inreference',
      'entry-encyclopedia': 'inreference',
      figure: 'artwork',
      graphic: 'artwork',
      interview: 'audio',
      legal_case: 'jurisdiction',
      legislation: 'legislation',
      manuscript: 'unpublished',
      motion_picture: 'movie',
      musical_score: 'music',
      'paper-conference': 'inproceedings',
      patent: 'patent',
      personal_communication: 'letter',
      post: 'online',
      'post-weblog': 'online',
      report: 'report',
      review: 'review',
      'review-book': 'review',
      song: 'music',
      speech: 'audio',
      thesis: 'thesis',
      treaty: 'legal',
      webpage: 'online',
    },
  },
  ef = {
    source: {
      article: 'article-journal',
      book: 'book',
      booklet: 'book',
      conference: 'paper-conference',
      inbook: 'chapter',
      incollection: 'chapter',
      inproceedings: 'paper-conference',
      mastersthesis: 'thesis',
      phdthesis: 'thesis',
      proceedings: 'book',
      techreport: 'report',
      unpublished: 'manuscript',
    },
    target: {
      article: 'article',
      'article-journal': 'article',
      'article-magazine': 'article',
      'article-newspaper': 'article',
      book: 'book',
      chapter: 'inbook',
      manuscript: 'unpublished',
      'paper-conference': 'inproceedings',
      report: 'techreport',
      review: 'article',
      'review-book': 'article',
    },
  },
  ma = {
    constants: LI,
    types: { biblatex: Zc, bibtex: ef },
    parse: { biblatex: !0, strict: !1, sentenceCase: 'never' },
    format: { useIdAsLabel: !1 },
  },
  HI = new Set(['the', 'a', 'an']),
  tf = /(?:<\/?.*?>|[\u0020-\u002F\u003A-\u0040\u005B-\u005E\u0060\u007B-\u007F])+/g,
  zI = /[^\u0020-\u007F]+/g
function dd(e) {
  return e
    ? e
        .normalize('NFKD')
        .replace(zI, '')
        .split(tf)
        .find((t) => t.length && !HI.has(t.toLowerCase()))
    : ''
}
const gd = new Pr([
    { source: 'given', target: 'given' },
    { source: 'family', target: 'family' },
    { source: 'suffix', target: 'suffix' },
    { source: 'prefix', target: 'non-dropping-particle' },
    {
      source: 'family',
      target: 'literal',
      when: { source: !1, target: { family: !1, given: !1 } },
    },
  ]),
  jI = ['jan', 'feb', 'mar', 'apr', 'may', 'jun', 'jul', 'aug', 'sep', 'oct', 'nov', 'dec'],
  rt = 'BibTeX type',
  Ks = 'BibTeX label',
  Yi = {
    jan: 1,
    feb: 2,
    mar: 3,
    apr: 4,
    may: 5,
    jun: 6,
    jul: 7,
    aug: 8,
    sep: 9,
    oct: 10,
    nov: 11,
    dec: 12,
    january: 1,
    february: 2,
    march: 3,
    april: 4,
    may: 5,
    june: 6,
    july: 7,
    august: 8,
    september: 9,
    october: 10,
    november: 11,
    december: 12,
  },
  qI = {
    bathesis: "Bachelor's thesis",
    mathesis: "Master's thesis",
    phdthesis: 'PhD thesis',
    candthesis: 'Candidate thesis',
    techreport: 'technical report',
    resreport: 'research report',
    software: 'computer software',
    datacd: 'data cd',
    audiocd: 'audio cd',
    patent: 'patent',
    patentde: 'German patent',
    patenteu: 'European patent',
    patentfr: 'French patent',
    patentuk: 'British patent',
    patentus: 'U.S. patent',
    patreq: 'patent request',
    patreqde: 'German patent request',
    patreqeu: 'European patent request',
    patreqfr: 'French patent request',
    patrequk: 'British patent request',
    patrequs: 'U.S. patent request',
  },
  $I =
    /(^(?:ISAN )?(?:[0-9a-f]{4}-){4}[0-9a-z](?:-(?:[0-9a-f]{4}-){2}[0-9a-z])?$)|(^(?:979-?0-?|M-?)(?:\d{9}|(?=[\d-]{11}$)\d+-\d+-\d)$)|(^ISRN .{1,36}$)|(^(?:ISWC )?T-?\d{9}-?\d$)/i
function VI(e) {
  const t = e
      .split('T')[0]
      .replace(/[?~%]$/, '')
      .split('-'),
    r = +t[0].replace(/^Y(?=-?\d{4}\d+)/, '').replace(/X/g, '0'),
    i = +t[1],
    n = +t[2]
  return !i || i > 20 ? [r] : n ? [r, i, n] : [r, i]
}
function GI(e) {
  if (e == null) return []
  if (+e) return [parseInt(e, 10)]
  if (((e = e.trim().toLowerCase()), e in Yi)) return [Yi[e]]
  const t = e.split(/\s+/)
  let r, i
  return (
    t[0] in Yi
      ? ((r = Yi[t[0]]), (i = parseInt(t[1])))
      : t[1] in Yi && ((r = Yi[t[1]]), (i = parseInt(t[0]))),
    i ? [r, i] : r ? [r] : []
  )
}
function XI(e, t, r, i) {
  let n = ''
  return (
    e && e[0] && (n += dd(e[0].family || e[0].literal)),
    t && t['date-parts'] && t['date-parts'][0] && (n += t['date-parts'][0][0]),
    r ? (n += r) : i && (n += dd(i)),
    n
  )
}
const xe = {
    PICK: {
      toTarget(...e) {
        return e.find(Boolean)
      },
      toSource(e) {
        return [e]
      },
    },
    DATE: {
      toTarget(e) {
        const t = e.split('/').map((r) => (r && r !== '..' ? VI(r) : void 0))
        return isNaN(t[0][0]) ? { literal: e } : { 'date-parts': t }
      },
      toSource(e) {
        if ('date-parts' in e)
          return e['date-parts']
            .map((t) => t.map((r) => r.toString().padStart(2, '0')).join('-'))
            .join('/')
      },
    },
    YEAR_MONTH: {
      toTarget(e, t, r) {
        return isNaN(+e)
          ? { literal: e }
          : !isNaN(+r) && !isNaN(+t)
          ? { 'date-parts': [[+e, +t, +r]] }
          : { 'date-parts': [[+e, ...GI(t)]] }
      },
      toSource(e) {
        if ('date-parts' in e) {
          const [t, r, i] = e['date-parts'][0]
          return [t.toString(), r ? (i ? `${jI[r - 1]} ${i}` : r) : void 0]
        }
      },
    },
    EPRINT: {
      toTarget(e, t) {
        if (t === 'pubmed') return e
      },
      toSource(e) {
        return [e, 'pubmed']
      },
    },
    HOW_PUBLISHED: {
      toTarget(e) {
        if (e.startsWith('http')) return e
      },
    },
    KEYWORDS: {
      toTarget(e) {
        return e.join(',')
      },
      toSource(e) {
        return e.split(',')
      },
    },
    LABEL: {
      toTarget(e) {
        return [e, e]
      },
      toSource(e, t, r, i, n, s) {
        let a
        return (
          e === null
            ? (a = 'null')
            : e === void 0
            ? (a = 'undefined')
            : (a = e.toString().replace(tf, '')),
          ma.format.useIdAsLabel ? a : t && !tf.test(t) ? t : XI(r, i, n, s) || a
        )
      },
    },
    NAMES: {
      toTarget(e) {
        return e.map(gd.convertToTarget)
      },
      toSource(e) {
        return e.map(gd.convertToSource)
      },
    },
    STANDARD_NUMBERS: {
      toTarget(...e) {
        return e.find(Boolean)
      },
      toSource(e) {
        const t = e.toString().match($I)
        return t ? t.slice(1, 5) : []
      },
    },
    STATUS: {
      toSource(e) {
        if (/^(inpreparation|submitted|forthcoming|inpress|prepublished)$/i.test(e)) return e
      },
    },
    TITLE: {
      toTarget(e, t, r) {
        return t && (e += ': ' + t), e
      },
      toSource(e) {
        return [e]
      },
    },
  },
  YI = [
    {
      source: 'note',
      target: 'accessed',
      when: { source: !1, target: { note: !1 } },
      convert: {
        toSource(e) {
          return `[Online; accessed ${Xs.format(e)}]`
        },
      },
    },
    {
      source: 'numpages',
      target: 'number-of-pages',
      when: { source: { pagetotal: !1 }, target: !1 },
    },
    {
      source: 'pmid',
      target: 'PMID',
      when: {
        source: {
          eprinttype(e) {
            return e !== 'pmid'
          },
          archiveprefix(e) {
            return e !== 'pmid'
          },
        },
        target: !1,
      },
    },
    { source: 'pmcid', target: 'PMCID', when: { target: !1 } },
  ],
  WI = [
    { source: 'annote', target: 'annote', when: { source: { annotation: !1 }, target: !1 } },
    {
      source: 'address',
      target: 'publisher-place',
      convert: xe.PICK,
      when: { source: { location: !1 }, target: !1 },
    },
    {
      source: ['eprint', 'archiveprefix'],
      target: 'PMID',
      convert: xe.EPRINT,
      when: { source: { eprinttype: !1 }, target: !1 },
    },
    {
      source: 'journal',
      target: 'container-title',
      when: { source: { maintitle: !1, booktitle: !1, journaltitle: !1 }, target: !1 },
    },
    {
      source: 'school',
      target: 'publisher',
      convert: xe.PICK,
      when: { source: { institution: !1, organization: !1, publisher: !1 }, target: !1 },
    },
  ],
  gy = new Pr([
    ...WI,
    ...YI,
    { source: 'abstract', target: 'abstract' },
    { source: 'urldate', target: 'accessed', convert: xe.DATE },
    { source: 'annotation', target: 'annote' },
    { source: 'author', target: 'author', convert: xe.NAMES },
    { source: 'library', target: 'call-number' },
    { source: 'chapter', target: 'chapter-number' },
    { source: 'bookauthor', target: 'container-author', convert: xe.NAMES },
    {
      source: ['maintitle', 'mainsubtitle', 'maintitleaddon'],
      target: 'container-title',
      when: { source: !0, target: { 'number-of-volumes': !0 } },
      convert: xe.TITLE,
    },
    {
      source: ['booktitle', 'booksubtitle', 'booktitleaddon'],
      target: 'container-title',
      when: {
        source: { maintitle: !1 },
        target: {
          'number-of-volumes': !1,
          type(e) {
            return !e.startsWith('article')
          },
        },
      },
      convert: xe.TITLE,
    },
    {
      source: ['journaltitle', 'journalsubtitle', 'journaltitleaddon'],
      target: 'container-title',
      when: {
        source: { [rt]: 'article' },
        target: { type: ['article', 'article-newspaper', 'article-journal', 'article-magazine'] },
      },
      convert: xe.TITLE,
    },
    {
      source: 'shortjournal',
      target: 'container-title-short',
      when: {
        source: { [rt]: 'article' },
        target: { type: ['article', 'article-newspaper', 'article-journal', 'article-magazine'] },
      },
    },
    {
      source: 'shortjournal',
      target: 'journalAbbreviation',
      when: { source: !1, target: { 'container-title-short': !1 } },
    },
    {
      source: 'number',
      target: 'collection-number',
      when: {
        source: {
          [rt]: [
            'book',
            'mvbook',
            'inbook',
            'bookinbook',
            'suppbook',
            'collection',
            'mvcollection',
            'incollection',
            'suppcollection',
            'manual',
            'suppperiodical',
            'proceedings',
            'mvproceedings',
            'refererence',
          ],
        },
        target: {
          type: [
            'bill',
            'book',
            'broadcast',
            'chapter',
            'dataset',
            'entry',
            'entry-dictionary',
            'entry-encyclopedia',
            'figure',
            'graphic',
            'interview',
            'legislation',
            'legal_case',
            'manuscript',
            'map',
            'motion_picture',
            'musical_score',
            'pamphlet',
            'post',
            'post-weblog',
            'personal_communication',
            'review',
            'review-book',
            'song',
            'speech',
            'thesis',
            'treaty',
            'webpage',
          ],
        },
      },
    },
    { source: 'series', target: 'collection-title' },
    { source: 'shortseries', target: 'collection-title-short' },
    { source: 'doi', target: 'DOI' },
    { source: 'edition', target: 'edition' },
    { source: 'editor', target: 'editor', convert: xe.NAMES },
    {
      source: [rt, 'entrysubtype', 'type'],
      target: ['type', 'genre'],
      convert: {
        toTarget(e, t, r) {
          return (
            r ||
              (e === 'masterthesis' && (r = 'mathesis'),
              e === 'phdthesis' && (r = 'phdthesis'),
              e === 'techreport' && (r = 'techreport')),
            [Zc.source[e] || 'book', r || t]
          )
        },
        toSource(e, t) {
          const r = Zc.target[e] || 'misc'
          return t in qI ? [r, void 0, t] : [r, t]
        },
      },
    },
    {
      source: rt,
      when: { target: { type: !1 } },
      convert: {
        toSource() {
          return 'misc'
        },
      },
    },
    { source: 'eventdate', target: 'event-date', convert: xe.DATE },
    { source: 'venue', target: 'event-place' },
    { source: 'eventtitle', target: 'event' },
    {
      source: Ks,
      target: ['id', 'citation-label', 'author', 'issued', 'year-suffix', 'title'],
      convert: xe.LABEL,
    },
    { source: 'isbn', target: 'ISBN' },
    { source: 'issn', target: 'ISSN' },
    {
      source: 'issue',
      target: 'issue',
      when: {
        source: { number: !1, [rt]: ['article', 'periodical'] },
        target: {
          issue(e) {
            return typeof e == 'string' && !e.match(/\d+/)
          },
          type: ['article', 'article-journal', 'article-newspaper', 'article-magazine'],
        },
      },
    },
    {
      source: 'number',
      target: 'issue',
      when: {
        source: { [rt]: ['article', 'periodical', 'inproceedings'] },
        target: {
          issue(e) {
            return e && (typeof e == 'number' || e.match(/\d+/))
          },
          type: [
            'article',
            'article-journal',
            'article-newspaper',
            'article-magazine',
            'paper-conference',
          ],
        },
      },
    },
    { source: 'date', target: 'issued', convert: xe.DATE },
    {
      source: ['year', 'month', 'day'],
      target: 'issued',
      convert: xe.YEAR_MONTH,
      when: { source: { date: !1 }, target: !1 },
    },
    {
      source: 'location',
      target: 'jurisdiction',
      when: { source: { type: 'patent' }, target: { type: 'patent' } },
    },
    { source: 'keywords', target: 'keyword', convert: xe.KEYWORDS },
    { source: 'language', target: 'language', convert: xe.PICK },
    { source: 'note', target: 'note' },
    {
      source: ['isan', 'ismn', 'isrn', 'iswc'],
      target: 'number',
      convert: xe.STANDARD_NUMBERS,
      when: {
        source: {
          [rt](e) {
            return e !== 'patent'
          },
        },
        target: {
          type(e) {
            return e !== 'patent'
          },
        },
      },
    },
    {
      source: 'number',
      target: 'number',
      when: {
        source: { [rt]: ['patent', 'report', 'techreport', 'legislation'] },
        target: { type: ['patent', 'report', 'legislation'] },
      },
    },
    { source: 'origdate', target: 'original-date', convert: xe.DATE },
    { source: 'origlocation', target: 'original-publisher-place', convert: xe.PICK },
    { source: 'origpublisher', target: 'original-publisher', convert: xe.PICK },
    { source: 'origtitle', target: 'original-title' },
    {
      source: ['pages', 'eid'],
      target: 'page',
      convert: {
        toTarget(e, t) {
          return t ? t.replace(/^e?/i, 'e') : e.replace(/[]/, '-')
        },
        toSource(e) {
          return /^e/i.test(e) ? [e, e] : [e.replace('-', '--')]
        },
      },
    },
    { source: 'pagetotal', target: 'number-of-pages' },
    { source: ['eprint', 'eprinttype'], target: 'PMID', convert: xe.EPRINT },
    { source: 'location', target: 'publisher-place', convert: xe.PICK },
    {
      source: 'publisher',
      target: 'publisher',
      convert: xe.PICK,
      when: {
        source: !0,
        target: {
          type: [
            'article',
            'article-journal',
            'article-magazine',
            'article-newspaper',
            'bill',
            'book',
            'broadcast',
            'chapter',
            'dataset',
            'entry',
            'entry-dictionary',
            'entry-encyclopedia',
            'figure',
            'graphic',
            'interview',
            'legal_case',
            'legislation',
            'manuscript',
            'map',
            'motion_picture',
            'musical_score',
            'pamphlet',
            'paper-conference',
            'patent',
            'personal_communication',
            'post',
            'post-weblog',
            'regulation',
            'review',
            'review-book',
            'song',
            'speech',
            'treaty',
          ],
        },
      },
    },
    {
      source: 'organization',
      target: 'publisher',
      convert: xe.PICK,
      when: { source: { publisher: !1 }, target: { type: 'webpage' } },
    },
    {
      source: 'institution',
      target: 'publisher',
      convert: xe.PICK,
      when: { source: { publisher: !1, organization: !1 }, target: { type: ['report', 'thesis'] } },
    },
    {
      source: 'howpublished',
      target: 'publisher',
      convert: xe.PICK,
      when: {
        source: { publisher: !1, organization: !1, institution: !1 },
        target: { type: 'manuscript' },
      },
    },
    {
      source: ['pages', 'bookpagination'],
      target: 'section',
      when: { source: { bookpagination: 'section' }, target: { page: !1 } },
      convert: {
        toTarget(e) {
          return e
        },
        toSource(e) {
          return [e, 'section']
        },
      },
    },
    { source: 'pubstate', target: 'status', convert: xe.STATUS },
    { source: 'shorttitle', target: 'title-short' },
    { source: ['title', 'subtitle', 'titleaddon'], target: 'title', convert: xe.TITLE },
    { source: 'translator', target: 'translator', convert: xe.NAMES },
    { source: 'url', target: 'URL' },
    {
      source: 'howpublished',
      target: 'URL',
      convert: xe.HOW_PUBLISHED,
      when: { source: { url: !1 }, target: !1 },
    },
    { source: 'version', target: 'version' },
    { source: 'volume', target: 'volume' },
    { source: 'volumes', target: 'number-of-volumes' },
  ]),
  by = new Pr([
    {
      source: 'note',
      target: 'accessed',
      when: { source: !1, target: { note: !1 } },
      convert: {
        toSource(e) {
          return `[Online; accessed ${Xs.format(e)}]`
        },
      },
    },
    { source: 'annote', target: 'annote' },
    { source: 'address', target: 'publisher-place', convert: xe.PICK },
    { source: 'author', target: 'author', convert: xe.NAMES },
    { source: 'chapter', target: 'chapter-number' },
    {
      source: 'number',
      target: 'collection-number',
      when: {
        source: {
          [rt]: [
            'book',
            'mvbook',
            'inbook',
            'collection',
            'mvcollection',
            'incollection',
            'suppcollection',
            'manual',
            'suppperiodical',
            'proceedings',
            'mvproceedings',
            'refererence',
          ],
        },
        target: {
          type: [
            'bill',
            'book',
            'broadcast',
            'chapter',
            'dataset',
            'entry',
            'entry-dictionary',
            'entry-encyclopedia',
            'figure',
            'graphic',
            'interview',
            'legislation',
            'legal_case',
            'manuscript',
            'map',
            'motion_picture',
            'musical_score',
            'pamphlet',
            'post',
            'post-weblog',
            'personal_communication',
            'review',
            'review-book',
            'song',
            'speech',
            'thesis',
            'treaty',
            'webpage',
          ],
        },
      },
    },
    { source: 'series', target: 'collection-title' },
    {
      source: 'booktitle',
      target: 'container-title',
      when: { target: { type: ['chapter', 'paper-conference'] } },
    },
    {
      source: 'journal',
      target: 'container-title',
      when: {
        source: { [rt]: 'article' },
        target: { type: ['article', 'article-newspaper', 'article-journal', 'article-magazine'] },
      },
    },
    { source: 'edition', target: 'edition' },
    { source: 'editor', target: 'editor', convert: xe.NAMES },
    {
      source: Ks,
      target: ['id', 'citation-label', 'author', 'issued', 'year-suffix', 'title'],
      convert: xe.LABEL,
    },
    {
      source: 'number',
      target: 'issue',
      when: {
        source: { [rt]: ['article', 'periodical', 'inproceedings'] },
        target: {
          issue(e) {
            return typeof e == 'number' || (typeof e == 'string' && e.match(/\d+/))
          },
          type: [
            'article',
            'article-journal',
            'article-newspaper',
            'article-magazine',
            'paper-conference',
          ],
        },
      },
    },
    { source: ['year', 'month', 'day'], target: 'issued', convert: xe.YEAR_MONTH },
    { source: 'note', target: 'note' },
    {
      source: 'number',
      target: 'number',
      when: {
        source: { [rt]: ['patent', 'report', 'techreport'] },
        target: { type: ['patent', 'report'] },
      },
    },
    {
      source: 'pages',
      target: 'page',
      convert: {
        toTarget(e) {
          return e.replace(/[]/, '-')
        },
        toSource(e) {
          return e.replace('-', '--')
        },
      },
    },
    {
      source: 'publisher',
      target: 'publisher',
      convert: xe.PICK,
      when: {
        target: {
          type: [
            'article',
            'article-journal',
            'article-magazine',
            'article-newspaper',
            'bill',
            'book',
            'broadcast',
            'chapter',
            'dataset',
            'entry',
            'entry-dictionary',
            'entry-encyclopedia',
            'figure',
            'graphic',
            'interview',
            'legal_case',
            'legislation',
            'map',
            'motion_picture',
            'musical_score',
            'pamphlet',
            'patent',
            'personal_communication',
            'post',
            'post-weblog',
            'review',
            'review-book',
            'song',
            'speech',
            'treaty',
            'webpage',
          ],
        },
      },
    },
    {
      source: 'organization',
      target: 'publisher',
      convert: xe.PICK,
      when: { source: { publisher: !1 }, target: { type: 'paper-conference' } },
    },
    {
      source: 'institution',
      target: 'publisher',
      convert: xe.PICK,
      when: { source: { publisher: !1, organization: !1 }, target: { type: 'report' } },
    },
    {
      source: 'school',
      target: 'publisher',
      convert: xe.PICK,
      when: {
        source: { institution: !1, organization: !1, publisher: !1 },
        target: { type: 'thesis' },
      },
    },
    {
      source: 'howpublished',
      target: 'publisher',
      convert: xe.PICK,
      when: {
        source: { publisher: !1, organization: !1, institution: !1, school: !1 },
        target: { type: 'manuscript' },
      },
    },
    { source: 'title', target: 'title' },
    {
      source: [rt, 'type'],
      target: ['type', 'genre'],
      convert: {
        toTarget(e, t) {
          const r = ef.source[e] || 'book'
          return t
            ? [r, t]
            : e === 'mastersthesis'
            ? [r, "Master's thesis"]
            : e === 'phdthesis'
            ? [r, 'PhD thesis']
            : [r]
        },
        toSource(e, t) {
          const r = ef.target[e] || 'misc'
          return /^(master'?s|diploma) thesis$/i.test(t)
            ? ['mastersthesis']
            : /^(phd|doctoral) thesis$/i.test(t)
            ? ['phdthesis']
            : [r, t]
        },
      },
    },
    {
      source: rt,
      when: { target: { type: !1 } },
      convert: {
        toSource() {
          return 'misc'
        },
      },
    },
    {
      source: 'howpublished',
      target: 'URL',
      convert: xe.HOW_PUBLISHED,
      when: { target: { publisher: !1 } },
    },
    { source: 'volume', target: 'volume' },
  ])
function QI(e, t) {
  if (e == null) return {}
  var r = KI(e, t),
    i,
    n
  if (Object.getOwnPropertySymbols) {
    var s = Object.getOwnPropertySymbols(e)
    for (n = 0; n < s.length; n++)
      (i = s[n]),
        !(t.indexOf(i) >= 0) && Object.prototype.propertyIsEnumerable.call(e, i) && (r[i] = e[i])
  }
  return r
}
function KI(e, t) {
  if (e == null) return {}
  var r = {},
    i = Object.keys(e),
    n,
    s
  for (s = 0; s < i.length; s++) (n = i[s]), !(t.indexOf(n) >= 0) && (r[n] = e[n])
  return r
}
function JI(e) {
  var t = ZI(e, 'string')
  return typeof t == 'symbol' ? t : String(t)
}
function ZI(e, t) {
  if (typeof e != 'object' || e === null) return e
  var r = e[Symbol.toPrimitive]
  if (r !== void 0) {
    var i = r.call(e, t || 'default')
    if (typeof i != 'object') return i
    throw new TypeError('@@toPrimitive must return a primitive value.')
  }
  return (t === 'string' ? String : Number)(e)
}
function bd(e, t) {
  var r = Object.keys(e)
  if (Object.getOwnPropertySymbols) {
    var i = Object.getOwnPropertySymbols(e)
    t &&
      (i = i.filter(function (n) {
        return Object.getOwnPropertyDescriptor(e, n).enumerable
      })),
      r.push.apply(r, i)
  }
  return r
}
function eD(e) {
  for (var t = 1; t < arguments.length; t++) {
    var r = arguments[t] != null ? arguments[t] : {}
    t % 2
      ? bd(Object(r), !0).forEach(function (i) {
          tD(e, i, r[i])
        })
      : Object.getOwnPropertyDescriptors
      ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(r))
      : bd(Object(r)).forEach(function (i) {
          Object.defineProperty(e, i, Object.getOwnPropertyDescriptor(r, i))
        })
  }
  return e
}
function tD(e, t, r) {
  return (
    t in e
      ? Object.defineProperty(e, t, { value: r, enumerable: !0, configurable: !0, writable: !0 })
      : (e[t] = r),
    e
  )
}
function yy(e, t) {
  if (e.crossref in t) {
    const r = t[e.crossref].properties
    return r === e ? e : Object.assign({}, yy(r, t), e)
  }
  return e
}
function _y(e, t) {
  const r = {}
  for (const i of e) r[i.label] = i
  return e.map(({ type: i, label: n, properties: s }) =>
    t.convertToTarget(eD({ [rt]: i, [Ks]: n }, yy(s, r)))
  )
}
function vy(e, t) {
  return e.map((r) => {
    const i = t.convertToSource(r),
      { [rt]: n, [Ks]: s } = i,
      a = QI(i, [rt, Ks].map(JI))
    return { type: n, label: s, properties: a }
  })
}
function rD(e) {
  return _y(e, by)
}
function iD(e) {
  return vy(e, by)
}
function nD(e) {
  return _y(e, gy)
}
function sD(e) {
  return vy(e, gy)
}
function aD(e) {
  const t = e.toUpperCase(),
    r = e.toLowerCase()
  for (let i = 0; i < e.length; i++) if (t[i] !== r[i]) return t[i] === e[i]
  return null
}
function ai(e) {
  if (e.length === 0) return
  let t = ''
  for (; e.length > 1; ) {
    const { value: i, hyphenated: n } = e.shift()
    t += i + (n ? '-' : ' ')
  }
  const r = t + e[0].value
  return r[0] && r
}
function oD(e, t = !0) {
  const r = [],
    i = []
  if (t)
    for (; e.length > 1 && e[0].upperCase !== !1; ) {
      for (r.push(...i), i.length = 0; e.length > 1 && e[0].upperCase !== !1 && !e[0].hyphenated; )
        r.push(e.shift())
      for (; e.length > 0 && e[0].upperCase !== !1 && e[0].hyphenated; ) i.push(e.shift())
    }
  const n = [],
    s = []
  for (; e.length > 1; ) {
    for (n.push(...s), s.length = 0; e.length > 1 && e[0].upperCase === !1; ) n.push(e.shift())
    for (; e.length > 0 && e[0].upperCase !== !1; ) s.push(e.shift())
  }
  return i.length && s.unshift(...i), e.length && s.push(e[0]), [ai(r), ai(n), ai(s)]
}
function uD(e) {
  if (e[0][0].label) {
    const s = {}
    for (const [{ value: a, label: o }] of e) s[o] = a
    return s
  }
  const t = {},
    [r, i, n] = oD(e[0], e.length === 1)
  return (
    n && (t.family = n),
    i && (t.prefix = i),
    e.length === 3
      ? ((t.given = ai(e[2])), (t.suffix = ai(e[1])))
      : e.length === 2
      ? (t.given = ai(e[1]))
      : r && (t.given = r),
    t
  )
}
const Wi = {
    command: {
      match: /\\(?:[a-zA-Z]+|.) */,
      type: Np.keywords({ commandBegin: '\\begin', commandEnd: '\\end' }),
      value: (e) => e.slice(1).trim(),
    },
    lbrace: { match: '{', push: 'bracedLiteral' },
    mathShift: { match: '$', push: 'mathLiteral' },
    whitespace: {
      match: /[\s]+|~/,
      lineBreaks: !0,
      value(e) {
        return e === '~' ? '' : ' '
      },
    },
  },
  lD = Np.states({
    stringLiteral: { ...Wi, text: /[^{$}\s~\\]+/ },
    namesLiteral: {
      and: /\s+[aA][nN][dD]\s+/,
      comma: ',',
      hyphen: '-',
      equals: '=',
      ...Wi,
      text: /[^{$}\s~\\,=-]+/,
    },
    listLiteral: { and: /\s+and\s+/, ...Wi, text: /[^{$}\s~\\]+/ },
    separatedLiteral: { comma: ',', ...Wi, text: /[^{$}\s~\\,]+/ },
    bracedLiteral: { ...Wi, rbrace: { match: '}', pop: !0 }, text: /[^{$}\s~\\]+/ },
    mathLiteral: {
      ...Wi,
      mathShift: { match: '$', pop: !0 },
      script: /[\^_]/,
      text: /[^{$}\s~\\^_]+/,
    },
  })
function ja(e) {
  return e[0], e
}
function Zn(e, t) {
  return t in jo ? e && jo[t].join(e) : e
}
const cD = new Kb(
  {
    String() {
      let e = ''
      for (; !this.matchEndOfFile(); ) e += this.consumeRule('Text')
      return ja(e)
    },
    StringNames() {
      const e = []
      for (;;) {
        if (
          (this.consumeToken('whitespace', !0),
          e.push(this.consumeRule('Name')),
          this.consumeToken('whitespace', !0),
          this.matchEndOfFile())
        )
          return e
        this.consumeToken('and')
      }
    },
    Name() {
      const e = []
      for (;;) {
        if (
          (e.push(this.consumeRule('NamePiece')), this.matchEndOfFile() || this.matchToken('and'))
        )
          return uD(e)
        this.consumeToken('comma'), this.consumeToken('whitespace', !0)
      }
    },
    NamePiece() {
      const e = []
      for (;;) {
        const t = this.consumeRule('NameToken')
        if (t.label) return (t.label = ai([...e, { value: t.label }])), [t]
        if (
          (e.push(t), this.matchEndOfFile() || this.matchToken('and') || this.matchToken('comma'))
        )
          return e
        for (; this.matchToken('hyphen') || this.matchToken('whitespace'); ) this.consumeToken()
      }
    },
    NameToken() {
      let e = null,
        t = ''
      for (;;)
        if (e === null && this.matchToken('text')) {
          const r = this.consumeToken().value
          ;(t += r), (e = aD(r))
        } else {
          if (
            this.matchEndOfFile() ||
            this.matchToken('and') ||
            this.matchToken('comma') ||
            this.matchToken('whitespace')
          )
            return { value: t, upperCase: e }
          if (this.matchToken('hyphen')) return { value: t, upperCase: e, hyphenated: !0 }
          if (this.matchToken('equals')) {
            this.consumeToken('equals')
            const r = this.consumeRule('NamePiece')
            return r[0].label && (t += '=' + r[0].label), { value: ai(r), label: t }
          } else t += this.consumeRule('Text')
        }
    },
    StringList() {
      const e = []
      for (; !this.matchEndOfFile(); ) {
        let t = ''
        for (; !this.matchEndOfFile() && !this.matchToken('and'); ) t += this.consumeRule('Text')
        e.push(ja(t)), this.consumeToken('and', !0)
      }
      return e.length === 1 ? e[0] : e
    },
    StringSeparated() {
      const e = []
      for (; !this.matchEndOfFile(); ) {
        let t = ''
        for (; !this.matchEndOfFile() && !this.matchToken('comma'); ) t += this.consumeRule('Text')
        e.push(t.trim()), this.consumeToken('comma', !0), this.consumeToken('whitespace', !0)
      }
      return e
    },
    StringVerbatim() {
      let e = ''
      for (; !this.matchEndOfFile(); ) e += this.consumeToken().text
      return ja(e)
    },
    StringUri() {
      const e = this.consumeRule('StringVerbatim')
      try {
        return decodeURI(e) === e ? encodeURI(e) : e
      } catch {
        return encodeURI(e)
      }
    },
    StringTitleCase() {
      this.state.sentenceCase = !0
      let e = ''
      for (; !this.matchEndOfFile(); ) e += this.consumeRule('Text')
      return ja(e)
    },
    BracketString() {
      var n
      let e = ''
      this.consumeToken('lbrace')
      const t = this.state.sentenceCase
      for (
        this.state.sentenceCase = t && this.matchToken('command'),
          (n = this.state).partlyLowercase && (n.partlyLowercase = this.state.sentenceCase);
        !this.matchToken('rbrace');

      )
        e += this.consumeRule('Text')
      const i = t && !this.state.sentenceCase && this.state.partlyLowercase
      return (this.state.sentenceCase = t), this.consumeToken('rbrace'), i ? Zn(e, 'nocase') : e
    },
    MathString() {
      let e = ''
      for (this.consumeToken('mathShift'); !this.matchToken('mathShift'); ) {
        if (this.matchToken('script')) {
          const t = this.consumeToken('script').value,
            r = this.consumeRule('Text').split('')
          if (r.every((i) => i in Jc[t])) e += r.map((i) => Jc[t][i]).join('')
          else {
            const i = ao[t]
            e += jo[i].join(r.join(''))
          }
          continue
        }
        if (this.matchToken('command')) {
          const t = this.token.value
          if (t in ao) {
            this.consumeToken('command')
            const r = this.consumeRule('BracketString')
            e += Zn(r, ao[t])
            continue
          }
        }
        e += this.consumeRule('Text')
      }
      return this.consumeToken('mathShift'), e
    },
    Text() {
      var a
      if (this.matchToken('lbrace')) return this.consumeRule('BracketString')
      if (this.matchToken('mathShift')) return this.consumeRule('MathString')
      if (this.matchToken('whitespace')) return this.consumeToken('whitespace').value
      if (this.matchToken('commandBegin')) return this.consumeRule('EnclosedEnv')
      if (this.matchToken('command')) return this.consumeRule('Command')
      const e = this.consumeToken('text').value.replace(my, (o) => Qs[o]),
        t = this.state.afterPunctuation
      if (((this.state.afterPunctuation = /[?!.:]$/.test(e)), !this.state.sentenceCase))
        return (
          (a = this.state).partlyLowercase ||
            (a.partlyLowercase = e === e.toLowerCase() && e !== e.toUpperCase()),
          e
        )
      const [r, ...i] = e,
        n = i.join(''),
        s = n.toLowerCase()
      return n !== s ? e : t ? r + s : e.toLowerCase()
    },
    Command() {
      const e = this.consumeToken('command'),
        t = e.value
      if (t in so) {
        const r = this.consumeRule('Env'),
          i = so[t]
        return Zn(r, i)
      } else if (t in Qc) {
        const r = this.consumeRule('BracketString'),
          i = Qc[t]
        return Zn(r, i)
      } else {
        if (t in Ws) return Ws[t]
        if (t in Ys && !this.matchEndOfFile()) {
          const r = this.consumeRule('Text')
          return (r[0] + Ys[t]).normalize('NFC') + r.slice(1)
        } else if (t in Kc) {
          const r = Kc[t],
            i = []
          let n = r.length
          for (; n-- > 0; )
            this.consumeToken('whitespace', !0), i.push(this.consumeRule('BracketString'))
          return r(...i)
        } else return /^[&%$#_{}]$/.test(t) ? e.text.slice(1) : e.text
      }
    },
    Env() {
      let e = ''
      for (; !this.matchEndOfFile() && !this.matchToken('rbrace'); ) e += this.consumeRule('Text')
      return e
    },
    EnclosedEnv() {
      this.consumeToken('commandBegin')
      const e = this.consumeRule('BracketString')
      let t = ''
      for (; !this.matchToken('commandEnd'); ) t += this.consumeRule('Text')
      const r = this.consumeToken('commandEnd'),
        i = this.consumeRule('BracketString')
      if (e !== i)
        throw new SyntaxError(
          this.lexer.formatError(r, `environment started with "${e}", ended with "${i}"`)
        )
      return Zn(t, so[e])
    },
  },
  { sentenceCase: !1, partlyLowercase: !1, afterPunctuation: !0 }
)
function yd(e) {
  return dy.includes(e.toLowerCase())
}
function fD(e) {
  return Array.isArray(e) ? e.every(yd) : yd(e)
}
function pD(e, t) {
  if (e[1] === 'name') return e[0] === 'list' ? 'StringNames' : 'Name'
  if (e[1] === 'title') {
    const r = ma.parse.sentenceCase
    return r === 'always' || (r === 'english' && fD(t)) ? 'StringTitleCase' : 'String'
  }
  switch (e[0] === 'field' ? e[1] : e[0]) {
    case 'list':
      return 'StringList'
    case 'separated':
      return 'StringSeparated'
    case 'verbatim':
      return 'StringVerbatim'
    case 'uri':
      return 'StringUri'
    case 'title':
    case 'literal':
    default:
      return 'String'
  }
}
function hD(e) {
  if (e[1] === 'name') return 'namesLiteral'
  switch (e[0]) {
    case 'list':
      return 'listLiteral'
    case 'separated':
      return 'separatedLiteral'
    case 'field':
    default:
      return 'stringLiteral'
  }
}
function _d(e, t, r = []) {
  const i = zo[t] || []
  return cD.parse(lD.reset(e, { state: hD(i), line: 0, col: 0 }), pD(i, r))
}
function Ey(e, t) {
  const r = []
  for (const { type: i, label: n, properties: s } of e)
    if (i in t) {
      const a = []
      for (const o of t[i])
        Array.isArray(o) && !o.some((u) => u in s)
          ? a.push(o.join('/'))
          : typeof o == 'string' && !(o in s) && a.push(o)
      a.length && r.push([n, `missing fields: ${a.join(', ')}`])
    } else r.push([n, `invalid type: "${i}"`])
  if (r.length)
    throw new RangeError(
      ['Invalid entries:'].concat(r.map(([i, n]) => `  - ${i} has ${n}`)).join(`
`)
    )
}
function xy(e) {
  const t = {}
  'language' in e.properties && (t.language = _d(e.properties.language, 'language'))
  for (const r in e.properties) {
    const i = e.properties[r]
    i !== '' && (t[r] = _d(i + '', r, t.language))
  }
  return { ...e, properties: t }
}
function vd(e) {
  return ma.parse.strict && Ey(e, Op.biblatex), nD(e.map(xy))
}
function Ed(e) {
  return ma.parse.strict && Ey(e, Op.bibtex), rD(e.map(xy))
}
const mD = '@bibtex',
  dD = {
    '@biblatex/text': {
      parse: md,
      parseType: {
        dataType: 'String',
        predicate: /@\s{0,5}[A-Za-z]{1,13}\s{0,5}\{\s{0,5}[^@{}"=,\\\s]{0,100}\s{0,5},[\s\S]*\}/,
      },
    },
    '@biblatex/entry+object': {
      parse(e) {
        return vd([e])
      },
      parseType: {
        dataType: 'SimpleObject',
        propertyConstraint: { props: ['type', 'label', 'properties'] },
      },
    },
    '@biblatex/entries+list': {
      parse: vd,
      parseType: { elementConstraint: '@biblatex/entry+object' },
    },
    '@bibtex/text': { parse: md, outputs: '@bibtex/entries+list' },
    '@bibtex/entry+object': {
      parse(e) {
        return Ed([e])
      },
    },
    '@bibtex/entries+list': { parse: Ed },
    '@bibtxt/text': {
      parse: UI,
      parseType: {
        dataType: 'String',
        predicate: /^\s*(\[(?!\s*[{[]).*?\]\s*(\n\s*[^[]((?!:)\S)+\s*:\s*.+?\s*)*\s*)+$/,
      },
    },
  },
  Yr = {}
for (const e in Ws) Yr[Ws[e]] = e
for (const e in Ys) Yr[Ys[e]] = e
for (const e in Qs) Yr[Qs[e]] = e
const gD =
    /[^a-zA-Z0-9\s!"#%&'()*+,\-./:;=?@[\]{}\u0300-\u0308\u030a-\u030c\u0332\u0323\u0327\u0328\u0361\u0326]/g,
  bD = /.[\u0300-\u0308\u030a-\u030c\u0332\u0323\u0327\u0328\u0361\u0326]+/g,
  Ip = { separated: ',', list: ' and ' },
  xd = {
    i: '\\textit{',
    b: '\\textbf{',
    sc: '\\textsc{',
    sup: '\\textsuperscript{',
    sub: '\\textsubscript{',
    'span style="font-variant:small-caps;"': '\\textsc{',
    'span class="nocase"': '{',
  }
function Dp(e) {
  return e
    .normalize('NFKD')
    .replace(gD, (t) => (t in Yr ? (Yr[t] in Qs ? Yr[t] : `\\${Yr[t]}{}`) : ''))
    .replace(bD, (t) => Array.from(t).reduce((r, i) => `{\\${Yr[i]} ${r}}`))
}
function Ty(e) {
  const t = []
  let r = e.split(/<(\/?(?:i|b|sc|sup|sub|span)|span .*?)>/g)
  return (
    (r = r.map((i, n) =>
      n % 2 === 0
        ? Dp(i)
        : i in xd
        ? (t.push('/' + i.split(' ')[0]), xd[i])
        : i === t[t.length - 1]
        ? (t.pop(), '}')
        : ''
    )),
    r.join('')
  )
}
function yD(e) {
  if (e.family && !e.prefix && !e.given & !e.suffix)
    return e.family.includes(Ip.list) ? e.family : `{${e.family}}`
  const t = ['']
  return (
    e.prefix && e.family && (t[0] += e.prefix + ' '),
    e.family && (t[0] += e.family),
    e.suffix ? (t.push(e.suffix), t.push(e.given || '')) : t.push(e.given),
    Dp(t.join(', ').trim())
  )
}
function _D(e) {
  return Ty(e)
    .split(/(:\s*)/)
    .map((t, r) => (r % 2 ? t : t.replace(/(?!^)\b[a-z]*[A-Z].*?\b/g, '{$&}')))
    .join('')
}
function rf(e, t) {
  switch (t) {
    case 'title':
      return _D(e)
    case 'literal':
      return Ty(e.toString())
    case 'name':
      return yD(e)
    case 'verbatim':
    case 'uri':
      return e.toString()
    default:
      return Dp(e.toString())
  }
}
function vD(e, t, r) {
  const i = Ip[r]
  return e
    .map((n) => {
      const s = rf(n, t)
      return s.includes(i) ? `{${s}}` : s
    })
    .join(i)
}
function ED(e, t) {
  if (!(e in zo)) return rf(t, 'verbatim')
  const [r, i] = zo[e]
  return r in Ip ? vD(t, i, r) : rf(t, i)
}
function Ay({ type: e, label: t, properties: r }) {
  const i = {}
  for (const n in r) {
    const s = r[n]
    i[n] = ED(n, s)
  }
  return { type: e, label: t, properties: i }
}
function xD(e) {
  return sD(e).map(Ay)
}
function Td(e) {
  return iD(e).map(Ay)
}
function TD({ type: e, label: t, properties: r }, i) {
  const n = Object.entries(r).map(([s, a]) => i.listItem.join(`${s} = {${a}},`))
  return i.entry.join(`@${e}{${t},${i.list.join(n.join(''))}}`)
}
function Ad(e, t) {
  const r = e.map((i) => TD(i, t)).join('')
  return t.bibliographyContainer.join(r)
}
function AD({ type: e, label: t, properties: r }, i) {
  const n = Object.entries(r)
    .concat([['type', e]])
    .map(([s, a]) => i.listItem.join(`${s}: ${a}`))
  return i.entry.join(`[${t}]${i.list.join(n.join(''))}`)
}
function SD(e, t) {
  const r = e.map((i) => AD(i, t)).join(`
`)
  return t.bibliographyContainer.join(r)
}
const Ol = function (e, t) {
    return function (r, i = {}) {
      const { type: n, format: s = n || 'text' } = i
      if (((r = e(r)), s === 'object')) return r
      if (sy(s)) return t(r, wp(s), i)
      throw new RangeError(`Output dictionary "${s}" not available`)
    }
  },
  CD = { bibtex: Ol(Td, Ad), biblatex: Ol(xD, Ad), bibtxt: Ol(Td, SD) }
ha(mD, { input: dD, output: CD, config: ma })
const kD = {
    'en-US':
      '<?xml version="1.0" encoding="utf-8"?><locale xmlns="http://purl.org/net/xbiblio/csl" version="1.0" xml:lang="en-US"><info><translator><name>Andrew Dunning</name></translator><translator><name>Sebastian Karcher</name></translator><translator><name>Rintze M. Zelle</name></translator><translator><name>Denis Meier</name></translator><translator><name>Brenton M. Wiernik</name></translator><rights license="http://creativecommons.org/licenses/by-sa/3.0/">This work is licensed under a Creative Commons Attribution-ShareAlike 3.0 License</rights><updated>2015-10-10T23:31:02+00:00</updated></info><style-options punctuation-in-quote="true"/><date form="text"><date-part name="month" suffix=" "/><date-part name="day" suffix=", "/><date-part name="year"/></date><date form="numeric"><date-part name="month" form="numeric-leading-zeros" suffix="/"/><date-part name="day" form="numeric-leading-zeros" suffix="/"/><date-part name="year"/></date><terms><term name="advance-online-publication">advance online publication</term><term name="album">album</term><term name="audio-recording">audio recording</term><term name="film">film</term><term name="henceforth">henceforth</term><term name="loc-cit">loc. cit.</term><term name="no-place">no place</term><term name="no-place" form="short">n.p.</term><term name="no-publisher">no publisher</term><term name="no-publisher" form="short">n.p.</term><term name="on">on</term><term name="op-cit">op. cit.</term><term name="original-work-published">original work published</term><term name="personal-communication">personal communication</term><term name="podcast">podcast</term><term name="podcast-episode">podcast episode</term><term name="preprint">preprint</term><term name="radio-broadcast">radio broadcast</term><term name="radio-series">radio series</term><term name="radio-series-episode">radio series episode</term><term name="special-issue">special issue</term><term name="special-section">special section</term><term name="television-broadcast">television broadcast</term><term name="television-series">television series</term><term name="television-series-episode">television series episode</term><term name="video">video</term><term name="working-paper">working paper</term><term name="accessed">accessed</term><term name="and">and</term><term name="and others">and others</term><term name="anonymous">anonymous</term><term name="anonymous" form="short">anon.</term><term name="at">at</term><term name="available at">available at</term><term name="by">by</term><term name="circa">circa</term><term name="circa" form="short">c.</term><term name="cited">cited</term><term name="edition"><single>edition</single><multiple>editions</multiple></term><term name="edition" form="short">ed.</term><term name="et-al">et al.</term><term name="forthcoming">forthcoming</term><term name="from">from</term><term name="ibid">ibid.</term><term name="in">in</term><term name="in press">in press</term><term name="internet">internet</term><term name="interview">interview</term><term name="letter">letter</term><term name="no date">no date</term><term name="no date" form="short">n.d.</term><term name="online">online</term><term name="presented at">presented at the</term><term name="reference"><single>reference</single><multiple>references</multiple></term><term name="reference" form="short"><single>ref.</single><multiple>refs.</multiple></term><term name="retrieved">retrieved</term><term name="scale">scale</term><term name="version">version</term><term name="article">preprint</term><term name="article-journal">journal article</term><term name="article-magazine">magazine article</term><term name="article-newspaper">newspaper article</term><term name="bill">bill</term><term name="book">book</term><term name="broadcast">broadcast</term><term name="chapter">book chapter</term><term name="classic">classic</term><term name="collection">collection</term><term name="dataset">dataset</term><term name="document">document</term><term name="entry">entry</term><term name="entry-dictionary">dictionary entry</term><term name="entry-encyclopedia">encyclopedia entry</term><term name="event">event</term><term name="graphic">graphic</term><term name="hearing">hearing</term><term name="interview">interview</term><term name="legal_case">legal case</term><term name="legislation">legislation</term><term name="manuscript">manuscript</term><term name="map">map</term><term name="motion_picture">video recording</term><term name="musical_score">musical score</term><term name="pamphlet">pamphlet</term><term name="paper-conference">conference paper</term><term name="patent">patent</term><term name="performance">performance</term><term name="periodical">periodical</term><term name="personal_communication">personal communication</term><term name="post">post</term><term name="post-weblog">blog post</term><term name="regulation">regulation</term><term name="report">report</term><term name="review">review</term><term name="review-book">book review</term><term name="software">software</term><term name="song">audio recording</term><term name="speech">presentation</term><term name="standard">standard</term><term name="thesis">thesis</term><term name="treaty">treaty</term><term name="webpage">webpage</term><term name="article-journal" form="short">journal art.</term><term name="article-magazine" form="short">mag. art.</term><term name="article-newspaper" form="short">newspaper art.</term><term name="book" form="short">bk.</term><term name="chapter" form="short">bk. chap.</term><term name="document" form="short">doc.</term><term name="graphic" form="short">graph.</term><term name="interview" form="short">interv.</term><term name="manuscript" form="short">MS</term><term name="motion_picture" form="short">video rec.</term><term name="report" form="short">rep.</term><term name="review" form="short">rev.</term><term name="review-book" form="short">bk. rev.</term><term name="song" form="short">audio rec.</term><term name="ad">AD</term><term name="bc">BC</term><term name="bce">BCE</term><term name="ce">CE</term><term name="open-quote"></term><term name="close-quote"></term><term name="open-inner-quote"></term><term name="close-inner-quote"></term><term name="page-range-delimiter"></term><term name="colon">:</term><term name="comma">,</term><term name="semicolon">;</term><term name="ordinal">th</term><term name="ordinal-01">st</term><term name="ordinal-02">nd</term><term name="ordinal-03">rd</term><term name="ordinal-11">th</term><term name="ordinal-12">th</term><term name="ordinal-13">th</term><term name="long-ordinal-01">first</term><term name="long-ordinal-02">second</term><term name="long-ordinal-03">third</term><term name="long-ordinal-04">fourth</term><term name="long-ordinal-05">fifth</term><term name="long-ordinal-06">sixth</term><term name="long-ordinal-07">seventh</term><term name="long-ordinal-08">eighth</term><term name="long-ordinal-09">ninth</term><term name="long-ordinal-10">tenth</term><term name="act"><single>act</single><multiple>acts</multiple></term><term name="appendix"><single>appendix</single><multiple>appendices</multiple></term><term name="article-locator"><single>article</single><multiple>articles</multiple></term><term name="canon"><single>canon</single><multiple>canons</multiple></term><term name="elocation"><single>location</single><multiple>locations</multiple></term><term name="equation"><single>equation</single><multiple>equations</multiple></term><term name="rule"><single>rule</single><multiple>rules</multiple></term><term name="scene"><single>scene</single><multiple>scenes</multiple></term><term name="table"><single>table</single><multiple>tables</multiple></term><term name="timestamp"><single></single><multiple></multiple></term><term name="title-locator"><single>title</single><multiple>titles</multiple></term><term name="book"><single>book</single><multiple>books</multiple></term><term name="chapter"><single>chapter</single><multiple>chapters</multiple></term><term name="column"><single>column</single><multiple>columns</multiple></term><term name="figure"><single>figure</single><multiple>figures</multiple></term><term name="folio"><single>folio</single><multiple>folios</multiple></term><term name="issue"><single>number</single><multiple>numbers</multiple></term><term name="line"><single>line</single><multiple>lines</multiple></term><term name="note"><single>note</single><multiple>notes</multiple></term><term name="opus"><single>opus</single><multiple>opera</multiple></term><term name="page"><single>page</single><multiple>pages</multiple></term><term name="number-of-pages"><single>page</single><multiple>pages</multiple></term><term name="paragraph"><single>paragraph</single><multiple>paragraphs</multiple></term><term name="part"><single>part</single><multiple>parts</multiple></term><term name="section"><single>section</single><multiple>sections</multiple></term><term name="sub-verbo"><single>sub verbo</single><multiple>sub verbis</multiple></term><term name="verse"><single>verse</single><multiple>verses</multiple></term><term name="volume"><single>volume</single><multiple>volumes</multiple></term><term name="appendix"><single>app.</single><multiple>apps.</multiple></term><term name="article-locator"><single>art.</single><multiple>arts.</multiple></term><term name="elocation"><single>loc.</single><multiple>locs.</multiple></term><term name="equation"><single>eq.</single><multiple>eqs.</multiple></term><term name="rule"><single>r.</single><multiple>rr.</multiple></term><term name="scene"><single>sc.</single><multiple>scs.</multiple></term><term name="table"><single>tbl.</single><multiple>tbls.</multiple></term><term name="timestamp"><single></single><multiple></multiple></term><term name="title-locator"><single>tit.</single><multiple>tits.</multiple></term><term name="book" form="short"><single>bk.</single><multiple>bks.</multiple></term><term name="chapter" form="short"><single>chap.</single><multiple>chaps.</multiple></term><term name="column" form="short"><single>col.</single><multiple>cols.</multiple></term><term name="figure" form="short"><single>fig.</single><multiple>figs.</multiple></term><term name="folio" form="short"><single>fol.</single><multiple>fols.</multiple></term><term name="issue" form="short"><single>no.</single><multiple>nos.</multiple></term><term name="line" form="short"><single>l.</single><multiple>ll.</multiple></term><term name="note" form="short"><single>n.</single><multiple>nn.</multiple></term><term name="opus" form="short"><single>op.</single><multiple>opp.</multiple></term><term name="page" form="short"><single>p.</single><multiple>pp.</multiple></term><term name="number-of-pages" form="short"><single>p.</single><multiple>pp.</multiple></term><term name="paragraph" form="short"><single>para.</single><multiple>paras.</multiple></term><term name="part" form="short"><single>pt.</single><multiple>pts.</multiple></term><term name="section" form="short"><single>sec.</single><multiple>secs.</multiple></term><term name="sub-verbo" form="short"><single>s.v.</single><multiple>s.vv.</multiple></term><term name="verse" form="short"><single>v.</single><multiple>vv.</multiple></term><term name="volume" form="short"><single>vol.</single><multiple>vols.</multiple></term><term name="paragraph" form="symbol"><single></single><multiple></multiple></term><term name="section" form="symbol"><single></single><multiple></multiple></term><term name="chair"><single>chair</single><multiple>chairs</multiple></term><term name="compiler"><single>compiler</single><multiple>compilers</multiple></term><term name="contributor"><single>contributor</single><multiple>contributors</multiple></term><term name="curator"><single>curator</single><multiple>curators</multiple></term><term name="executive-producer"><single>executive producer</single><multiple>executive producers</multiple></term><term name="guest"><single>guest</single><multiple>guests</multiple></term><term name="host"><single>host</single><multiple>hosts</multiple></term><term name="narrator"><single>narrator</single><multiple>narrators</multiple></term><term name="organizer"><single>organizer</single><multiple>organizers</multiple></term><term name="performer"><single>performer</single><multiple>performers</multiple></term><term name="producer"><single>producer</single><multiple>producers</multiple></term><term name="script-writer"><single>writer</single><multiple>writers</multiple></term><term name="series-creator"><single>series creator</single><multiple>series creators</multiple></term><term name="director"><single>director</single><multiple>directors</multiple></term><term name="editor"><single>editor</single><multiple>editors</multiple></term><term name="editorial-director"><single>editor</single><multiple>editors</multiple></term><term name="illustrator"><single>illustrator</single><multiple>illustrators</multiple></term><term name="translator"><single>translator</single><multiple>translators</multiple></term><term name="editortranslator"><single>editor &amp; translator</single><multiple>editors &amp; translators</multiple></term><term name="compiler" form="short"><single>comp.</single><multiple>comps.</multiple></term><term name="contributor" form="short"><single>contrib.</single><multiple>contribs.</multiple></term><term name="curator" form="short"><single>cur.</single><multiple>curs.</multiple></term><term name="executive-producer" form="short"><single>exec. prod.</single><multiple>exec. prods.</multiple></term><term name="narrator" form="short"><single>narr.</single><multiple>narrs.</multiple></term><term name="organizer" form="short"><single>org.</single><multiple>orgs.</multiple></term><term name="performer" form="short"><single>perf.</single><multiple>perfs.</multiple></term><term name="producer" form="short"><single>prod.</single><multiple>prods.</multiple></term><term name="script-writer" form="short"><single>writ.</single><multiple>writs.</multiple></term><term name="series-creator" form="short"><single>cre.</single><multiple>cres.</multiple></term><term name="director" form="short"><single>dir.</single><multiple>dirs.</multiple></term><term name="editor" form="short"><single>ed.</single><multiple>eds.</multiple></term><term name="editorial-director" form="short"><single>ed.</single><multiple>eds.</multiple></term><term name="illustrator" form="short"><single>ill.</single><multiple>ills.</multiple></term><term name="translator" form="short"><single>tran.</single><multiple>trans.</multiple></term><term name="editortranslator" form="short"><single>ed. &amp; tran.</single><multiple>eds. &amp; trans.</multiple></term><term name="chair" form="verb">chaired by</term><term name="compiler" form="verb">compiled by</term><term name="contributor" form="verb">with</term><term name="curator" form="verb">curated by</term><term name="executive-producer" form="verb">executive produced by</term><term name="guest" form="verb">with guest</term><term name="host" form="verb">hosted by</term><term name="narrator" form="verb">narrated by</term><term name="organizer" form="verb">organized by</term><term name="performer" form="verb">performed by</term><term name="producer" form="verb">produced by</term><term name="script-writer" form="verb">written by</term><term name="series-creator" form="verb">created by</term><term name="container-author" form="verb">by</term><term name="director" form="verb">directed by</term><term name="editor" form="verb">edited by</term><term name="editorial-director" form="verb">edited by</term><term name="illustrator" form="verb">illustrated by</term><term name="interviewer" form="verb">interview by</term><term name="recipient" form="verb">to</term><term name="reviewed-author" form="verb">by</term><term name="translator" form="verb">translated by</term><term name="editortranslator" form="verb">edited &amp; translated by</term><term name="compiler" form="verb-short">comp. by</term><term name="contributor" form="verb-short">w.</term><term name="curator" form="verb-short">cur. by</term><term name="executive-producer" form="verb-short">exec. prod. by</term><term name="guest" form="verb-short">w. guest</term><term name="host" form="verb-short">hosted by</term><term name="narrator" form="verb-short">narr. by</term><term name="organizer" form="verb-short">org. by</term><term name="performer" form="verb-short">perf. by</term><term name="producer" form="verb-short">prod. by</term><term name="script-writer" form="verb-short">writ. by</term><term name="series-creator" form="verb-short">cre. by</term><term name="director" form="verb-short">dir. by</term><term name="editor" form="verb-short">ed. by</term><term name="editorial-director" form="verb-short">ed. by</term><term name="illustrator" form="verb-short">illus. by</term><term name="translator" form="verb-short">trans. by</term><term name="editortranslator" form="verb-short">ed. &amp; trans. by</term><term name="month-01">January</term><term name="month-02">February</term><term name="month-03">March</term><term name="month-04">April</term><term name="month-05">May</term><term name="month-06">June</term><term name="month-07">July</term><term name="month-08">August</term><term name="month-09">September</term><term name="month-10">October</term><term name="month-11">November</term><term name="month-12">December</term><term name="month-01" form="short">Jan.</term><term name="month-02" form="short">Feb.</term><term name="month-03" form="short">Mar.</term><term name="month-04" form="short">Apr.</term><term name="month-05" form="short">May</term><term name="month-06" form="short">Jun.</term><term name="month-07" form="short">Jul.</term><term name="month-08" form="short">Aug.</term><term name="month-09" form="short">Sep.</term><term name="month-10" form="short">Oct.</term><term name="month-11" form="short">Nov.</term><term name="month-12" form="short">Dec.</term><term name="season-01">Spring</term><term name="season-02">Summer</term><term name="season-03">Autumn</term><term name="season-04">Winter</term></terms></locale>',
  },
  hn = new xu(kD),
  wD = {
    apa: '<?xml version="1.0" encoding="utf-8"?><style xmlns="http://purl.org/net/xbiblio/csl" class="in-text" version="1.0" demote-non-dropping-particle="never" page-range-format="expanded"><info><title>American Psychological Association 7th edition</title><title-short>APA</title-short><id>http://www.zotero.org/styles/apa</id><link href="http://www.zotero.org/styles/apa" rel="self"/><link href="http://www.zotero.org/styles/apa-6th-edition" rel="template"/><link href="https://apastyle.apa.org/style-grammar-guidelines/references/examples" rel="documentation"/><author><name>Brenton M. Wiernik</name><email>zotero@wiernik.org</email></author><category citation-format="author-date"/><category field="psychology"/><category field="generic-base"/><updated>2022-01-31T14:30:00+00:00</updated><rights license="http://creativecommons.org/licenses/by-sa/3.0/">This work is licensed under a Creative Commons Attribution-ShareAlike 3.0 License</rights></info><locale xml:lang="en"><terms><term name="editortranslator" form="short"><single>ed. &amp; trans.</single><multiple>eds. &amp; trans.</multiple></term><term name="translator" form="short">trans.</term><term name="interviewer" form="short"><single>interviewer</single><multiple>interviewers</multiple></term><term name="collection-editor" form="short"><single>ed.</single><multiple>eds.</multiple></term><term name="circa" form="short">ca.</term><term name="bc"> B.C.E.</term><term name="ad"> C.E.</term><term name="letter">personal communication</term><term name="letter" form="short">letter</term><term name="issue" form="long"><single>issue</single><multiple>issues</multiple></term></terms></locale><locale xml:lang="af"><terms><term name="letter">persoonlike kommunikasie</term><term name="letter" form="short">brief</term></terms></locale><locale xml:lang="ar"><terms><term name="letter"> </term><term name="letter" form="short"></term></terms></locale><locale xml:lang="bg"><terms><term name="letter"> </term><term name="letter" form="short"></term></terms></locale><locale xml:lang="ca"><terms><term name="letter">comunicaci personal</term><term name="letter" form="short">carta</term></terms></locale><locale xml:lang="cs"><terms><term name="letter">osobn komunikace</term><term name="letter" form="short">dopis</term></terms></locale><locale xml:lang="cy"><terms><term name="letter">cyfathrebu personol</term><term name="letter" form="short">llythyr</term></terms></locale><locale xml:lang="da"><terms><term name="et-al">et al.</term><term name="letter">personlig kommunikation</term><term name="letter" form="short">brev</term></terms></locale><locale xml:lang="de"><terms><term name="et-al">et al.</term><term name="letter">persnliche Kommunikation</term><term name="letter" form="short">Brief</term></terms></locale><locale xml:lang="el"><terms><term name="letter"> </term><term name="letter" form="short"></term></terms></locale><locale xml:lang="es"><terms><term name="from">de</term><term name="letter">comunicacin personal</term><term name="letter" form="short">carta</term></terms></locale><locale xml:lang="et"><terms><term name="letter">isiklik suhtlus</term><term name="letter" form="short">kiri</term></terms></locale><locale xml:lang="eu"><terms><term name="letter">komunikazio pertsonala</term><term name="letter" form="short">gutuna</term></terms></locale><locale xml:lang="fa"><terms><term name="letter"> </term><term name="letter" form="short"></term></terms></locale><locale xml:lang="fi"><terms><term name="letter">henkilkohtainen viestint</term><term name="letter" form="short">kirje</term></terms></locale><locale xml:lang="fr"><terms><term name="letter">communication personnelle</term><term name="letter" form="short">lettre</term><term name="editor" form="short"><single>d.</single><multiple>ds.</multiple></term></terms></locale><locale xml:lang="he"><terms><term name="letter"> </term><term name="letter" form="short"></term></terms></locale><locale xml:lang="hr"><terms><term name="letter">osobna komunikacija</term><term name="letter" form="short">pismo</term></terms></locale><locale xml:lang="hu"><terms><term name="letter">szemlyes kommunikci</term><term name="letter" form="short">levl</term></terms></locale><locale xml:lang="id"><terms><term name="letter">komunikasi pribadi</term><term name="letter" form="short">surat</term></terms></locale><locale xml:lang="is"><terms><term name="letter">persnuleg samskipti</term><term name="letter" form="short">brf</term></terms></locale><locale xml:lang="it"><terms><term name="letter">comunicazione personale</term><term name="letter" form="short">lettera</term></terms></locale><locale xml:lang="ja"><terms><term name="letter"></term><term name="letter" form="short"></term></terms></locale><locale xml:lang="ko"><terms><term name="letter"> </term><term name="letter" form="short"></term></terms></locale><locale xml:lang="la"><terms><term name="letter"/><term name="letter" form="short">epistula</term></terms></locale><locale xml:lang="lt"><terms><term name="letter">communicationis personalis</term><term name="letter" form="short"/></terms></locale><locale xml:lang="lv"><terms><term name="letter">personga komunikcija</term><term name="letter" form="short">vstule</term></terms></locale><locale xml:lang="mn"><terms><term name="letter">  </term><term name="letter" form="short"></term></terms></locale><locale xml:lang="nb"><terms><term name="et-al">et al.</term><term name="letter">personlig kommunikasjon</term><term name="letter" form="short">brev</term></terms></locale><locale xml:lang="nl"><terms><term name="et-al">et al.</term><term name="letter">persoonlijke communicatie</term><term name="letter" form="short">brief</term></terms></locale><locale xml:lang="nn"><terms><term name="et-al">et al.</term><term name="letter">personlig kommunikasjon</term><term name="letter" form="short">brev</term></terms></locale><locale xml:lang="pl"><terms><term name="letter">osobista komunikacja</term><term name="letter" form="short">list</term></terms></locale><locale xml:lang="pt"><terms><term name="letter">comunicao pessoal</term><term name="letter" form="short">carta</term></terms></locale><locale xml:lang="ro"><terms><term name="letter">comunicare personal</term><term name="letter" form="short">scrisoare</term></terms></locale><locale xml:lang="ru"><terms><term name="letter"> </term><term name="letter" form="short"></term></terms></locale><locale xml:lang="sk"><terms><term name="letter">osobn komunikcia</term><term name="letter" form="short">list</term></terms></locale><locale xml:lang="sl"><terms><term name="letter">osebna komunikacija</term><term name="letter" form="short">pismo</term></terms></locale><locale xml:lang="sr"><terms><term name="letter"> </term><term name="letter" form="short"></term></terms></locale><locale xml:lang="sv"><terms><term name="letter">personlig kommunikation</term><term name="letter" form="short">brev</term></terms></locale><locale xml:lang="th"><terms><term name="letter"></term><term name="letter" form="short"></term></terms></locale><locale xml:lang="tr"><terms><term name="letter">kiisel iletiim</term><term name="letter" form="short">mektup</term></terms></locale><locale xml:lang="uk"><terms><term name="letter"> </term><term name="letter" form="short"></term></terms></locale><locale xml:lang="vi"><terms><term name="letter">giao tip c nhn</term><term name="letter" form="short">th</term></terms></locale><locale xml:lang="zh-CN"><terms><term name="letter"></term><term name="letter" form="short"></term></terms></locale><locale xml:lang="zh-TW"><terms><term name="letter"></term><term name="letter" form="short"></term></terms></locale><macro name="author-bib"><names variable="composer" delimiter=", "><name name-as-sort-order="all" and="symbol" sort-separator=", " initialize-with=". " delimiter=", " delimiter-precedes-last="always"/><substitute><names variable="author"/><names variable="illustrator"/><names variable="director"><name name-as-sort-order="all" and="symbol" sort-separator=", " initialize-with=". " delimiter=", " delimiter-precedes-last="always"/><label form="long" prefix=" (" suffix=")" text-case="title"/></names><choose><if variable="container-title"><choose><if type="book entry entry-dictionary entry-encyclopedia" match="any"><choose><if variable="title"><group delimiter=" "><text macro="title"/><text macro="parenthetical"/></group></if><else><text macro="title-and-descriptions"/></else></choose></if></choose></if></choose><names variable="editor" delimiter=", "><name name-as-sort-order="all" and="symbol" sort-separator=", " initialize-with=". " delimiter=", " delimiter-precedes-last="always"/><label form="short" prefix=" (" suffix=")" text-case="title"/></names><names variable="editorial-director"><name name-as-sort-order="all" and="symbol" sort-separator=", " initialize-with=". " delimiter=", " delimiter-precedes-last="always"/><label form="short" prefix=" (" suffix=")" text-case="title"/></names><names variable="collection-editor"><name name-as-sort-order="all" and="symbol" sort-separator=", " initialize-with=". " delimiter=", " delimiter-precedes-last="always"/><label form="short" prefix=" (" suffix=")" text-case="title"/></names><choose><if variable="title"><group delimiter=" "><text macro="title"/><text macro="parenthetical"/></group></if><else><text macro="title-and-descriptions"/></else></choose></substitute></names></macro><macro name="author-intext"><choose><if type="bill legal_case legislation treaty" match="any"><text macro="title-intext"/></if><else-if type="interview personal_communication" match="any"><choose><if variable="archive container-title DOI publisher URL" match="none"><group delimiter=", "><names variable="author"><name and="symbol" delimiter=", " initialize-with=". "/><substitute><text macro="title-intext"/></substitute></names><text term="letter"/></group></if><else><names variable="author" delimiter=", "><name form="short" and="symbol" delimiter=", " initialize-with=". "/><substitute><text macro="title-intext"/></substitute></names></else></choose></else-if><else><names variable="composer" delimiter=", "><name form="short" and="symbol" delimiter=", " initialize-with=". "/><substitute><names variable="author"/><names variable="illustrator"/><names variable="director"/><choose><if variable="container-title"><choose><if type="book entry entry-dictionary entry-encyclopedia" match="any"><text macro="title-intext"/></if></choose></if></choose><names variable="editor"/><names variable="editorial-director"/><text macro="title-intext"/></substitute></names></else></choose></macro><macro name="date-bib"><group delimiter=" " prefix="(" suffix=")"><choose><if is-uncertain-date="issued"><text term="circa" form="short"/></if></choose><group><choose><if variable="issued"><date variable="issued"><date-part name="year"/></date><text variable="year-suffix"/><choose><if type="article-magazine article-newspaper broadcast interview motion_picture pamphlet personal_communication post post-weblog song speech webpage" match="any"><date variable="issued"><date-part prefix=", " name="month"/><date-part prefix=" " name="day"/></date></if><else-if type="paper-conference"><choose><if variable="collection-editor editor editorial-director issue page volume" match="none"><date variable="issued"><date-part prefix=", " name="month"/><date-part prefix=" " name="day"/></date></if></choose></else-if></choose></if><else-if variable="status"><group><text variable="status" text-case="lowercase"/><text variable="year-suffix" prefix="-"/></group></else-if><else><text term="no date" form="short"/><text variable="year-suffix" prefix="-"/></else></choose></group></group></macro><macro name="date-sort-group"><choose><if variable="issued"><text value="1"/></if><else-if variable="status"><text value="2"/></else-if><else><text value="0"/></else></choose></macro><macro name="date-sort-date"><date variable="issued" form="numeric"/></macro><macro name="date-intext"><choose><if variable="issued"><group delimiter="/"><group delimiter=" "><choose><if is-uncertain-date="original-date"><text term="circa" form="short"/></if></choose><date variable="original-date"><date-part name="year"/></date></group><group delimiter=" "><choose><if is-uncertain-date="issued"><text term="circa" form="short"/></if></choose><group><choose><if type="interview personal_communication" match="any"><choose><if variable="archive container-title DOI publisher URL" match="none"><date variable="issued" form="text"/></if><else><date variable="issued"><date-part name="year"/></date></else></choose></if><else><date variable="issued"><date-part name="year"/></date></else></choose><text variable="year-suffix"/></group></group></group></if><else-if variable="status"><text variable="status" text-case="lowercase"/><text variable="year-suffix" prefix="-"/></else-if><else><text term="no date" form="short"/><text variable="year-suffix" prefix="-"/></else></choose></macro><macro name="title-and-descriptions"><choose><if variable="title"><group delimiter=" "><text macro="title"/><text macro="parenthetical"/><text macro="bracketed"/></group></if><else><group delimiter=" "><text macro="bracketed"/><text macro="parenthetical"/></group></else></choose></macro><macro name="title"><choose><if type="post webpage" match="any"><text variable="title" font-style="italic"/></if><else-if variable="container-title" match="any"><text variable="title"/></else-if><else><choose><if type="article-journal article-magazine article-newspaper post-weblog review review-book" match="any"><text variable="title" font-style="italic"/></if><else-if type="paper-conference"><choose><if variable="collection-editor editor editorial-director" match="any"><group delimiter=": " font-style="italic"><text variable="title"/><choose><if is-numeric="volume" match="none"><group delimiter=" "><label variable="volume" form="short" text-case="capitalize-first"/><text variable="volume"/></group></if></choose></group></if><else><text variable="title" font-style="italic"/></else></choose></else-if><else><group delimiter=": " font-style="italic"><text variable="title"/><choose><if is-numeric="volume" match="none"><group delimiter=" "><label variable="volume" form="short" text-case="capitalize-first"/><text variable="volume"/></group></if></choose></group></else></choose></else></choose></macro><macro name="title-intext"><choose><if variable="title" match="none"><text macro="bracketed-intext" prefix="[" suffix="]"/></if><else-if type="bill"><choose><if variable="number container-title" match="none"><text variable="title" form="short" font-style="italic" text-case="title"/></if><else-if variable="title"><text variable="title" form="short" text-case="title"/></else-if><else><group delimiter=" "><text variable="genre"/><group delimiter=" "><choose><if variable="chapter-number container-title" match="none"><text term="issue" form="short"/></if></choose><text variable="number"/></group></group></else></choose></else-if><else-if type="legal_case" match="any"><text variable="title" font-style="italic"/></else-if><else-if type="legislation treaty" match="any"><text variable="title" form="short" text-case="title"/></else-if><else-if type="post webpage" match="any"><text variable="title" form="short" font-style="italic" text-case="title"/></else-if><else-if variable="container-title" match="any"><text variable="title" form="short" quotes="true" text-case="title"/></else-if><else><text variable="title" form="short" font-style="italic" text-case="title"/></else></choose></macro><macro name="parenthetical"><group prefix="(" suffix=")"><choose><if type="patent"><group delimiter=" "><text variable="authority" form="short"/><choose><if variable="genre"><text variable="genre" text-case="capitalize-first"/></if><else><text value="patent" text-case="capitalize-first"/></else></choose><group delimiter=" "><text term="issue" form="short" text-case="capitalize-first"/><text variable="number"/></group></group></if><else-if type="post webpage" match="any"><group delimiter="; "><text macro="secondary-contributors"/><text macro="database-location"/><text macro="number"/><text macro="locators-booklike"/></group></else-if><else-if variable="container-title"><group delimiter="; "><text macro="secondary-contributors"/><choose><if type="broadcast graphic map motion_picture song" match="any"><text macro="number"/></if></choose></group></else-if><else><group delimiter="; "><text macro="secondary-contributors"/><text macro="database-location"/><text macro="number"/><text macro="locators-booklike"/></group></else></choose></group></macro><macro name="parenthetical-container"><choose><if variable="container-title" match="any"><group prefix="(" suffix=")"><group delimiter="; "><text macro="database-location"/><choose><if type="broadcast graphic map motion_picture song" match="none"><text macro="number"/></if></choose><text macro="locators-booklike"/></group></group></if></choose></macro><macro name="bracketed"><group prefix="[" suffix="]"><choose><if variable="reviewed-author reviewed-title" type="review review-book" match="any"><group delimiter="; "><group delimiter=", "><group delimiter=" "><choose><if variable="number" match="none"><choose><if variable="genre"><text variable="genre" text-case="capitalize-first"/></if><else-if variable="medium"><text variable="medium" text-case="capitalize-first"/></else-if><else><text value="Review of"/></else></choose></if><else><choose><if variable="medium"><text variable="medium" text-case="capitalize-first"/></if><else><text value="Review of"/></else></choose></else></choose><text macro="reviewed-title"/></group><names variable="reviewed-author"><label form="verb-short" suffix=" "/><name and="symbol" initialize-with=". " delimiter=", "/></names></group><choose><if variable="genre" match="any"><choose><if variable="number" match="none"><text variable="medium" text-case="capitalize-first"/></if></choose></if></choose></group></if><else-if type="thesis"><group delimiter="; "><choose><if variable="number" match="none"><group delimiter=", "><text variable="genre" text-case="capitalize-first"/><choose><if variable="archive DOI URL" match="any"><text variable="publisher"/></if></choose></group></if></choose><text variable="medium" text-case="capitalize-first"/></group></else-if><else-if variable="interviewer" type="interview" match="any"><choose><if variable="title"><text macro="format"/></if><else-if variable="genre"><group delimiter="; "><group delimiter=" "><text variable="genre" text-case="capitalize-first"/><group delimiter=" "><text term="author" form="verb"/><names variable="interviewer"><name and="symbol" initialize-with=". " delimiter=", "/></names></group></group></group></else-if><else-if variable="interviewer"><group delimiter="; "><names variable="interviewer"><label form="verb" suffix=" " text-case="capitalize-first"/><name and="symbol" initialize-with=". " delimiter=", "/></names><text variable="medium" text-case="capitalize-first"/></group></else-if><else><text macro="format"/></else></choose></else-if><else-if type="personal_communication"><choose><if variable="recipient"><group delimiter="; "><group delimiter=" "><choose><if variable="number" match="none"><choose><if variable="genre"><text variable="genre" text-case="capitalize-first"/></if><else-if variable="medium"><text variable="medium" text-case="capitalize-first"/></else-if><else><text term="letter" form="short" text-case="capitalize-first"/></else></choose></if><else><choose><if variable="medium"><text variable="medium" text-case="capitalize-first"/></if><else><text term="letter" form="short" text-case="capitalize-first"/></else></choose></else></choose><names variable="recipient" delimiter=", "><label form="verb" suffix=" "/><name and="symbol" delimiter=", "/></names></group><choose><if variable="genre" match="any"><choose><if variable="number" match="none"><text variable="medium" text-case="capitalize-first"/></if></choose></if></choose></group></if><else><text macro="format"/></else></choose></else-if><else-if variable="composer" type="song" match="all"><group delimiter="; "><choose><if variable="number" match="none"><group delimiter=" "><choose><if variable="genre"><text variable="genre" text-case="capitalize-first"/><names variable="author" prefix="recorded by "><name and="symbol" initialize-with=". " delimiter=", "/></names></if><else-if variable="medium"><text variable="medium" text-case="capitalize-first"/><names variable="author" prefix="recorded by "><name and="symbol" initialize-with=". " delimiter=", "/></names></else-if><else><names variable="author" prefix="Recorded by "><name and="symbol" initialize-with=". " delimiter=", "/></names></else></choose></group></if><else><group delimiter=" "><choose><if variable="medium"><text variable="medium" text-case="capitalize-first"/><names variable="author" prefix="recorded by "><name and="symbol" initialize-with=". " delimiter=", "/></names></if><else><names variable="author" prefix="Recorded by "><name and="symbol" initialize-with=". " delimiter=", "/></names></else></choose></group></else></choose><choose><if variable="genre" match="any"><choose><if variable="number" match="none"><text variable="medium" text-case="capitalize-first"/></if></choose></if></choose></group></else-if><else-if variable="container-title" match="none"><text macro="format"/></else-if><else><choose><if type="paper-conference speech" match="any"><choose><if variable="collection-editor editor editorial-director issue page volume" match="any"><text macro="format"/></if></choose></if><else-if type="book"><choose><if variable="version" match="none"><text macro="format"/></if></choose></else-if><else-if type="report" match="none"><text macro="format"/></else-if></choose></else></choose></group></macro><macro name="bracketed-intext"><group prefix="[" suffix="]"><choose><if variable="reviewed-author reviewed-title" type="review review-book" match="any"><text macro="reviewed-title-intext" prefix="Review of "/></if><else-if variable="interviewer" type="interview" match="any"><names variable="interviewer"><label form="verb" suffix=" " text-case="capitalize-first"/><name and="symbol" initialize-with=". " delimiter=", "/><substitute><text macro="format-intext"/></substitute></names></else-if><else-if type="personal_communication"><choose><if variable="recipient"><group delimiter=" "><choose><if variable="number" match="none"><text variable="genre" text-case="capitalize-first"/></if><else><text term="letter" form="short" text-case="capitalize-first"/></else></choose><names variable="recipient" delimiter=", "><label form="verb" suffix=" "/><name and="symbol" delimiter=", "/></names></group></if><else><text macro="format-intext"/></else></choose></else-if><else><text macro="format-intext"/></else></choose></group></macro><macro name="bracketed-container"><group prefix="[" suffix="]"><choose><if type="paper-conference speech" match="any"><choose><if variable="collection-editor editor editorial-director issue page volume" match="none"><text macro="format"/></if></choose></if><else-if type="book" variable="version" match="all"><text macro="format"/></else-if><else-if type="report"><text macro="format"/></else-if></choose></group></macro><macro name="secondary-contributors"><choose><if type="article-journal article-magazine article-newspaper post-weblog review review-book" match="any"><text macro="secondary-contributors-periodical"/></if><else-if type="paper-conference"><choose><if variable="collection-editor editor editorial-director" match="any"><text macro="secondary-contributors-booklike"/></if><else><text macro="secondary-contributors-periodical"/></else></choose></else-if><else><text macro="secondary-contributors-booklike"/></else></choose></macro><macro name="secondary-contributors-periodical"><group delimiter="; "><choose><if variable="title"><names variable="interviewer" delimiter="; "><name and="symbol" initialize-with=". " delimiter=", "/><label form="short" prefix=", " text-case="title"/></names></if></choose><names variable="translator" delimiter="; "><name and="symbol" initialize-with=". " delimiter=", "/><label form="short" prefix=", " text-case="title"/></names></group></macro><macro name="secondary-contributors-booklike"><group delimiter="; "><choose><if variable="title"><names variable="interviewer"><name and="symbol" initialize-with=". " delimiter=", "/><label form="short" prefix=", " text-case="title"/></names></if></choose><choose><if type="post webpage" match="none"><choose><if variable="container-title" match="none"><group delimiter="; "><names variable="container-author"><label form="verb-short" suffix=" " text-case="title"/><name and="symbol" initialize-with=". " delimiter=", "/></names><names variable="editor translator" delimiter="; "><name and="symbol" initialize-with=". " delimiter=", "/><label form="short" prefix=", " text-case="title"/></names></group></if></choose></if><else><group delimiter="; "><names variable="container-author"><label form="verb-short" suffix=" " text-case="title"/><name and="symbol" initialize-with=". " delimiter=", "/></names><names variable="editor translator" delimiter="; "><name and="symbol" initialize-with=". " delimiter=", "/><label form="short" prefix=", " text-case="title"/></names></group></else></choose></group></macro><macro name="database-location"><choose><if variable="archive-place" match="none"><text variable="archive_location"/></if></choose></macro><macro name="number"><choose><if variable="number"><group delimiter=", "><group delimiter=" "><text variable="genre" text-case="title"/><choose><if is-numeric="number"><text term="issue" form="short" text-case="capitalize-first"/><text variable="number"/></if><else><text variable="number"/></else></choose></group><choose><if type="thesis"><choose><if variable="archive DOI URL" match="any"><text variable="publisher"/></if></choose></if></choose></group></if></choose></macro><macro name="locators-booklike"><choose><if type="article-journal article-magazine article-newspaper broadcast interview patent post post-weblog review review-book speech webpage" match="any"/><else-if type="paper-conference"><choose><if variable="collection-editor editor editorial-director" match="any"><group delimiter=", "><text macro="version"/><text macro="edition"/><text macro="volume-booklike"/></group></if></choose></else-if><else><group delimiter=", "><text macro="version"/><text macro="edition"/><text macro="volume-booklike"/></group></else></choose></macro><macro name="version"><choose><if is-numeric="version"><group delimiter=" "><text term="version" text-case="capitalize-first"/><text variable="version"/></group></if><else><text variable="version"/></else></choose></macro><macro name="edition"><choose><if is-numeric="edition"><group delimiter=" "><number variable="edition" form="ordinal"/><label variable="edition" form="short"/></group></if><else><text variable="edition"/></else></choose></macro><macro name="volume-booklike"><group delimiter=", "><choose><if type="report"><group delimiter=" "><text variable="collection-title" text-case="title"/><text variable="collection-number"/></group></if></choose><choose><if variable="volume" match="any"><choose><if is-numeric="volume" match="none"/><else><group delimiter=" "><label variable="volume" form="short" text-case="capitalize-first"/><number variable="volume" form="numeric"/></group></else></choose></if><else><group><text term="volume" form="short" text-case="capitalize-first" suffix=" "/><text term="page-range-delimiter" prefix="1"/><number variable="number-of-volumes" form="numeric"/></group></else></choose><group delimiter=" "><label variable="issue" text-case="capitalize-first"/><text variable="issue"/></group><group delimiter=" "><label variable="page" form="short" suffix=" "/><text variable="page"/></group></group></macro><macro name="reviewed-title"><choose><if variable="reviewed-title"><text variable="reviewed-title" font-style="italic"/></if><else><text variable="title" font-style="italic"/></else></choose></macro><macro name="reviewed-title-intext"><choose><if variable="reviewed-title"><text variable="reviewed-title" form="short" font-style="italic" text-case="title"/></if><else><text variable="title" form="short" font-style="italic" text-case="title"/></else></choose></macro><macro name="format"><choose><if variable="genre medium" match="any"><group delimiter="; "><choose><if variable="number" match="none"><text variable="genre" text-case="capitalize-first"/></if></choose><text variable="medium" text-case="capitalize-first"/></group></if><else-if type="dataset"><text value="Data set"/></else-if><else-if type="book" variable="version" match="all"><text value="Computer software"/></else-if><else-if type="interview personal_communication" match="any"><choose><if variable="archive container-title DOI publisher URL" match="none"><text term="letter" text-case="capitalize-first"/></if><else-if type="interview"><text term="interview" text-case="capitalize-first"/></else-if></choose></else-if><else-if type="map"><text value="Map"/></else-if></choose></macro><macro name="format-intext"><choose><if variable="genre" match="any"><text variable="genre" text-case="capitalize-first"/></if><else-if variable="medium"><text variable="medium" text-case="capitalize-first"/></else-if><else-if type="dataset"><text value="Data set"/></else-if><else-if type="book" variable="version" match="all"><text value="Computer software"/></else-if><else-if type="interview personal_communication" match="any"><choose><if variable="archive container-title DOI publisher URL" match="none"><text term="letter" text-case="capitalize-first"/></if><else-if type="interview"><text term="interview" text-case="capitalize-first"/></else-if></choose></else-if><else-if type="map"><text value="Map"/></else-if></choose></macro><macro name="container"><choose><if type="article-journal article-magazine article-newspaper post-weblog review review-book" match="any"><text macro="container-periodical"/></if><else-if type="paper-conference"><choose><if variable="editor editorial-director collection-editor container-author" match="any"><text macro="container-booklike"/></if><else><text macro="container-periodical"/></else></choose></else-if><else-if type="post webpage" match="none"><text macro="container-booklike"/></else-if></choose></macro><macro name="container-periodical"><group delimiter=". "><group delimiter=", "><text variable="container-title" font-style="italic" text-case="title"/><choose><if variable="volume"><group><text variable="volume" font-style="italic"/><text variable="issue" prefix="(" suffix=")"/></group></if><else><text variable="issue" font-style="italic"/></else></choose><choose><if variable="page"><text variable="page"/></if><else><text variable="number" prefix="Article "/></else></choose></group><choose><if variable="issued"><choose><if variable="issue page volume" match="none"><text variable="status" text-case="capitalize-first"/></if></choose></if></choose></group></macro><macro name="container-booklike"><choose><if variable="container-title" match="any"><group delimiter=" "><text term="in" text-case="capitalize-first"/><group delimiter=", "><names variable="editor translator" delimiter=", &amp; "><name and="symbol" initialize-with=". " delimiter=", "/><label form="short" text-case="title" prefix=" (" suffix=")"/><substitute><names variable="editorial-director"/><names variable="collection-editor"/><names variable="container-author"/></substitute></names><group delimiter=": " font-style="italic"><text variable="container-title"/><choose><if is-numeric="volume" match="none"><group delimiter=" "><label variable="volume" form="short" text-case="capitalize-first"/><text variable="volume"/></group></if></choose></group></group><text macro="parenthetical-container"/><text macro="bracketed-container"/></group></if></choose></macro><macro name="publisher"><group delimiter="; "><choose><if type="thesis"><choose><if variable="archive DOI URL" match="none"><text variable="publisher"/></if></choose></if><else-if type="post webpage" match="any"><group delimiter="; "><text variable="container-title" text-case="title"/><text variable="publisher"/></group></else-if><else-if type="paper-conference"><choose><if variable="collection-editor editor editorial-director" match="any"><text variable="publisher"/></if></choose></else-if><else-if type="article-journal article-magazine article-newspaper post-weblog" match="none"><text variable="publisher"/></else-if></choose><group delimiter=", "><choose><if variable="archive-place"><text variable="archive_location"/></if></choose><text variable="archive"/><text variable="archive-place"/></group></group></macro><macro name="access"><choose><if variable="DOI" match="any"><text variable="DOI" prefix="https://doi.org/"/></if><else-if variable="URL"><group delimiter=" "><choose><if variable="issued status" match="none"><group delimiter=" "><text term="retrieved" text-case="capitalize-first"/><date variable="accessed" form="text" suffix=","/><text term="from"/></group></if></choose><text variable="URL"/></group></else-if></choose></macro><macro name="event"><choose><if variable="event"><choose><if variable="collection-editor editor editorial-director issue page volume" match="none"><group delimiter=", "><text variable="event"/><text variable="event-place"/></group></if></choose></if></choose></macro><macro name="publication-history"><choose><if type="patent" match="none"><group prefix="(" suffix=")"><choose><if variable="references"><text variable="references"/></if><else><group delimiter=" "><text value="Original work published"/><choose><if is-uncertain-date="original-date"><text term="circa" form="short"/></if></choose><date variable="original-date"><date-part name="year"/></date></group></else></choose></group></if><else><text variable="references" prefix="(" suffix=")"/></else></choose></macro><macro name="legal-cites"><choose><if type="legal_case"><group delimiter=". "><group delimiter=", "><text variable="title"/><group delimiter=" "><text macro="container-legal"/><text macro="date-legal"/></group><text variable="references"/></group><text macro="access"/></group></if><else-if type="bill"><group delimiter=". "><group delimiter=", "><choose><if variable="number container-title" match="none"><text variable="title" font-style="italic"/></if><else><text variable="title"/></else></choose><group delimiter=" "><text macro="container-legal"/><text macro="date-legal"/><choose><if variable="number container-title" match="none"><names variable="author" prefix="(testimony of " suffix=")"><name and="symbol" delimiter=", "/></names></if><else><text variable="status" prefix="(" suffix=")"/></else></choose></group><text variable="references"/></group><text macro="access"/></group></else-if><else-if type="legislation"><group delimiter=". "><group delimiter=", "><text variable="title"/><group delimiter=" "><text macro="container-legal"/><text macro="date-legal"/><text variable="status" prefix="(" suffix=")"/></group><text variable="references"/></group><text macro="access"/></group></else-if><else-if type="treaty"><group delimiter=", "><text variable="title" text-case="title"/><names variable="author"><name initialize-with="." form="short" delimiter="-"/></names><text macro="date-legal"/><text macro="container-legal"/><text macro="access"/></group></else-if></choose></macro><macro name="date-legal"><choose><if type="legal_case"><group prefix="(" suffix=")" delimiter=" "><text variable="authority"/><choose><if variable="container-title" match="any"><date variable="issued" form="numeric" date-parts="year"/></if><else><date variable="issued" form="text"/></else></choose></group></if><else-if type="bill legislation" match="any"><group prefix="(" suffix=")" delimiter=" "><group delimiter=" "><date variable="original-date"><date-part name="year"/></date><text term="and" form="symbol"/></group><date variable="issued"><date-part name="year"/></date></group></else-if><else-if type="treaty"><date variable="issued" form="text"/></else-if></choose></macro><macro name="container-legal"><choose><if type="legal_case"><group delimiter=" "><choose><if variable="container-title"><group delimiter=" "><text variable="volume"/><text variable="container-title"/><group delimiter=" "><text term="section" form="symbol"/><text variable="section"/></group><choose><if variable="page page-first" match="any"><text variable="page-first"/></if><else><text value="___"/></else></choose></group></if><else><group delimiter=" "><choose><if is-numeric="number"><text term="issue" form="short" text-case="capitalize-first"/></if></choose><text variable="number"/></group></else></choose></group></if><else-if type="bill"><group delimiter=", "><group delimiter=" "><text variable="genre"/><group delimiter=" "><choose><if variable="chapter-number container-title" match="none"><text term="issue" form="short"/></if></choose><text variable="number"/></group></group><text variable="authority"/><text variable="chapter-number"/><group delimiter=" "><text variable="volume"/><text variable="container-title"/><text variable="page-first"/></group></group></else-if><else-if type="legislation"><choose><if variable="number"><group delimiter=", "><text variable="number" prefix="Pub. L. No. "/><group delimiter=" "><text variable="volume"/><text variable="container-title"/><text variable="page-first"/></group></group></if><else><group delimiter=" "><text variable="volume"/><text variable="container-title"/><choose><if variable="section"><group delimiter=" "><text term="section" form="symbol"/><text variable="section"/></group></if><else><text variable="page-first"/></else></choose></group></else></choose></else-if><else-if type="treaty"><group delimiter=" "><number variable="volume"/><text variable="container-title"/><choose><if variable="page page-first" match="any"><text variable="page-first"/></if><else><group delimiter=" "><text term="issue" form="short" text-case="capitalize-first"/><text variable="number"/></group></else></choose></group></else-if></choose></macro><macro name="citation-locator"><group delimiter=" "><choose><if locator="chapter"><label variable="locator" text-case="capitalize-first"/></if><else><label variable="locator" form="short"/></else></choose><text variable="locator"/></group></macro><citation et-al-min="3" et-al-use-first="1" disambiguate-add-year-suffix="true" disambiguate-add-names="true" disambiguate-add-givenname="true" collapse="year" givenname-disambiguation-rule="primary-name-with-initials"><sort><key macro="author-bib" names-min="3" names-use-first="1"/><key macro="date-sort-group"/><key macro="date-sort-date" sort="ascending"/><key variable="status"/></sort><layout prefix="(" suffix=")" delimiter="; "><group delimiter=", "><text macro="author-intext"/><text macro="date-intext"/><text macro="citation-locator"/></group></layout></citation><bibliography hanging-indent="true" et-al-min="21" et-al-use-first="19" et-al-use-last="true" entry-spacing="0" line-spacing="2"><sort><key macro="author-bib"/><key macro="date-sort-group"/><key macro="date-sort-date" sort="ascending"/><key variable="status"/><key macro="title"/></sort><layout><choose><if type="bill legal_case legislation treaty" match="any"><choose><if variable="DOI URL" match="any"><text macro="legal-cites"/></if><else><text macro="legal-cites" suffix="."/></else></choose></if><else><group delimiter=" "><group delimiter=". " suffix="."><text macro="author-bib"/><text macro="date-bib"/><text macro="title-and-descriptions"/><text macro="container"/><text macro="event"/><text macro="publisher"/></group><text macro="access"/><text macro="publication-history"/></group></else></choose></layout></bibliography></style>',
  },
  nf = new xu(wD)
var l = {
  PROCESSOR_VERSION: '1.4.61',
  error: function (e) {
    throw typeof Error > 'u' ? new Error('citeproc-js error: ' + e) : 'citeproc-js error: ' + e
  },
  debug: function (e) {
    typeof console > 'u'
      ? dump(
          'CSL: ' +
            e +
            `
`
        )
      : console.log('citeproc-js warning: ' + e)
  },
  toLocaleUpperCase(e) {
    var t = this.tmp.lang_array
    try {
      e = e.toLocaleUpperCase(t)
    } catch {
      e = e.toUpperCase()
    }
    return e
  },
  toLocaleLowerCase(e) {
    var t = this.tmp.lang_array
    try {
      e = e.toLocaleLowerCase(t)
    } catch {
      e = e.toLowerCase()
    }
    return e
  },
  LOCATOR_LABELS_REGEXP: new RegExp(
    '^((vrs|sv|subpara|op|subch|add|amend|annot|app|art|bibliog|bk|ch|cl|col|cmt|dec|dept|div|ex|fig|fld|fol|n|hypo|illus|intro|l|no|p|pp|para|pt|pmbl|princ|pub|r|rn|sched|sec|ser|subdiv|subsec|supp|tbl|tit|vol)\\.)\\s+(.*)'
  ),
  STATUTE_SUBDIV_PLAIN_REGEX:
    /(?:(?:^| )(?:vrs|sv|subpara|op|subch|add|amend|annot|app|art|bibliog|bk|ch|cl|col|cmt|dec|dept|div|ex|fig|fld|fol|n|hypo|illus|intro|l|no|p|pp|para|pt|pmbl|princ|pub|r|rn|sched|sec|ser|subdiv|subsec|supp|tbl|tit|vol)\. *)/,
  STATUTE_SUBDIV_PLAIN_REGEX_FRONT:
    /(?:^\s*[.,;]*\s*(?:vrs|sv|subpara|op|subch|add|amend|annot|app|art|bibliog|bk|ch|cl|col|cmt|dec|dept|div|ex|fig|fld|fol|n|hypo|illus|intro|l|no|p|pp|para|pt|pmbl|princ|pub|r|rn|sched|sec|ser|subdiv|subsec|supp|tbl|tit|vol)\. *)/,
  STATUTE_SUBDIV_STRINGS: {
    'vrs.': 'verse',
    'sv.': 'sub-verbo',
    'subpara.': 'subparagraph',
    'op.': 'opus',
    'subch.': 'subchapter',
    'add.': 'addendum',
    'amend.': 'amendment',
    'annot.': 'annotation',
    'app.': 'appendix',
    'art.': 'article',
    'bibliog.': 'bibliography',
    'bk.': 'book',
    'ch.': 'chapter',
    'cl.': 'clause',
    'col.': 'column',
    'cmt.': 'comment',
    'dec.': 'decision',
    'dept.': 'department',
    'ex.': 'example',
    'fig.': 'figure',
    'fld.': 'field',
    'fol.': 'folio',
    'n.': 'note',
    'hypo.': 'hypothetical',
    'illus.': 'illustration',
    'intro.': 'introduction',
    'l.': 'line',
    'no.': 'issue',
    'p.': 'page',
    'pp.': 'page',
    'para.': 'paragraph',
    'pt.': 'part',
    'pmbl.': 'preamble',
    'princ.': 'principle',
    'pub.': 'publication',
    'r.': 'rule',
    'rn.': 'randnummer',
    'sched.': 'schedule',
    'sec.': 'section',
    'ser.': 'series,',
    'subdiv.': 'subdivision',
    'subsec.': 'subsection',
    'supp.': 'supplement',
    'tbl.': 'table',
    'tit.': 'title',
    'vol.': 'volume',
  },
  STATUTE_SUBDIV_STRINGS_REVERSE: {
    verse: 'vrs.',
    'sub-verbo': 'sv.',
    'sub verbo': 'sv.',
    subparagraph: 'subpara.',
    opus: 'op.',
    subchapter: 'subch.',
    addendum: 'add.',
    amendment: 'amend.',
    annotation: 'annot.',
    appendix: 'app.',
    article: 'art.',
    bibliography: 'bibliog.',
    book: 'bk.',
    chapter: 'ch.',
    clause: 'cl.',
    column: 'col.',
    comment: 'cmt.',
    decision: 'dec.',
    department: 'dept.',
    example: 'ex.',
    figure: 'fig.',
    field: 'fld.',
    folio: 'fol.',
    note: 'n.',
    hypothetical: 'hypo.',
    illustration: 'illus.',
    introduction: 'intro.',
    line: 'l.',
    issue: 'no.',
    page: 'p.',
    paragraph: 'para.',
    part: 'pt.',
    preamble: 'pmbl.',
    principle: 'princ.',
    publication: 'pub.',
    rule: 'r.',
    randnummer: 'rn.',
    schedule: 'sched.',
    section: 'sec.',
    'series,': 'ser.',
    subdivision: 'subdiv.',
    subsection: 'subsec.',
    supplement: 'supp.',
    table: 'tbl.',
    title: 'tit.',
    volume: 'vol.',
  },
  LOCATOR_LABELS_MAP: {
    vrs: 'verse',
    sv: 'sub-verbo',
    subpara: 'subparagraph',
    op: 'opus',
    subch: 'subchapter',
    add: 'addendum',
    amend: 'amendment',
    annot: 'annotation',
    app: 'appendix',
    art: 'article',
    bibliog: 'bibliography',
    bk: 'book',
    ch: 'chapter',
    cl: 'clause',
    col: 'column',
    cmt: 'comment',
    dec: 'decision',
    dept: 'department',
    ex: 'example',
    fig: 'figure',
    fld: 'field',
    fol: 'folio',
    n: 'note',
    hypo: 'hypothetical',
    illus: 'illustration',
    intro: 'introduction',
    l: 'line',
    no: 'issue',
    p: 'page',
    pp: 'page',
    para: 'paragraph',
    pt: 'part',
    pmbl: 'preamble',
    princ: 'principle',
    pub: 'publication',
    r: 'rule',
    rn: 'randnummer',
    sched: 'schedule',
    sec: 'section',
    ser: 'series,',
    subdiv: 'subdivision',
    subsec: 'subsection',
    supp: 'supplement',
    tbl: 'table',
    tit: 'title',
    vol: 'volume',
  },
  MODULE_MACROS: {
    'juris-pretitle': !0,
    'juris-title': !0,
    'juris-pretitle-short': !0,
    'juris-title-short': !0,
    'juris-main': !0,
    'juris-main-short': !0,
    'juris-tail': !0,
    'juris-tail-short': !0,
    'juris-locator': !0,
  },
  MODULE_TYPES: {
    legal_case: !0,
    legislation: !0,
    bill: !0,
    hearing: !0,
    gazette: !0,
    report: !0,
    regulation: !0,
    standard: !0,
    patent: !0,
    locator: !0,
  },
  checkNestedBrace: function (e) {
    e.opt.xclass === 'note'
      ? ((this.depth = 0),
        (this.update = function (r) {
          for (var r = r || '', i = r.split(/([\(\)])/), n = 1, s = i.length; n < s; n += 2)
            i[n] === '('
              ? (this.depth % 2 === 1 && (i[n] = '['), (this.depth += 1))
              : i[n] === ')' && (this.depth % 2 === 0 && (i[n] = ']'), (this.depth -= 1))
          var a = i.join('')
          return a
        }))
      : (this.update = function (t) {
          return t
        })
  },
  MULTI_FIELDS: [
    'event',
    'publisher',
    'publisher-place',
    'event-place',
    'title',
    'container-title',
    'collection-title',
    'authority',
    'genre',
    'title-short',
    'medium',
    'country',
    'jurisdiction',
    'archive',
    'archive-place',
  ],
  LangPrefsMap: {
    title: 'titles',
    'title-short': 'titles',
    event: 'titles',
    genre: 'titles',
    medium: 'titles',
    'container-title': 'journals',
    'collection-title': 'titles',
    archive: 'journals',
    publisher: 'publishers',
    authority: 'publishers',
    'publisher-place': 'places',
    'event-place': 'places',
    'archive-place': 'places',
    jurisdiction: 'places',
    number: 'places',
    edition: 'places',
    issue: 'places',
    volume: 'places',
  },
  AbbreviationSegments: function () {
    ;(this['container-title'] = {}),
      (this['collection-title'] = {}),
      (this['institution-entire'] = {}),
      (this['institution-part'] = {}),
      (this.nickname = {}),
      (this.number = {}),
      (this.title = {}),
      (this.place = {}),
      (this.hereinafter = {}),
      (this.classic = {}),
      (this['container-phrase'] = {}),
      (this['title-phrase'] = {})
  },
  getAbbrevsDomain: function (e, t, r) {
    var i = null
    if (e.opt.availableAbbrevDomains && t && t !== 'default') {
      var n = e.locale[e.opt.lang].opts['jurisdiction-preference'],
        s = null
      if ((e.locale[r] && (s = e.locale[r].opts['jurisdiction-preference']), s)) {
        for (var a = s.length - 1; a > -1; a--)
          if (e.opt.availableAbbrevDomains[t].indexOf(s[a]) > -1) {
            i = s[a]
            break
          }
      }
      if (!i && n) {
        for (var a = n.length - 1; a > -1; a--)
          if (e.opt.availableAbbrevDomains[t].indexOf(n[a]) > -1) {
            i = n[a]
            break
          }
      }
    }
    return i
  },
  FIELD_CATEGORY_REMAP: {
    title: 'title',
    'container-title': 'container-title',
    'collection-title': 'collection-title',
    country: 'place',
    number: 'number',
    place: 'place',
    archive: 'container-title',
    'title-short': 'title',
    genre: 'title',
    event: 'title',
    medium: 'title',
    'archive-place': 'place',
    'publisher-place': 'place',
    'event-place': 'place',
    jurisdiction: 'place',
    'language-name': 'place',
    'language-name-original': 'place',
    'call-number': 'number',
    'chapter-number': 'number',
    'collection-number': 'number',
    edition: 'number',
    page: 'number',
    issue: 'number',
    locator: 'number',
    'locator-extra': 'number',
    'number-of-pages': 'number',
    'number-of-volumes': 'number',
    volume: 'number',
    'citation-number': 'number',
    publisher: 'institution-part',
  },
  parseLocator: function (e) {
    if (this.opt.development_extensions.locator_date_and_revision && e.locator) {
      e.locator = '' + e.locator
      var t = e.locator.indexOf('|')
      if (t > -1) {
        var r = e.locator
        ;(e.locator = r.slice(0, t)), (r = r.slice(t + 1))
        var i = r.match(/^([0-9]{4}-[0-9]{2}-[0-9]{2}).*/)
        i &&
          ((e['locator-date'] = this.fun.dateparser.parseDateToObject(i[1])),
          (r = r.slice(i[1].length))),
          (e['locator-extra'] = r.replace(/^\s+/, '').replace(/\s+$/, ''))
      }
    }
    return e.locator && (e.locator = ('' + e.locator).replace(/\s+$/, '')), e
  },
  normalizeLocaleStr: function (e) {
    if (e) {
      var t = e.split('-')
      return (t[0] = t[0].toLowerCase()), t[1] && (t[1] = t[1].toUpperCase()), t.join('-')
    }
  },
  parseNoteFieldHacks: function (e, t, r) {
    if (typeof e.note == 'string') {
      for (
        var i = [],
          n = e.note.split(`
`),
          s = 0,
          a = n.length;
        s < a;
        s++
      ) {
        var o = n[s],
          i = [],
          u = o.match(l.NOTE_FIELDS_REGEXP)
        if (u) {
          for (var c = o.split(l.NOTE_FIELDS_REGEXP), f = 0, h = c.length - 1; f < h; f++)
            i.push(c[f]), i.push(u[f])
          i.push(c[c.length - 1])
          for (
            var f = 1, h = i.length;
            f < h && !(i[f - 1].trim() && (s > 0 || f > 1) && !i[f - 1].match(l.NOTE_FIELD_REGEXP));
            f += 2
          )
            i[f] =
              `
` +
              i[f].slice(2, -1).trim() +
              `
`
          n[s] = i.join('')
        }
      }
      n = n.join(`
`).split(`
`)
      for (var p = 0, m = {}, s = 0, a = n.length; s < a; s++) {
        var o = n[s],
          v = o.match(l.NOTE_FIELD_REGEXP)
        if (o.trim()) {
          if (!v) {
            if (s === 0) continue
            p = s
            break
          }
        } else continue
        var b = v[1],
          S = v[2].replace(/^\s+/, '').replace(/\s+$/, '')
        if (b === 'type') (e.type = S), (n[s] = '')
        else if (l.DATE_VARIABLES.indexOf(b.replace(/^alt-/, '')) > -1)
          (!e[b] || r) &&
            ((e[b] = l.DateParser.parseDateToArray(S)),
            (!t || (t[b] && this.isDateString(S))) && (n[s] = ''))
        else if (!e[b]) {
          if (l.NAME_VARIABLES.indexOf(b.replace(/^alt-/, '')) > -1) {
            m[b] || (m[b] = [])
            var g = S.split(/\s*\|\|\s*/)
            if (g.length === 1) m[b].push({ literal: g[0] })
            else if (g.length === 2) {
              var _ = { family: g[0], given: g[1] }
              l.parseParticles(_), m[b].push(_)
            }
          } else e[b] = S
          ;(!t || t[b]) && (n[s] = '')
        }
      }
      for (var b in m) e[b] = m[b]
      if (t) {
        n[p].trim() &&
          (n[p] =
            `
` + n[p])
        for (var s = p - 1; s > -1; s--) n[s].trim() || (n = n.slice(0, s).concat(n.slice(s + 1)))
      }
      e.note = n
        .join(
          `
`
        )
        .trim()
    }
  },
  checkPrefixSpaceAppend: function (e, s) {
    s || (s = '')
    var r = '',
      i = s.replace(/<[^>]+>/g, '').replace(/["'\u201d\u2019\u00bb\u202f\u00a0 ]+$/g, ''),
      n = i.slice(-1)
    ;(i.match(l.ENDSWITH_ROMANESQUE_REGEXP) ||
      l.TERMINAL_PUNCTUATION.slice(0, -1).indexOf(n) > -1 ||
      n.match(/[\)\],0-9]/)) &&
      (r = ' ')
    var s = (s + r).replace(/\s+/g, ' ')
    return s
  },
  checkIgnorePredecessor: function (e, t) {
    var r = t.replace(/<[^>]+>/g, '').replace(/["'\u201d\u2019\u00bb\u202f\u00a0 ]+$/g, ''),
      i = r.slice(-1)
    return l.TERMINAL_PUNCTUATION.slice(0, -1).indexOf(i) > -1 && t.trim().indexOf(' ') > -1
      ? ((e.tmp.term_predecessor = !1), !0)
      : !1
  },
  checkSuffixSpacePrepend: function (e, t) {
    return t
      ? ((t.match(l.STARTSWITH_ROMANESQUE_REGEXP) || ['[', '('].indexOf(t.slice(0, 1)) > -1) &&
          (t = ' ' + t),
        t)
      : ''
  },
  GENDERS: ['masculine', 'feminine'],
  ERROR_NO_RENDERED_FORM: 1,
  PREVIEW: 'Just for laughs.',
  ASSUME_ALL_ITEMS_REGISTERED: 2,
  START: 0,
  END: 1,
  SINGLETON: 2,
  SEEN: 6,
  SUCCESSOR: 3,
  SUCCESSOR_OF_SUCCESSOR: 4,
  SUPPRESS: 5,
  SINGULAR: 0,
  PLURAL: 1,
  LITERAL: !0,
  BEFORE: 1,
  AFTER: 2,
  DESCENDING: 1,
  ASCENDING: 2,
  PRIMARY: 1,
  SECONDARY: 2,
  POSITION_FIRST: 0,
  POSITION_SUBSEQUENT: 1,
  POSITION_IBID: 2,
  POSITION_IBID_WITH_LOCATOR: 3,
  POSITION_CONTAINER_SUBSEQUENT: 4,
  POSITION_MAP: { 0: 0, 4: 1, 1: 2, 2: 3, 3: 4 },
  POSITION_TEST_VARS: ['position', 'first-reference-note-number', 'near-note'],
  AREAS: ['citation', 'citation_sort', 'bibliography', 'bibliography_sort', 'intext'],
  CITE_FIELDS: [
    'first-reference-note-number',
    'first-container-reference-note-number',
    'locator',
    'locator-extra',
  ],
  SWAPPING_PUNCTUATION: ['.', '!', '?', ':', ','],
  TERMINAL_PUNCTUATION: [':', '.', ';', '!', '?', ' '],
  NONE: 0,
  NUMERIC: 1,
  POSITION: 2,
  TRIGRAPH: 3,
  DATE_PARTS: ['year', 'month', 'day'],
  DATE_PARTS_ALL: ['year', 'month', 'day', 'season'],
  DATE_PARTS_INTERNAL: ['year', 'month', 'day', 'year_end', 'month_end', 'day_end'],
  NAME_PARTS: [
    'non-dropping-particle',
    'family',
    'given',
    'dropping-particle',
    'suffix',
    'literal',
  ],
  DISAMBIGUATE_OPTIONS: [
    'disambiguate-add-names',
    'disambiguate-add-givenname',
    'disambiguate-add-year-suffix',
  ],
  GIVENNAME_DISAMBIGUATION_RULES: [
    'all-names',
    'all-names-with-initials',
    'primary-name',
    'primary-name-with-initials',
    'by-cite',
  ],
  NAME_ATTRIBUTES: [
    'and',
    'delimiter-precedes-last',
    'delimiter-precedes-et-al',
    'initialize-with',
    'initialize',
    'name-as-sort-order',
    'sort-separator',
    'et-al-min',
    'et-al-use-first',
    'et-al-subsequent-min',
    'et-al-subsequent-use-first',
    'form',
    'prefix',
    'suffix',
    'delimiter',
  ],
  LOOSE: 0,
  STRICT: 1,
  TOLERANT: 2,
  PREFIX_PUNCTUATION: /[.;:]\s*$/,
  SUFFIX_PUNCTUATION: /^\s*[.;:,\(\)]/,
  NUMBER_REGEXP: /(?:^\d+|\d+$)/,
  NAME_INITIAL_REGEXP:
    /^([A-Z\u0e01-\u0e5b\u00c0-\u017f\u0400-\u042f\u0590-\u05d4\u05d6-\u05ff\u0600-\u06ff\u0370\u0372\u0376\u0386\u0388-\u03ab\u03e2\u03e4\u03e6\u03e8\u03ea\u03ec\u03ee\u03f4\u03f7\u03fd-\u03ff])([a-zA-Z\u0e01-\u0e5b\u00c0-\u017f\u0400-\u052f\u0600-\u06ff\u0370-\u03ff\u1f00-\u1fff]*|)(\.)*/,
  ROMANESQUE_REGEXP:
    /[-0-9a-zA-Z\u0e01-\u0e5b\u00c0-\u017f\u0370-\u03ff\u0400-\u052f\u0590-\u05d4\u05d6-\u05ff\u1f00-\u1fff\u0600-\u06ff\u200c\u200d\u200e\u0218\u0219\u021a\u021b\u202a-\u202e]/,
  ROMANESQUE_NOT_REGEXP:
    /[^a-zA-Z\u0e01-\u0e5b\u00c0-\u017f\u0370-\u03ff\u0400-\u052f\u0590-\u05d4\u05d6-\u05ff\u1f00-\u1fff\u0600-\u06ff\u200c\u200d\u200e\u0218\u0219\u021a\u021b\u202a-\u202e]/g,
  STARTSWITH_ROMANESQUE_REGEXP:
    /^[&a-zA-Z\u0e01-\u0e5b\u00c0-\u017f\u0370-\u03ff\u0400-\u052f\u0590-\u05d4\u05d6-\u05ff\u1f00-\u1fff\u0600-\u06ff\u200c\u200d\u200e\u0218\u0219\u021a\u021b\u202a-\u202e]/,
  ENDSWITH_ROMANESQUE_REGEXP:
    /[.;:&a-zA-Z\u0e01-\u0e5b\u00c0-\u017f\u0370-\u03ff\u0400-\u052f\u0590-\u05d4\u05d6-\u05ff\u1f00-\u1fff\u0600-\u06ff\u200c\u200d\u200e\u0218\u0219\u021a\u021b\u202a-\u202e]$/,
  ALL_ROMANESQUE_REGEXP:
    /^[a-zA-Z\u0e01-\u0e5b\u00c0-\u017f\u0370-\u03ff\u0400-\u052f\u0590-\u05d4\u05d6-\u05ff\u1f00-\u1fff\u0600-\u06ff\u200c\u200d\u200e\u0218\u0219\u021a\u021b\u202a-\u202e]+$/,
  VIETNAMESE_SPECIALS:
    /[\u00c0-\u00c3\u00c8-\u00ca\u00cc\u00cd\u00d2-\u00d5\u00d9\u00da\u00dd\u00e0-\u00e3\u00e8-\u00ea\u00ec\u00ed\u00f2-\u00f5\u00f9\u00fa\u00fd\u0101\u0103\u0110\u0111\u0128\u0129\u0168\u0169\u01a0\u01a1\u01af\u01b0\u1ea0-\u1ef9]/,
  VIETNAMESE_NAMES:
    /^(?:(?:[.AaBbCcDdEeGgHhIiKkLlMmNnOoPpQqRrSsTtUuVvXxYy \u00c0-\u00c3\u00c8-\u00ca\u00cc\u00cd\u00d2-\u00d5\u00d9\u00da\u00dd\u00e0-\u00e3\u00e8-\u00ea\u00ec\u00ed\u00f2-\u00f5\u00f9\u00fa\u00fd\u0101\u0103\u0110\u0111\u0128\u0129\u0168\u0169\u01a0\u01a1\u01af\u01b0\u1ea0-\u1ef9]{2,6})(\s+|$))+$/,
  NOTE_FIELDS_REGEXP: /\{:(?:[\-_a-z]+|[A-Z]+):[^\}]+\}/g,
  NOTE_FIELD_REGEXP: /^([\-_a-z]+|[A-Z]+):\s*([^\}]+)$/,
  PARTICLE_GIVEN_REGEXP: /^([^ ]+(?:\u02bb |\u2019 | |\' ) *)(.+)$/,
  PARTICLE_FAMILY_REGEXP: /^([^ ]+(?:\-|\u02bb|\u2019| |\') *)(.+)$/,
  DISPLAY_CLASSES: ['block', 'left-margin', 'right-inline', 'indent'],
  NAME_VARIABLES: [
    'author',
    'chair',
    'collection-editor',
    'compiler',
    'composer',
    'container-author',
    'contributor',
    'curator',
    'director',
    'editor',
    'editor-translator',
    'editorial-director',
    'executive-producer',
    'guest',
    'host',
    'illustrator',
    'interviewer',
    'narrator',
    'organizer',
    'original-author',
    'performer',
    'producer',
    'recipient',
    'reviewed-author',
    'script-writer',
    'series-creator',
    'translator',
    'commenter',
  ],
  CREATORS: [
    'author',
    'chair',
    'collection-editor',
    'compiler',
    'composer',
    'container-author',
    'contributor',
    'curator',
    'director',
    'editor',
    'editor-translator',
    'editorial-director',
    'executive-producer',
    'guest',
    'host',
    'illustrator',
    'interviewer',
    'narrator',
    'organizer',
    'original-author',
    'performer',
    'producer',
    'recipient',
    'reviewed-author',
    'script-writer',
    'series-creator',
    'translator',
    'commenter',
  ],
  NUMERIC_VARIABLES: [
    'call-number',
    'chapter-number',
    'collection-number',
    'division',
    'edition',
    'page',
    'issue',
    'locator',
    'locator-extra',
    'number',
    'number-of-pages',
    'number-of-volumes',
    'part-number',
    'printing-number',
    'section',
    'supplement-number',
    'version',
    'volume',
    'supplement',
    'citation-number',
  ],
  DATE_VARIABLES: [
    'locator-date',
    'issued',
    'event-date',
    'accessed',
    'original-date',
    'publication-date',
    'available-date',
    'submitted',
    'alt-issued',
    'alt-event',
  ],
  VARIABLES_WITH_SHORT_FORM: ['title', 'container-title'],
  TITLE_FIELD_SPLITS: function (e) {
    for (
      var t = ['title', 'short', 'main', 'sub', 'subjoin'], r = {}, i = 0, n = t.length;
      i < n;
      i++
    )
      r[t[i]] = e + 'title' + (t[i] === 'title' ? '' : '-' + t[i])
    return r
  },
  demoteNoiseWords: function (e, t, r) {
    var i = e.locale[e.opt.lang].opts['leading-noise-words']
    if (t && r) {
      ;(t = t.split(/\s+/)), t.reverse()
      for (var n = [], s = t.length - 1; s > -1 && i.indexOf(t[s].toLowerCase()) > -1; s += -1)
        n.push(t.pop())
      t.reverse()
      var a = t.join(' '),
        o = n.join(' ')
      r === 'drop' || !o ? (t = a) : r === 'demote' && (t = [a, o].join(', '))
    }
    return t
  },
  extractTitleAndSubtitle: function (e, t) {
    var r = t ? '' : '',
      i = ['']
    this.opt.development_extensions.split_container_title && i.push('container-')
    for (var n = 0, s = i.length; n < s; n++) {
      var a = i[n],
        o = l.TITLE_FIELD_SPLITS(a),
        u = [!1]
      if (e.multi) for (var c in e.multi._keys[o.short]) u.push(c)
      for (var f = 0, h = u.length; f < h; f++) {
        var c = u[f],
          p = {}
        c
          ? (e.multi._keys[o.title] && (p[o.title] = e.multi._keys[o.title][c]),
            e.multi._keys[o.short] && (p[o.short] = e.multi._keys[o.short][c]))
          : ((p[o.title] = e[o.title]), (p[o.short] = e[o.short])),
          (p[o.main] = p[o.title]),
          (p[o.sub] = !1)
        var m = p[o.short]
        if (p[o.title]) {
          if (m && m.toLowerCase() === p[o.title].toLowerCase())
            (p[o.main] = p[o.title]), (p[o.subjoin] = ''), (p[o.sub] = '')
          else if (m) {
            var v = p[o.title].slice(m.replace(/[\?\!]+$/, '').length),
              b = p[o.title].replace(v.replace(/^[\?\!]+/, ''), '').trim(),
              S = l.TITLE_SPLIT_REGEXP.matchfirst.exec(v)
            if (S && b.toLowerCase() === m.toLowerCase())
              (p[o.main] = b),
                (p[o.subjoin] = S[1].replace(/[\?\!]+(\s*)$/, '$1')),
                (p[o.sub] = v.replace(l.TITLE_SPLIT_REGEXP.matchfirst, '')),
                this.opt.development_extensions.force_short_title_casing_alignment &&
                  (p[o.short] = p[o.main])
            else {
              var g = l.TITLE_SPLIT(p[o.title])
              g.length == 3
                ? ((p[o.main] = g[0]), (p[o.subjoin] = g[1]), (p[o.sub] = g[2]))
                : ((p[o.main] = p[o.title]), (p[o.subjoin] = ''), (p[o.sub] = ''))
            }
          } else {
            var g = l.TITLE_SPLIT(p[o.title])
            if (g.length == 3) {
              if (
                ((p[o.main] = g[0]),
                (p[o.subjoin] = g[1]),
                (p[o.sub] = g[2]),
                this.opt.development_extensions.implicit_short_title &&
                  e.type !== 'legal_case' &&
                  !e[o.short] &&
                  !p[o.main].match(/^[\-\.[0-9]+$/))
              ) {
                var _ = p[o.subjoin].trim()
                ;['?', '!'].indexOf(_) === -1 && (_ = ''), (p[o.short] = p[o.main] + _)
              }
            } else (p[o.main] = p[o.title]), (p[o.subjoin] = ''), (p[o.sub] = '')
          }
          if (p[o.subjoin] && p[o.subjoin].match(/([\?\!])/)) {
            var S = p[o.subjoin].match(/(\s*)$/)
            ;(p[o.main] = p[o.main] + r + p[o.subjoin].trim()), (p[o.subjoin] = S[1])
          }
        }
        if (
          (p[o.subjoin] &&
            (p[o.subjoin].indexOf(':') > -1 && (p[o.subjoin] = r + ': '),
            (p[o.subjoin].indexOf('-') > -1 || p[o.subjoin].indexOf('') > -1) &&
              (p[o.subjoin] = '')),
          c)
        )
          for (var y in p) e.multi._keys[y] || (e.multi._keys[y] = {}), (e.multi._keys[y][c] = p[y])
        else for (var y in p) e[y] = p[y]
      }
    }
  },
  titlecaseSentenceOrNormal: function (e, t, r, i, n) {
    var s = l.TITLE_FIELD_SPLITS(r),
      a = {}
    if (
      (i && t.multi
        ? (t.multi._keys[s.title] && (a[s.title] = t.multi._keys[s.title][i]),
          t.multi._keys[s.main] && (a[s.main] = t.multi._keys[s.main][i]),
          t.multi._keys[s.sub] && (a[s.sub] = t.multi._keys[s.sub][i]),
          t.multi._keys[s.subjoin] && (a[s.subjoin] = t.multi._keys[s.subjoin][i]))
        : ((a[s.title] = t[s.title]),
          (a[s.main] = t[s.main]),
          (a[s.sub] = t[s.sub]),
          (a[s.subjoin] = t[s.subjoin])),
      a[s.main] && a[s.sub])
    ) {
      var o = a[s.main],
        u = a[s.subjoin],
        c = a[s.sub]
      return (
        n
          ? ((o = l.Output.Formatters.sentence(e, o)), (c = l.Output.Formatters.sentence(e, c)))
          : e.opt.development_extensions.uppercase_subtitles &&
            (c = l.Output.Formatters['capitalize-first'](e, c)),
        [o, u, c].join('')
      )
    } else if (a[s.title]) {
      if (n) return l.Output.Formatters.sentence(e, a[s.title])
      if (e.opt.development_extensions.uppercase_subtitles) {
        for (var f = l.TITLE_SPLIT(a[s.title]), h = 0, p = f.length; h < p; h += 2)
          f[h] = l.Output.Formatters['capitalize-first'](e, f[h])
        for (var h = 1, p = f.length - 1; h < p; h += 2) {
          var m = f[h].match(/([:\?\!] )/)
          if (m) {
            var v = e.opt['default-locale'][0].slice(0, 2).toLowerCase() === 'fr' ? '' : ''
            f[h] = v + m[1]
          }
          ;(f[h].indexOf('-') > -1 || f[h].indexOf('') > -1) && (f[h] = '')
        }
        return (a[s.title] = f.join('')), a[s.title]
      } else return a[s.title]
    } else return ''
  },
  getSafeEscape: function (e) {
    if (['bibliography', 'citation'].indexOf(e.tmp.area) > -1) {
      var t = []
      return (
        e.opt.development_extensions.thin_non_breaking_space_html_hack &&
          e.opt.mode === 'html' &&
          t.push(function (r) {
            return r.replace(/\u202f/g, '<span style="white-space:nowrap">&thinsp;</span>')
          }),
        t.length
          ? function (r) {
              for (var i = 0, n = t.length; i < n; i += 1) r = t[i](r)
              return l.Output.Formats[e.opt.mode].text_escape(r)
            }
          : l.Output.Formats[e.opt.mode].text_escape
      )
    } else
      return function (r) {
        return r
      }
  },
  SKIP_WORDS: [
    'about',
    'above',
    'across',
    'afore',
    'after',
    'against',
    'al',
    'along',
    'alongside',
    'amid',
    'amidst',
    'among',
    'amongst',
    'anenst',
    'apropos',
    'apud',
    'around',
    'as',
    'aside',
    'astride',
    'at',
    'athwart',
    'atop',
    'barring',
    'before',
    'behind',
    'below',
    'beneath',
    'beside',
    'besides',
    'between',
    'beyond',
    'but',
    'by',
    'circa',
    'despite',
    'down',
    'during',
    'et',
    'except',
    'for',
    'forenenst',
    'from',
    'given',
    'in',
    'inside',
    'into',
    'lest',
    'like',
    'modulo',
    'near',
    'next',
    'notwithstanding',
    'of',
    'off',
    'on',
    'onto',
    'out',
    'over',
    'per',
    'plus',
    'pro',
    'qua',
    'sans',
    'since',
    'than',
    'through',
    ' thru',
    'throughout',
    'thruout',
    'till',
    'to',
    'toward',
    'towards',
    'under',
    'underneath',
    'until',
    'unto',
    'up',
    'upon',
    'versus',
    'vs.',
    'v.',
    'vs',
    'v',
    'via',
    'vis--vis',
    'with',
    'within',
    'without',
    'according to',
    'ahead of',
    'apart from',
    'as for',
    'as of',
    'as per',
    'as regards',
    'aside from',
    'back to',
    'because of',
    'close to',
    'due to',
    'except for',
    'far from',
    'inside of',
    'instead of',
    'near to',
    'next to',
    'on to',
    'out from',
    'out of',
    'outside of',
    'prior to',
    'pursuant to',
    'rather than',
    'regardless of',
    'such as',
    'that of',
    'up to',
    'where as',
    'or',
    'yet',
    'so',
    'for',
    'and',
    'nor',
    'a',
    'an',
    'the',
    'de',
    "d'",
    'von',
    'van',
    'c',
    'ca',
  ],
  FORMAT_KEY_SEQUENCE: [
    '@strip-periods',
    '@font-style',
    '@font-variant',
    '@font-weight',
    '@text-decoration',
    '@vertical-align',
    '@quotes',
  ],
  INSTITUTION_KEYS: ['font-style', 'font-variant', 'font-weight', 'text-decoration', 'text-case'],
  SUFFIX_CHARS: 'a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x,y,z',
  ROMAN_NUMERALS: [
    ['', 'i', 'ii', 'iii', 'iv', 'v', 'vi', 'vii', 'viii', 'ix'],
    ['', 'x', 'xx', 'xxx', 'xl', 'l', 'lx', 'lxx', 'lxxx', 'xc'],
    ['', 'c', 'cc', 'ccc', 'cd', 'd', 'dc', 'dcc', 'dccc', 'cm'],
    ['', 'm', 'mm', 'mmm', 'mmmm', 'mmmmm'],
  ],
  LANGS: {
    'af-ZA': 'Afrikaans',
    ar: 'Arabic',
    'bg-BG': 'Bulgarian',
    'ca-AD': 'Catalan',
    'cs-CZ': 'Czech',
    'da-DK': 'Danish',
    'de-AT': 'Austrian',
    'de-CH': 'German (CH)',
    'de-DE': 'German (DE)',
    'el-GR': 'Greek',
    'en-GB': 'English (GB)',
    'en-US': 'English (US)',
    'es-ES': 'Spanish',
    'et-EE': 'Estonian',
    eu: 'European',
    'fa-IR': 'Persian',
    'fi-FI': 'Finnish',
    'fr-CA': 'French (CA)',
    'fr-FR': 'French (FR)',
    'he-IL': 'Hebrew',
    'hr-HR': 'Croatian',
    'hu-HU': 'Hungarian',
    'is-IS': 'Icelandic',
    'it-IT': 'Italian',
    'ja-JP': 'Japanese',
    'km-KH': 'Khmer',
    'ko-KR': 'Korean',
    'lt-LT': 'Lithuanian',
    'lv-LV': 'Latvian',
    'mn-MN': 'Mongolian',
    'nb-NO': 'Norwegian (Bokml)',
    'nl-NL': 'Dutch',
    'nn-NO': 'Norwegian (Nynorsk)',
    'pl-PL': 'Polish',
    'pt-BR': 'Portuguese (BR)',
    'pt-PT': 'Portuguese (PT)',
    'ro-RO': 'Romanian',
    'ru-RU': 'Russian',
    'sk-SK': 'Slovak',
    'sl-SI': 'Slovenian',
    'sr-RS': 'Serbian',
    'sv-SE': 'Swedish',
    'th-TH': 'Thai',
    'tr-TR': 'Turkish',
    'uk-UA': 'Ukrainian',
    'vi-VN': 'Vietnamese',
    'zh-CN': 'Chinese (CN)',
    'zh-TW': 'Chinese (TW)',
  },
  LANG_BASES: {
    af: 'af_ZA',
    ar: 'ar',
    bg: 'bg_BG',
    ca: 'ca_AD',
    cs: 'cs_CZ',
    da: 'da_DK',
    de: 'de_DE',
    el: 'el_GR',
    en: 'en_US',
    es: 'es_ES',
    et: 'et_EE',
    eu: 'eu',
    fa: 'fa_IR',
    fi: 'fi_FI',
    fr: 'fr_FR',
    he: 'he_IL',
    hr: 'hr-HR',
    hu: 'hu_HU',
    is: 'is_IS',
    it: 'it_IT',
    ja: 'ja_JP',
    km: 'km_KH',
    ko: 'ko_KR',
    lt: 'lt_LT',
    lv: 'lv-LV',
    mn: 'mn_MN',
    nb: 'nb_NO',
    nl: 'nl_NL',
    nn: 'nn-NO',
    pl: 'pl_PL',
    pt: 'pt_PT',
    ro: 'ro_RO',
    ru: 'ru_RU',
    sk: 'sk_SK',
    sl: 'sl_SI',
    sr: 'sr_RS',
    sv: 'sv_SE',
    th: 'th_TH',
    tr: 'tr_TR',
    uk: 'uk_UA',
    vi: 'vi_VN',
    zh: 'zh_CN',
  },
  SUPERSCRIPTS: {
    : 'a',
    '': '2',
    '': '3',
    '': '1',
    : 'o',
    : 'h',
    : '',
    : 'j',
    : 'r',
    : '',
    : '',
    : '',
    : 'w',
    : 'y',
    : '',
    : 'l',
    : 's',
    : 'x',
    : '',
    : 'A',
    : '',
    : 'B',
    : 'D',
    : 'E',
    : '',
    : 'G',
    : 'H',
    : 'I',
    : 'J',
    : 'K',
    : 'L',
    : 'M',
    : 'N',
    : 'O',
    : '',
    : 'P',
    : 'R',
    : 'T',
    : 'U',
    : 'W',
    : 'a',
    : '',
    : '',
    : '',
    : 'b',
    : 'd',
    : 'e',
    : '',
    : '',
    : '',
    : 'g',
    : 'k',
    : 'm',
    : '',
    : 'o',
    : '',
    : '',
    : '',
    : 'p',
    : 't',
    : 'u',
    : '',
    : '',
    : 'v',
    : '',
    : '',
    : '',
    : '',
    : '',
    : '',
    '': '0',
    : 'i',
    '': '4',
    '': '5',
    '': '6',
    '': '7',
    '': '8',
    '': '9',
    '': '+',
    '': '',
    '': '=',
    '': '(',
    '': ')',
    : 'n',
    '': 'SM',
    '': 'TM',
    '': '',
    '': '',
    '': '',
    '': '',
    '': '',
    '': '',
    '': '',
    '': '',
    '': '',
    '': '',
    '': '',
    '': '',
    '': '',
    '': '',
    : '',
    : '',
    : '',
    : '',
  },
  SUPERSCRIPTS_REGEXP: new RegExp(
    '[]',
    'g'
  ),
  UPDATE_GROUP_CONTEXT_CONDITION: function (e, t, r, i, n) {
    if (e.opt.use_context_condition) {
      var s = e.tmp.group_context.tip
      s.condition
        ? (s.condition.termtxt || ((s.condition.termtxt = t), (s.condition.valueTerm = r)),
          !s.value_seen &&
            s.condition.test === 'comma-safe-numbers-only' &&
            n &&
            ((s.value_seen = !0), n.match(/^[0-9]/) || (e.tmp.just_did_number = !1)))
        : (i && i.decorations.filter((a) => a[0] === '@vertical-align').length > 0) ||
          (i && i.strings.suffix)
        ? (e.tmp.just_did_number = !1)
        : t && (t.match(/[0-9]$/) ? (e.tmp.just_did_number = !0) : (e.tmp.just_did_number = !1))
    }
  },
  EVALUATE_GROUP_CONDITION: function (e, t) {
    if (e.opt.use_context_condition) {
      var r,
        i = t.condition.test === 'comma-safe-numbers-only'
      if (t.condition.test === 'empty-label') r = !t.condition.termtxt
      else if (t.condition.test === 'empty-label-no-decor')
        r = !t.condition.termtxt || t.condition.termtxt.indexOf('%s') > -1
      else if (['comma-safe', 'comma-safe-numbers-only'].indexOf(t.condition.test) > -1) {
        var n = t.condition.termtxt,
          s = !1
        t.condition.termtxt && (s = t.condition.termtxt.slice(0, 1).match(l.ALL_ROMANESQUE_REGEXP))
        var a = e.tmp.just_did_number
        a
          ? t.condition.valueTerm
            ? (r = !i)
            : n
            ? s
              ? (r = !i)
              : ['always', 'after-number'].indexOf(e.opt.require_comma_on_symbol) > -1
              ? (r = !0)
              : (r = !1)
            : (r = !0)
          : t.condition.valueTerm
          ? (r = !1)
          : n
          ? s
            ? (r = !i)
            : e.opt.require_comma_on_symbol === 'always'
            ? (r = !0)
            : (r = !1)
          : (r = !1)
      }
      if (r) var o = !1
      else var o = !0
      return t.condition.not && (o = !o), o
    }
  },
  SYS_OPTIONS: [
    'prioritize_disambiguate_condition',
    'csl_reverse_lookup_support',
    'main_title_from_short_title',
    'uppercase_subtitles',
    'force_short_title_casing_alignment',
    'implicit_short_title',
    'split_container_title',
  ],
  TITLE_SPLIT_REGEXP: (function () {
    var e = [
      '\\.\\s+',
      '\\!\\s+',
      '\\?\\s+',
      '\\s*::*\\s+',
      '\\s*\\s*',
      '\\s+\\-\\s+',
      '\\s*\\-\\-\\-*\\s*',
    ]
    return {
      match: new RegExp('(' + e.join('|') + ')', 'g'),
      matchfirst: new RegExp('^(' + e.join('|') + ')'),
      split: new RegExp('(?:' + e.join('|') + ')'),
    }
  })(),
  TITLE_SPLIT: function (e) {
    if (!e) return e
    for (
      var t = e.match(l.TITLE_SPLIT_REGEXP.match),
        r = e.split(l.TITLE_SPLIT_REGEXP.split),
        i = r.length - 2;
      i > -1;
      i--
    )
      (r[i] = r[i].trim()),
        r[i] && r[i].slice(-1).toLowerCase() !== r[i].slice(-1)
          ? ((r[i] = r[i] + t[i] + r[i + 1]), (r = r.slice(0, i + 1).concat(r.slice(i + 2))))
          : (r = r
              .slice(0, i + 1)
              .concat([t[i]])
              .concat(r.slice(i + 1)))
    return r
  },
  GET_COURT_CLASS: function (e, t, r) {
    var i = '',
      n = null,
      s = t.jurisdiction ? t.jurisdiction.split(':')[0] : null,
      a = 'court_condition_classes'
    return (
      r && (a = 'court_key_classes'),
      s &&
        t.authority &&
        (typeof t.authority == 'string'
          ? (n = t.authority)
          : t.authority[0] && t.authority[0].literal && (n = t.authority[0].literal)),
      n &&
        (this.lang &&
        e.locale[this.lang].opts[a] &&
        e.locale[this.lang].opts[a][s] &&
        e.locale[this.lang].opts[a][s][n]
          ? (i = e.locale[this.lang].opts[a][s][n])
          : e.locale[e.opt['default-locale'][0]].opts[a] &&
            e.locale[e.opt['default-locale'][0]].opts[a][s] &&
            e.locale[e.opt['default-locale'][0]].opts[a][s][n] &&
            (i = e.locale[e.opt['default-locale'][0]].opts[a][s][n])),
      i
    )
  },
  SET_COURT_CLASSES: function (e, t, r, i) {
    for (var n = r.getNodesByName(i, 'court-class'), s = 0, a = r.numberofnodes(n); s < a; s += 1) {
      var o = n[s],
        u = r.attributes(o),
        c = u['@name'],
        f = u['@country'],
        h = u['@courts'],
        p = 'court_key_classes'
      if ((e.registry && (p = 'court_condition_classes'), c && f && h)) {
        ;(h = h.trim().split(/\s+/)),
          e.locale[t].opts[p] || (e.locale[t].opts[p] = {}),
          e.locale[t].opts[p][f] || (e.locale[t].opts[p][f] = {})
        for (var m = 0, v = h.length; m < v; m++) e.locale[t].opts[p][f][h[m]] = c
      }
    }
  },
  INIT_JURISDICTION_MACROS: function (e, t, r, i) {
    if (t['best-jurisdiction']) return !0
    if (!e.sys.retrieveStyleModule || !l.MODULE_MACROS[i] || !t.jurisdiction) return !1
    var o = e.getJurisdictionList(t.jurisdiction)
    if (!e.opt.jurisdictions_seen[o[0]]) {
      var n = e.retrieveAllStyleModules(o)
      for (var s in n) {
        var a = e.loadStyleModule(s, n[s])
        a &&
          (n[a] ||
            (Object.assign(n, e.retrieveAllStyleModules([a])), e.loadStyleModule(a, n[a], !0)))
      }
    }
    var o = e.getJurisdictionList(t.jurisdiction)
    e.opt.parallel.enable && (e.parallel || (e.parallel = new l.Parallel(e)))
    for (var u = 0, c = o.length; u < c; u++) {
      var s = o[u]
      if (
        (r &&
          e.juris[s] &&
          !r['best-jurisdiction'] &&
          e.juris[s].types.locator &&
          (t['best-jurisdiction'] = s),
        e.juris[s] && e.juris[s].types[t.type])
      )
        return (t['best-jurisdiction'] = s), !0
    }
    return !1
  },
}
l.XmlJSON = function (e) {
  ;(this.dataObj = e),
    (this.institution = {
      name: 'institution',
      attrs: { 'institution-parts': 'long', delimiter: ', ' },
      children: [{ name: 'institution-part', attrs: { name: 'long' }, children: [] }],
    })
}
l.XmlJSON.prototype.clean = function (e) {
  return e
}
l.XmlJSON.prototype.getStyleId = function (e, t) {
  var r = 'id'
  t && (r = 'title')
  for (var i = '', n = e.children, s = 0, a = n.length; s < a; s++)
    if (n[s].name === 'info')
      for (var o = n[s].children, u = 0, c = o.length; u < c; u++)
        o[u].name === r && (i = o[u].children[0])
  return i
}
l.XmlJSON.prototype.children = function (e) {
  return e && e.children.length ? e.children.slice() : !1
}
l.XmlJSON.prototype.nodename = function (e) {
  return e ? e.name : null
}
l.XmlJSON.prototype.attributes = function (e) {
  var t = {}
  for (var r in e.attrs) t['@' + r] = e.attrs[r]
  return t
}
l.XmlJSON.prototype.content = function (e) {
  var t = ''
  if (!e || !e.children) return t
  for (var r = 0, i = e.children.length; r < i; r += 1)
    typeof e.children[r] == 'string' && (t += e.children[r])
  return t
}
l.XmlJSON.prototype.namespace = {}
l.XmlJSON.prototype.numberofnodes = function (e) {
  return e && typeof e.length == 'number' ? e.length : 0
}
l.XmlJSON.prototype.getAttributeValue = function (e, t, r) {
  var i = ''
  return r && (t = r + ':' + t), e && e.attrs && (e.attrs[t] ? (i = e.attrs[t]) : (i = '')), i
}
l.XmlJSON.prototype.getNodeValue = function (e, t) {
  var r = ''
  if (t)
    for (var i = 0, n = e.children.length; i < n; i += 1)
      e.children[i].name === t && (e.children[i].children.length ? (r = e.children[i]) : (r = ''))
  else e && (r = e)
  return (
    r &&
      r.children &&
      r.children.length == 1 &&
      typeof r.children[0] == 'string' &&
      (r = r.children[0]),
    r
  )
}
l.XmlJSON.prototype.setAttributeOnNodeIdentifiedByNameAttribute = function (e, t, r, i, n) {
  i.slice(0, 1) === '@' && (i = i.slice(1))
  for (var s = 0, a = e.children.length; s < a; s += 1)
    e.children[s].name === t && e.children[s].attrs.name === r && (e.children[s].attrs[i] = n)
}
l.XmlJSON.prototype.deleteNodeByNameAttribute = function (e, t) {
  var r, i
  for (r = 0, i = e.children.length; r < i; r += 1)
    !e.children[r] ||
      typeof e.children[r] == 'string' ||
      (e.children[r].attrs.name == t &&
        (e.children = e.children.slice(0, r).concat(e.children.slice(r + 1))))
}
l.XmlJSON.prototype.deleteAttribute = function (e, t) {
  typeof e.attrs[t] < 'u' && e.attrs.pop(t)
}
l.XmlJSON.prototype.setAttribute = function (e, t, r) {
  return (e.attrs[t] = r), !1
}
l.XmlJSON.prototype.nodeCopy = function (e, t) {
  if (!t) var t = {}
  if (typeof t == 'object' && typeof t.length > 'u')
    for (var r in e)
      typeof e[r] == 'string'
        ? (t[r] = e[r])
        : typeof e[r] == 'object' &&
          (typeof e[r].length > 'u'
            ? (t[r] = this.nodeCopy(e[r], {}))
            : (t[r] = this.nodeCopy(e[r], [])))
  else
    for (var i = 0, n = e.length; i < n; i += 1)
      typeof e[i] == 'string' ? (t[i] = e[i]) : (t[i] = this.nodeCopy(e[i], {}))
  return t
}
l.XmlJSON.prototype.getNodesByName = function (e, t, r, i) {
  if (!i) var i = []
  if (!e || !e.children) return i
  t === e.name && (r ? r === e.attrs.name && i.push(e) : i.push(e))
  for (var n = 0, s = e.children.length; n < s; n += 1)
    typeof e.children[n] == 'object' && this.getNodesByName(e.children[n], t, r, i)
  return i
}
l.XmlJSON.prototype.nodeNameIs = function (e, t) {
  return typeof e > 'u' ? !1 : t == e.name
}
l.XmlJSON.prototype.makeXml = function (e) {
  return (
    typeof e == 'string' &&
      (e.slice(0, 1) === '<' ? (e = this.jsonStringWalker.walkToObject(e)) : (e = JSON.parse(e))),
    e
  )
}
l.XmlJSON.prototype.insertChildNodeAfter = function (e, t, r, i) {
  for (var n = 0, s = e.children.length; n < s; n += 1)
    if (t === e.children[n]) {
      e.children = e.children
        .slice(0, n)
        .concat([i])
        .concat(e.children.slice(n + 1))
      break
    }
  return e
}
l.XmlJSON.prototype.insertPublisherAndPlace = function (e) {
  if (e.name === 'group') {
    for (
      var t = !0, r = ['publisher', 'publisher-place'], i = 0, n = e.children.length;
      i < n;
      i += 1
    ) {
      var s = r.indexOf(e.children[i].attrs.variable),
        a = e.children[i].name === 'text'
      if (a && s > -1 && !e.children[i].attrs.prefix && !e.children[i].attrs.suffix)
        r = r.slice(0, s).concat(r.slice(s + 1))
      else {
        t = !1
        break
      }
    }
    t && !r.length && (e.attrs['has-publisher-and-publisher-place'] = !0)
  }
  for (var i = 0, n = e.children.length; i < n; i += 1)
    typeof e.children[i] == 'object' && this.insertPublisherAndPlace(e.children[i])
}
l.XmlJSON.prototype.isChildOfSubstitute = function (e) {
  if (e.length > 0) {
    var t = e.slice(),
      r = t.pop()
    return r === 'substitute' ? !0 : this.isChildOfSubstitute(t)
  }
  return !1
}
l.XmlJSON.prototype.addMissingNameNodes = function (e, t) {
  if ((t || (t = []), e.name === 'names' && !this.isChildOfSubstitute(t))) {
    for (var r = !0, i = 0, n = e.children.length; i < n; i++)
      if (e.children[i].name === 'name') {
        r = !1
        break
      }
    r && (e.children = [{ name: 'name', attrs: {}, children: [] }].concat(e.children))
  }
  t.push(e.name)
  for (var i = 0, n = e.children.length; i < n; i += 1)
    typeof e.children[i] == 'object' && this.addMissingNameNodes(e.children[i], t)
  t.pop()
}
l.XmlJSON.prototype.addInstitutionNodes = function (e) {
  var t
  if (e.name === 'names') {
    for (var r = {}, i = -1, n = 0, s = e.children.length; n < s; n += 1) {
      if (e.children[n].name == 'name') {
        for (var a in e.children[n].attrs) r[a] = e.children[n].attrs[a]
        ;(r.delimiter = e.children[n].attrs.delimiter), (r.and = e.children[n].attrs.and), (i = n)
        for (var o = 0, u = e.children[n].children.length; o < u; o += 1)
          if (e.children[n].children[o].attrs.name === 'family')
            for (var a in e.children[n].children[o].attrs) r[a] = e.children[n].children[o].attrs[a]
      }
      if (e.children[n].name == 'institution') {
        i = -1
        break
      }
    }
    if (i > -1) {
      for (
        var t = this.nodeCopy(this.institution), n = 0, s = l.INSTITUTION_KEYS.length;
        n < s;
        n += 1
      ) {
        var c = l.INSTITUTION_KEYS[n]
        typeof r[c] < 'u' && (t.children[0].attrs[c] = r[c]),
          r.delimiter && (t.attrs.delimiter = r.delimiter),
          r.and && (t.attrs.and = r.and)
      }
      e.children = e.children
        .slice(0, i + 1)
        .concat([t])
        .concat(e.children.slice(i + 1))
    }
  }
  for (var n = 0, s = e.children.length; n < s; n += 1)
    typeof e.children[n] != 'string' && this.addInstitutionNodes(e.children[n])
}
l.XmlJSON.prototype.flagDateMacros = function (e) {
  for (var t = 0, r = e.children.length; t < r; t += 1)
    e.children[t].name === 'macro' &&
      this.inspectDateMacros(e.children[t]) &&
      (e.children[t].attrs['macro-has-date'] = 'true')
}
l.XmlJSON.prototype.inspectDateMacros = function (e) {
  if (!e || !e.children) return !1
  if (e.name === 'date') return !0
  for (var t = 0, r = e.children.length; t < r; t += 1)
    if (this.inspectDateMacros(e.children[t])) return !0
  return !1
}
l.stripXmlProcessingInstruction = function (e) {
  return (
    e &&
    ((e = e.replace(/^<\?[^?]+\?>/, '')),
    (e = e.replace(/<!--[^>]+-->/g, '')),
    (e = e.replace(/^\s+/g, '')),
    (e = e.replace(/\s+$/g, '')),
    e)
  )
}
l.parseXml = function (e) {
  var t = { children: [] },
    r = [t.children]
  function i(g) {
    g = g
      .split(/(?:\r\n|\n|\r)/)
      .join(' ')
      .replace(/>[	 ]+</g, '><')
      .replace(/<\!--.*?-->/g, '')
    for (var _ = g.split('><'), y = null, x = 0, D = _.length; x < D; x++)
      x > 0 && (_[x] = '<' + _[x]),
        x < _.length - 1 && (_[x] = _[x] + '>'),
        typeof y != 'number' &&
          (_[x].slice(0, 7) === '<style ' || _[x].slice(0, 8) == '<locale ') &&
          (y = x)
    _ = _.slice(y)
    for (var x = _.length - 2; x > -1; x--)
      if (_[x].slice(1).indexOf('<') === -1) {
        var C = _[x].slice(0, 5)
        _[x].slice(-2) !== '/>' &&
          (C === '<term'
            ? _[x + 1].slice(0, 6) === '</term' &&
              ((_[x] = _[x] + _[x + 1]), (_ = _.slice(0, x + 1).concat(_.slice(x + 2))))
            : ['<sing', '<mult'].indexOf(C) > -1 &&
              _[x].slice(-2) !== '/>' &&
              _[x + 1].slice(0, 1) === '<' &&
              ((_[x] = _[x] + _[x + 1]), (_ = _.slice(0, x + 1).concat(_.slice(x + 2)))))
      }
    return _
  }
  function n(g) {
    return g
      .split('&amp;')
      .join('&')
      .split('&quot;')
      .join('"')
      .split('&gt;')
      .join('>')
      .split('&lt;')
      .join('<')
      .replace(/&#([0-9]{1,6});/gi, function (_, y) {
        var x = parseInt(y, 10)
        return String.fromCharCode(x)
      })
      .replace(/&#x([a-f0-9]{1,6});/gi, function (_, y) {
        var x = parseInt(y, 16)
        return String.fromCharCode(x)
      })
  }
  function s(g) {
    var _ = g.match(/([^\'\"=	 ]+)=(?:\"[^\"]*\"|\'[^\']*\')/g)
    if (_) for (var y = 0, x = _.length; y < x; y++) _[y] = _[y].replace(/=.*/, '')
    return _
  }
  function a(g, _) {
    var y = RegExp('^.*[	 ]+' + _ + `=("(?:[^"]*)"|'(?:[^']*)').*$`),
      x = g.match(y)
    return x ? x[1].slice(1, -1) : null
  }
  function o(g) {
    var _ = RegExp('^<([^	 />]+)'),
      y = g.match(_)
    return y ? y[1] : null
  }
  function u(g) {
    var _ = {}
    ;(_.name = o(g)), (_.attrs = {})
    var y = s(g)
    if (y)
      for (var x = 0, D = y.length; x < D; x++) {
        var C = { name: y[x], value: a(g, y[x]) }
        _.attrs[C.name] = n(C.value)
      }
    return (_.children = []), _
  }
  function c(g) {
    var _ = g.match(/^.*>([^<]*)<.*$/)
    return n(_[1])
  }
  function f(g) {
    r.slice(-1)[0].push(g)
  }
  function h(g) {
    r.push(g.children)
  }
  function p(g) {
    var _
    if (g.slice(1).indexOf('<') > -1) {
      var y = g.slice(0, g.indexOf('>') + 1)
      ;(_ = u(y)), (_.children = [c(g)]), f(_)
    } else
      g.slice(-2) === '/>'
        ? ((_ = u(g)), o(g) === 'term' && _.children.push(''), f(_))
        : g.slice(0, 2) === '</'
        ? r.pop()
        : ((_ = u(g)), f(_), h(_))
  }
  for (var m = i(e), v = 0, b = m.length; v < b; v++) {
    var S = m[v]
    p(S)
  }
  return t.children[0]
}
l.XmlDOM = function (e) {
  ;(this.dataObj = e),
    typeof DOMParser > 'u'
      ? ((DOMParser = function () {}),
        (DOMParser.prototype.parseFromString = function (s, a) {
          if (typeof ActiveXObject < 'u') {
            var o = new ActiveXObject('MSXML.DomDocument')
            return (o.async = !1), o.loadXML(s), o
          } else if (typeof XMLHttpRequest < 'u') {
            var o = new XMLHttpRequest()
            return (
              a || (a = 'text/xml'),
              o.open('GET', 'data:' + a + ';charset=utf-8,' + encodeURIComponent(s), !1),
              o.overrideMimeType && o.overrideMimeType(a),
              o.send(null),
              o.responseXML
            )
          } else if (typeof marknote < 'u') {
            var u = new marknote.Parser()
            return u.parse(s)
          }
        }),
        (this.hasAttributes = function (s) {
          var a
          return s.attributes && s.attributes.length ? (a = !0) : (a = !1), a
        }))
      : (this.hasAttributes = function (s) {
          var a
          return s.attributes && s.attributes.length ? (a = !0) : (a = !1), a
        }),
    (this.importNode = function (s, a) {
      var o
      return (
        typeof s.importNode > 'u' ? (o = this._importNode(s, a, !0)) : (o = s.importNode(a, !0)), o
      )
    }),
    (this._importNode = function (s, a, o) {
      switch (a.nodeType) {
        case 1:
          var u = s.createElement(a.nodeName)
          if (a.attributes && a.attributes.length > 0)
            for (var c = 0, f = a.attributes.length; c < f; )
              u.setAttribute(a.attributes[c].nodeName, a.getAttribute(a.attributes[c++].nodeName))
          if (o && a.childNodes && a.childNodes.length > 0)
            for (var c = 0, f = a.childNodes.length; c < f; )
              u.appendChild(this._importNode(s, a.childNodes[c++], o))
          return u
      }
    }),
    (this.parser = new DOMParser())
  var t =
      '<docco><institution institution-parts="long" delimiter=", " substitute-use-first="1" use-last="1"><institution-part name="long"/></institution></docco>',
    r = this.parser.parseFromString(t, 'text/xml'),
    i = r.getElementsByTagName('institution')
  this.institution = i.item(0)
  var n = r.getElementsByTagName('institution-part')
  ;(this.institutionpart = n.item(0)), (this.ns = 'http://purl.org/net/xbiblio/csl')
}
l.XmlDOM.prototype.clean = function (e) {
  return (
    (e = e.replace(/<\?[^?]+\?>/g, '')),
    (e = e.replace(/<![^>]+>/g, '')),
    (e = e.replace(/^\s+/, '')),
    (e = e.replace(/\s+$/, '')),
    (e = e.replace(/^\n*/, '')),
    e
  )
}
l.XmlDOM.prototype.getStyleId = function (e, t) {
  var r = '',
    i = 'id'
  t && (i = 'title')
  var n = e.getElementsByTagName(i)
  return (
    n && n.length && (n = n.item(0)),
    n && (r = n.textContent),
    r || (r = n.innerText),
    r || (r = n.innerHTML),
    r
  )
}
l.XmlDOM.prototype.children = function (e) {
  var t, r, i, n
  if (e) {
    for (n = [], t = e.childNodes, r = 0, i = t.length; r < i; r += 1)
      t[r].nodeName != '#text' && n.push(t[r])
    return n
  } else return []
}
l.XmlDOM.prototype.nodename = function (e) {
  var t = e.nodeName
  return t
}
l.XmlDOM.prototype.attributes = function (e) {
  var t, r, i, n, s
  if (((t = new Object()), e && this.hasAttributes(e)))
    for (r = e.attributes, n = 0, s = r.length; n < s; n += 1)
      (i = r[n]), (t['@' + i.name] = i.value)
  return t
}
l.XmlDOM.prototype.content = function (e) {
  var t
  return (
    typeof e.textContent < 'u'
      ? (t = e.textContent)
      : typeof e.innerText < 'u'
      ? (t = e.innerText)
      : (t = e.txt),
    t
  )
}
l.XmlDOM.prototype.namespace = { xml: 'http://www.w3.org/XML/1998/namespace' }
l.XmlDOM.prototype.numberofnodes = function (e) {
  return e ? e.length : 0
}
l.XmlDOM.prototype.getAttributeName = function (e) {
  var t = e.name
  return t
}
l.XmlDOM.prototype.getAttributeValue = function (e, t, r) {
  var i = ''
  return (
    r && (t = r + ':' + t),
    e && this.hasAttributes(e) && e.getAttribute(t) && (i = e.getAttribute(t)),
    i
  )
}
l.XmlDOM.prototype.getNodeValue = function (e, t) {
  var r = null
  if (t) {
    var i = e.getElementsByTagName(t)
    i.length > 0 &&
      (typeof i[0].textContent < 'u'
        ? (r = i[0].textContent)
        : typeof i[0].innerText < 'u'
        ? (r = i[0].innerText)
        : (r = i[0].text))
  }
  return (
    r === null &&
      e &&
      e.childNodes &&
      (e.childNodes.length == 0 ||
        (e.childNodes.length == 1 && e.firstChild.nodeName == '#text')) &&
      (typeof e.textContent < 'u'
        ? (r = e.textContent)
        : typeof e.innerText < 'u'
        ? (r = e.innerText)
        : (r = e.text)),
    r === null && (r = e),
    r
  )
}
l.XmlDOM.prototype.setAttributeOnNodeIdentifiedByNameAttribute = function (e, t, r, i, n) {
  var s, a, o, u
  for (
    i.slice(0, 1) === '@' && (i = i.slice(1)), o = e.getElementsByTagName(t), s = 0, a = o.length;
    s < a;
    s += 1
  )
    (u = o[s]), u.getAttribute('name') == r && u.setAttribute(i, n)
}
l.XmlDOM.prototype.deleteNodeByNameAttribute = function (e, t) {
  var r, i, n, s
  for (s = e.childNodes, r = 0, i = s.length; r < i; r += 1)
    (n = s[r]),
      !(!n || n.nodeType == n.TEXT_NODE) &&
        this.hasAttributes(n) &&
        n.getAttribute('name') == t &&
        e.removeChild(s[r])
}
l.XmlDOM.prototype.deleteAttribute = function (e, t) {
  e.removeAttribute(t)
}
l.XmlDOM.prototype.setAttribute = function (e, t, r) {
  return (
    e.ownerDocument || (e = e.firstChild),
    ['function', 'unknown'].indexOf(typeof e.setAttribute) > -1 && e.setAttribute(t, r),
    !1
  )
}
l.XmlDOM.prototype.nodeCopy = function (e) {
  var t = e.cloneNode(!0)
  return t
}
l.XmlDOM.prototype.getNodesByName = function (e, t, r) {
  var i, n, s, a, o
  for (i = [], n = e.getElementsByTagName(t), a = 0, o = n.length; a < o; a += 1)
    (s = n.item(a)), !(r && !(this.hasAttributes(s) && s.getAttribute('name') == r)) && i.push(s)
  return i
}
l.XmlDOM.prototype.nodeNameIs = function (e, t) {
  return t == e.nodeName
}
l.XmlDOM.prototype.makeXml = function (e) {
  e || (e = '<docco><bogus/></docco>'), (e = e.replace(/\s*<\?[^>]*\?>\s*\n*/g, ''))
  var t = this.parser.parseFromString(e, 'application/xml')
  return t.firstChild
}
l.XmlDOM.prototype.insertChildNodeAfter = function (e, t, r, i) {
  var n
  return (n = this.importNode(t.ownerDocument, i)), e.replaceChild(n, t), e
}
l.XmlDOM.prototype.insertPublisherAndPlace = function (e) {
  for (var t = e.getElementsByTagName('group'), r = 0, i = t.length; r < i; r += 1) {
    for (var n = t.item(r), s = [], a = 0, o = n.childNodes.length; a < o; a += 1)
      n.childNodes.item(a).nodeType !== 1 && s.push(a)
    if (n.childNodes.length - s.length === 2) {
      for (var u = [], a = 0, o = 2; a < o; a += 1)
        if (!(s.indexOf(a) > -1)) {
          for (var c = n.childNodes.item(a), f = [], h = 0, p = c.childNodes.length; h < p; h += 1)
            c.childNodes.item(h).nodeType !== 1 && f.push(h)
          if (
            c.childNodes.length - f.length === 0 &&
            (u.push(c.getAttribute('variable')),
            c.getAttribute('suffix') || c.getAttribute('prefix'))
          ) {
            u = []
            break
          }
        }
      u.indexOf('publisher') > -1 &&
        u.indexOf('publisher-place') > -1 &&
        n.setAttribute('has-publisher-and-publisher-place', !0)
    }
  }
}
l.XmlDOM.prototype.isChildOfSubstitute = function (e) {
  return e.parentNode
    ? e.parentNode.tagName.toLowerCase() === 'substitute'
      ? !0
      : this.isChildOfSubstitute(e.parentNode)
    : !1
}
l.XmlDOM.prototype.addMissingNameNodes = function (e) {
  for (var t = e.getElementsByTagName('names'), r = 0, i = t.length; r < i; r += 1) {
    var n = t.item(r),
      s = n.getElementsByTagName('name')
    if ((!s || s.length === 0) && !this.isChildOfSubstitute(n)) {
      var a = n.ownerDocument,
        o = a.createElement('name')
      n.appendChild(o)
    }
  }
}
l.XmlDOM.prototype.addInstitutionNodes = function (e) {
  var t, r, i, n, s, a, o, u, c
  for (t = e.getElementsByTagName('names'), u = 0, c = t.length; u < c; u += 1)
    if (
      ((r = t.item(u)),
      (a = r.getElementsByTagName('name')),
      a.length != 0 && ((i = r.getElementsByTagName('institution')), i.length == 0))
    ) {
      ;(n = this.importNode(e.ownerDocument, this.institution)),
        (s = n.getElementsByTagName('institution-part').item(0)),
        (o = a.item(0)),
        r.insertBefore(n, o.nextSibling)
      for (var f = 0, h = l.INSTITUTION_KEYS.length; f < h; f += 1) {
        var p = l.INSTITUTION_KEYS[f],
          m = o.getAttribute(p)
        m && s.setAttribute(p, m)
      }
      for (var v = o.getElementsByTagName('name-part'), f = 0, h = v.length; f < h; f += 1)
        if (v[f].getAttribute('name') === 'family')
          for (var b = 0, S = l.INSTITUTION_KEYS.length; b < S; b += 1) {
            var p = l.INSTITUTION_KEYS[b],
              m = v[f].getAttribute(p)
            m && s.setAttribute(p, m)
          }
    }
}
l.XmlDOM.prototype.flagDateMacros = function (e) {
  var t,
    r,
    i,
    n,
    s = e.getElementsByTagName('macro')
  for (t = 0, r = s.length; t < r; t += 1)
    (i = s.item(t)),
      (n = i.getElementsByTagName('date')),
      n.length && i.setAttribute('macro-has-date', 'true')
}
l.setupXml = function (e) {
  var t = {},
    r = null
  return (
    typeof e < 'u'
      ? typeof e == 'string'
        ? ((e = e.replace('^\uFEFF', '').replace(/^\s+/, '')),
          e.slice(0, 1) === '<' ? (t = l.parseXml(e)) : (t = JSON.parse(e)),
          (r = new l.XmlJSON(t)))
        : typeof e.getAttribute < 'u'
        ? (r = new l.XmlDOM(e))
        : typeof e.toXMLString < 'u'
        ? (r = new l.XmlE4X(e))
        : (r = new l.XmlJSON(e))
      : l.error('unable to parse XML input'),
    r || l.error('citeproc-js error: unable to parse CSL style or locale object'),
    r
  )
}
l.getSortCompare = function (e) {
  if (l.stringCompare) return l.stringCompare
  var t = this,
    r,
    i = { sensitivity: 'base', ignorePunctuation: !0, numeric: !0 }
  e || (e = 'en-US'),
    (r = function (u, c) {
      return l.toLocaleLowerCase.call(t, u).localeCompare(l.toLocaleLowerCase.call(t, c), e, i)
    })
  var n = function (u) {
      return u.replace(/^[\[\]\'\"]*/g, '')
    },
    s = function () {
      return r('[x', 'x')
        ? function (u, c) {
            return r(n(u), n(c))
          }
        : !1
    },
    a = s(),
    o = function (u, c) {
      return a ? a(u, c) : r(u, c)
    }
  return o
}
l.ambigConfigDiff = function (e, t) {
  var r, i, n, s
  if (e.names.length !== t.names.length) return 1
  for (r = 0, i = e.names.length; r < i; r += 1) {
    if (e.names[r] !== t.names[r]) return 1
    for (n = 0, s = e.givens[r]; n < s; n += 1) if (e.givens[r][n] !== t.givens[r][n]) return 1
  }
  return e.disambiguate != t.disambiguate || e.year_suffix !== t.year_suffix ? 1 : 0
}
l.cloneAmbigConfig = function (e, t) {
  var r,
    i,
    n,
    s,
    a,
    o = {}
  for (
    o.names = [], o.givens = [], o.year_suffix = !1, o.disambiguate = !1, r = 0, i = e.names.length;
    r < i;
    r += 1
  )
    (a = e.names[r]), (o.names[r] = a)
  for (r = 0, i = e.givens.length; r < i; r += 1) {
    for (a = [], n = 0, s = e.givens[r].length; n < s; n += 1) a.push(e.givens[r][n])
    o.givens.push(a)
  }
  return (
    t
      ? ((o.year_suffix = t.year_suffix), (o.disambiguate = t.disambiguate))
      : ((o.year_suffix = e.year_suffix), (o.disambiguate = e.disambiguate)),
    o
  )
}
l.getAmbigConfig = function () {
  var e, t
  ;(e = this.tmp.disambig_request), e || (e = this.tmp.disambig_settings)
  var t = l.cloneAmbigConfig(e)
  return t
}
l.getMaxVals = function () {
  return this.tmp.names_max.mystack.slice()
}
l.getMinVal = function () {
  return this.tmp['et-al-min']
}
l.tokenExec = function (e, t, r) {
  var i, n, s, a
  ;(a = !1), (i = e.next), (n = !1)
  var o = function (f) {
    return f
      ? (this.tmp.jump.replace('succeed'), e.succeed)
      : (this.tmp.jump.replace('fail'), e.fail)
  }
  e.test && (i = o.call(this, e.test(t, r)))
  for (var u = 0, c = e.execs.length; u < c; u++)
    (s = e.execs[u]), (n = s.call(e, this, t, r)), n && (i = n)
  return a && l.debug(e.name + ' (' + e.tokentype + ') ---> done'), i
}
l.expandMacro = function (e, t) {
  var r, i, n, s
  r = e.postponed_macro
  var a = e.strings.sort_direction
  e = new l.Token('group', l.START)
  var o = !1,
    u = !1
  ;(i = this.cslXml.getNodesByName(this.cslXml.dataObj, 'macro', r)),
    i.length &&
      ((u = this.cslXml.getAttributeValue(i[0], 'cslid')),
      (o = this.cslXml.getAttributeValue(i[0], 'macro-has-date'))),
    o &&
      ((r = r + '@' + this.build.current_default_locale),
      (s = function (h) {
        h.tmp.extension && (h.tmp['doing-macro-with-date'] = !0)
      }),
      e.execs.push(s)),
    this.build.macro_stack.indexOf(r) > -1
      ? l.error('CSL processor error: call to macro "' + r + '" would cause an infinite loop')
      : this.build.macro_stack.push(r),
    (e.cslid = u),
    l.MODULE_MACROS[r] && ((e.juris = r), (this.opt.update_mode = l.POSITION)),
    l.Node.group.build.call(e, this, t, !0),
    this.cslXml.getNodeValue(i) || l.error('CSL style error: undefined macro "' + r + '"')
  var c = l.getMacroTarget.call(this, r)
  if (
    (c && (l.buildMacro.call(this, c, i), l.configureMacro.call(this, c)), !this.build.extension)
  ) {
    var s = (function (p) {
        return function (m, v, b) {
          for (var S = 0; S < m.macros[p].length; ) S = l.tokenExec.call(m, m.macros[p][S], v, b)
        }
      })(r),
      f = new l.Token('text', l.SINGLETON)
    f.execs.push(s), t.push(f)
  }
  ;(n = new l.Token('group', l.END)),
    (n.strings.sort_direction = a),
    o &&
      ((s = function (h) {
        h.tmp.extension && (h.tmp['doing-macro-with-date'] = !1)
      }),
      n.execs.push(s)),
    e.juris && (n.juris = r),
    l.Node.group.build.call(n, this, t, !0),
    this.build.macro_stack.pop()
}
l.getMacroTarget = function (e) {
  var t = !1
  return (
    this.build.extension
      ? (t = this[this.build.root + this.build.extension].tokens)
      : this.macros[e] || ((t = []), (this.macros[e] = t)),
    t
  )
}
l.buildMacro = function (e, t) {
  var r = l.makeBuilder(this, e),
    i
  typeof t.length > 'u' ? (i = t) : (i = t[0]), r(i)
}
l.configureMacro = function (e) {
  this.build.extension || this.configureTokenList(e)
}
l.XmlToToken = function (e, t, r, i) {
  var n, s, a, o, u, c, f
  if (((n = e.cslXml.nodename(this)), !(e.build.skip && e.build.skip !== n))) {
    if (!n) {
      ;(s = e.cslXml.content(this)), s && (e.build.text = s)
      return
    }
    if (
      (l.Node[e.cslXml.nodename(this)] || l.error('Undefined node name "' + n + '".'),
      (a = e.cslXml.attributes(this)),
      (o = l.setDecorations.call(this, e, a)),
      (u = new l.Token(n, t)),
      t !== l.END || n === 'if' || n === 'else-if' || n === 'layout')
    ) {
      for (var c in a)
        if (a.hasOwnProperty(c)) {
          if (t === l.END && c !== '@language' && c !== '@locale') continue
          if (a.hasOwnProperty(c))
            if (l.Attributes[c])
              try {
                l.Attributes[c].call(u, e, '' + a[c])
              } catch (p) {
                l.error(c + ' attribute: ' + p)
              }
            else l.debug('warning: undefined attribute "' + c + '" in style')
        }
      ;(u.decorations = o), l.DATE_VARIABLES.indexOf(a['@variable']) > -1 && i.push(u.variables)
    } else
      t === l.END &&
        a['@variable'] &&
        ((u.hasVariable = !0),
        l.DATE_VARIABLES.indexOf(a['@variable']) > -1 && (u.variables = i.pop()))
    r ? (f = r) : (f = e[e.build.area].tokens), l.Node[n].build.call(u, e, f, !0)
  }
}
l.DateParser = function () {
  for (
    var e = [
        ['', 1867],
        ['', 1911],
        ['', 1925],
        ['', 1988],
      ],
      t = 0,
      r = e.length;
    t < r;
    t++
  ) {
    e[t][0]
    var i = e[t][1]
  }
  for (var n = [], s = {}, t = 0, r = e.length; t < r; t++) {
    var a = e[t],
      i = a[0]
    n.push(i), (s[a[0]] = a[1])
  }
  var o = n.join('|'),
    u = new RegExp('(?:' + o + ')(?:[0-9]+)'),
    c = new RegExp('(?:' + o + ')(?:[0-9]+)', 'g'),
    f = /(\u6708|\u5E74)/g,
    h = /\u65E5/g,
    p = /\u301c/g,
    m = '(?:[?0-9]{1,2}%%NUMD%%){0,2}[?0-9]{4}(?![0-9])',
    v = '[?0-9]{4}(?:%%NUMD%%[?0-9]{1,2}){0,2}(?![0-9])',
    b = '[?0-9]{1,3}',
    S = '[%%DATED%%]',
    g = '[?~]',
    _ = '[^-/~?0-9]+',
    y = '(' + v + '|' + m + '|' + b + '|' + S + '|' + g + '|' + _ + ')',
    x = new RegExp(y.replace(/%%NUMD%%/g, '-').replace(/%%DATED%%/g, '-')),
    D = new RegExp(y.replace(/%%NUMD%%/g, '-').replace(/%%DATED%%/g, '/')),
    C = new RegExp(y.replace(/%%NUMD%%/g, '/').replace(/%%DATED%%/g, '-')),
    H =
      'january february march april may june july august september october november december spring summer fall winter spring summer'
  ;(this.monthStrings = H.split(' ')),
    (this.setOrderDayMonth = function () {
      ;(this.monthGuess = 1), (this.dayGuess = 0)
    }),
    (this.setOrderMonthDay = function () {
      ;(this.monthGuess = 0), (this.dayGuess = 1)
    }),
    (this.resetDateParserMonths = function () {
      this.monthSets = []
      for (var T = 0, k = this.monthStrings.length; T < k; T++)
        this.monthSets.push([this.monthStrings[T]])
      this.monthAbbrevs = []
      for (var T = 0, k = this.monthSets.length; T < k; T++) {
        this.monthAbbrevs.push([])
        for (var O = 0, N = this.monthSets[T].length; O < N; O++)
          this.monthAbbrevs[T].push(this.monthSets[T][0].slice(0, 3))
      }
      this.monthRexes = []
      for (var T = 0, k = this.monthAbbrevs.length; T < k; T++)
        this.monthRexes.push(new RegExp('(?:' + this.monthAbbrevs[T].join('|') + ')'))
    }),
    (this.addDateParserMonths = function (T) {
      if ((typeof T == 'string' && (T = T.split(/\s+/)), T.length !== 12 && T.length !== 16)) {
        l.debug('month [+season] list of ' + T.length + ', expected 12 or 16. Ignoring.')
        return
      }
      for (var k = 0, O = T.length; k < O; k++) {
        for (var N = null, M = !1, V = 3, j = {}, R = 0, $ = this.monthAbbrevs.length; R < $; R++) {
          if (((j[R] = {}), R === k)) {
            for (var L = 0, P = this.monthAbbrevs[k].length; L < P; L++)
              if (this.monthAbbrevs[k][L] === T[k].slice(0, this.monthAbbrevs[k][L].length)) {
                M = !0
                break
              }
          } else
            for (var L = 0, P = this.monthAbbrevs[R].length; L < P; L++)
              if (
                ((N = this.monthAbbrevs[R][L].length), this.monthAbbrevs[R][L] === T[k].slice(0, N))
              ) {
                for (; this.monthSets[R][L].slice(0, N) === T[k].slice(0, N); )
                  if (N > T[k].length || N > this.monthSets[R][L].length) {
                    l.debug('unable to disambiguate month string in date parser: ' + T[k])
                    break
                  } else N += 1
                ;(V = N), (j[R][L] = N)
              }
          for (var Y in j)
            for (var w in j[Y])
              (N = j[Y][w]),
                (Y = parseInt(Y, 10)),
                (w = parseInt(w, 10)),
                (this.monthAbbrevs[Y][w] = this.monthSets[Y][w].slice(0, N))
        }
        M || (this.monthSets[k].push(T[k]), this.monthAbbrevs[k].push(T[k].slice(0, V)))
      }
      ;(this.monthRexes = []), (this.monthRexStrs = [])
      for (var k = 0, O = this.monthAbbrevs.length; k < O; k++)
        this.monthRexes.push(new RegExp('^(?:' + this.monthAbbrevs[k].join('|') + ')')),
          this.monthRexStrs.push('^(?:' + this.monthAbbrevs[k].join('|') + ')')
      if (this.monthAbbrevs.length === 18)
        for (var k = 12, O = 14; k < O; k++)
          (this.monthRexes[k + 4] = new RegExp('^(?:' + this.monthAbbrevs[k].join('|') + ')')),
            (this.monthRexStrs[k + 4] = '^(?:' + this.monthAbbrevs[k].join('|') + ')')
    }),
    (this.convertDateObjectToArray = function (T) {
      ;(T['date-parts'] = []), T['date-parts'].push([])
      for (var k = 0, O, N = 0, M = 3; N < M && ((O = ['year', 'month', 'day'][N]), !!T[O]); N++)
        (k += 1), T['date-parts'][0].push(T[O]), delete T[O]
      T['date-parts'].push([])
      for (var N = 0, M = k; N < M && ((O = ['year_end', 'month_end', 'day_end'][N]), !!T[O]); N++)
        T['date-parts'][1].push(T[O]), delete T[O]
      return T['date-parts'][0].length !== T['date-parts'][1].length && T['date-parts'].pop(), T
    }),
    (this.convertDateObjectToString = function (T) {
      for (var k = [], O = 0, N = 3; O < N && T[l.DATE_PARTS_ALL[O]]; O += 1)
        k.push(T[l.DATE_PARTS_ALL[O]])
      return k.join('-')
    }),
    (this._parseNumericDate = function (T, k, O, N) {
      O || (O = '')
      for (var M = N.split(k), V = 0, j = M.length; V < j; V++)
        if (M[V].length === 4) {
          ;(T['year' + O] = M[V].replace(/^0*/, '')), V ? (M = M.slice(0, V)) : (M = M.slice(1))
          break
        }
      for (var V = 0, j = M.length; V < j; V++) M[V] = parseInt(M[V], 10)
      if (M.length === 1 || (M.length === 2 && !M[1])) {
        var R = M[0]
        R && (T['month' + O] = '' + M[0])
      } else if (M.length === 2)
        if (M[this.monthGuess] > 12) {
          var R = M[this.dayGuess],
            $ = M[this.monthGuess]
          R && ((T['month' + O] = '' + R), $ && (T['day' + O] = '' + $))
        } else {
          var R = M[this.monthGuess],
            $ = M[this.dayGuess]
          R && ((T['month' + O] = '' + R), $ && (T['day' + O] = '' + $))
        }
    }),
    (this.parseDateToObject = function (T) {
      var k = T,
        O = -1,
        N = -1,
        M = !1,
        V
      if (T) {
        if (
          ((T = T.replace(/^(.*[0-9])T[0-9].*/, '$1')),
          T.slice(0, 1) === '-' && ((M = !0), (T = T.slice(1))),
          T.match(/^[0-9]{1,3}$/))
        )
          for (; T.length < 4; ) T = '0' + T
        ;(T = '' + T), (T = T.replace(/\s*[0-9]{2}:[0-9]{2}(?::[0-9]+)/, ''))
        var j = T.match(f)
        if (j) {
          ;(T = T.replace(/\s+/g, '')),
            (T = T.replace(h, '')),
            (T = T.replace(f, '-')),
            (T = T.replace(p, '/')),
            (T = T.replace(/\-\//g, '/')),
            (T = T.replace(/-$/g, ''))
          var R = T.split(u)
          V = []
          var $ = T.match(c)
          if ($) {
            for (var L = [], P = 0, Y = $.length; P < Y; P++)
              L = L.concat($[P].match(/([^0-9]+)([0-9]+)/).slice(1))
            for (var P = 0, Y = R.length; P < Y; P++)
              if ((V.push(R[P]), P !== Y - 1)) {
                var w = P * 2
                V.push(L[w]), V.push(L[w + 1])
              }
          } else V = R
          for (var P = 1, Y = V.length; P < Y; P += 3)
            (V[P + 1] = s[V[P]] + parseInt(V[P + 1], 10)), (V[P] = '')
          ;(T = V.join('')),
            (T = T.replace(/\s*-\s*$/, '').replace(/\s*-\s*\//, '/')),
            (T = T.replace(/\.\s*$/, '')),
            (T = T.replace(/\.(?! )/, '')),
            (O = T.indexOf('/')),
            (N = T.indexOf('-'))
        }
      }
      T = T.replace(/([A-Za-z])\./g, '$1')
      var q = '',
        X = '',
        I = {},
        re,
        ie
      if (T.slice(0, 1) === '"' && T.slice(-1) === '"') return (I.literal = T.slice(1, -1)), I
      if (O > -1 && N > -1) {
        var Z = T.split('/')
        Z.length > 3
          ? ((re = '-'), (T = T.replace(/\_/g, '-')), (ie = '/'), (V = T.split(C)))
          : ((re = '/'), (T = T.replace(/\_/g, '/')), (ie = '-'), (V = T.split(D)))
      } else
        (T = T.replace(/\//g, '-')),
          (T = T.replace(/\_/g, '-')),
          (re = '-'),
          (ie = '-'),
          (V = T.split(x))
      for (var oe = [], P = 0, Y = V.length; P < Y; P++) {
        var j = V[P].match(/^\s*([\-\/]|[^\-\/\~\?0-9]+|[\-~?0-9]+)\s*$/)
        j && oe.push(j[1])
      }
      var ce = oe.indexOf(re),
        fe = [],
        ge = !1
      ce > -1
        ? (fe.push([0, ce]), fe.push([ce + 1, oe.length]), (ge = !0))
        : fe.push([0, oe.length])
      for (var me = '', P = 0, Y = fe.length; P < Y; P++) {
        var be = fe[P],
          Ne = oe.slice(be[0], be[1])
        e: for (var Oe = 0, _e = Ne.length; Oe < _e; Oe++) {
          var F = Ne[Oe]
          if (F.indexOf(ie) > -1) {
            this._parseNumericDate(I, ie, me, F)
            continue
          }
          if (F.match(/[0-9]{4}/)) {
            I['year' + me] = F.replace(/^0*/, '')
            continue
          }
          ;(F === '~' || F === '?' || F === 'c' || F.match(/^cir/)) && (I.circa = !0)
          for (var E = 0, A = this.monthRexes.length; E < A; E++)
            if (F.toLocaleLowerCase().match(this.monthRexes[E])) {
              I['month' + me] = '' + (parseInt(E, 10) + 1)
              continue e
            }
          if ((F.match(/^[0-9]+$/) && (q = F), F.toLocaleLowerCase().match(/^bc/) && q)) {
            ;(I['year' + me] = '' + q * -1), (q = '')
            continue
          }
          if (F.toLocaleLowerCase().match(/^ad/) && q) {
            ;(I['year' + me] = '' + q), (q = '')
            continue
          }
          if (F.toLocaleLowerCase().match(/(?:mic|tri|hil|eas)/) && !I['season' + me]) {
            X = F
            continue
          }
        }
        q && ((I['day' + me] = q), (q = '')),
          X && !I['season' + me] && ((I['season' + me] = X.trim()), (X = '')),
          (me = '_end')
      }
      if (ge)
        for (var Oe = 0, _e = l.DATE_PARTS_ALL.length; Oe < _e; Oe++) {
          var z = l.DATE_PARTS_ALL[Oe]
          I[z] && !I[z + '_end']
            ? (I[z + '_end'] = I[z])
            : !I[z] && I[z + '_end'] && (I[z] = I[z + '_end'])
        }
      ;(!I.year || (I.year && I.day && !I.month)) && (I = { literal: k })
      for (
        var W = ['year', 'month', 'day', 'year_end', 'month_end', 'day_end'], P = 0, Y = W.length;
        P < Y;
        P++
      ) {
        var te = W[P]
        typeof I[te] == 'string' && I[te].match(/^[0-9]+$/) && (I[te] = parseInt(I[te], 10))
      }
      return M && Object.keys(I).indexOf('year') > -1 && (I.year = I.year * -1), I
    }),
    (this.parseDateToArray = function (T) {
      return this.convertDateObjectToArray(this.parseDateToObject(T))
    }),
    (this.parseDateToString = function (T) {
      return this.convertDateObjectToString(this.parseDateToObject(T))
    }),
    (this.parse = function (T) {
      return this.parseDateToObject(T)
    }),
    this.setOrderMonthDay(),
    this.resetDateParserMonths()
}
l.DateParser = new l.DateParser()
l.Engine = function (e, t, r, i) {
  var n, s
  ;(this.processor_version = l.PROCESSOR_VERSION),
    (this.csl_version = '1.0'),
    (this.sys = e),
    typeof Object.assign != 'function' &&
      Object.defineProperty(Object, 'assign', {
        value: function (h) {
          if (h == null) throw new TypeError('Cannot convert undefined or null to object')
          for (var p = Object(h), m = 1; m < arguments.length; m++) {
            var v = arguments[m]
            if (v != null)
              for (var b in v) Object.prototype.hasOwnProperty.call(v, b) && (p[b] = v[b])
          }
          return p
        },
        writable: !0,
        configurable: !0,
      }),
    e.variableWrapper &&
      (l.VARIABLE_WRAPPER_PREPUNCT_REX = new RegExp(
        '^([' + [' '].concat(l.SWAPPING_PUNCTUATION).join('') + ']*)(.*)'
      )),
    l.retrieveStyleModule && (this.sys.retrieveStyleModule = l.retrieveStyleModule),
    l.getAbbreviation && (this.sys.getAbbreviation = l.getAbbreviation),
    this.sys.stringCompare && (l.stringCompare = this.sys.stringCompare),
    (this.sys.AbbreviationSegments = l.AbbreviationSegments),
    (this.transform = new l.Transform(this)),
    (this.setParseNames = function (f) {
      this.opt['parse-names'] = f
    }),
    (this.opt = new l.Engine.Opt()),
    (this.tmp = new l.Engine.Tmp()),
    (this.build = new l.Engine.Build()),
    (this.fun = new l.Engine.Fun(this)),
    (this.configure = new l.Engine.Configure()),
    (this.citation_sort = new l.Engine.CitationSort()),
    (this.bibliography_sort = new l.Engine.BibliographySort()),
    (this.citation = new l.Engine.Citation(this)),
    (this.bibliography = new l.Engine.Bibliography()),
    (this.intext = new l.Engine.InText()),
    (this.output = new l.Output.Queue(this)),
    (this.dateput = new l.Output.Queue(this)),
    (this.cslXml = l.setupXml(t))
  for (var a in l.SYS_OPTIONS) {
    var o = l.SYS_OPTIONS[a]
    typeof this.sys[o] == 'boolean' && (this.opt.development_extensions[o] = this.sys[o])
  }
  ;(this.opt.development_extensions.uppercase_subtitles ||
    this.opt.development_extensions.implicit_short_title) &&
    (this.opt.development_extensions.main_title_from_short_title = !0),
    this.opt.development_extensions.csl_reverse_lookup_support &&
      ((this.build.cslNodeId = 0),
      (this.setCslNodeIds = function (f, h) {
        var p = this.cslXml.children(f)
        this.cslXml.setAttribute(f, 'cslid', this.build.cslNodeId),
          this.opt.nodenames.push(h),
          (this.build.cslNodeId += 1)
        for (var m = 0, v = this.cslXml.numberofnodes(p); m < v; m += 1)
          (h = this.cslXml.nodename(p[m])), h && this.setCslNodeIds(p[m], h)
      }),
      this.setCslNodeIds(this.cslXml.dataObj, 'style')),
    this.cslXml.addMissingNameNodes(this.cslXml.dataObj),
    this.cslXml.addInstitutionNodes(this.cslXml.dataObj),
    this.cslXml.insertPublisherAndPlace(this.cslXml.dataObj),
    this.cslXml.flagDateMacros(this.cslXml.dataObj),
    (n = this.cslXml.attributes(this.cslXml.dataObj)),
    typeof n['@sort-separator'] > 'u' &&
      this.cslXml.setAttribute(this.cslXml.dataObj, 'sort-separator', ', '),
    (this.opt['initialize-with-hyphen'] = !0),
    this.setStyleAttributes(),
    (this.opt.xclass = this.cslXml.getAttributeValue(this.cslXml.dataObj, 'class')),
    (this.opt.class = this.opt.xclass),
    (this.opt.styleID = this.cslXml.getStyleId(this.cslXml.dataObj)),
    (this.opt.styleName = this.cslXml.getStyleId(this.cslXml.dataObj, !0)),
    this.opt.version.slice(0, 4) === '1.1m' &&
      ((this.opt.development_extensions.consolidate_legal_items = !0),
      (this.opt.development_extensions.consolidate_container_items = !0),
      (this.opt.development_extensions.main_title_from_short_title = !0),
      (this.opt.development_extensions.expect_and_symbol_form = !0),
      (this.opt.development_extensions.require_explicit_legal_case_title_short = !0),
      (this.opt.development_extensions.force_jurisdiction = !0),
      (this.opt.development_extensions.force_title_abbrev_fallback = !0)),
    r && ((r = r.replace('_', '-')), (r = l.normalizeLocaleStr(r))),
    this.opt['default-locale'][0] &&
      ((this.opt['default-locale'][0] = this.opt['default-locale'][0].replace('_', '-')),
      (this.opt['default-locale'][0] = l.normalizeLocaleStr(this.opt['default-locale'][0]))),
    r && i && (this.opt['default-locale'] = [r]),
    r && !i && this.opt['default-locale'][0] && (r = this.opt['default-locale'][0]),
    this.opt['default-locale'].length === 0 &&
      (r || (r = 'en-US'), this.opt['default-locale'].push('en-US')),
    r || (r = this.opt['default-locale'][0]),
    (s = l.localeResolve(r)),
    (this.opt.lang = s.best),
    (this.opt['default-locale'][0] = s.best),
    (this.locale = {}),
    this.opt['default-locale-sort'] ||
      (this.opt['default-locale-sort'] = this.opt['default-locale'][0]),
    'dale|'.localeCompare('daleb', this.opt['default-locale-sort']) > -1
      ? (this.opt.sort_sep = '@')
      : (this.opt.sort_sep = '|'),
    this.localeConfigure(s)
  function u(h) {
    var h = h.slice(),
      p = new RegExp('(?:(?:[?!:]*\\s+|-|^)(?:' + h.join('|') + ')(?=[!?:]*\\s+|-|$))', 'g')
    return p
  }
  ;(this.locale[this.opt.lang].opts['skip-words-regexp'] = u(
    this.locale[this.opt.lang].opts['skip-words']
  )),
    (this.output.adjust = new l.Output.Queue.adjust(this.getOpt('punctuation-in-quote'))),
    (this.registry = new l.Registry(this)),
    (this.macros = {}),
    (this.build.area = 'citation')
  var c = this.cslXml.getNodesByName(this.cslXml.dataObj, this.build.area)
  this.buildTokenLists(c, this[this.build.area].tokens), (this.build.area = 'bibliography')
  var c = this.cslXml.getNodesByName(this.cslXml.dataObj, this.build.area)
  this.buildTokenLists(c, this[this.build.area].tokens), (this.build.area = 'intext')
  var c = this.cslXml.getNodesByName(this.cslXml.dataObj, this.build.area)
  this.buildTokenLists(c, this[this.build.area].tokens),
    this.opt.parallel.enable && (this.parallel = new l.Parallel(this)),
    (this.juris = {}),
    this.configureTokenLists(),
    (this.disambiguate = new l.Disambiguation(this)),
    (this.splice_delimiter = !1),
    (this.fun.dateparser = l.DateParser),
    (this.fun.flipflopper = new l.Util.FlipFlopper(this)),
    this.setCloseQuotesArray(),
    this.fun.ordinalizer.init(this),
    this.fun.long_ordinalizer.init(this),
    (this.fun.page_mangler = l.Util.PageRangeMangler.getFunction(this, 'page')),
    (this.fun.year_mangler = l.Util.PageRangeMangler.getFunction(this, 'year')),
    this.setOutputFormat('html')
}
l.Engine.prototype.setCloseQuotesArray = function () {
  var e
  ;(e = []),
    e.push(this.getTerm('close-quote')),
    e.push(this.getTerm('close-inner-quote')),
    e.push('"'),
    e.push("'"),
    (this.opt.close_quotes_array = e)
}
l.makeBuilder = function (e, t) {
  var r = [],
    i = []
  function n(u) {
    i.push(u), l.XmlToToken.call(u, e, l.START, t, r)
  }
  function s() {
    var u = i.pop()
    l.XmlToToken.call(u, e, l.END, t, r)
  }
  function a(u) {
    l.XmlToToken.call(u, e, l.SINGLETON, t, r)
  }
  function o(u, c, f) {
    u || (u = []), typeof u.length > 'u' && (u = [u])
    for (var h = 0; h < u.length; h++) {
      var p = u[h]
      e.cslXml.nodename(p) !== null &&
        (c &&
          e.cslXml.nodename(p) === 'date' &&
          (l.Util.fixDateNode.call(e, c, h, p), (p = e.cslXml.children(c)[h])),
        e.cslXml.numberofnodes(e.cslXml.children(p))
          ? (n(p), o(e.cslXml.children(p), p), s())
          : a(p))
    }
  }
  return o
}
l.Engine.prototype.buildTokenLists = function (e, t) {
  if (this.cslXml.getNodeValue(e)) {
    var r = l.makeBuilder(this, t),
      i
    typeof e.length > 'u' ? (i = e) : (i = e[0]), r(i)
  }
}
l.Engine.prototype.setStyleAttributes = function () {
  var r,
    e,
    t,
    r = {}
  ;(r.name = this.cslXml.nodename(this.cslXml.dataObj)),
    (e = this.cslXml.attributes(this.cslXml.dataObj))
  for (t in e) e.hasOwnProperty(t) && l.Attributes[t].call(r, this, e[t])
}
l.Engine.prototype.getTerm = function (e, t, r, i, n, s) {
  e &&
    e.match(/[A-Z]/) &&
    e === e.toUpperCase() &&
    (l.debug('Warning: term key is in uppercase form: ' + e), (e = e.toLowerCase()))
  var a
  s ? (a = this.opt['default-locale'][0]) : (a = this.opt.lang)
  var o = l.Engine.getField(l.LOOSE, this.locale[a].terms, e, t, r, i)
  return (
    !o && e === 'range-delimiter' && (o = ''),
    typeof o > 'u' &&
      (n === l.STRICT
        ? l.error('Error in getTerm: term "' + e + '" does not exist.')
        : n === l.TOLERANT && (o = '')),
    o && (this.tmp.cite_renders_content = !0),
    o
  )
}
l.Engine.prototype.getDate = function (e, t) {
  var r
  return (
    t ? (r = this.opt['default-locale']) : (r = this.opt.lang),
    this.locale[r].dates[e] ? this.locale[r].dates[e] : !1
  )
}
l.Engine.prototype.getOpt = function (e) {
  return typeof this.locale[this.opt.lang].opts[e] < 'u' ? this.locale[this.opt.lang].opts[e] : !1
}
l.Engine.prototype.getVariable = function (e, t, r, i) {
  return l.Engine.getField(l.LOOSE, e, t, r, i)
}
l.Engine.prototype.getDateNum = function (e, t) {
  return typeof e > 'u' ? 0 : e[t]
}
l.Engine.getField = function (e, t, r, i, n, s) {
  var a, o, u, c, f, h
  if (((a = ''), typeof t[r] > 'u'))
    if (e === l.STRICT) l.error('Error in getField: term "' + r + '" does not exist.')
    else return
  for (
    s && t[r][s] ? (h = t[r][s]) : (h = t[r]),
      o = [],
      i === 'symbol'
        ? (o = ['symbol', 'short'])
        : i === 'verb-short'
        ? (o = ['verb-short', 'verb'])
        : i !== 'long' && (o = [i]),
      o = o.concat(['long']),
      f = o.length,
      c = 0;
    c < f;
    c += 1
  )
    if (((u = o[c]), typeof h == 'string' || typeof h == 'number')) a = h
    else if (typeof h[u] < 'u') {
      typeof h[u] == 'string' || typeof h[u] == 'number'
        ? (a = h[u])
        : typeof n == 'number'
        ? (a = h[u][n])
        : (a = h[u][0])
      break
    }
  return a
}
l.Engine.prototype.configureTokenLists = function () {
  var e, t, r
  for (r = l.AREAS.length, t = 0; t < r; t += 1) {
    e = l.AREAS[t]
    var i = this[e].tokens
    this.configureTokenList(i)
  }
  return (this.version = l.version), this.state
}
l.Engine.prototype.configureTokenList = function (e) {
  var t, r, i, n, s, a, o, u
  for (t = ['year', 'month', 'day'], o = e.length - 1, s = o; s > -1; s += -1) {
    if (
      ((r = e[s]),
      r.name === 'date' && l.END === r.tokentype && (i = []),
      r.name === 'date-part' && r.strings.name)
    )
      for (u = t.length, a = 0; a < u; a += 1)
        (n = t[a]), n === r.strings.name && i.push(r.strings.name)
    r.name === 'date' && l.START === r.tokentype && (i.reverse(), (r.dateparts = i)),
      (r.next = s + 1),
      r.name && l.Node[r.name].configure && l.Node[r.name].configure.call(r, this, s)
  }
}
l.Engine.prototype.refetchItems = function (e) {
  for (var t = [], r = 0, i = e.length; r < i; r += 1) t.push(this.refetchItem('' + e[r]))
  return t
}
l.ITERATION = 0
l.Engine.prototype.retrieveItem = function (e) {
  var t, r, i
  if (!this.tmp.loadedItemIDs[e]) this.tmp.loadedItemIDs[e] = !0
  else return this.registry.refhash[e]
  if (
    this.opt.development_extensions.normalize_lang_keys_to_lowercase &&
    typeof this.opt.development_extensions.normalize_lang_keys_to_lowercase == 'boolean'
  ) {
    for (var i = 0, n = this.opt['default-locale'].length; i < n; i += 1)
      this.opt['default-locale'][i] = this.opt['default-locale'][i].toLowerCase()
    for (var i = 0, n = this.opt['locale-translit'].length; i < n; i += 1)
      this.opt['locale-translit'][i] = this.opt['locale-translit'][i].toLowerCase()
    for (var i = 0, n = this.opt['locale-translat'].length; i < n; i += 1)
      this.opt['locale-translat'][i] = this.opt['locale-translat'][i].toLowerCase()
    this.opt.development_extensions.normalize_lang_keys_to_lowercase = 100
  }
  if (
    ((l.ITERATION += 1),
    (t = JSON.parse(JSON.stringify(this.sys.retrieveItem('' + e)))),
    this.opt.development_extensions.normalize_lang_keys_to_lowercase)
  ) {
    if (t.multi) {
      if (t.multi._keys)
        for (var s in t.multi._keys)
          for (var a in t.multi._keys[s])
            a !== a.toLowerCase() &&
              ((t.multi._keys[s][a.toLowerCase()] = t.multi._keys[s][a]),
              delete t.multi._keys[s][a])
      if (t.multi.main) for (var s in t.multi.main) t.multi.main[s] = t.multi.main[s].toLowerCase()
    }
    for (var i = 0, n = l.NAME_VARIABLES.length; i > n; i += 1) {
      var o = l.NAME_VARIABLES[i]
      if (t[o] && t[o].multi)
        for (var u = 0, c = t[o].length; u < c; u += 1) {
          var f = t[o][u]
          if (f.multi) {
            if (f.multi._key)
              for (var a in f.multi._key)
                a !== a.toLowerCase() &&
                  ((f.multi._key[a.toLowerCase()] = f.multi._key[a]), delete f.multi._key[a])
            f.multi.main && (f.multi.main = f.multi.main.toLowerCase())
          }
        }
    }
  }
  if (t.language && t.language.match(/[><]/)) {
    var r = t.language.match(/(.*?)([<>])(.*)/)
    r[2] === '<'
      ? ((t['language-name'] = r[1]), (t['language-name-original'] = r[3]))
      : ((t['language-name'] = r[3]), (t['language-name-original'] = r[1])),
      this.opt.multi_layout
        ? t['language-name-original'] && (t.language = t['language-name-original'])
        : t['language-name'] && (t.language = t['language-name'])
  }
  if (t.page) {
    t['page-first'] = t.page
    var h = '' + t.page,
      r = h.split(/\s*(?:&|, |-|\u2013)\s*/)
    r[0].slice(-1) !== '\\' && (t['page-first'] = r[0])
  }
  this.opt.development_extensions.field_hack &&
    t.note &&
    l.parseNoteFieldHacks(t, !1, this.opt.development_extensions.allow_field_hack_date_override)
  for (var a in t)
    if (l.DATE_VARIABLES.indexOf(a.replace(/^alt-/, '')) > -1) {
      var p = t[a]
      p &&
        (this.opt.development_extensions.raw_date_parsing &&
          p.raw &&
          (!p['date-parts'] || p['date-parts'].length === 0) &&
          (p = this.fun.dateparser.parseDateToObject(p.raw)),
        (t[a] = this.dateParseArray(p)))
    }
  if (
    this.opt.development_extensions.consolidate_legal_items &&
    t.type &&
    ['bill', 'gazette', 'legislation', 'regulation', 'treaty'].indexOf(t.type) > -1
  ) {
    for (
      var m,
        v = ['type', 'title', 'jurisdiction', 'genre', 'volume', 'container-title'],
        b = [],
        i = 0,
        n = v.length;
      i < n;
      i += 1
    )
      (m = v[i]), t[m] && b.push(t[m])
    v = ['original-date', 'issued']
    for (var i = 0, n = v.length; i < n; i += 1)
      if (((m = v[i]), t[m] && t[m].year)) {
        var S = t[m].year
        b.push(S)
        break
      }
    t.legislation_id = b.join('::')
  }
  if (
    this.bibliography.opt.track_container_items &&
    this.bibliography.opt.track_container_items.indexOf(t.type) > -1
  ) {
    for (
      var m, v = ['type', 'container-title', 'publisher', 'edition'], g = [], i = 0, n = v.length;
      i < n;
      i += 1
    )
      (m = v[i]), t[m] && g.push(t[m])
    t.container_id = g.join('::')
  }
  if (
    this.opt.development_extensions.force_jurisdiction &&
    typeof t.authority == 'string' &&
    ((t.authority = [{ literal: t.authority, multi: { _key: {} } }]),
    t.multi && t.multi._keys && t.multi._keys.authority)
  ) {
    t.authority[0].multi._key = {}
    for (var a in t.multi._keys.authority)
      t.authority[0].multi._key[a] = { literal: t.multi._keys.authority[a] }
  }
  if (
    (t['title-short'] || (t['title-short'] = t.shortTitle),
    this.opt.development_extensions.main_title_from_short_title)
  ) {
    var _ = this.opt['default-locale'][0].slice(0, 2).toLowerCase() === 'fr'
    l.extractTitleAndSubtitle.call(this, t, _)
  }
  var y = ['bill', 'legal_case', 'legislation', 'gazette', 'regulation'].indexOf(t.type) > -1
  this.opt.development_extensions.force_jurisdiction &&
    y &&
    (t.jurisdiction || (t.jurisdiction = 'us'))
  var x
  if (!y && t.title && this.sys.getAbbreviation) {
    t.jurisdiction,
      this.sys.normalizeAbbrevsKey
        ? (x = this.sys.normalizeAbbrevsKey('title', t.title))
        : (x = t.title)
    var D = this.transform.loadAbbreviation(t.jurisdiction, 'title', x, t.language)
    this.transform.abbrevs[D].title &&
      this.transform.abbrevs[D].title[x] &&
      (t['title-short'] = this.transform.abbrevs[D].title[x])
  }
  if (
    (t['container-title-short'] || (t['container-title-short'] = t.journalAbbreviation),
    t['container-title'] && this.sys.getAbbreviation)
  ) {
    this.sys.normalizeAbbrevsKey
      ? (x = this.sys.normalizeAbbrevsKey(t['container-title']))
      : (x = t['container-title'])
    var D = this.transform.loadAbbreviation(t.jurisdiction, 'container-title', x, t.language)
    this.transform.abbrevs[D]['container-title'] &&
      this.transform.abbrevs[D]['container-title'][x] &&
      (t['container-title-short'] = this.transform.abbrevs[D]['container-title'][x])
  }
  if ((t.jurisdiction && (t.country = t.jurisdiction.split(':')[0]), this.registry.refhash[e])) {
    if (JSON.stringify(this.registry.refhash[e]) != JSON.stringify(t)) {
      for (var a in this.registry.refhash[e]) delete this.registry.refhash[e][a]
      ;(this.tmp.taintedItemIDs[t.id] = !0), Object.assign(this.registry.refhash[e], t)
    }
  } else this.registry.refhash[e] = t
  return this.registry.refhash[e]
}
l.Engine.prototype.refetchItem = function (e) {
  return this.registry.refhash[e]
}
l.Engine.prototype.setOpt = function (e, t, r) {
  e.name === 'style' || e.name === 'cslstyle'
    ? ((this.opt.inheritedAttributes[t] = r),
      (this.citation.opt.inheritedAttributes[t] = r),
      (this.bibliography.opt.inheritedAttributes[t] = r))
    : ['citation', 'bibliography'].indexOf(e.name) > -1
    ? (this[e.name].opt.inheritedAttributes[t] = r)
    : (e.strings[t] = r)
}
l.Engine.prototype.inheritOpt = function (e, t, r, i) {
  if (typeof e.strings[t] < 'u') return e.strings[t]
  var n = this[this.tmp.root].opt.inheritedAttributes[r || t]
  return typeof n < 'u' ? n : i
}
l.Engine.prototype.remapSectionVariable = function (e) {
  for (var t = 0, r = e.length; t < r; t += 1) {
    var i = e[t][0],
      n = e[t][1]
    if (['bill', 'gazette', 'legislation', 'regulation', 'treaty'].indexOf(i.type) > -1) {
      if (n.locator) {
        n.locator = n.locator.trim()
        var s = n.locator.match(l.STATUTE_SUBDIV_PLAIN_REGEX_FRONT)
        s ||
          (n.label
            ? (n.locator = l.STATUTE_SUBDIV_STRINGS_REVERSE[n.label] + ' ' + n.locator)
            : (n.locator = 'p. ' + n.locator))
      }
      var a = null
      if (i.section) {
        i.section = i.section.trim()
        var s = i.section.match(l.STATUTE_SUBDIV_PLAIN_REGEX_FRONT)
        s ? (a = s[0].trim()) : ((i.section = 'sec. ' + i.section), (a = 'sec.'))
      }
      if (i.section)
        if (!n.locator) n.locator = i.section
        else {
          var s = n.locator.match(/^([^ ]*)\s*(.*)/),
            o = ' '
          s
            ? (s[1] === 'p.' && a !== 'p.' && (n.locator = s[2]),
              ['[', '(', '.', ',', ';', ':', '?'].indexOf(n.locator.slice(0, 1)) > -1 && (o = ''))
            : (o = ''),
            (n.locator = i.section + o + n.locator)
        }
      n.label = ''
    }
  }
}
l.Engine.prototype.setNumberLabels = function (e) {
  if (
    e.number &&
    ['bill', 'gazette', 'legislation', 'regulation', 'treaty'].indexOf(e.type) > -1 &&
    this.opt.development_extensions.consolidate_legal_items &&
    !this.tmp.shadow_numbers.number
  ) {
    ;(this.tmp.shadow_numbers.number = {}),
      (this.tmp.shadow_numbers.number.values = []),
      (this.tmp.shadow_numbers.number.plural = 0),
      (this.tmp.shadow_numbers.number.numeric = !1),
      (this.tmp.shadow_numbers.number.label = !1)
    var t = '' + e.number
    t = t.split('\\').join('')
    var r = t.split(/\s+/)[0],
      i = l.STATUTE_SUBDIV_STRINGS[r]
    if (i) {
      var n = t.split(l.STATUTE_SUBDIV_PLAIN_REGEX)
      if (n.length > 1) {
        for (var s = [], a = 1, o = n.length; a < o; a += 1)
          s.push(n[a].replace(/\s*$/, '').replace(/^\s*/, ''))
        t = s.join(' ')
      } else t = n[0]
      ;(this.tmp.shadow_numbers.number.label = i),
        this.tmp.shadow_numbers.number.values.push(['Blob', t, !1]),
        (this.tmp.shadow_numbers.number.numeric = !1)
    } else
      this.tmp.shadow_numbers.number.values.push(['Blob', t, !1]),
        (this.tmp.shadow_numbers.number.numeric = !0)
  }
}
l.substituteOne = function (e) {
  return function (t, r) {
    return r ? e.replace('%%STRING%%', r) : ''
  }
}
l.substituteTwo = function (e) {
  return function (t) {
    var r = e.replace('%%PARAM%%', t)
    return function (i, n) {
      return n ? r.replace('%%STRING%%', n) : ''
    }
  }
}
l.Mode = function (e) {
  var t, r, i, n, s, a
  ;(t = {}), (r = l.Output.Formats[e])
  for (i in r) {
    if (i.slice(0, 1) !== '@') {
      t[i] = r[i]
      continue
    }
    ;(n = !1),
      (s = r[i]),
      (a = i.split('/')),
      typeof s == 'string' && s.indexOf('%%STRING%%') > -1
        ? s.indexOf('%%PARAM%%') > -1
          ? (n = l.substituteTwo(s))
          : (n = l.substituteOne(s))
        : typeof s == 'boolean' && !s
        ? (n = l.Output.Formatters.passthrough)
        : typeof s == 'function'
        ? (n = s)
        : l.error('Bad ' + e + ' config entry for ' + i + ': ' + s),
      a.length === 1
        ? (t[a[0]] = n)
        : a.length === 2 && (t[a[0]] || (t[a[0]] = {}), (t[a[0]][a[1]] = n))
  }
  return t
}
l.setDecorations = function (e, t) {
  var r, i, n
  r = []
  for (n in l.FORMAT_KEY_SEQUENCE) {
    var i = l.FORMAT_KEY_SEQUENCE[n]
    t[i] && (r.push([i, t[i]]), delete t[i])
  }
  return r
}
l.Doppeler = function (e, t) {
  var r = new RegExp('(' + e + ')', 'g'),
    i = new RegExp(e, 'g')
  ;(this.split = function (n) {
    t && (n = t(n))
    var s = n.match(r)
    if (!s) return { tags: [], strings: [n] }
    for (var a = n.split(i), o = s.length - 1; o > -1; o--) {
      typeof s[o] == 'number' && (s[o] = '')
      var u = s[o]
      u === "'" && a[o + 1].length > 0 && ((a[o + 1] = s[o] + a[o + 1]), (s[o] = ''))
    }
    return { tags: s, strings: a, origStrings: a.slice() }
  }),
    (this.join = function (n) {
      for (var s = n.strings.slice(-1), a = n.tags.length - 1; a > -1; a--)
        s.push(n.tags[a]), s.push(n.strings[a])
      return s.reverse(), s.join('')
    })
}
l.Engine.prototype.normalDecorIsOrphan = function (e, t) {
  if (t[1] === 'normal') {
    var r = !1,
      i
    this.tmp.area === 'citation'
      ? (i = [this.citation.opt.layout_decorations].concat(e.alldecor))
      : (i = e.alldecor)
    for (var n = i.length - 1; n > -1; n += -1)
      for (var s = i[n].length - 1; s > -1; s += -1)
        i[n][s][0] === t[0] && i[n][s][1] !== 'normal' && (r = !0)
    if (!r) return !0
  }
  return !1
}
l.Engine.prototype.getCitationLabel = function (e) {
  var t = '',
    r = this.getTrigraphParams(),
    i = r[0],
    n = this.getTerm('reference', 'short', 0)
  typeof n > 'u' && (n = 'reference'),
    (n = n.replace('.', '')),
    (n = n.slice(0, 1).toUpperCase() + n.slice(1))
  for (var s = 0, a = l.NAME_VARIABLES.length; s < a; s += 1) {
    var o = l.NAME_VARIABLES[s]
    if (e[o]) {
      var u = e[o]
      u.length > r.length ? (i = r[r.length - 1]) : (i = r[u.length - 1])
      for (var c = 0, f = u.length; c < f && c !== i.authors.length; c += 1) {
        var h = this.nameOutput.getName(u[c], 'locale-translit', !0),
          p = h.name
        p && p.family
          ? ((n = p.family), (n = n.replace(/^([ \'\u2019a-z]+\s+)/, '')))
          : p && p.literal && (n = p.literal)
        var m = n.toLowerCase().match(/^(a\s+|the\s+|an\s+)/)
        if ((m && (n = n.slice(m[1].length)), (n = n.replace(l.ROMANESQUE_NOT_REGEXP, '')), !n))
          break
        ;(n = n.slice(0, i.authors[c])),
          n.length > 1
            ? (n = n.slice(0, 1).toUpperCase() + n.slice(1).toLowerCase())
            : n.length === 1 && (n = n.toUpperCase()),
          (t += n)
      }
      break
    }
  }
  if (!t && e.title) {
    for (
      var v = this.locale[this.opt.lang].opts['skip-words'],
        b = e.title.split(/\s+/),
        s = b.length - 1;
      s > -1;
      s--
    )
      v.indexOf(b[s]) > -1 && (b = b.slice(0, s).concat(b.slice(s + 1)))
    var S = b.join('')
    ;(S = S.slice(0, r[0].authors[0])),
      S.length > 1
        ? (S = S.slice(0, 1).toUpperCase() + S.slice(1).toLowerCase())
        : S.length === 1 && (S = S.toUpperCase()),
      (t = S)
  }
  var g = '0000'
  return (
    e.issued && e.issued.year && (g = '' + e.issued.year),
    (g = g.slice(i.year * -1)),
    (t = t + g),
    t
  )
}
l.Engine.prototype.getTrigraphParams = function () {
  var e = [],
    t = this.opt.trigraph.split(':')
  ;(!this.opt.trigraph || this.opt.trigraph.slice(0, 1) !== 'A') &&
    l.error('Bad trigraph definition: ' + this.opt.trigraph)
  for (var r = 0, i = t.length; r < i; r += 1) {
    for (var n = t[r], s = { authors: [], year: 0 }, a = 0, o = n.length; a < o; a += 1)
      switch (n.slice(a, a + 1)) {
        case 'A':
          s.authors.push(1)
          break
        case 'a':
          s.authors[s.authors.length - 1] += 1
          break
        case '0':
          s.year += 1
          break
        default:
          l.error('Invalid character in trigraph definition: ' + this.opt.trigraph)
      }
    e.push(s)
  }
  return e
}
l.Engine.prototype.setOutputFormat = function (e) {
  ;(this.opt.mode = e),
    (this.fun.decorate = l.Mode(e)),
    this.output[e] || ((this.output[e] = {}), (this.output[e].tmp = {}))
}
l.Engine.prototype.getSortFunc = function () {
  return function (e, t) {
    return (
      (e = e.split('-')),
      (t = t.split('-')),
      e.length < t.length
        ? 1
        : e.length > t.length
        ? -1
        : ((e = e.slice(-1)[0]),
          (t = t.slice(-1)[0]),
          e.length < t.length ? 1 : e.length > t.length ? -1 : 0)
    )
  }
}
l.Engine.prototype.setLangTagsForCslSort = function (e) {
  var t, r
  if (e)
    for (this.opt['locale-sort'] = [], t = 0, r = e.length; t < r; t += 1)
      this.opt['locale-sort'].push(e[t])
  this.opt['locale-sort'].sort(this.getSortFunc())
}
l.Engine.prototype.setLangTagsForCslTransliteration = function (e) {
  var t, r
  if (((this.opt['locale-translit'] = []), e))
    for (t = 0, r = e.length; t < r; t += 1) this.opt['locale-translit'].push(e[t])
  this.opt['locale-translit'].sort(this.getSortFunc())
}
l.Engine.prototype.setLangTagsForCslTranslation = function (e) {
  var t, r
  if (((this.opt['locale-translat'] = []), e))
    for (t = 0, r = e.length; t < r; t += 1) this.opt['locale-translat'].push(e[t])
  this.opt['locale-translat'].sort(this.getSortFunc())
}
l.Engine.prototype.setLangPrefsForCites = function (e, t) {
  var r = this.opt['cite-lang-prefs']
  t ||
    (t = function (m) {
      return m.toLowerCase()
    })
  for (
    var i = ['Persons', 'Institutions', 'Titles', 'Journals', 'Publishers', 'Places'],
      n = 0,
      s = i.length;
    n < s;
    n += 1
  ) {
    var a = t(i[n]),
      o = i[n].toLowerCase()
    if (e[a]) {
      for (var u = []; e[a].length > 1; ) u.push(e[a].pop())
      var c = { orig: 1, translit: 2, translat: 3 }
      for (u.length === 2 && c[u[0]] < c[u[1]] && u.reverse(); u.length; ) e[a].push(u.pop())
      for (var f = r[o]; f.length; ) f.pop()
      for (var h = 0, p = e[a].length; h < p; h += 1) f.push(e[a][h])
    }
  }
}
l.Engine.prototype.setLangPrefsForCiteAffixes = function (e) {
  if (e && e.length === 48) {
    for (
      var t = this.opt.citeAffixes,
        r = 0,
        i = ['persons', 'institutions', 'titles', 'journals', 'publishers', 'places'],
        n = ['translit', 'orig', 'translit', 'translat'],
        s,
        a = 0,
        o = i.length;
      a < o;
      a += 1
    )
      for (var u = 0, c = n.length; u < c; u += 1)
        (s = ''),
          r % 8 === 4
            ? !t[i[a]]['locale-' + n[u]].prefix &&
              !t[i[a]]['locale-' + n[u]].suffix &&
              ((s = e[r] ? e[r] : ''),
              (t[i[a]]['locale-' + n[u]].prefix = s),
              (s = e[r] ? e[r + 1] : ''),
              (t[i[a]]['locale-' + n[u]].suffix = s))
            : ((s = e[r] ? e[r] : ''),
              (t[i[a]]['locale-' + n[u]].prefix = s),
              (s = e[r] ? e[r + 1] : ''),
              (t[i[a]]['locale-' + n[u]].suffix = s)),
          (r += 2)
    this.opt.citeAffixes = t
  }
}
l.Engine.prototype.setAutoVietnameseNamesOption = function (e) {
  e ? (this.opt['auto-vietnamese-names'] = !0) : (this.opt['auto-vietnamese-names'] = !1)
}
l.Engine.prototype.setAbbreviations = function (e) {
  this.sys.setAbbreviations && this.sys.setAbbreviations(e)
}
l.Engine.prototype.setSuppressTrailingPunctuation = function (e) {
  this.citation.opt.suppressTrailingPunctuation = !!e
}
l.Output = {}
l.Output.Queue = function (e) {
  ;(this.levelname = ['top']),
    (this.state = e),
    (this.queue = []),
    (this.empty = new l.Token('empty'))
  var t = {}
  ;(t.empty = this.empty), (this.formats = new l.Stack(t)), (this.current = new l.Stack(this.queue))
}
l.Output.Queue.prototype.pop = function () {
  var e = this.current.value()
  return e.length ? e.pop() : e.blobs.pop()
}
l.Output.Queue.prototype.getToken = function (e) {
  var t = this.formats.value()[e]
  return t
}
l.Output.Queue.prototype.mergeTokenStrings = function (e, t) {
  var r, i, n, s
  if (((r = this.formats.value()[e]), (i = this.formats.value()[t]), (n = r), i)) {
    r || ((r = new l.Token(e, l.SINGLETON)), (r.decorations = [])),
      (n = new l.Token(e, l.SINGLETON))
    var s = ''
    for (var s in r.strings) r.strings.hasOwnProperty(s) && (n.strings[s] = r.strings[s])
    for (var s in i.strings) i.strings.hasOwnProperty(s) && (n.strings[s] = i.strings[s])
    n.decorations = r.decorations.concat(i.decorations)
  }
  return n
}
l.Output.Queue.prototype.addToken = function (e, t, r) {
  var i, n
  if (
    ((i = new l.Token('output')),
    typeof r == 'string' && (r = this.formats.value()[r]),
    r && r.strings)
  ) {
    for (n in r.strings) r.strings.hasOwnProperty(n) && (i.strings[n] = r.strings[n])
    i.decorations = r.decorations
  }
  typeof t == 'string' && (i.strings.delimiter = t), (this.formats.value()[e] = i)
}
l.Output.Queue.prototype.pushFormats = function (e) {
  e || (e = {}), (e.empty = this.empty), this.formats.push(e)
}
l.Output.Queue.prototype.popFormats = function () {
  this.formats.pop()
}
l.Output.Queue.prototype.startTag = function (e, t) {
  var r = {}
  this.state.tmp['doing-macro-with-date'] &&
    this.state.tmp.extension &&
    ((t = this.empty), (e = 'empty')),
    (r[e] = t),
    this.pushFormats(r),
    this.openLevel(e)
}
l.Output.Queue.prototype.endTag = function (e) {
  this.closeLevel(e), this.popFormats()
}
l.Output.Queue.prototype.openLevel = function (e) {
  var t, r
  typeof e == 'object'
    ? (t = new l.Blob(void 0, e))
    : typeof e > 'u'
    ? (t = new l.Blob(void 0, this.formats.value().empty, 'empty'))
    : ((!this.formats.value() || !this.formats.value()[e]) &&
        l.error('CSL processor error: call to nonexistent format token "' + e + '"'),
      (t = new l.Blob(void 0, this.formats.value()[e], e))),
    (r = this.current.value()),
    !this.state.tmp.just_looking &&
      this.checkNestedBrace &&
      (t.strings.prefix = this.checkNestedBrace.update(t.strings.prefix)),
    r.push(t),
    this.current.push(t)
}
l.Output.Queue.prototype.closeLevel = function (e) {
  e &&
    e !== this.current.value().levelname &&
    l.error('Level mismatch error:  wanted ' + e + ' but found ' + this.current.value().levelname)
  var t = this.current.pop()
  !this.state.tmp.just_looking &&
    this.checkNestedBrace &&
    (t.strings.suffix = this.checkNestedBrace.update(t.strings.suffix))
}
l.Output.Queue.prototype.append = function (e, t, r, i, n) {
  var s,
    a,
    o,
    u = !0
  if ((r && (i = !0), this.state.tmp['doing-macro-with-date'] && !r)) {
    if (t !== 'macro-with-date') return !1
    t === 'macro-with-date' && (t = 'empty')
  }
  if (
    typeof e > 'u' ||
    (typeof e == 'number' && (e = '' + e),
    !r && this.state.tmp.element_trace && this.state.tmp.element_trace.value() === 'suppress-me')
  )
    return !1
  if (
    ((a = !1),
    t
      ? t === 'literal'
        ? ((s = !0), (u = !1))
        : typeof t == 'string'
        ? (s = this.formats.value()[t])
        : (s = t)
      : (s = this.formats.value().empty),
    s || l.error('CSL processor error: unknown format token name: ' + t),
    s.strings && typeof s.strings.delimiter > 'u' && (s.strings.delimiter = ''),
    typeof e == 'string' &&
      e.length &&
      ((e = e.replace(/ ([:;?!\u00bb])/g, '$1').replace(/\u00ab /g, '')),
      (this.last_char_rendered = e.slice(-1)),
      (e = e.replace(/\s+'/g, " '")),
      r || (e = e.replace(/^'/g, " '")),
      i
        ? r && (this.state.tmp.term_predecessor_name = !0)
        : ((this.state.tmp.term_predecessor = !0), (this.state.tmp.in_cite_predecessor = !0))),
    (a = new l.Blob(e, s)),
    (o = this.current.value()),
    typeof o > 'u' &&
      this.current.mystack.length === 0 &&
      (this.current.mystack.push([]), (o = this.current.value())),
    typeof a.blobs == 'string' &&
      (i
        ? r && (this.state.tmp.term_predecessor_name = !0)
        : ((this.state.tmp.term_predecessor = !0), (this.state.tmp.in_cite_predecessor = !0))),
    typeof e == 'string')
  ) {
    if (typeof a.blobs == 'string' && a.blobs.slice(0, 1) !== ' ') {
      for (var c = '', f = a.blobs; l.TERMINAL_PUNCTUATION.indexOf(f.slice(0, 1)) > -1; )
        (c = c + f.slice(0, 1)), (f = f.slice(1))
      f && c && ((a.strings.prefix = a.strings.prefix + c), (a.blobs = f))
    }
    a.strings['text-case'] &&
      (a.blobs = l.Output.Formatters[a.strings['text-case']](this.state, e)),
      this.state.tmp.strip_periods && !n && (a.blobs = a.blobs.replace(/\.([^a-z]|$)/g, '$1'))
    for (var h = a.decorations.length - 1; h > -1; h += -1)
      a.decorations[h][0] === '@quotes' &&
        a.decorations[h][1] !== 'false' &&
        (a.punctuation_in_quote = this.state.getOpt('punctuation-in-quote')),
        a.blobs.match(l.ROMANESQUE_REGEXP) ||
          (a.decorations[h][0] === '@font-style' &&
            (a.decorations = a.decorations.slice(0, h).concat(a.decorations.slice(h + 1))))
    o.push(a), this.state.fun.flipflopper.processTags(a)
  } else u ? o.push(a) : o.push(e)
  return !0
}
l.Output.Queue.prototype.string = function (e, t, r) {
  var i,
    n,
    s,
    a,
    o,
    u = l.getSafeEscape(this.state),
    c = t.slice(),
    f = []
  if (c.length === 0) return f
  var h = ''
  r
    ? (h = r.strings.delimiter)
    : ((e.tmp.count_offset_characters = !1), (e.tmp.offset_characters = 0)),
    r && r.new_locale && ((r.old_locale = e.opt.lang), (e.opt.lang = r.new_locale))
  for (var p, m, v, b, i = 0, n = c.length; i < n; i += 1) {
    if (
      ((p = c[i]),
      p.strings.first_blob && (e.tmp.count_offset_characters = p.strings.first_blob),
      typeof p.blobs == 'string')
    ) {
      if (typeof p.num == 'number') f.push(p)
      else if (p.blobs) {
        p.particle && ((p.blobs = p.particle + p.blobs), (p.particle = '')), (o = u(p.blobs))
        var S = o.length
        if (!e.tmp.suppress_decorations)
          for (s = 0, a = p.decorations.length; s < a; s += 1)
            (b = p.decorations[s]),
              b[0] !== '@showid' &&
                (e.normalDecorIsOrphan(p, b) ||
                  (o = e.fun.decorate[b[0]][b[1]].call(p, e, o, b[2])))
        if (o && o.length) {
          if (
            ((o = u(p.strings.prefix) + o + u(p.strings.suffix)),
            e.opt.development_extensions.csl_reverse_lookup_support && !e.tmp.suppress_decorations)
          )
            for (s = 0, a = p.decorations.length; s < a; s += 1)
              (b = p.decorations[s]),
                b[0] === '@showid' && (o = e.fun.decorate[b[0]][b[1]].call(p, e, o, b[2]))
          f.push(o),
            e.tmp.count_offset_characters &&
              (e.tmp.offset_characters += S + p.strings.suffix.length + p.strings.prefix.length)
        }
      }
    } else if (p.blobs.length) {
      var g = e.output.string(e, p.blobs, p)
      if (r && g !== 'string' && g.length > 1 && p.strings.delimiter)
        for (var _ = !1, s = 0, a = g.length; s < a; s++)
          typeof g[s] != 'string' ? (_ = !0) : _ && (g[s] = p.strings.delimiter + g[s])
      f = f.concat(g)
    }
    p.strings.first_blob &&
      e.registry.registry[p.strings.first_blob] &&
      ((e.registry.registry[p.strings.first_blob].offset = e.tmp.offset_characters),
      (e.tmp.count_offset_characters = !1))
  }
  for (i = 0, n = f.length - 1; i < n; i += 1)
    typeof f[i].num == 'number' &&
      typeof f[i + 1].num == 'number' &&
      !f[i + 1].UGLY_DELIMITER_SUPPRESS_HACK &&
      ((f[i].strings.suffix = f[i].strings.suffix + (h || '')),
      (f[i + 1].successor_prefix = ''),
      (f[i + 1].UGLY_DELIMITER_SUPPRESS_HACK = !0))
  for (var y = 0, i = 0, n = f.length; i < n; i += 1)
    typeof f[i] == 'string' &&
      ((y = parseInt(i, 10) + 1),
      i < f.length - 1 &&
        typeof f[i + 1] == 'object' &&
        (h && !f[i + 1].UGLY_DELIMITER_SUPPRESS_HACK && (f[i] += u(h)),
        (f[i + 1].UGLY_DELIMITER_SUPPRESS_HACK = !0)))
  if (r && (r.decorations.length || r.strings.suffix)) y = f.length
  else if (r && r.strings.prefix) {
    for (var i = 0, n = f.length; i < n; i++)
      if (typeof f[i].num < 'u') {
        ;(y = i), i === 0 && (f[i].strings.prefix = r.strings.prefix + f[i].strings.prefix)
        break
      }
  }
  var x = e.output.renderBlobs(f.slice(0, y), h, !1, r)
  if (x && r && (r.decorations.length || r.strings.suffix || r.strings.prefix)) {
    if (!e.tmp.suppress_decorations)
      for (var i = 0, n = r.decorations.length; i < n; i += 1)
        (b = r.decorations[i]),
          !(['@cite', '@bibliography', '@display', '@showid'].indexOf(b[0]) > -1) &&
            (e.normalDecorIsOrphan(p, b) ||
              (b[0] &&
                typeof x == 'string' &&
                (x = e.fun.decorate[b[0]][b[1]].call(r, e, x, b[2]))))
    if (
      ((o = x),
      (m = r.strings.suffix),
      o &&
        o.length &&
        ((v = r.strings.prefix),
        (o = u(v) + o + u(m)),
        e.tmp.count_offset_characters && (e.tmp.offset_characters += v.length + m.length)),
      (x = o),
      !e.tmp.suppress_decorations)
    )
      for (var i = 0, n = r.decorations.length; i < n; i += 1)
        (b = r.decorations[i]),
          ['@cite', '@bibliography', '@display', '@showid'].indexOf(b[0]) !== -1 &&
            typeof x == 'string' &&
            (x = e.fun.decorate[b[0]][b[1]].call(r, e, x, b[2]))
  }
  var D = f.slice(y, f.length)
  return (
    !D.length && x ? (f = [x]) : D.length && !x ? (f = D) : x && D.length && (f = [x].concat(D)),
    typeof r > 'u'
      ? ((this.queue = []),
        (this.current.mystack = []),
        this.current.mystack.push(this.queue),
        e.tmp.suppress_decorations && (f = e.output.renderBlobs(f, void 0, !1)))
      : typeof r == 'boolean' && (f = e.output.renderBlobs(f, void 0, !0)),
    r && r.new_locale && (e.opt.lang = r.old_locale),
    f
  )
}
l.Output.Queue.prototype.clearlevel = function () {
  var e, t, r
  for (e = this.current.value(), r = e.blobs.length, t = 0; t < r; t += 1) e.blobs.pop()
}
l.Output.Queue.prototype.renderBlobs = function (e, t, r, i) {
  var n, s, a, o, u, c, f, h, p, m, v
  if (
    ((v = l.getSafeEscape(this.state)),
    t || (t = ''),
    (n = this.state),
    (s = ''),
    (a = ''),
    (c = e.length),
    this.state.tmp.area === 'citation' &&
      !this.state.tmp.just_looking &&
      c === 1 &&
      typeof e[0] == 'object' &&
      i)
  )
    return (
      (e[0].strings.prefix = i.strings.prefix + e[0].strings.prefix),
      (e[0].strings.suffix = e[0].strings.suffix + i.strings.suffix),
      (e[0].decorations = e[0].decorations.concat(i.decorations)),
      (e[0].params = i.params),
      e[0]
    )
  var b = !0
  for (u = 0; u < c; u += 1)
    e[u].checkNext
      ? (e[u].checkNext(e[u + 1], b), (b = !1))
      : e[u + 1] && e[u + 1].splice_prefix
      ? (b = !1)
      : (b = !0)
  var S = !0
  for (u = e.length - 1; u > 0; u += -1)
    e[u].checkLast ? S && e[u].checkLast(e[u - 1]) && (S = !1) : (S = !0)
  for (c = e.length, u = 0; u < c; u += 1)
    if (((o = e[u]), s && (a = t), typeof o == 'string'))
      (s += v(a)), (s += o), n.tmp.count_offset_characters && (n.tmp.offset_characters += a.length)
    else if (r) s ? (s = [s, o]) : (s = [o])
    else if (o.status !== l.SUPPRESS) {
      o.particle ? (p = o.particle + o.num) : (p = o.formatter.format(o.num, o.gender))
      var g = p.replace(/<[^>]*>/g, '').length
      this.append(p, 'empty', !0)
      var _ = this.pop(),
        y = n.tmp.count_offset_characters
      if (
        ((p = this.string(n, [_], !1)),
        (n.tmp.count_offset_characters = y),
        o.strings['text-case'] && (p = l.Output.Formatters[o.strings['text-case']](this.state, p)),
        p && this.state.tmp.strip_periods && (p = p.replace(/\.([^a-z]|$)/g, '$1')),
        !n.tmp.suppress_decorations)
      )
        for (h = o.decorations.length, f = 0; f < h; f += 1)
          (m = o.decorations[f]),
            !n.normalDecorIsOrphan(o, m) && (p = n.fun.decorate[m[0]][m[1]].call(o, n, p, m[2]))
      p = v(o.strings.prefix) + p + v(o.strings.suffix)
      var x = ''
      o.status === l.END
        ? (x = v(o.range_prefix))
        : o.status === l.SUCCESSOR
        ? (x = v(o.successor_prefix))
        : o.status === l.START
        ? u > 0 && !o.suppress_splice_prefix
          ? (x = v(o.splice_prefix))
          : (x = '')
        : o.status === l.SEEN && (x = v(o.splice_prefix)),
        (s += x),
        (s += p),
        n.tmp.count_offset_characters &&
          (n.tmp.offset_characters +=
            x.length + o.strings.prefix.length + g + o.strings.suffix.length)
    }
  return s
}
l.Output.Queue.purgeEmptyBlobs = function (e) {
  if (!(typeof e != 'object' || typeof e.blobs != 'object' || !e.blobs.length))
    for (var t = e.blobs.length - 1; t > -1; t--) {
      l.Output.Queue.purgeEmptyBlobs(e.blobs[t])
      var r = e.blobs[t]
      if (!r || !r.blobs || !r.blobs.length) {
        for (var i = []; e.blobs.length - 1 > t; ) i.push(e.blobs.pop())
        for (e.blobs.pop(); i.length; ) e.blobs.push(i.pop())
      }
    }
}
l.Output.Queue.adjust = function (e) {
  var t = { ';': !0, ':': !0 },
    r = { '.': !0, '!': !0, '?': !0 },
    i = {
      '!': { '.': '!', '?': '!?', ':': '!', ',': '!,', ';': '!;' },
      '?': { '!': '?!', '.': '?', ':': '?', ',': '?,', ';': '?;' },
      '.': { '!': '.!', '?': '.?', ':': '.:', ',': '.,', ';': '.;' },
      ':': { '!': '!', '?': '?', '.': ':', ',': ':,', ';': ':;' },
      ',': { '!': ',!', '?': ',?', ':': ',:', '.': ',.', ';': ',;' },
      ';': { '!': '!', '?': '?', ':': ';', ',': ';,', '.': ';' },
    },
    n = {},
    s = {},
    a = {},
    o = {}
  for (var u in i) (a[u] = !0), (o[u] = !0), t[u] || (n[u] = !0), r[u] || (s[u] = !0)
  ;(o[' '] = !0), (o[''] = !0)
  var c = {}
  for (var u in i) for (var f in i[u]) c[f] || (c[f] = {}), (c[f][u] = i[u][f])
  function h(T) {
    return (
      typeof T.num == 'number' ||
      (T.blobs && T.blobs.length === 1 && typeof T.blobs[0].num == 'number')
    )
  }
  function p(T) {
    if (typeof T.num == 'number') return !0
    if (!T.blobs || typeof T.blobs != 'object') return !1
    if (p(T.blobs[T.blobs.length - 1])) return !0
  }
  function m(T, k) {
    var O = !1,
      N = ['@font-style', '@font-variant', '@font-weight', '@text-decoration', '@vertical-align']
    if ((k && N.push('@quotes'), T.decorations)) {
      for (var M = 0, V = T.decorations.length; M < V; M++)
        if (N.indexOf(T.decorations[M][0]) > -1) {
          O = !0
          break
        }
    }
    return O
  }
  function v(T) {
    if (T.decorations) {
      for (var k = 0, O = T.decorations.length; k < O; k++)
        if (T.decorations[k][0] === '@quotes' && T.decorations[k][1] !== 'false') return !0
    }
    return typeof T.blobs != 'object' ? !1 : v(T.blobs[T.blobs.length - 1])
  }
  function b(T, k) {
    var O = k.strings.suffix.slice(-1)
    !O && typeof k.blobs == 'string' && (O = k.blobs.slice(-1))
    var N = c[T][O]
    return N && N.length === 1
      ? !0
      : typeof k.blobs != 'object'
      ? !1
      : !!b(T, k.blobs[k.blobs.length - 1])
  }
  function S(T, k) {
    if (!a[k]) return !1
    if (typeof T.blobs == 'string') return T.blobs.slice(-1) === k
    var O = T.blobs[T.blobs.length - 1]
    if (O) {
      var N = O.strings.suffix.slice(-1)
      return N ? O.strings.suffix.slice(-1) == k : S(O, k)
    } else return !1
  }
  function g(T, k, O, N, M) {
    var V = k === 'blobs' ? T : T.strings,
      j = N === 'blobs' ? O : O.strings,
      R = V[k].slice(-1),
      $ = j[N].slice(0, 1)
    function L() {
      j[N] = j[N].slice(1)
    }
    function P() {
      V[k] = V[k].slice(0, -1)
    }
    function Y(fe) {
      j[N] = fe + j[N]
    }
    function w(fe) {
      V[k] += fe
    }
    var q = M ? P : L
    function X() {
      return c[$]
    }
    function I() {
      return i[R]
    }
    var re = M ? I : X
    function ie() {
      var fe = i[R][$]
      typeof fe == 'string' ? (P(), L(), Y(fe)) : (Y(R), P())
    }
    function Z() {
      var fe = c[$][R]
      typeof fe == 'string' ? (P(), L(), w(fe)) : (w($), L())
    }
    var oe = M ? ie : Z,
      ce = R === $
    ce ? q() : re() && oe()
  }
  function _(T) {
    if (T.blobs && typeof T.blobs == 'string') {
      a[T.strings.suffix.slice(0, 1)] &&
        T.strings.suffix.slice(0, 1) === T.blobs.slice(-1) &&
        (T.strings.suffix = T.strings.suffix.slice(1))
      return
    } else if (typeof T != 'object' || typeof T.blobs != 'object' || !T.blobs.length) return
    for (var k = m(T, !0), O = T.blobs.length - 1; O > -1; O--) {
      this.upward(T.blobs[O])
      var N = T.strings,
        M = T.blobs[O].strings
      if (O === 0) {
        N.prefix.slice(-1) === ' ' && M.prefix.slice(0, 1) === ' ' && (M.prefix = M.prefix.slice(1))
        var V = M.prefix.slice(0, 1)
        !k && o[V] && !N.prefix && ((N.prefix += V), (M.prefix = M.prefix.slice(1)))
      }
      if (O === T.blobs.length - 1) {
        var V = M.suffix.slice(-1)
        !k &&
          [' '].indexOf(V) > -1 &&
          (N.suffix.slice(0, 1) !== V && (N.suffix = V + N.suffix),
          (M.suffix = M.suffix.slice(0, -1)))
      }
      N.delimiter &&
        O > 0 &&
        o[N.delimiter.slice(-1)] &&
        N.delimiter.slice(-1) === M.prefix.slice(0, 1) &&
        (M.prefix = M.prefix.slice(1))
    }
  }
  function y(T) {
    if (!(typeof T != 'object' || typeof T.blobs != 'object' || !T.blobs.length)) {
      for (var k = T.blobs.length - 1; k > -1; k--)
        if ((this.leftward(T.blobs[k]), k < T.blobs.length - 1 && !T.strings.delimiter)) {
          var O = T.blobs[k],
            N = O.strings.suffix.slice(-1),
            M = T.blobs[k + 1],
            V = M.strings.prefix.slice(0, 1),
            j = m(O) || m(M),
            R = typeof N == 'number' || typeof V == 'number'
          if (!j && !R && a[V] && !R) {
            var $ = V === O.strings.suffix.slice(-1),
              L = !O.strings.suffix && typeof O.blobs == 'string' && O.blobs.slice(-1) === V
            !$ && !L ? g(O, 'suffix', M, 'prefix') : (M.strings.prefix = M.strings.prefix.slice(1))
          }
        }
    }
  }
  function x(T) {
    if (T.blobs && typeof T.blobs == 'string') {
      a[T.strings.suffix.slice(0, 1)] &&
        T.strings.suffix.slice(0, 1) === T.blobs.slice(-1) &&
        (T.strings.suffix = T.strings.suffix.slice(1))
      return
    } else if (typeof T != 'object' || typeof T.blobs != 'object' || !T.blobs.length) return
    for (var k = T.strings, O = 0, N = T.blobs.length; O < N && !h(T.blobs[O]); O++);
    if (k.delimiter && a[k.delimiter.slice(0, 1)]) {
      for (var M = k.delimiter.slice(0, 1), O = T.blobs.length - 2; O > -1; O--) {
        var V = T.blobs[O].strings
        V.suffix.slice(-1) !== M && (V.suffix += M)
      }
      k.delimiter = k.delimiter.slice(1)
    }
    for (var O = T.blobs.length - 1; O > -1; O--) {
      var j = T.blobs[O],
        V = T.blobs[O].strings,
        R = m(j, !0),
        $ = h(j)
      if (O === T.blobs.length - 1) {
        {
          var L = k.suffix.slice(0, 1),
            P = !1
          a[L] && ((P = b(L, j)), !P && e && (P = v(j))),
            P &&
              a[L] &&
              (p(j) ||
                (typeof j.blobs == 'string'
                  ? g(j, 'blobs', T, 'suffix')
                  : g(j, 'suffix', T, 'suffix'),
                k.suffix.slice(0, 1) === '.' &&
                  ((V.suffix += k.suffix.slice(0, 1)), (k.suffix = k.suffix.slice(1))))),
            V.suffix.slice(-1) === '' &&
              k.suffix.slice(0, 1) === ' ' &&
              (k.suffix = k.suffix.slice(1)),
            o[V.suffix.slice(0, 1)] &&
              (typeof j.blobs == 'string' &&
                j.blobs.slice(-1) === V.suffix.slice(0, 1) &&
                (V.suffix = V.suffix.slice(1)),
              V.suffix.slice(-1) === k.suffix.slice(0, 1) && (k.suffix = k.suffix.slice(0, -1)))
        }
        S(T, T.strings.suffix.slice(0, 1)) && (T.strings.suffix = T.strings.suffix.slice(1))
      } else if (k.delimiter)
        o[k.delimiter.slice(0, 1)] &&
          k.delimiter.slice(0, 1) === V.suffix.slice(-1) &&
          (T.blobs[O].strings.suffix = T.blobs[O].strings.suffix.slice(0, -1))
      else {
        var Y = T.blobs[O + 1].strings
        !h(j) &&
          !R &&
          o[V.suffix.slice(-1)] &&
          V.suffix.slice(-1) === Y.prefix.slice(0, 1) &&
          (Y.prefix = Y.prefix.slice(1))
      }
      !$ &&
        !R &&
        a[V.suffix.slice(0, 1)] &&
        typeof j.blobs == 'string' &&
        g(j, 'blobs', j, 'suffix'),
        this.downward(T.blobs[O])
    }
  }
  function D(T) {
    var k = T.strings.suffix.slice(0, 1)
    if (typeof T.blobs == 'string')
      for (; n[k]; ) g(T, 'blobs', T, 'suffix'), (k = T.strings.suffix.slice(0, 1))
    else
      for (; n[k]; )
        g(T.blobs[T.blobs.length - 1], 'suffix', T, 'suffix'), (k = T.strings.suffix.slice(0, 1))
  }
  function C(T) {
    if (typeof T.blobs == 'string')
      for (var k = T.blobs.slice(-1); s[k]; )
        g(T, 'blobs', T, 'suffix', !0), (k = T.blobs.slice(-1))
    else
      for (var k = T.blobs[T.blobs.length - 1].strings.suffix.slice(-1); s[k]; )
        g(T.blobs[T.blobs.length - 1], 'suffix', T, 'suffix', !0),
          (k = T.blobs[T.blobs.length - 1].strings.suffix.slice(-1))
  }
  function H(T) {
    if (!(typeof T != 'object' || typeof T.blobs != 'object' || !T.blobs.length)) {
      for (var k, O = 0, N = T.blobs.length; O < N; O++) {
        for (var M = T.blobs[O], V = !1, j = 0, R = M.decorations.length; j < R; j++) {
          var $ = M.decorations[j]
          $[0] === '@quotes' && $[1] !== 'false' && (V = !0)
        }
        V && (e ? D(M) : C(M)),
          (k = this.fix(T.blobs[O])),
          M.blobs && typeof M.blobs == 'string' && (k = M.blobs.slice(-1))
      }
      return k
    }
  }
  ;(this.upward = _), (this.leftward = y), (this.downward = x), (this.fix = H)
}
l.Engine.Opt = function () {
  ;(this.parallel = { enable: !1 }),
    (this.has_disambiguate = !1),
    (this.mode = 'html'),
    (this.dates = {}),
    (this.jurisdictions_seen = {}),
    (this.suppressedJurisdictions = {}),
    (this.inheritedAttributes = {}),
    (this['locale-sort'] = []),
    (this['locale-translit'] = []),
    (this['locale-translat'] = []),
    (this.citeAffixes = {
      persons: {
        'locale-orig': { prefix: '', suffix: '' },
        'locale-translit': { prefix: '', suffix: '' },
        'locale-translat': { prefix: '', suffix: '' },
      },
      institutions: {
        'locale-orig': { prefix: '', suffix: '' },
        'locale-translit': { prefix: '', suffix: '' },
        'locale-translat': { prefix: '', suffix: '' },
      },
      titles: {
        'locale-orig': { prefix: '', suffix: '' },
        'locale-translit': { prefix: '', suffix: '' },
        'locale-translat': { prefix: '', suffix: '' },
      },
      journals: {
        'locale-orig': { prefix: '', suffix: '' },
        'locale-translit': { prefix: '', suffix: '' },
        'locale-translat': { prefix: '', suffix: '' },
      },
      publishers: {
        'locale-orig': { prefix: '', suffix: '' },
        'locale-translit': { prefix: '', suffix: '' },
        'locale-translat': { prefix: '', suffix: '' },
      },
      places: {
        'locale-orig': { prefix: '', suffix: '' },
        'locale-translit': { prefix: '', suffix: '' },
        'locale-translat': { prefix: '', suffix: '' },
      },
    }),
    (this['default-locale'] = []),
    (this.update_mode = l.NONE),
    (this.bib_mode = l.NONE),
    (this.sort_citations = !1),
    (this['et-al-min'] = 0),
    (this['et-al-use-first'] = 1),
    (this['et-al-use-last'] = !1),
    (this['et-al-subsequent-min'] = !1),
    (this['et-al-subsequent-use-first'] = !1),
    (this['demote-non-dropping-particle'] = 'display-and-sort'),
    (this['parse-names'] = !0),
    (this.citation_number_slug = !1),
    (this.trigraph = 'Aaaa00:AaAa00:AaAA00:AAAA00'),
    (this.nodenames = []),
    (this.gender = {}),
    (this['cite-lang-prefs'] = {
      persons: ['orig'],
      institutions: ['orig'],
      titles: ['orig'],
      journals: ['orig'],
      publishers: ['orig'],
      places: ['orig'],
      number: ['orig'],
    }),
    (this.has_layout_locale = !1),
    (this.disable_duplicate_year_suppression = []),
    (this.use_context_condition = !1),
    (this.jurisdiction_fallbacks = {}),
    (this.development_extensions = {}),
    (this.development_extensions.field_hack = !0),
    (this.development_extensions.allow_field_hack_date_override = !0),
    (this.development_extensions.locator_date_and_revision = !0),
    (this.development_extensions.locator_label_parse = !0),
    (this.development_extensions.raw_date_parsing = !0),
    (this.development_extensions.clean_up_csl_flaws = !0),
    (this.development_extensions.consolidate_legal_items = !1),
    (this.development_extensions.csl_reverse_lookup_support = !1),
    (this.development_extensions.wrap_url_and_doi = !1),
    (this.development_extensions.thin_non_breaking_space_html_hack = !1),
    (this.development_extensions.apply_citation_wrapper = !1),
    (this.development_extensions.main_title_from_short_title = !1),
    (this.development_extensions.uppercase_subtitles = !1),
    (this.development_extensions.normalize_lang_keys_to_lowercase = !1),
    (this.development_extensions.strict_text_case_locales = !1),
    (this.development_extensions.expect_and_symbol_form = !1),
    (this.development_extensions.require_explicit_legal_case_title_short = !1),
    (this.development_extensions.spoof_institutional_affiliations = !1),
    (this.development_extensions.force_jurisdiction = !1),
    (this.development_extensions.parse_names = !0),
    (this.development_extensions.hanging_indent_legacy_number = !1),
    (this.development_extensions.throw_on_empty = !1),
    (this.development_extensions.strict_inputs = !0),
    (this.development_extensions.prioritize_disambiguate_condition = !1),
    (this.development_extensions.force_short_title_casing_alignment = !0),
    (this.development_extensions.implicit_short_title = !1),
    (this.development_extensions.force_title_abbrev_fallback = !1),
    (this.development_extensions.split_container_title = !1),
    (this.development_extensions.legacy_institution_name_ordering = !1),
    (this.development_extensions.etal_min_etal_usefirst_hack = !1)
}
l.Engine.Tmp = function () {
  ;(this.names_max = new l.Stack()),
    (this.names_base = new l.Stack()),
    (this.givens_base = new l.Stack()),
    (this.value = []),
    (this.namepart_decorations = {}),
    (this.namepart_type = !1),
    (this.area = 'citation'),
    (this.root = 'citation'),
    (this.extension = ''),
    (this.can_substitute = new l.Stack(0, l.LITERAL)),
    (this.element_rendered_ok = !1),
    (this.element_trace = new l.Stack('style')),
    (this.nameset_counter = 0),
    (this.group_context = new l.Stack({
      term_intended: !1,
      variable_attempt: !1,
      variable_success: !1,
      output_tip: void 0,
      label_form: void 0,
      parallel_first: void 0,
      parallel_last: void 0,
      parallel_delimiter_override: void 0,
      condition: !1,
      force_suppress: !1,
      done_vars: [],
    })),
    (this.term_predecessor = !1),
    (this.in_cite_predecessor = !1),
    (this.jump = new l.Stack(0, l.LITERAL)),
    (this.decorations = new l.Stack()),
    (this.tokenstore_stack = new l.Stack()),
    (this.last_suffix_used = ''),
    (this.last_names_used = []),
    (this.last_years_used = []),
    (this.years_used = []),
    (this.names_used = []),
    (this.taintedItemIDs = {}),
    (this.taintedCitationIDs = {}),
    (this.initialize_with = new l.Stack()),
    (this.disambig_request = !1),
    (this['name-as-sort-order'] = !1),
    (this.suppress_decorations = !1),
    (this.disambig_settings = new l.AmbigConfig()),
    (this.bib_sort_keys = []),
    (this.prefix = new l.Stack('', l.LITERAL)),
    (this.suffix = new l.Stack('', l.LITERAL)),
    (this.delimiter = new l.Stack('', l.LITERAL)),
    (this.cite_locales = []),
    (this.cite_affixes = {
      citation: !1,
      bibliography: !1,
      citation_sort: !1,
      bibliography_sort: !1,
    }),
    (this.strip_periods = 0),
    (this.shadow_numbers = {}),
    (this.authority_stop_last = 0),
    (this.loadedItemIDs = {}),
    (this.condition_counter = 0),
    (this.condition_lang_val_arr = []),
    (this.condition_lang_counter_arr = [])
}
l.Engine.Fun = function (e) {
  ;(this.match = new l.Util.Match()),
    (this.suffixator = new l.Util.Suffixator(l.SUFFIX_CHARS)),
    (this.romanizer = new l.Util.Romanizer()),
    (this.ordinalizer = new l.Util.Ordinalizer(e)),
    (this.long_ordinalizer = new l.Util.LongOrdinalizer())
}
l.Engine.Build = function () {
  ;(this['alternate-term'] = !1),
    (this.in_bibliography = !1),
    (this.in_style = !1),
    (this.skip = !1),
    (this.postponed_macro = !1),
    (this.layout_flag = !1),
    (this.name = !1),
    (this.names_variables = [[]]),
    (this.name_label = [{}]),
    (this.form = !1),
    (this.term = !1),
    (this.macro = {}),
    (this.macro_stack = []),
    (this.text = !1),
    (this.lang = !1),
    (this.area = 'citation'),
    (this.root = 'citation'),
    (this.extension = ''),
    (this.substitute_level = new l.Stack(0, l.LITERAL)),
    (this.names_level = 0),
    (this.render_nesting_level = 0),
    (this.render_seen = !1),
    (this.bibliography_key_pos = 0)
}
l.Engine.Configure = function () {
  ;(this.tests = []), (this.fail = []), (this.succeed = [])
}
l.Engine.Citation = function (e) {
  ;(this.opt = { inheritedAttributes: {} }),
    (this.tokens = []),
    (this.srt = new l.Registry.Comparifier(e, 'citation_sort')),
    (this.opt.collapse = []),
    (this.opt['disambiguate-add-names'] = !1),
    (this.opt['disambiguate-add-givenname'] = !1),
    (this.opt['disambiguate-add-year-suffix'] = !1),
    (this.opt['givenname-disambiguation-rule'] = 'by-cite'),
    (this.opt['near-note-distance'] = 5),
    (this.opt.topdecor = []),
    (this.opt.layout_decorations = []),
    (this.opt.layout_prefix = ''),
    (this.opt.layout_suffix = ''),
    (this.opt.layout_delimiter = ''),
    (this.opt.sort_locales = []),
    (this.opt.max_number_of_names = 0),
    (this.root = 'citation')
}
l.Engine.Bibliography = function () {
  ;(this.opt = { inheritedAttributes: {} }),
    (this.tokens = []),
    (this.opt.collapse = []),
    (this.opt.topdecor = []),
    (this.opt.layout_decorations = []),
    (this.opt.layout_prefix = ''),
    (this.opt.layout_suffix = ''),
    (this.opt.layout_delimiter = ''),
    (this.opt['line-spacing'] = 1),
    (this.opt['entry-spacing'] = 1),
    (this.opt.sort_locales = []),
    (this.opt.max_number_of_names = 0),
    (this.root = 'bibliography')
}
l.Engine.BibliographySort = function () {
  ;(this.tokens = []),
    (this.opt = {}),
    (this.opt.sort_directions = []),
    (this.opt.topdecor = []),
    (this.opt.citation_number_sort_direction = l.ASCENDING),
    (this.opt.citation_number_secondary = !1),
    (this.tmp = {}),
    (this.keys = []),
    (this.root = 'bibliography')
}
l.Engine.CitationSort = function () {
  ;(this.tokens = []),
    (this.opt = {}),
    (this.opt.sort_directions = []),
    (this.keys = []),
    (this.opt.topdecor = []),
    (this.root = 'citation')
}
l.Engine.InText = function () {
  ;(this.opt = { inheritedAttributes: {} }),
    (this.tokens = []),
    (this.opt.collapse = []),
    (this.opt['disambiguate-add-names'] = !1),
    (this.opt['disambiguate-add-givenname'] = !1),
    (this.opt['disambiguate-add-year-suffix'] = !1),
    (this.opt['givenname-disambiguation-rule'] = 'by-cite'),
    (this.opt['near-note-distance'] = 5),
    (this.opt.topdecor = []),
    (this.opt.layout_decorations = []),
    (this.opt.layout_prefix = ''),
    (this.opt.layout_suffix = ''),
    (this.opt.layout_delimiter = ''),
    (this.opt.sort_locales = []),
    (this.opt.max_number_of_names = 0),
    (this.root = 'intext')
}
l.Engine.prototype.previewCitationCluster = function (e, t, r, i) {
  var n = this.opt.mode
  this.setOutputFormat(i), e.citationID && delete e.citationID
  var s = this.processCitationCluster(e, t, r, l.PREVIEW)
  return this.setOutputFormat(n), s[1]
}
l.Engine.prototype.appendCitationCluster = function (e) {
  for (var t = [], r = this.registry.citationreg.citationByIndex.length, i = 0; i < r; i += 1) {
    var n = this.registry.citationreg.citationByIndex[i]
    t.push(['' + n.citationID, n.properties.noteIndex])
  }
  return this.processCitationCluster(e, t, [])[1]
}
l.Engine.prototype.processCitationCluster = function (e, t, r, i) {
  var n, s, a, o, u, c, f, h, p, m, v, b, S, g, _, y, x, D
  ;(this.debug = !1),
    (this.tmp.loadedItemIDs = {}),
    (this.tmp.citation_errors = []),
    (this.registry.return_data = { bibchange: !1 }),
    this.setCitationId(e)
  var C, H, T
  if (i === l.PREVIEW) {
    this.debug && l.debug('****** start state save *********'),
      (C = this.registry.citationreg.citationByIndex.slice()),
      (H = this.registry.reflist.slice())
    for (var k = t.concat(r), O = {}, N = [], o = 0, u = k.length; o < u; o += 1)
      for (
        n = this.registry.citationreg.citationById[k[o][0]], c = 0, f = n.citationItems.length;
        c < f;
        c += 1
      )
        (O[n.citationItems[c].id] = !0), N.push('' + n.citationItems[c].id)
    for (c = 0, f = e.citationItems.length; c < f; c += 1)
      (O[e.citationItems[c].id] = !0), N.push('' + e.citationItems[c].id)
    T = {}
    for (var o = 0, u = H.length; o < u; o += 1)
      if (!O[H[o].id]) {
        var M = this.registry.registry[H[o].id].ambig,
          V = this.registry.ambigcites[M]
        if (V)
          for (c = 0, f = V.length; c < f; c += 1)
            T[V[c]] = l.cloneAmbigConfig(this.registry.registry[V[c]].disambig)
      }
    this.debug && l.debug('****** end state save *********')
  }
  this.tmp.taintedCitationIDs = {}
  for (var j = [], R = {}, o = 0, u = e.citationItems.length; o < u; o += 1) {
    g = {}
    for (var b in e.citationItems[o]) g[b] = e.citationItems[o][b]
    if (
      ((S = this.retrieveItem('' + g.id)),
      S.id && this.transform.loadAbbreviation('default', 'hereinafter', S.id, S.language),
      (g = l.parseLocator.call(this, g)),
      this.opt.development_extensions.consolidate_legal_items &&
        this.remapSectionVariable([[S, g]]),
      this.opt.development_extensions.locator_label_parse &&
        g.locator &&
        ['bill', 'gazette', 'legislation', 'regulation', 'treaty'].indexOf(S.type) === -1 &&
        (!g.label || g.label === 'page'))
    ) {
      var x = l.LOCATOR_LABELS_REGEXP.exec(g.locator)
      if (x) {
        var $ = l.LOCATOR_LABELS_MAP[x[2]]
        this.getTerm($) && ((g.label = $), (g.locator = x[3]))
      }
    }
    var L = [S, g]
    j.push(L), (e.citationItems[o].item = S)
  }
  e.sortedItems = j
  var P = [],
    Y = {},
    w
  for (o = 0, u = t.length; o < u; o += 1)
    (s = t[o]),
      this.opt.development_extensions.strict_inputs &&
        (Y[s[0]] &&
          l.error('Previously referenced citationID ' + s[0] + ' encountered in citationsPre'),
        s[1] &&
          (w > s[1] && l.debug('Note index sequence is not sane at citationsPre[' + o + ']'),
          (w = s[1]))),
      (this.registry.citationreg.citationById[s[0]].properties.noteIndex = s[1]),
      P.push(this.registry.citationreg.citationById[s[0]]),
      (Y[s[0]] = this.registry.citationreg.citationById[s[0]])
  for (
    e.properties || (e.properties = { noteIndex: 0 }),
      this.opt.development_extensions.strict_inputs &&
        (Y[e.citationID] &&
          l.error('Citation with previously referenced citationID ' + e.citationID),
        e.properties.noteIndex &&
          (w > e.properties.noteIndex &&
            l.debug('Note index sequence is not sane for citation ' + e.citationID),
          (w = e.properties.noteIndex))),
      P.push(e),
      Y[e.citationID] = e,
      o = 0,
      u = r.length;
    o < u;
    o += 1
  )
    (a = r[o]),
      this.opt.development_extensions.strict_inputs &&
        (Y[a[0]] &&
          l.error('Previously referenced citationID ' + a[0] + ' encountered in citationsPost'),
        a[1] &&
          (w > a[1] && l.debug('Note index sequence is not sane at postCitation[' + o + ']'),
          (w = a[1]))),
      (this.registry.citationreg.citationById[a[0]].properties.noteIndex = a[1]),
      P.push(this.registry.citationreg.citationById[a[0]]),
      (Y[a[0]] = this.registry.citationreg.citationById[a[0]])
  ;(this.registry.citationreg.citationByIndex = P),
    (this.registry.citationreg.citationById = Y),
    (this.registry.citationreg.citationsByItemId = {}),
    this.opt.update_mode === l.POSITION && ((y = []), (_ = []), (D = {}))
  for (var q = [], o = 0, u = P.length; o < u; o += 1) {
    for (P[o].properties.index = o, c = 0, f = P[o].sortedItems.length; c < f; c += 1)
      (g = P[o].sortedItems[c]),
        this.registry.citationreg.citationsByItemId[g[1].id] ||
          ((this.registry.citationreg.citationsByItemId[g[1].id] = []), q.push('' + g[1].id)),
        this.registry.citationreg.citationsByItemId[g[1].id].indexOf(P[o]) === -1 &&
          this.registry.citationreg.citationsByItemId[g[1].id].push(P[o])
    this.opt.update_mode === l.POSITION &&
      (P[o].properties.noteIndex ? _.push(P[o]) : ((P[o].properties.noteIndex = 0), y.push(P[o])))
  }
  if (
    (i !== l.ASSUME_ALL_ITEMS_REGISTERED &&
      (this.debug && l.debug('****** start update items *********'),
      this.updateItems(q, null, null, !0),
      this.debug && l.debug('****** endo update items *********')),
    !this.opt.citation_number_sort && j && j.length > 1 && this.citation_sort.tokens.length > 0)
  ) {
    for (var o = 0, u = j.length; o < u; o += 1)
      j[o][1].sortkeys = l.getSortKeys.call(this, j[o][0], 'citation_sort')
    if (this.opt.grouped_sort && !e.properties.unsorted) {
      for (var o = 0, u = j.length; o < u; o += 1) {
        var X = j[o][1].sortkeys
        this.tmp.authorstring_request = !0
        var I = this.registry.registry[j[o][0].id].disambig
        ;(this.tmp.authorstring_request = !0), l.getAmbiguousCite.call(this, j[o][0], I)
        var re = this.registry.authorstrings[j[o][0].id]
        ;(this.tmp.authorstring_request = !1), (j[o][1].sortkeys = [re].concat(X))
      }
      j.sort(this.citation.srt.compareCompositeKeys)
      for (var ie = !1, Z = !1, oe = !1, o = 0, u = j.length; o < u; o += 1)
        j[o][1].sortkeys[0] !== ie && ((oe = j[o][1].sortkeys[0]), (Z = j[o][1].sortkeys[1])),
          (j[o][1].sortkeys[0] = '' + Z + o),
          (ie = oe)
    }
    e.properties.unsorted || j.sort(this.citation.srt.compareCompositeKeys)
  }
  this.opt.parallel.enable && this.parallel.StartCitation(e.sortedItems)
  var ce
  if (this.opt.update_mode === l.POSITION)
    for (var o = 0; o < 2; o += 1) {
      var fe = {},
        ge = {},
        me = {}
      for (ce = [y, _][o], c = 0, f = ce.length; c < f; c += 1) {
        var be = ce[c]
        for (
          ce[c].properties.noteIndex || (ce[c].properties.noteIndex = 0),
            ce[c].properties.noteIndex = parseInt(ce[c].properties.noteIndex, 10),
            c > 0 &&
              be.properties.noteIndex &&
              ce[c - 1].properties.noteIndex > be.properties.noteIndex &&
              ((D = {}), (fe = {}), (ge = {}), (me = {})),
            h = 0,
            p = be.sortedItems.length;
          h < p;
          h += 1
        )
          (be.sortedItems[h][1].parallel && be.sortedItems[h][1].parallel !== 'first') ||
            (D[be.properties.noteIndex]
              ? (D[be.properties.noteIndex] += 1)
              : (D[be.properties.noteIndex] = 1))
        for (h = 0, p = ce[c].sortedItems.length; h < p; h += 1) {
          g = ce[c].sortedItems[h]
          var Ne = g[0].id,
            Oe = g[0].legislation_id ? g[0].legislation_id : g[0].id,
            _e = g[0].legislation_id
              ? g[0].legislation_id
              : g[0].container_id
              ? g[0].container_id
              : g[0].id,
            F = g[1]['locator-extra'],
            E = g[1].locator,
            A = g[1].label,
            z,
            W
          if (h > 0)
            if (be.sortedItems[h - 1][0].legislation_id) z = be.sortedItems[h - 1][0].legislation_id
            else {
              ;(z = be.sortedItems[h - 1][1].id), (W = be.sortedItems[h - 1][1]['locator-extra'])
              for (var te = h - 2; te > -1; te--)
                be.sortedItems[te][1].parallel === 'first' &&
                  ((z = be.sortedItems[te][1].id), (W = be.sortedItems[te][1]['locator-extra']))
            }
          if (i === l.PREVIEW && be.citationID != e.citationID) {
            typeof fe[g[1].id] > 'u' && (fe[Oe] = be.properties.noteIndex),
              (ge[_e] = be.properties.noteIndex)
            continue
          }
          var ne = {}
          if (
            ((ne.position = g[1].position),
            (ne['first-reference-note-number'] = g[1]['first-reference-note-number']),
            (ne['first-container-reference-note-number'] =
              g[1]['first-container-reference-note-number']),
            (ne['near-note'] = g[1]['near-note']),
            (g[1]['first-reference-note-number'] = 0),
            (g[1]['first-container-reference-note-number'] = 0),
            (g[1]['near-note'] = !1),
            this.registry.citationreg.citationsByItemId[Ne] &&
              this.opt.xclass === 'note' &&
              this.opt.has_disambiguate)
          ) {
            var Te = this.registry.registry[g[0].id]['citation-count'],
              De = this.registry.citationreg.citationsByItemId[Ne].length
            if (
              ((this.registry.registry[g[0].id]['citation-count'] =
                this.registry.citationreg.citationsByItemId[Ne].length),
              typeof Te == 'number')
            ) {
              var K = Te < 2,
                se = De < 2
              if (K !== se)
                for (
                  var te = 0, pe = this.registry.citationreg.citationsByItemId[Ne].length;
                  te < pe;
                  te++
                )
                  (R[this.registry.registry[g[0].id].ambig] = !0),
                    (this.tmp.taintedCitationIDs[
                      this.registry.citationreg.citationsByItemId[Ne][te].citationID
                    ] = !0)
            } else
              for (
                var te = 0, pe = this.registry.citationreg.citationsByItemId[Ne].length;
                te < pe;
                te++
              )
                (R[this.registry.registry[g[0].id].ambig] = !0),
                  (this.tmp.taintedCitationIDs[
                    this.registry.citationreg.citationsByItemId[Ne][te].citationID
                  ] = !0)
          }
          var ve, Ce
          if (typeof ge[_e] > 'u' && be.properties.mode !== 'author-only')
            (fe[Oe] = be.properties.noteIndex),
              (ge[_e] = be.properties.noteIndex),
              (me[_e] = be.properties.noteIndex),
              (g[1].position = l.POSITION_FIRST)
          else {
            var ze = !1,
              Et = !1,
              Me = null
            if (c > 0) var Me = ce[c - 1]
            var ur = ce[c]
            if (c > 0) {
              var Er = 1
              Me.properties.mode === 'author-only' && c > 1 && (Er = 2)
              var lt = c - Er
              ce[lt].sortedItems.length &&
                ((ve = ce[lt].sortedItems.slice(-1)[0][1].id),
                (Ce = ce[c - Er].sortedItems.slice(-1)[0][1]['locator-extra'])),
                Me.sortedItems.length &&
                  Me.sortedItems[0].slice(-1)[0].legislation_id &&
                  (ve = Me.sortedItems[0].slice(-1)[0].legislation_id)
            }
            if (c > 0 && h === 0 && Me.properties.noteIndex !== ur.properties.noteIndex) {
              var xr = !1,
                zt = Me.sortedItems[0][0].id
              if (
                (Me.sortedItems[0][0].legislation_id && (zt = Me.sortedItems[0][0].legislation_id),
                zt == Oe && Me.properties.noteIndex >= ur.properties.noteIndex - 1)
              ) {
                var wy = Me.sortedItems[0][1]['locator-extra'],
                  Ny = ur.sortedItems[0][1]['locator-extra']
                ;(D[Me.properties.noteIndex] === 1 || Me.properties.noteIndex === 0) &&
                  wy === Ny &&
                  (xr = !0)
              }
              xr ? (ze = !0) : (Et = !0)
            } else
              (h > 0 && z == Oe && W == F) ||
              (h === 0 &&
                c > 0 &&
                Me.properties.noteIndex == ur.properties.noteIndex &&
                Me.sortedItems.length &&
                ve == Oe &&
                Ce == F)
                ? (ze = !0)
                : (Et = !0)
            var di, Tr, ku, Mr, wu
            ze &&
              (h > 0 ? (di = be.sortedItems[h - 1][1]) : (di = ce[c - 1].sortedItems[0][1]),
              di.locator
                ? (di.label ? (ku = di.label) : (ku = ''), (Tr = '' + di.locator + ku))
                : (Tr = di.locator),
              E ? (A ? (wu = A) : (wu = ''), (Mr = '' + E + wu)) : (Mr = E)),
              ze && Tr && !Mr && ((ze = !1), (Et = !0)),
              ze &&
                (!Tr && Mr
                  ? (g[1].position = l.POSITION_IBID_WITH_LOCATOR)
                  : (!Tr && !Mr) || (Tr && Mr === Tr)
                  ? (g[1].position = l.POSITION_IBID)
                  : Tr && Mr && Mr !== Tr
                  ? (g[1].position = l.POSITION_IBID_WITH_LOCATOR)
                  : ((ze = !1), (Et = !0))),
              Et &&
                ((g[1].position = l.POSITION_CONTAINER_SUBSEQUENT),
                typeof fe[Oe] > 'u'
                  ? (fe[Oe] = be.properties.noteIndex)
                  : (g[1].position = l.POSITION_SUBSEQUENT)),
              (Et || ze) &&
                (be.properties.mode === 'author-only' && (g[1].position = l.POSITION_FIRST),
                me[_e] != be.properties.noteIndex &&
                  ((g[1]['first-container-reference-note-number'] = me[_e]),
                  this.registry.registry[g[0].id] &&
                    (this.registry.registry[g[0].id]['first-container-reference-note-number'] =
                      me[_e])),
                fe[Oe] != be.properties.noteIndex &&
                  ((g[1]['first-reference-note-number'] = fe[Oe]),
                  this.registry.registry[g[0].id] &&
                    (this.registry.registry[g[0].id]['first-reference-note-number'] = fe[Oe])))
          }
          if (be.properties.noteIndex) {
            var Oy = parseInt(be.properties.noteIndex, 10) - parseInt(ge[_e], 10)
            g[1].position !== l.POSITION_FIRST &&
              Oy <= this.citation.opt['near-note-distance'] &&
              (g[1]['near-note'] = !0),
              (ge[_e] = be.properties.noteIndex)
          } else g[1].position !== l.POSITION_FIRST && (g[1]['near-note'] = !0)
          if (be.citationID != e.citationID)
            for (m = 0, v = l.POSITION_TEST_VARS.length; m < v; m += 1) {
              var Nu = l.POSITION_TEST_VARS[m]
              g[1][Nu] !== ne[Nu] &&
                (this.registry.registry[g[0].id] &&
                  Nu === 'first-reference-note-number' &&
                  ((R[this.registry.registry[g[0].id].ambig] = !0),
                  (this.tmp.taintedItemIDs[g[0].id] = !0)),
                (this.tmp.taintedCitationIDs[be.citationID] = !0))
            }
          this.sys.variableWrapper &&
            ((g[1].index = be.properties.index), (g[1].noteIndex = be.properties.noteIndex))
        }
      }
    }
  if (
    this.opt.citation_number_sort &&
    j &&
    j.length > 1 &&
    this.citation_sort.tokens.length > 0 &&
    !e.properties.unsorted
  ) {
    for (var o = 0, u = j.length; o < u; o += 1)
      j[o][1].sortkeys = l.getSortKeys.call(this, j[o][0], 'citation_sort')
    j.sort(this.citation.srt.compareCompositeKeys)
  }
  for (var b in this.tmp.taintedItemIDs)
    if (
      this.tmp.taintedItemIDs.hasOwnProperty(b) &&
      ((ce = this.registry.citationreg.citationsByItemId[b]), ce)
    )
      for (var o = 0, u = ce.length; o < u; o += 1)
        this.tmp.taintedCitationIDs[ce[o].citationID] = !0
  var Hn = []
  if (i === l.PREVIEW) {
    this.debug && l.debug('****** start run processor *********')
    try {
      Hn = this.process_CitationCluster.call(this, e.sortedItems, e)
    } catch (da) {
      l.error('Error running CSL processor for preview: ' + da)
    }
    this.debug &&
      (l.debug('****** end run processor *********'),
      l.debug('****** start state restore *********')),
      (this.registry.citationreg.citationByIndex = C),
      (this.registry.citationreg.citationById = {})
    for (var o = 0, u = C.length; o < u; o += 1)
      this.registry.citationreg.citationById[C[o].citationID] = C[o]
    this.debug && l.debug('****** start final update *********')
    for (var Lp = [], o = 0, u = H.length; o < u; o += 1) Lp.push('' + H[o].id)
    this.updateItems(Lp, null, null, !0), this.debug && l.debug('****** end final update *********')
    for (var b in T) T.hasOwnProperty(b) && (this.registry.registry[b].disambig = T[b])
    this.debug && l.debug('****** end state restore *********')
  } else {
    for (var Iy in R) this.disambiguate.run(Iy, e)
    var lr
    for (var b in this.tmp.taintedCitationIDs)
      if (b != e.citationID) {
        var jt = this.registry.citationreg.citationById[b]
        if (!jt.properties.unsorted) {
          for (var o = 0, u = jt.sortedItems.length; o < u; o += 1)
            jt.sortedItems[o][1].sortkeys = l.getSortKeys.call(
              this,
              jt.sortedItems[o][0],
              'citation_sort'
            )
          jt.sortedItems.sort(this.citation.srt.compareCompositeKeys)
        }
        ;(this.tmp.citation_pos = jt.properties.index),
          (this.tmp.citation_note_index = jt.properties.noteIndex),
          (this.tmp.citation_id = '' + jt.citationID),
          (lr = []),
          lr.push(jt.properties.index),
          lr.push(this.process_CitationCluster.call(this, jt.sortedItems, jt)),
          lr.push(jt.citationID),
          Hn.push(lr)
      }
    ;(this.tmp.taintedItemIDs = {}),
      (this.tmp.taintedCitationIDs = {}),
      (this.tmp.citation_pos = e.properties.index),
      (this.tmp.citation_note_index = e.properties.noteIndex),
      (this.tmp.citation_id = '' + e.citationID),
      (lr = []),
      lr.push(t.length),
      lr.push(this.process_CitationCluster.call(this, j, e)),
      lr.push(e.citationID),
      Hn.push(lr),
      Hn.sort(function (da, Pp) {
        return da[0] > Pp[0] ? 1 : da[0] < Pp[0] ? -1 : 0
      })
  }
  return (
    (this.registry.return_data.citation_errors = this.tmp.citation_errors.slice()),
    [this.registry.return_data, Hn]
  )
}
l.Engine.prototype.process_CitationCluster = function (e, t) {
  var r = ''
  if (t && t.properties && t.properties.mode === 'composite') {
    t.properties.mode = 'author-only'
    var i = l.getCitationCluster.call(this, e, t)
    t.properties.mode = 'suppress-author'
    var n = ''
    t.properties.infix &&
      (this.output.append(t.properties.infix),
      (n = this.output.string(this, this.output.queue)),
      typeof n == 'object' && (n = n.join('')))
    var s = l.getCitationCluster.call(this, e, t)
    ;(t.properties.mode = 'composite'),
      i &&
        n &&
        l.SWAPPING_PUNCTUATION.concat(['', "'"]).indexOf(n[0]) > -1 &&
        ((i += n), (n = !1)),
      (r = [i, n, s]
        .filter(function (a) {
          return a
        })
        .join(' '))
  } else r = l.getCitationCluster.call(this, e, t)
  return r
}
l.Engine.prototype.makeCitationCluster = function (e) {
  var t, r, f, i, n, s, a
  for (t = [], n = e.length, i = 0; i < n; i += 1) {
    s = {}
    for (var o in e[i]) s[o] = e[i][o]
    if (
      ((a = this.retrieveItem('' + s.id)),
      this.opt.development_extensions.locator_label_parse &&
        s.locator &&
        ['bill', 'gazette', 'legislation', 'regulation', 'treaty'].indexOf(a.type) === -1 &&
        (!s.label || s.label === 'page'))
    ) {
      var u = l.LOCATOR_LABELS_REGEXP.exec(s.locator)
      if (u) {
        var c = l.LOCATOR_LABELS_MAP[u[2]]
        this.getTerm(c) && ((s.label = c), (s.locator = u[3]))
      }
    }
    s.locator && (s.locator = ('' + s.locator).replace(/\s+$/, '')), (r = [a, s]), t.push(r)
  }
  if (
    (this.opt.development_extensions.consolidate_legal_items && this.remapSectionVariable(t),
    t && t.length > 1 && this.citation_sort.tokens.length > 0)
  ) {
    for (n = t.length, i = 0; i < n; i += 1)
      t[i][1].sortkeys = l.getSortKeys.call(this, t[i][0], 'citation_sort')
    t.sort(this.citation.srt.compareCompositeKeys)
  }
  this.tmp.citation_errors = []
  var f = l.getCitationCluster.call(this, t)
  return f
}
l.getAmbiguousCite = function (e, t, r, i) {
  var p,
    n = this.tmp.group_context.tip,
    s = {
      term_intended: n.term_intended,
      variable_attempt: n.variable_attempt,
      variable_success: n.variable_success,
      output_tip: n.output_tip,
      label_form: n.label_form,
      non_parallel: n.non_parallel,
      parallel_last: n.parallel_last,
      parallel_first: n.parallel_first,
      parallel_last_override: n.parallel_last_override,
      parallel_delimiter_override: n.parallel_delimiter_override,
      parallel_delimiter_override_on_suppress: n.parallel_delimiter_override_on_suppress,
      condition: n.condition,
      force_suppress: n.force_suppress,
      done_vars: n.done_vars.slice(),
    }
  t ? (this.tmp.disambig_request = t) : (this.tmp.disambig_request = !1)
  var a = { position: l.POSITION_SUBSEQUENT, 'near-note': !0 }
  i && ((a.locator = i.locator), (a.label = i.label)),
    this.registry.registry[e.id] &&
      this.registry.citationreg.citationsByItemId &&
      this.registry.citationreg.citationsByItemId[e.id] &&
      this.registry.citationreg.citationsByItemId[e.id].length &&
      r &&
      this.citation.opt['givenname-disambiguation-rule'] === 'by-cite' &&
      (a['first-reference-note-number'] =
        this.registry.registry[e.id]['first-reference-note-number']),
    (this.tmp.area = 'citation'),
    (this.tmp.root = 'citation')
  var o = this.tmp.suppress_decorations
  ;(this.tmp.suppress_decorations = !0),
    (this.tmp.just_looking = !0),
    l.getCite.call(this, e, a, null, !1)
  for (var u = 0, c = this.output.queue.length; u < c; u += 1)
    l.Output.Queue.purgeEmptyBlobs(this.output.queue[u])
  if (this.opt.development_extensions.clean_up_csl_flaws)
    for (var f = 0, h = this.output.queue.length; f < h; f += 1)
      this.output.adjust.upward(this.output.queue[f]),
        this.output.adjust.leftward(this.output.queue[f]),
        this.output.adjust.downward(this.output.queue[f]),
        this.output.adjust.fix(this.output.queue[f])
  var p = this.output.string(this, this.output.queue)
  return (
    (this.tmp.just_looking = !1),
    (this.tmp.suppress_decorations = o),
    this.tmp.group_context.replace(s),
    p
  )
}
l.getSpliceDelimiter = function (e, t, r) {
  if (this.citation.opt['after-collapse-delimiter'] !== void 0)
    e
      ? (this.tmp.splice_delimiter = this.citation.opt['after-collapse-delimiter'])
      : t && !this.tmp.have_collapsed
      ? (this.tmp.splice_delimiter = this.citation.opt['after-collapse-delimiter'])
      : !t && !this.tmp.have_collapsed && this.citation.opt.collapse !== 'year-suffix'
      ? (this.tmp.splice_delimiter = this.citation.opt['after-collapse-delimiter'])
      : (this.tmp.splice_delimiter = this.citation.opt.layout_delimiter)
  else if (this.tmp.use_cite_group_delimiter)
    this.tmp.splice_delimiter = this.citation.opt.cite_group_delimiter
  else if (
    this.tmp.have_collapsed &&
    this.opt.xclass === 'in-text' &&
    this.opt.update_mode !== l.NUMERIC
  )
    this.tmp.splice_delimiter = ', '
  else if (this.tmp.cite_locales[r - 1]) {
    var i = this.tmp.cite_affixes[this.tmp.area][this.tmp.cite_locales[r - 1]]
    i && i.delimiter && (this.tmp.splice_delimiter = i.delimiter)
  } else this.tmp.splice_delimiter || (this.tmp.splice_delimiter = '')
  return this.tmp.splice_delimiter
}
l.getCitationCluster = function (e, t) {
  var r,
    i,
    n,
    s,
    a,
    o,
    u,
    c,
    f,
    h,
    p,
    m,
    v,
    b,
    S,
    g,
    _,
    y,
    x,
    D,
    C,
    H = ''
  ;(this.output.checkNestedBrace = new l.checkNestedBrace(this)),
    t &&
      ((x = t.citationID),
      (D = t.properties.mode === 'author-only' ? !!t.properties.mode : !1),
      this.opt.xclass !== 'note' &&
        (C = t.properties.mode === 'suppress-author' ? !!t.properties.mode : !1),
      t.properties.prefix && (H = l.checkPrefixSpaceAppend(this, t.properties.prefix))),
    (e = e || []),
    (this.tmp.last_primary_names_string = !1),
    (_ = l.getSafeEscape(this)),
    (this.tmp.area = 'citation'),
    (this.tmp.root = 'citation'),
    (r = ''),
    (i = []),
    (this.tmp.last_suffix_used = ''),
    (this.tmp.last_names_used = []),
    (this.tmp.last_years_used = []),
    (this.tmp.backref_index = []),
    (this.tmp.cite_locales = []),
    this.tmp.just_looking || (this.tmp.abbrev_trimmer = { QUASHES: {} })
  var T = this.output.checkNestedBrace.update(this.citation.opt.layout_prefix + H),
    k = !1
  if (
    (this.citation.opt.suppressTrailingPunctuation && (k = !0),
    x &&
      this.registry.citationreg.citationById[x].properties['suppress-trailing-punctuation'] &&
      (k = !0),
    this.opt.xclass === 'note')
  ) {
    for (var O = [], N = !1, M = !1, V = [], j = 0, R = e.length; j < R; j += 1) {
      var $ = e[j][0].type,
        L = e[j][0].title,
        P = e[j][1].position,
        Y = e[j][0].id
      L &&
        $ === 'legal_case' &&
        Y !== M &&
        P &&
        ((L !== N || O.length === 0) && ((V = []), O.push(V)), V.push(e[j][1])),
        (N = L),
        (M = Y)
    }
    for (j = 0, R = O.length; j < R; j += 1)
      if (((V = O[j]), !(V.length < 2))) {
        var w = V.slice(-1)[0].locator
        if (w) for (var q = 0, X = V.length - 1; q < X; q += 1) V[q].locator && (w = !1)
        w &&
          ((V[0].locator = w),
          delete V.slice(-1)[0].locator,
          (V[0].label = V.slice(-1)[0].label),
          V.slice(-1)[0].label && delete V.slice(-1)[0].label)
      }
  }
  for (
    n = [],
      s = e.length,
      e[0] &&
        e[0][1] &&
        (D
          ? (delete e[0][1]['suppress-author'], (e[0][1]['author-only'] = !0))
          : C && (delete e[0][1]['author-only'], (e[0][1]['suppress-author'] = !0))),
      this.opt.parallel.enable && this.parallel.StartCitation(e),
      a = 0;
    a < s;
    a += 1
  ) {
    ;(this.tmp.cite_index = a),
      (m = e[a][0]),
      (o = e[a][1]),
      (o = l.parseLocator.call(this, o)),
      (u = this.tmp.have_collapsed)
    var I = !1
    if (
      (a > 0 && e[a - 1][1] && (I = !!e[a - 1][1].locator),
      (c = {}),
      (this.tmp.shadow_numbers = {}),
      !this.tmp.just_looking && this.opt.hasPlaceholderTerm)
    ) {
      var re = this.output
      ;(this.output = new l.Output.Queue(this)),
        (this.output.adjust = new l.Output.Queue.adjust()),
        l.getAmbiguousCite.call(this, m, null, !1, o),
        (this.output = re)
    }
    if (
      ((this.tmp.in_cite_predecessor = !1),
      a > 0
        ? l.getCite.call(this, m, o, '' + e[a - 1][0].id, !0)
        : ((this.tmp.term_predecessor = !1), l.getCite.call(this, m, o, null, !0)),
      this.tmp.cite_renders_content ||
        ((y = {
          citationID: '' + this.tmp.citation_id,
          index: this.tmp.citation_pos,
          noteIndex: this.tmp.citation_note_index,
          itemID: '' + m.id,
          citationItems_pos: a,
          error_code: l.ERROR_NO_RENDERED_FORM,
        }),
        this.tmp.citation_errors.push(y)),
      (c.splice_delimiter = l.getSpliceDelimiter.call(this, I, u, a)),
      o && o['author-only'] && (this.tmp.suppress_decorations = !0),
      a > 0)
    ) {
      g = e[a - 1][1]
      var ie = g.suffix && [';', '.', ','].indexOf(g.suffix.slice(-1)) > -1,
        Z = !g.suffix && o.prefix && [';', '.', ','].indexOf(o.prefix.slice(0, 1)) > -1
      if (ie || Z) {
        var oe = c.splice_delimiter.indexOf(' ')
        oe > -1 && !Z
          ? (c.splice_delimiter = c.splice_delimiter.slice(oe))
          : (c.splice_delimiter = '')
      }
    }
    if (
      ((c.suppress_decorations = this.tmp.suppress_decorations),
      (c.have_collapsed = this.tmp.have_collapsed),
      n.push(c),
      o['author-only'])
    )
      break
  }
  p = this.output.queue.slice()
  var ce = ''
  t && (ce = l.checkSuffixSpacePrepend(this, t.properties.suffix))
  var fe = this.citation.opt.layout_suffix,
    ge = this.tmp.cite_locales[this.tmp.cite_locales.length - 1]
  ge &&
    this.tmp.cite_affixes[this.tmp.area][ge] &&
    this.tmp.cite_affixes[this.tmp.area][ge].suffix &&
    (fe = this.tmp.cite_affixes[this.tmp.area][ge].suffix),
    l.TERMINAL_PUNCTUATION.slice(0, -1).indexOf(fe.slice(0, 1)) > -1 && (fe = fe.slice(0, 1)),
    (fe = this.output.checkNestedBrace.update(ce + fe))
  for (var j = 0, R = this.output.queue.length; j < R; j += 1)
    l.Output.Queue.purgeEmptyBlobs(this.output.queue[j])
  if (
    (!this.tmp.suppress_decorations &&
      this.output.queue.length &&
      ((this.opt.development_extensions.apply_citation_wrapper &&
        this.sys.wrapCitationEntry &&
        !this.tmp.just_looking &&
        this.tmp.area === 'citation') ||
        (k || (this.output.queue[this.output.queue.length - 1].strings.suffix = fe),
        (this.output.queue[0].strings.prefix = T))),
    this.opt.development_extensions.clean_up_csl_flaws)
  )
    for (var q = 0, X = this.output.queue.length; q < X; q += 1)
      this.output.adjust.upward(this.output.queue[q]),
        this.output.adjust.leftward(this.output.queue[q]),
        this.output.adjust.downward(this.output.queue[q]),
        (this.tmp.last_chr = this.output.adjust.fix(this.output.queue[q]))
  for (a = 0, s = p.length; a < s; a += 1) {
    var me = []
    if (
      ((this.output.queue = [p[a]]),
      (this.tmp.suppress_decorations = n[a].suppress_decorations),
      (this.tmp.splice_delimiter = n[a].splice_delimiter),
      p[a].parallel_delimiter && (this.tmp.splice_delimiter = p[a].parallel_delimiter),
      (this.tmp.have_collapsed = n[a].have_collapsed),
      (f = this.output.string(this, this.output.queue)),
      (this.tmp.suppress_decorations = !1),
      typeof f == 'string')
    )
      return (
        (this.tmp.suppress_decorations = !1),
        f ||
          (this.opt.development_extensions.throw_on_empty
            ? l.error('Citation would render no content')
            : (f = '[NO_PRINTED_FORM]')),
        f
      )
    if (typeof f == 'object' && f.length === 0 && !o['suppress-author']) {
      if (a === 0) {
        var be = '[CSL STYLE ERROR: reference with no printed form.]',
          Ne = a === 0 ? _(this.citation.opt.layout_prefix) : '',
          Oe = a === p.length - 1 ? _(this.citation.opt.layout_suffix) : ''
        f.push(Ne + be + Oe)
      } else if (a === p.length - 1) {
        var _e = i[i.length - 1]
        typeof _e == 'string'
          ? (i[i.length - 1] += _(this.citation.opt.layout_suffix))
          : typeof _e == 'object' && (_e.strings.suffix += _(this.citation.opt.layout_suffix))
      }
    }
    if (me.length && typeof f[0] == 'string') {
      f.reverse()
      var F = f.pop()
      F && F.slice(0, 1) === ','
        ? me.push(F)
        : typeof me.slice(-1)[0] == 'string' && me.slice(-1)[0].slice(-1) === ','
        ? me.push(' ' + F)
        : F && me.push(_(this.tmp.splice_delimiter) + F)
    } else
      f.reverse(),
        (h = f.pop()),
        typeof h < 'u' &&
          (me.length &&
            typeof me[me.length - 1] == 'string' &&
            (me[me.length - 1] += h.successor_prefix),
          me.push(h))
    for (v = f.length, b = 0; b < v; b += 1) {
      if (((S = f[b]), typeof S == 'string')) {
        me.push(_(this.tmp.splice_delimiter) + S)
        continue
      }
      ;(h = f.pop()), typeof h < 'u' && me.push(h)
    }
    me.length === 0 && e[a][1]['suppress-author'],
      me.length > 1 && typeof me[0] != 'string' && (me = [this.output.renderBlobs(me)]),
      me.length &&
        (typeof me[0] == 'string'
          ? a > 0 && (me[0] = _(this.tmp.splice_delimiter) + me[0])
          : a > 0
          ? (me[0].splice_prefix = this.tmp.splice_delimiter)
          : (me[0].splice_prefix = '')),
      (i = i.concat(me))
  }
  if (((r += this.output.renderBlobs(i)), r && !this.tmp.suppress_decorations))
    for (s = this.citation.opt.layout_decorations.length, a = 0; a < s; a += 1)
      (c = this.citation.opt.layout_decorations[a]),
        c[1] !== 'normal' &&
          (!o || !o['author-only']) &&
          (r = this.fun.decorate[c[0]][c[1]](this, r))
  return (
    (this.tmp.suppress_decorations = !1),
    r ||
      (this.opt.development_extensions.throw_on_empty
        ? l.error('Citation would render no content')
        : (r = '[NO_PRINTED_FORM]')),
    r
  )
}
l.getCite = function (e, t, r, i) {
  var n,
    s,
    a = this.tmp.area
  for (
    t &&
      t['author-only'] &&
      this.intext &&
      this.intext.tokens.length > 0 &&
      (this.tmp.area = 'intext'),
      this.tmp.cite_renders_content = !1,
      this.tmp.probably_rendered_something = !1,
      this.tmp.prevItemID = r,
      l.citeStart.call(this, e, t, i),
      n = 0,
      this.tmp.name_node = {},
      this.nameOutput = new l.NameOutput(this, e, t);
    n < this[this.tmp.area].tokens.length;

  )
    n = l.tokenExec.call(this, this[this.tmp.area].tokens[n], e, t)
  return (
    l.citeEnd.call(this, e, t),
    !this.tmp.cite_renders_content &&
      !this.tmp.just_looking &&
      this.tmp.area === 'bibliography' &&
      ((s = {
        index: this.tmp.bibliography_pos,
        itemID: '' + e.id,
        error_code: l.ERROR_NO_RENDERED_FORM,
      }),
      this.tmp.bibliography_errors.push(s)),
    (this.tmp.area = a),
    '' + e.id
  )
}
l.citeStart = function (e, t, r) {
  if (((this.tmp.lang_array = []), e.language)) {
    var i = e.language.match(/^([a-zA-Z]+).*/)
    i && this.tmp.lang_array.push(i[1].toLowerCase())
  }
  if (
    (this.tmp.lang_array.push(this.opt.lang),
    r || (this.tmp.shadow_numbers = {}),
    (this.tmp.disambiguate_count = 0),
    (this.tmp.disambiguate_maxMax = 0),
    (this.tmp.same_author_as_previous_cite = !1),
    this.tmp.suppress_decorations
      ? (this.tmp.subsequent_author_substitute_ok = !1)
      : (this.tmp.subsequent_author_substitute_ok = !0),
    (this.tmp.lastchr = ''),
    this.tmp.area === 'citation' && this.citation.opt.collapse && this.citation.opt.collapse.length
      ? (this.tmp.have_collapsed = !0)
      : (this.tmp.have_collapsed = !1),
    (this.tmp.render_seen = !1),
    this.tmp.disambig_request && !this.tmp.disambig_override
      ? (this.tmp.disambig_settings = this.tmp.disambig_request)
      : this.registry.registry[e.id] && !this.tmp.disambig_override
      ? ((this.tmp.disambig_request = this.registry.registry[e.id].disambig),
        (this.tmp.disambig_settings = this.registry.registry[e.id].disambig))
      : (this.tmp.disambig_settings = new l.AmbigConfig()),
    this.tmp.area !== 'citation')
  ) {
    if (!this.registry.registry[e.id]) this.tmp.disambig_restore = new l.AmbigConfig()
    else if (
      ((this.tmp.disambig_restore = l.cloneAmbigConfig(this.registry.registry[e.id].disambig)),
      this.tmp.area === 'bibliography' &&
        this.tmp.disambig_settings &&
        this.tmp.disambig_override &&
        (this.opt['disambiguate-add-names'] &&
          ((this.tmp.disambig_settings.names = this.registry.registry[e.id].disambig.names.slice()),
          this.tmp.disambig_request &&
            (this.tmp.disambig_request.names =
              this.registry.registry[e.id].disambig.names.slice())),
        this.opt['disambiguate-add-givenname']))
    ) {
      ;(this.tmp.disambig_request = this.tmp.disambig_settings),
        (this.tmp.disambig_settings.givens = this.registry.registry[e.id].disambig.givens.slice()),
        (this.tmp.disambig_request.givens = this.registry.registry[e.id].disambig.givens.slice())
      for (var n = 0, s = this.tmp.disambig_settings.givens.length; n < s; n += 1)
        this.tmp.disambig_settings.givens[n] =
          this.registry.registry[e.id].disambig.givens[n].slice()
      for (var n = 0, s = this.tmp.disambig_request.givens.length; n < s; n += 1)
        this.tmp.disambig_request.givens[n] =
          this.registry.registry[e.id].disambig.givens[n].slice()
    }
  }
  ;(this.tmp.names_used = []),
    (this.tmp.nameset_counter = 0),
    (this.tmp.years_used = []),
    this.tmp.names_max.clear(),
    this.tmp.just_looking ||
      ((!t || t.parallel === 'first' || !t.parallel) &&
        (this.tmp.abbrev_trimmer = { QUASHES: {} })),
    (this.tmp.splice_delimiter = this[this.tmp.area].opt.layout_delimiter),
    (this.bibliography_sort.keys = []),
    (this.citation_sort.keys = []),
    (this.tmp.has_done_year_suffix = !1),
    (this.tmp.last_cite_locale = !1),
    !this.tmp.just_looking &&
      t &&
      !t.position &&
      this.registry.registry[e.id] &&
      (this.tmp.disambig_restore = l.cloneAmbigConfig(this.registry.registry[e.id].disambig)),
    (this.tmp.first_name_string = !1),
    (this.tmp.authority_stop_last = 0)
}
l.citeEnd = function (e, t) {
  if (this.tmp.disambig_restore && this.registry.registry[e.id]) {
    ;(this.registry.registry[e.id].disambig.names = this.tmp.disambig_restore.names.slice()),
      (this.registry.registry[e.id].disambig.givens = this.tmp.disambig_restore.givens.slice())
    for (var r = 0, i = this.registry.registry[e.id].disambig.givens.length; r < i; r += 1)
      this.registry.registry[e.id].disambig.givens[r] = this.tmp.disambig_restore.givens[r].slice()
  }
  if (
    ((this.tmp.disambig_restore = !1),
    t && t.suffix ? (this.tmp.last_suffix_used = t.suffix) : (this.tmp.last_suffix_used = ''),
    (this.tmp.last_years_used = this.tmp.years_used.slice()),
    (this.tmp.last_names_used = this.tmp.names_used.slice()),
    (this.tmp.cut_var = !1),
    (this.tmp.disambig_request = !1),
    this.tmp.cite_locales.push(this.tmp.last_cite_locale),
    this.tmp.issued_date && this.tmp.renders_collection_number)
  ) {
    for (
      var n = [], r = this.tmp.issued_date.list.length - 1;
      r > this.tmp.issued_date.pos;
      r += -1
    )
      n.push(this.tmp.issued_date.list.pop())
    for (this.tmp.issued_date.list.pop(), r = n.length - 1; r > -1; r += -1)
      this.tmp.issued_date.list.push(n.pop())
  }
  ;(this.tmp.issued_date = !1), (this.tmp.renders_collection_number = !1)
}
l.Engine.prototype.makeBibliography = function (e) {
  var t, r, i, n, s, a, o, u, c
  if (
    ((t = !1),
    !e && (this.bibliography.opt.exclude_types || this.bibliography.opt.exclude_with_fields))
  ) {
    if (((e = { exclude: [] }), this.bibliography.opt.exclude_types))
      for (var f in this.bibliography.opt.exclude_types) {
        var h = this.bibliography.opt.exclude_types[f]
        e.exclude.push({ field: 'type', value: h })
      }
    if (this.bibliography.opt.exclude_with_fields)
      for (var f in this.bibliography.opt.exclude_with_fields) {
        var p = this.bibliography.opt.exclude_with_fields[f]
        e.exclude.push({ field: p, value: !0 })
      }
  }
  if (!this.bibliography.tokens.length) return !1
  if ((typeof e == 'string' && ((this.opt.citation_number_slug = e), (e = !1)), t)) {
    for (s = this.bibliography.tokens.length, a = 0; a < s; a += 1)
      (o = this.bibliography.tokens[a]), l.debug('bibtok: ' + o.name)
    for (l.debug('---'), s = this.citation.tokens.length, a = 0; a < s; a += 1)
      this.citation.tokens[a], l.debug('cittok: ' + o.name)
    for (l.debug('---'), s = this.bibliography_sort.tokens.length, a = 0; a < s; a += 1)
      this.bibliography_sort.tokens[a], l.debug('bibsorttok: ' + o.name)
  }
  ;(r = l.getBibliographyEntries.call(this, e)), (u = r[0]), (c = r[1])
  var m = r[2]
  for (
    i = {
      maxoffset: 0,
      entryspacing: this.bibliography.opt['entry-spacing'],
      linespacing: this.bibliography.opt['line-spacing'],
      'second-field-align': !1,
      entry_ids: u,
      bibliography_errors: this.tmp.bibliography_errors.slice(),
      done: m,
    },
      this.bibliography.opt['second-field-align'] &&
        (i['second-field-align'] = this.bibliography.opt['second-field-align']),
      s = this.registry.reflist.length,
      a = 0;
    a < s;
    a += 1
  )
    (n = this.registry.reflist[a]), n.offset > i.maxoffset && (i.maxoffset = n.offset)
  return (
    this.bibliography.opt.hangingindent && (i.hangingindent = this.bibliography.opt.hangingindent),
    (i.bibstart = this.fun.decorate.bibstart),
    (i.bibend = this.fun.decorate.bibend),
    (this.opt.citation_number_slug = !1),
    [i, c]
  )
}
l.getBibliographyEntries = function (e) {
  var t, r, i, n, s, a, o, u, c, f, h, p, m, v, b, S, g, _, y, x, D
  ;(t = []),
    (y = []),
    (this.tmp.area = 'bibliography'),
    (this.tmp.root = 'bibliography'),
    (this.tmp.last_rendered_name = !1),
    (this.tmp.bibliography_errors = []),
    (this.tmp.bibliography_pos = 0),
    e && e.page_start && e.page_length
      ? (r = this.registry.getSortedIds())
      : (r = this.refetchItems(this.registry.getSortedIds())),
    (this.tmp.disambig_override = !0)
  function C($, L) {
    return $ === L
  }
  function H($, L) {
    for (f = L.length, h = 0; h < f; h += 1) if (C($, L[h])) return !0
    return !1
  }
  function T($, L) {
    return typeof $ == 'boolean' || !$
      ? $
        ? !!L
        : !L
      : typeof L == 'string'
      ? C($, L)
      : L
      ? H($, L)
      : !1
  }
  g = {}
  var k
  if (e && e.page_start && e.page_length && ((k = 0), e.page_start !== !0))
    for (v = 0, b = r.length; v < b && ((g[r[v]] = !0), e.page_start != r[v]); v += 1);
  var O = [],
    N = {}
  for (
    this.tmp.container_item_count = {},
      r = r.filter(($) => {
        var L = $
        return (
          $.legislation_id
            ? N[$.legislation_id]
              ? (L = !1)
              : (N[$.legislation_id] = !0)
            : $.container_id &&
              (this.tmp.container_item_count[$.container_id] ||
                (this.tmp.container_item_count[$.container_id] = 0),
              this.tmp.container_item_count[$.container_id]++,
              this.bibliography.opt.consolidate_containers.indexOf($.type) > -1 &&
                (N[$.container_id] ? (L = !1) : (N[$.container_id] = !0))),
          L
        )
      }),
      this.tmp.container_item_pos = {},
      v = 0,
      b = r.length;
    v < b;
    v += 1
  ) {
    if (e && e.page_start && e.page_length) {
      if (g[r[v]]) continue
      if (((u = this.refetchItem(r[v])), k === e.page_length)) break
    } else if (((u = r[v]), g[u.id])) continue
    if (e) {
      if (((i = !0), e.include)) {
        for (i = !1, x = 0, D = e.include.length; x < D; x += 1)
          if (((c = e.include[x]), T(c.value, u[c.field]))) {
            i = !0
            break
          }
      } else if (e.exclude) {
        for (n = !1, x = 0, D = e.exclude.length; x < D; x += 1)
          if (((c = e.exclude[x]), T(c.value, u[c.field]))) {
            n = !0
            break
          }
        n && (i = !1)
      } else if (e.select) {
        for (i = !1, s = !0, x = 0, D = e.select.length; x < D; x += 1)
          (c = e.select[x]), T(c.value, u[c.field]) || (s = !1)
        s && (i = !0)
      }
      if (e.quash) {
        for (s = !0, x = 0, D = e.quash.length; x < D; x += 1)
          (c = e.quash[x]), T(c.value, u[c.field]) || (s = !1)
        s && (i = !1)
      }
      if (!i) continue
    }
    if (
      (u.container_id &&
        (this.tmp.container_item_pos[u.container_id] ||
          (this.tmp.container_item_pos[u.container_id] = 0),
        this.tmp.container_item_pos[u.container_id]++),
      (a = new l.Token('group', l.START)),
      (a.decorations = [['@bibliography', 'entry']].concat(
        this.bibliography.opt.layout_decorations
      )),
      this.output.startTag('bib_entry', a),
      u.system_id && this.sys.embedBibliographyEntry
        ? (this.output.current.value().item_id = u.system_id)
        : (this.output.current.value().system_id = u.id),
      (m = []),
      this.registry.registry[u.id].master && !(e && e.page_start && e.page_length))
    ) {
      ;(_ = [[u, { id: u.id }]]), (S = this.registry.registry[u.id].siblings)
      for (var x = 0, D = S.length; x < D; x++) _.push([this.refetchItem(S[x]), { id: S[x] }])
      for (
        this.parallel.StartCitation(_),
          this.registry.registry[u.id].parallel_delimiter_override
            ? (this.output.queue[0].strings.delimiter =
                this.registry.registry[u.id].parallel_delimiter_override)
            : (this.output.queue[0].strings.delimiter = ', '),
          this.tmp.term_predecessor = !1,
          this.tmp.cite_index = 0,
          x = 0,
          D = _.length;
        x < D;
        x += 1
      )
        x < _.length - 1
          ? (this.tmp.parallel_and_not_last = !0)
          : delete this.tmp.parallel_and_not_last,
          m.push('' + l.getCite.call(this, _[x][0], _[x][1])),
          this.tmp.cite_index++,
          (g[_[x][0].id] = !0)
    } else
      this.registry.registry[u.id].siblings ||
        ((this.tmp.term_predecessor = !1),
        (this.tmp.cite_index = 0),
        m.push('' + l.getCite.call(this, u)),
        e && e.page_start && e.page_length && (k += 1))
    for (
      y.push(''),
        this.tmp.bibliography_pos += 1,
        O.push(m),
        this.output.endTag('bib_entry'),
        this.output.queue[0].blobs.length &&
          this.output.queue[0].blobs[0].blobs.length &&
          (this.output.queue[0].blobs[0].blobs[0].strings
            ? (p = this.output.queue[0].blobs[0].blobs)
            : (p = this.output.queue[0].blobs),
          (p[0].strings.prefix = this.bibliography.opt.layout_prefix + p[0].strings.prefix)),
        x = 0,
        D = this.output.queue.length;
      x < D;
      x += 1
    )
      l.Output.Queue.purgeEmptyBlobs(this.output.queue[x])
    for (x = 0, D = this.output.queue.length; x < D; x += 1)
      this.output.adjust.upward(this.output.queue[x]),
        this.output.adjust.leftward(this.output.queue[x]),
        this.output.adjust.downward(this.output.queue[x], !0),
        this.output.adjust.fix(this.output.queue[x])
    if (
      ((o = this.output.string(this, this.output.queue)[0]),
      !o && this.opt.update_mode === l.NUMERIC)
    ) {
      var M = t.length + 1 + '. [CSL STYLE ERROR: reference with no printed form.]'
      o = l.Output.Formats[this.opt.mode]['@bibliography/entry'](this, M)
    }
    o && t.push(o)
  }
  var V = !1
  if (e && e.page_start && e.page_length) {
    var j = r.slice(-1)[0],
      R = O.slice(-1)[0]
    ;(!j || !R || j == R) && (V = !0)
  }
  return (this.tmp.disambig_override = !1), [O, t, V]
}
l.Engine.prototype.setCitationId = function (e, t) {
  var r, i, n
  if (((r = !1), !e.citationID || t)) {
    for (i = Math.floor(Math.random() * 1e14); ; ) {
      if (((n = 0), this.registry.citationreg.citationById[i])) !n && i < 5e13 ? (n = 1) : (n = -1)
      else {
        e.citationID = 'a' + i.toString(32)
        break
      }
      n === 1 ? (i += 1) : (i += -1)
    }
    r = '' + i
  }
  return (this.registry.citationreg.citationById[e.citationID] = e), r
}
l.Engine.prototype.rebuildProcessorState = function (e, t, r) {
  e || (e = []), t || (t = 'html')
  for (var i = {}, n = [], s = 0, a = e.length; s < a; s += 1)
    for (var o = 0, u = e[s].citationItems.length; o < u; o += 1) {
      var c = '' + e[s].citationItems[o].id
      i[c] || n.push(c), (i[c] = !0)
    }
  this.updateItems(n)
  var f = [],
    h = [],
    p = [],
    m = this.opt.mode
  this.setOutputFormat(t)
  for (var s = 0, a = e.length; s < a; s += 1) {
    var v = this.processCitationCluster(e[s], f, h, l.ASSUME_ALL_ITEMS_REGISTERED)
    f.push([e[s].citationID, e[s].properties.noteIndex])
    for (var o = 0, u = v[1].length; o < u; o += 1) {
      var b = v[1][o][0]
      p[b] = [f[b][0], f[b][1], v[1][o][1]]
    }
  }
  return this.updateUncitedItems(r), this.setOutputFormat(m), p
}
l.Engine.prototype.restoreProcessorState = function (e) {
  var t, r, i, n, s, a, o, u, c, f
  ;(u = []), (c = []), e || (e = [])
  var h = [],
    p = {}
  for (t = 0, r = e.length; t < r; t += 1)
    p[e[t].citationID] && this.setCitationId(e[t], !0),
      (p[e[t].citationID] = !0),
      h.push(e[t].properties.index)
  var m = e.slice()
  for (
    m.sort(function (b, S) {
      return b.properties.index < S.properties.index
        ? -1
        : b.properties.index > S.properties.index
        ? 1
        : 0
    }),
      t = 0,
      r = m.length;
    t < r;
    t += 1
  )
    m[t].properties.index = t
  for (t = 0, r = m.length; t < r; t += 1) {
    for (f = [], i = 0, n = m[t].citationItems.length; i < n; i += 1)
      (s = m[t].citationItems[i]),
        typeof s.sortkeys > 'u' && (s.sortkeys = []),
        (a = this.retrieveItem('' + s.id)),
        (o = [a, s]),
        f.push(o),
        (m[t].citationItems[i].item = a),
        c.push('' + s.id)
    m[t].properties.unsorted || f.sort(this.citation.srt.compareCompositeKeys),
      (m[t].sortedItems = f),
      (this.registry.citationreg.citationById[m[t].citationID] = m[t])
  }
  for (this.updateItems(c), t = 0, r = e.length; t < r; t += 1)
    u.push(['' + e[t].citationID, e[t].properties.noteIndex])
  var v = []
  return (
    e && e.length
      ? (v = this.processCitationCluster(e[0], [], u.slice(1)))
      : ((this.registry = new l.Registry(this)),
        (this.tmp = new l.Engine.Tmp()),
        (this.disambiguate = new l.Disambiguation(this))),
    v
  )
}
l.Engine.prototype.updateItems = function (e, t, r, i) {
  var n = this.tmp.area,
    s = this.tmp.root,
    a = this.tmp.extension
  if (
    (this.bibliography_sort.tokens.length === 0 && (t = !0),
    (this.tmp.area = 'citation'),
    (this.tmp.root = 'citation'),
    (this.tmp.extension = ''),
    i || (this.tmp.loadedItemIDs = {}),
    this.registry.init(e),
    r)
  )
    for (var o in this.registry.ambigcites) this.registry.ambigsTouched[o] = !0
  return (
    this.registry.dodeletes(this.registry.myhash),
    this.registry.doinserts(this.registry.mylist),
    this.registry.dorefreshes(),
    this.registry.rebuildlist(t),
    this.registry.setsortkeys(),
    this.registry.setdisambigs(),
    this.registry.sorttokens(t),
    this.registry.renumber(),
    (this.tmp.extension = a),
    (this.tmp.area = n),
    (this.tmp.root = s),
    this.registry.getSortedIds()
  )
}
l.Engine.prototype.updateUncitedItems = function (e, t) {
  var r,
    i = this.tmp.area,
    n = this.tmp.root,
    s = this.tmp.extension
  if (
    (this.bibliography_sort.tokens.length === 0 && (t = !0),
    (this.tmp.area = 'citation'),
    (this.tmp.root = 'citation'),
    (this.tmp.extension = ''),
    (this.tmp.loadedItemIDs = {}),
    e || (e = []),
    typeof e == 'object')
  ) {
    if (typeof e.length > 'u') {
      ;(r = e), (e = [])
      for (var a in r) e.push(a)
    } else if (typeof e.length == 'number') {
      r = {}
      for (var o = 0, u = e.length; o < u; o += 1) r[e[o]] = !0
    }
  }
  return (
    this.registry.init(e, !0),
    this.registry.dopurge(r),
    this.registry.doinserts(this.registry.mylist),
    this.registry.dorefreshes(),
    this.registry.rebuildlist(t),
    this.registry.setsortkeys(),
    this.registry.setdisambigs(),
    this.registry.sorttokens(t),
    this.registry.renumber(),
    (this.tmp.extension = s),
    (this.tmp.area = i),
    (this.tmp.root = n),
    this.registry.getSortedIds()
  )
}
l.localeResolve = function (e, t) {
  var r, i
  return (
    t || (t = 'en-US'),
    e || (e = t),
    (r = {}),
    (i = e.split(/[\-_]/)),
    (r.base = l.LANG_BASES[i[0]]),
    typeof r.base > 'u'
      ? { base: t, best: e, bare: i[0] }
      : (i.length === 1 && (r.generic = !0),
        i.length === 1 || i[1] === 'x'
          ? (r.best = r.base.replace('_', '-'))
          : (r.best = i.slice(0, 2).join('-')),
        (r.base = r.base.replace('_', '-')),
        (r.bare = i[0]),
        r)
  )
}
l.Engine.prototype.localeConfigure = function (e, t) {
  var r
  if (
    !(t && this.locale[e.best]) &&
    (e.best === 'en-US'
      ? ((r = l.setupXml(this.sys.retrieveLocale('en-US'))), this.localeSet(r, 'en-US', e.best))
      : e.best !== 'en-US' &&
        (e.base !== e.best &&
          ((r = l.setupXml(this.sys.retrieveLocale(e.base))), this.localeSet(r, e.base, e.best)),
        (r = l.setupXml(this.sys.retrieveLocale(e.best))),
        this.localeSet(r, e.best, e.best)),
    this.localeSet(this.cslXml, '', e.best),
    this.localeSet(this.cslXml, e.bare, e.best),
    e.base !== e.best && this.localeSet(this.cslXml, e.base, e.best),
    this.localeSet(this.cslXml, e.best, e.best),
    typeof this.locale[e.best].terms['page-range-delimiter'] > 'u' &&
      (['fr', 'pt'].indexOf(e.best.slice(0, 2).toLowerCase()) > -1
        ? (this.locale[e.best].terms['page-range-delimiter'] = '-')
        : (this.locale[e.best].terms['page-range-delimiter'] = '')),
    typeof this.locale[e.best].terms['year-range-delimiter'] > 'u' &&
      (this.locale[e.best].terms['year-range-delimiter'] = ''),
    typeof this.locale[e.best].terms['citation-range-delimiter'] > 'u' &&
      (this.locale[e.best].terms['citation-range-delimiter'] = ''),
    this.opt.development_extensions.normalize_lang_keys_to_lowercase)
  ) {
    for (
      var i = ['default-locale', 'locale-sort', 'locale-translit', 'locale-translat'],
        n = 0,
        s = i.length;
      n < s;
      n += 1
    )
      for (var a = 0, o = this.opt[i[n]].length; a < o; a += 1)
        this.opt[i[n]][a] = this.opt[i[n]][a].toLowerCase()
    this.opt.lang = this.opt.lang.toLowerCase()
  }
}
l.Engine.prototype.localeSet = function (e, t, r) {
  var i, n, s, a, o, u, c, f, h, p, m, v, b, S, g, _
  if (
    ((t = t.replace('_', '-')),
    (r = r.replace('_', '-')),
    this.opt.development_extensions.normalize_lang_keys_to_lowercase &&
      ((t = t.toLowerCase()), (r = r.toLowerCase())),
    this.locale[r] ||
      ((this.locale[r] = {}),
      (this.locale[r].terms = {}),
      (this.locale[r].opts = {}),
      (this.locale[r].opts['skip-words'] = l.SKIP_WORDS),
      this.locale[r].opts['leading-noise-words'] ||
        (this.locale[r].opts['leading-noise-words'] = []),
      (this.locale[r].dates = {}),
      (this.locale[r].ord = { '1.0.1': !1, keys: {} }),
      (this.locale[r]['noun-genders'] = {})),
    (n = e.makeXml()),
    e.nodeNameIs(e.dataObj, 'locale'))
  )
    n = e.dataObj
  else {
    s = e.getNodesByName(e.dataObj, 'locale')
    var y = !1
    for (o = 0, v = e.numberofnodes(s); o < v; o += 1)
      if (((i = s[o]), !y && e.getAttributeValue(i, 'lang', 'xml') === t)) (n = i), (y = !0)
      else {
        var x = e.getAttributeValue(i, 'lang', 'xml'),
          D = e.getNodesByName(i, 'style-options')
        if (x && D && D.length) {
          var C = e.getAttributeValue(D[0], 'jurisdiction-preference')
          C &&
            (this.locale[x] || (this.locale[x] = { opts: {} }),
            (this.locale[x].opts['jurisdiction-preference'] = C.split(/\s+/)))
        }
      }
  }
  for (s = e.getNodesByName(n, 'type'), g = 0, _ = e.numberofnodes(s); g < _; g += 1) {
    var H = s[g],
      T = e.getAttributeValue(H, 'name'),
      k = e.getAttributeValue(H, 'gender')
    this.opt.gender[T] = k
  }
  var O = e.getNodesByName(n, 'term', 'ordinal').length
  if (O) {
    for (var N in this.locale[r].ord.keys) delete this.locale[r].terms[N]
    this.locale[r].ord = { '1.0.1': !1, keys: {} }
  }
  s = e.getNodesByName(n, 'term')
  var M = { 'last-digit': {}, 'last-two-digits': {}, 'whole-number': {} },
    V = !1,
    j = {}
  for (o = 0, v = e.numberofnodes(s); o < v; o += 1) {
    if (
      ((u = s[o]),
      (f = e.getAttributeValue(u, 'name')),
      f === 'sub verbo' && (f = 'sub-verbo'),
      f.slice(0, 7) === 'ordinal')
    ) {
      if (f === 'ordinal') V = !0
      else {
        var R = e.getAttributeValue(u, 'match'),
          $ = f.slice(8),
          b = e.getAttributeValue(u, 'gender-form')
        b || (b = 'neuter'),
          R || ((R = 'last-two-digits'), $.slice(0, 1) === '0' && (R = 'last-digit')),
          $.slice(0, 1) === '0' && ($ = $.slice(1)),
          M[R][$] || (M[R][$] = {}),
          (M[R][$][b] = f)
      }
      this.locale[r].ord.keys[f] = !0
    }
    typeof this.locale[r].terms[f] > 'u' && (this.locale[r].terms[f] = {}),
      (c = 'long'),
      (b = !1),
      e.getAttributeValue(u, 'form') && (c = e.getAttributeValue(u, 'form')),
      e.getAttributeValue(u, 'gender-form') && (b = e.getAttributeValue(u, 'gender-form')),
      e.getAttributeValue(u, 'gender') &&
        (this.locale[r]['noun-genders'][f] = e.getAttributeValue(u, 'gender')),
      b
        ? ((this.locale[r].terms[f][b] = {}),
          (this.locale[r].terms[f][b][c] = []),
          (S = this.locale[r].terms[f][b]),
          (j[f] = !0))
        : ((this.locale[r].terms[f][c] = []), (S = this.locale[r].terms[f])),
      e.numberofnodes(e.getNodesByName(u, 'multiple'))
        ? ((S[c][0] = e.getNodeValue(u, 'single')),
          S[c][0].indexOf('%s') > -1 && (this.opt.hasPlaceholderTerm = !0),
          (S[c][1] = e.getNodeValue(u, 'multiple')),
          S[c][1].indexOf('%s') > -1 && (this.opt.hasPlaceholderTerm = !0))
        : ((S[c] = e.getNodeValue(u)),
          S[c].indexOf('%s') > -1 && (this.opt.hasPlaceholderTerm = !0))
  }
  if (
    (this.locale[r].terms.supplement || (this.locale[r].terms.supplement = {}),
    this.locale[r].terms.supplement.long ||
      (this.locale[r].terms.supplement.long = ['supplement', 'supplements']),
    V)
  ) {
    for (var L in j) {
      var P = {},
        Y = 0
      for (var w in this.locale[r].terms[L])
        ['masculine', 'feminine'].indexOf(w) > -1 ? (P[w] = this.locale[r].terms[L][w]) : (Y += 1)
      if (!Y) {
        if (P.feminine) for (var w in P.feminine) this.locale[r].terms[L][w] = P.feminine[w]
        else if (P.masculine) for (var w in P.masculine) this.locale[r].terms[L][w] = P.masculine[w]
      }
    }
    this.locale[r].ord['1.0.1'] = M
  }
  for (f in this.locale[r].terms)
    for (g = 0, _ = 2; g < _; g += 1)
      if (((b = l.GENDERS[g]), this.locale[r].terms[f][b]))
        for (c in this.locale[r].terms[f])
          this.locale[r].terms[f][b][c] ||
            (this.locale[r].terms[f][b][c] = this.locale[r].terms[f][c])
  for (s = e.getNodesByName(n, 'style-options'), o = 0, v = e.numberofnodes(s); o < v; o += 1) {
    ;(h = s[o]), (a = e.attributes(h))
    for (m in a)
      if (a.hasOwnProperty(m)) {
        if (m === '@punctuation-in-quote' || m === '@limit-day-ordinals-to-day-1')
          a[m] === 'true'
            ? (this.locale[r].opts[m.slice(1)] = !0)
            : (this.locale[r].opts[m.slice(1)] = !1)
        else if (m === '@jurisdiction-preference') {
          var q = a[m].split(/\s+/)
          this.locale[r].opts[m.slice(1)] = q
        } else if (m === '@skip-words') {
          var X = a[m].split(/\s*,\s*/)
          this.locale[r].opts[m.slice(1)] = X
        } else if (m === '@leading-noise-words') {
          var I = a[m].split(/\s*,\s*/)
          this.locale[r].opts['leading-noise-words'] = I
        } else if (m === '@name-as-sort-order') {
          this.locale[r].opts['name-as-sort-order'] = {}
          for (var re = a[m].split(/\s+/), g = 0, _ = re.length; g < _; g += 1)
            this.locale[r].opts['name-as-sort-order'][re[g]] = !0
        } else if (m === '@name-as-reverse-order') {
          this.locale[r].opts['name-as-reverse-order'] = {}
          for (var re = a[m].split(/\s+/), g = 0, _ = re.length; g < _; g += 1)
            this.locale[r].opts['name-as-reverse-order'][re[g]] = !0
        } else if (m === '@name-never-short') {
          this.locale[r].opts['name-never-short'] = {}
          for (var re = a[m].split(/\s+/), g = 0, _ = re.length; g < _; g += 1)
            this.locale[r].opts['name-never-short'][re[g]] = !0
        }
      }
  }
  for (s = e.getNodesByName(n, 'date'), o = 0, v = e.numberofnodes(s); o < v; o += 1) {
    var p = s[o]
    this.locale[r].dates[e.getAttributeValue(p, 'form')] = p
  }
  l.SET_COURT_CLASSES(this, r, e, n)
}
l.getLocaleNames = function (e, t) {
  var r = l.setupXml(e)
  function i(h, p) {
    var m = ['base', 'best']
    if (p)
      for (var v = l.localeResolve(p), b = 0, S = m.length; b < S; b++)
        v[m[b]] && h.indexOf(v[m[b]]) === -1 && h.push(v[m[b]])
  }
  var n = ['en-US']
  function s(h) {
    for (var p = r.getNodesByName(r.dataObj, h), m = 0, v = p.length; m < v; m++) {
      var b = r.getAttributeValue(p[m], 'locale')
      if (b) {
        b = b.split(/ +/)
        for (var S = 0, g = b.length; S < g; S++) this.extendLocaleList(n, b[S])
      }
    }
  }
  i(n, t)
  var a = r.getNodesByName(r.dataObj, 'style')[0],
    o = r.getAttributeValue(a, 'default-locale')
  i(n, o)
  for (var u = ['layout', 'if', 'else-if', 'condition'], c = 0, f = u.length; c < f; c++) s(r)
  return n
}
l.Node = {}
l.Node.bibliography = {
  build: function (e, t) {
    if (this.tokentype === l.START) {
      ;(e.build.area = 'bibliography'), (e.build.root = 'bibliography'), (e.build.extension = '')
      var r = function (i) {
        ;(i.tmp.area = 'bibliography'), (i.tmp.root = 'bibliography'), (i.tmp.extension = '')
      }
      this.execs.push(r)
    }
    t.push(this)
  },
}
l.Node.choose = {
  build: function (e, t) {
    var r
    this.tokentype === l.START &&
      (r = function (i) {
        i.tmp.jump.push(void 0, l.LITERAL)
      }),
      this.tokentype === l.END &&
        (r = function (i) {
          i.tmp.jump.pop()
        }),
      this.execs.push(r),
      t.push(this)
  },
  configure: function (e, t) {
    this.tokentype === l.END
      ? (e.configure.fail.push(t), e.configure.succeed.push(t))
      : (e.configure.fail.pop(), e.configure.succeed.pop())
  },
}
l.Node.citation = {
  build: function (e, t) {
    if (this.tokentype === l.START) {
      ;(e.build.area = 'citation'), (e.build.root = 'citation'), (e.build.extension = '')
      var r = function (n) {
        ;(n.tmp.area = 'citation'), (n.tmp.root = 'citation'), (n.tmp.extension = '')
      }
      this.execs.push(r)
    }
    if (this.tokentype === l.END) {
      if (
        ((e.opt.grouped_sort =
          (e.opt.xclass === 'in-text' &&
            e.citation.opt.collapse &&
            e.citation.opt.collapse.length) ||
          (e.citation.opt.cite_group_delimiter &&
            e.citation.opt.cite_group_delimiter.length &&
            e.opt.update_mode !== l.POSITION &&
            e.opt.update_mode !== l.NUMERIC)),
        e.opt.grouped_sort && e.citation_sort.opt.sort_directions.length)
      ) {
        var i = e.citation_sort.opt.sort_directions[0].slice()
        e.citation_sort.opt.sort_directions = [i].concat(e.citation_sort.opt.sort_directions)
      }
      e.citation.srt = new l.Registry.Comparifier(e, 'citation_sort')
    }
    t.push(this)
  },
}
l.Node['#comment'] = { build: function () {} }
l.Node.date = {
  build: function (e, t) {
    var r, i, n, s, a, o, u, c, f, h
    ;(this.tokentype === l.START || this.tokentype === l.SINGLETON) &&
      (e.dateput.string(e, e.dateput.queue),
      (e.tmp.date_token = l.Util.cloneToken(this)),
      (e.tmp.date_token.strings.prefix = ''),
      (e.tmp.date_token.strings.suffix = ''),
      e.dateput.openLevel(this),
      (e.build.date_parts = []),
      (e.build.date_variables = this.variables),
      e.build.extension || l.Util.substituteStart.call(this, e, t),
      e.build.extension
        ? (r = l.dateMacroAsSortKey)
        : (r = function (p, m, v) {
            var b
            if (
              ((p.tmp.element_rendered_ok = !1),
              (p.tmp.donesies = []),
              (p.tmp.dateparts = []),
              (b = []),
              this.variables.length && !(p.tmp.just_looking && this.variables[0] === 'accessed'))
            ) {
              for (
                i = m[this.variables[0]],
                  typeof i > 'u' &&
                    ((i = { 'date-parts': [[0]] }),
                    p.opt.development_extensions.locator_date_and_revision &&
                      v &&
                      this.variables[0] === 'locator-date' &&
                      v['locator-date'] &&
                      (i = v['locator-date'])),
                  p.tmp.date_object = i,
                  n = this.dateparts.length,
                  s = 0;
                s < n;
                s += 1
              )
                (a = this.dateparts[s]),
                  (typeof p.tmp.date_object[a + '_end'] < 'u' ||
                    (a === 'month' && typeof p.tmp.date_object.season_end < 'u')) &&
                    b.push(a)
              for (o = [], u = ['year', 'month', 'day'], n = u.length, s = 0; s < n; s += 1)
                b.indexOf(u[s]) > -1 && o.push(u[s])
              for (b = o.slice(), c = 2, n = b.length, s = 0; s < n; s += 1)
                if (
                  ((a = b[s]),
                  (f = p.tmp.date_object[a]),
                  (h = p.tmp.date_object[a + '_end']),
                  f !== h)
                ) {
                  c = s
                  break
                }
              p.tmp.date_collapse_at = b.slice(c)
            } else p.tmp.date_object = !1
          }),
      this.execs.push(r),
      (r = function (p, m) {
        if (
          m[this.variables[0]] &&
          (p.output.startTag('date', this),
          this.variables[0] === 'issued' &&
            (m.type === 'legal_case' || m.type === 'legislation') &&
            p.opt.disable_duplicate_year_suppression.indexOf(m.country) === -1 &&
            !p.tmp.extension &&
            '' + m['collection-number'] == '' + p.tmp.date_object.year &&
            this.dateparts.length === 1 &&
            this.dateparts[0] === 'year')
        ) {
          for (var v in p.tmp.date_object)
            if (p.tmp.date_object.hasOwnProperty(v) && v.slice(0, 4) === 'year') {
              p.tmp.issued_date = {}
              var b = p.output.current.mystack.slice(-2)[0].blobs
              ;(p.tmp.issued_date.list = b), (p.tmp.issued_date.pos = b.length - 1)
            }
        }
      }),
      this.execs.push(r)),
      !e.build.extension &&
        (this.tokentype === l.END || this.tokentype === l.SINGLETON) &&
        ((r = function (p, m) {
          m[this.variables[0]] && p.output.endTag()
        }),
        this.execs.push(r)),
      t.push(this),
      (this.tokentype === l.END || this.tokentype === l.SINGLETON) &&
        (e.build.extension || l.Util.substituteEnd.call(this, e, t))
  },
}
l.Node['date-part'] = {
  build: function (e, t) {
    var r, i, n, s, a, o, u, c, f, h, p, m, v, b, S, g, _, y, x, D, C
    this.strings.form || (this.strings.form = 'long'), e.build.date_parts.push(this.strings.name)
    var H = e.build.date_variables[0]
    function T(k, O, N) {
      if (!N) return N
      if (
        ((N = '' + l.Util.Dates[this.strings.name][k](e, N, O, this.default_locale)),
        this.strings.name === 'month')
      ) {
        if (e.tmp.strip_periods) N = N.replace(/\./g, '')
        else
          for (var M = 0, V = this.decorations.length; M < V; M += 1)
            if (this.decorations[M][0] === '@strip-periods' && this.decorations[M][1] === 'true') {
              N = N.replace(/\./g, '')
              break
            }
      }
      return N
    }
    ;(r = function (k, O) {
      if (k.tmp.date_object) k.tmp.probably_rendered_something = !0
      else return
      var N = ''
      if (
        ((s = !0),
        (a = ''),
        (o = ''),
        k.tmp.donesies.push(this.strings.name),
        k.tmp.date_object.literal &&
          this.strings.name === 'year' &&
          ((N = k.tmp.date_object.literal), k.output.append(k.tmp.date_object.literal, this)),
        k.tmp.date_object &&
          ((a = k.tmp.date_object[this.strings.name]),
          (o = k.tmp.date_object[this.strings.name + '_end'])),
        this.strings.name === 'year' && a === 0 && !k.tmp.suppress_decorations && (a = !1),
        (u = !k.tmp.suppress_decorations),
        (c = k.tmp.have_collapsed),
        (f =
          k[k.tmp.area].opt.collapse === 'year-suffix' ||
          k[k.tmp.area].opt.collapse === 'year-suffix-ranged'),
        (h = k.opt['disambiguate-add-year-suffix']),
        u &&
          h &&
          f &&
          (k.tmp.years_used.push(a),
          (p = k.tmp.last_years_used.length >= k.tmp.years_used.length),
          p && c && k.tmp.last_years_used[k.tmp.years_used.length - 1] === a && (a = !1)),
        typeof a < 'u')
      ) {
        ;(m = !1),
          (v = !1),
          this.strings.name === 'year' &&
            (parseInt(a, 10) < 500 && parseInt(a, 10) > 0 && (v = k.getTerm('ad')),
            parseInt(a, 10) < 0 && ((m = k.getTerm('bc')), (a = parseInt(a, 10) * -1)),
            o &&
              (parseInt(o, 10) < 500 && parseInt(o, 10) > 0 && k.getTerm('ad'),
              parseInt(o, 10) < 0 && (k.getTerm('bc'), (o = parseInt(o, 10) * -1))))
        for (var M = '' + k.tmp.date_object.month; M.length < 2; ) M = '0' + M
        M = 'month-' + M
        var V = k.locale[k.opt.lang]['noun-genders'][M]
        if (this.strings.form) {
          var j = this.strings.form,
            R = this.strings.form
          this.strings.name === 'day' &&
            j === 'ordinal' &&
            k.locale[k.opt.lang].opts['limit-day-ordinals-to-day-1'] &&
            (a != 1 && (j = 'numeric'), o != 1 && (R = 'numeric')),
            (a = T.call(this, j, V, a)),
            (o = T.call(this, R, V, o))
        }
        if ((k.output.openLevel('empty'), k.tmp.date_collapse_at.length)) {
          for (b = !0, n = k.tmp.date_collapse_at.length, i = 0; i < n; i += 1)
            if (((D = k.tmp.date_collapse_at[i]), k.tmp.donesies.indexOf(D) === -1)) {
              b = !1
              break
            }
          if (b) {
            if ('' + o != '0') {
              if (
                (k.dateput.queue.length === 0 && (s = !0),
                k.opt['year-range-format'] &&
                  k.opt['year-range-format'] !== 'expanded' &&
                  !k.tmp.date_object.day &&
                  !k.tmp.date_object.month &&
                  !k.tmp.date_object.season &&
                  this.strings.name === 'year' &&
                  a &&
                  o)
              ) {
                o = k.fun.year_mangler(a + '-' + o, !0)
                var $ = k.getTerm('year-range-delimiter')
                o = o.slice(o.indexOf($) + 1)
              }
              ;(N = o),
                k.dateput.append(o, this),
                s && ((C = k.dateput.current.value().blobs[0]), C && (C.strings.prefix = ''))
            }
            ;(N = a),
              k.output.append(a, this),
              (S = k.output.current.value()),
              (C = S.blobs[S.blobs.length - 1]),
              C && (C.strings.suffix = ''),
              this.strings['range-delimiter']
                ? k.output.append(this.strings['range-delimiter'])
                : k.output.append(k.getTerm('year-range-delimiter'), 'empty'),
              k.dateput.closeLevel(),
              (g = k.dateput.current.value()),
              (S.blobs = S.blobs.concat(g)),
              k.dateput.string(k, k.dateput.queue),
              k.dateput.openLevel(k.tmp.date_token),
              (k.tmp.date_collapse_at = [])
          } else
            (N = a),
              k.output.append(a, this),
              k.tmp.date_collapse_at.indexOf(this.strings.name) > -1 &&
                '' + o != '0' &&
                (k.dateput.queue.length === 0 && (s = !0),
                k.dateput.openLevel('empty'),
                (N = o),
                k.dateput.append(o, this),
                s && ((C = k.dateput.current.value().blobs[0]), C && (C.strings.prefix = '')),
                m && ((N = m), k.dateput.append(m)),
                v && ((N = v), k.dateput.append(v)),
                k.dateput.closeLevel())
        } else (N = a), k.output.append(a, this)
        m && ((N = m), k.output.append(m)),
          v && ((N = v), k.output.append(v)),
          k.output.closeLevel()
      } else
        this.strings.name === 'month' &&
          k.tmp.date_object.season &&
          ((a = '' + k.tmp.date_object.season),
          a && a.match(/^[1-4]$/)
            ? ((k.tmp.group_context.tip.variable_success = !0),
              (N = 'winter'),
              k.output.append(k.getTerm('season-0' + a), this))
            : a && ((N = a), k.output.append(a, this)))
      ;(k.tmp.value = []),
        O[H] &&
          (a || k.tmp.have_collapsed) &&
          !k.opt.has_year_suffix &&
          this.strings.name === 'year' &&
          !k.tmp.just_looking &&
          k.registry.registry[O.id] &&
          k.registry.registry[O.id].disambig.year_suffix !== !1 &&
          !k.tmp.has_done_year_suffix &&
          ((k.tmp.has_done_year_suffix = !0),
          (N = 'x'),
          (y = parseInt(k.registry.registry[O.id].disambig.year_suffix, 10)),
          (_ = new l.NumericBlob(k, !1, y, this, O.id)),
          (this.successor_prefix = k[k.build.area].opt.layout_delimiter),
          (this.splice_prefix = k[k.build.area].opt.layout_delimiter),
          (x = new l.Util.Suffixator(l.SUFFIX_CHARS)),
          _.setFormatter(x),
          k[k.tmp.area].opt.collapse === 'year-suffix-ranged' &&
            (_.range_prefix = k.getTerm('citation-range-delimiter')),
          k[k.tmp.area].opt.cite_group_delimiter
            ? (_.successor_prefix = k[k.tmp.area].opt.cite_group_delimiter)
            : k[k.tmp.area].opt['year-suffix-delimiter']
            ? (_.successor_prefix = k[k.tmp.area].opt['year-suffix-delimiter'])
            : (_.successor_prefix = k[k.tmp.area].opt.layout_delimiter),
          (_.UGLY_DELIMITER_SUPPRESS_HACK = !0),
          k.output.append(_, 'literal')),
        N &&
          !k.tmp.group_context.tip.condition &&
          ((k.tmp.just_did_number = N.match(/[0-9]$/)),
          k.output.current.tip.strings.suffix && (k.tmp.just_did_number = !1))
    }),
      this.execs.push(r),
      t.push(this)
  },
}
l.Node['else-if'] = {
  build: function (e, t) {
    l.Conditions.TopNode.call(this, e, t), t.push(this)
  },
  configure: function (e, t) {
    l.Conditions.Configure.call(this, e, t)
  },
}
l.Node.else = {
  build: function (e, t) {
    t.push(this)
  },
  configure: function (e, t) {
    this.tokentype === l.START && (e.configure.fail[e.configure.fail.length - 1] = t)
  },
}
l.Node['et-al'] = {
  build: function (e, t) {
    if (e.build.area === 'citation' || e.build.area === 'bibliography') {
      var r = function (i) {
        ;(i.tmp.etal_node = this),
          typeof this.strings.term == 'string' && (i.tmp.etal_term = this.strings.term)
      }
      this.execs.push(r)
    }
    t.push(this)
  },
}
l.Node.group = {
  build: function (e, t, r) {
    var i, n
    if (
      ((this.realGroup = r),
      this.tokentype === l.START &&
        (l.Util.substituteStart.call(this, e, t),
        e.build.substitute_level.value() &&
          e.build.substitute_level.replace(e.build.substitute_level.value() + 1),
        this.juris || t.push(this),
        (i = function (p) {
          if (
            (p.output.startTag('group', this),
            this.strings.label_form_override &&
              (p.tmp.group_context.tip.label_form ||
                (p.tmp.group_context.tip.label_form = this.strings.label_form_override)),
            this.strings.label_capitalize_if_first_override &&
              (p.tmp.group_context.tip.label_capitalize_if_first ||
                (p.tmp.group_context.tip.label_capitalize_if_first =
                  this.strings.label_capitalize_if_first_override)),
            this.realGroup)
          ) {
            p.tmp.group_context.tip.condition &&
              l.UPDATE_GROUP_CONTEXT_CONDITION(p, this.strings.prefix, null, this)
            var m = !1,
              v = !1
            p.tmp.group_context.mystack.length &&
              (p.output.current.value().parent = p.tmp.group_context.tip.output_tip)
            var b = p.tmp.group_context.tip.label_form
            b || (b = this.strings.label_form_override)
            var S = p.tmp.group_context.tip.label_capitalize_if_first
            S || (S = this.strings.label_capitalize_if_first),
              p.tmp.group_context.tip.condition
                ? ((m = p.tmp.group_context.tip.condition),
                  (v = p.tmp.group_context.tip.force_suppress))
                : this.strings.reject
                ? (m = { test: this.strings.reject, not: !0 })
                : this.strings.require && (m = { test: this.strings.require, not: !1 })
            var g = {
              old_term_predecessor: p.tmp.term_predecessor,
              term_intended: !1,
              variable_attempt: !1,
              variable_success: !1,
              variable_success_parent: p.tmp.group_context.tip.variable_success,
              output_tip: p.output.current.tip,
              label_form: b,
              label_static: p.tmp.group_context.tip.label_static,
              label_capitalize_if_first: S,
              parallel_delimiter_override: this.strings.set_parallel_delimiter_override,
              parallel_delimiter_override_on_suppress:
                this.strings.set_parallel_delimiter_override_on_suppress,
              condition: m,
              force_suppress: v,
              done_vars: p.tmp.group_context.tip.done_vars.slice(),
            }
            if (this.non_parallel) {
              var _ = p.tmp.group_context.tip.non_parallel
              _ || (_ = {}), Object.assign(_, this.non_parallel), (g.non_parallel = _)
            }
            if (this.parallel_first) {
              var y = p.tmp.group_context.tip.parallel_first
              y || (y = {}), Object.assign(y, this.parallel_first), (g.parallel_first = y)
            }
            if (this.parallel_last) {
              var x = p.tmp.group_context.tip.parallel_last
              x || (x = {}), Object.assign(x, this.parallel_last), (g.parallel_last = x)
            }
            if (p.tmp.abbrev_trimmer && p.tmp.abbrev_trimmer.LAST_TO_FIRST && g.parallel_last) {
              g.parallel_first || (g.parallel_first = {})
              for (var D in p.tmp.abbrev_trimmer.LAST_TO_FIRST)
                g.parallel_last[D] && ((g.parallel_first[D] = !0), delete g.parallel_last[D])
            }
            if (
              (p.tmp.group_context.push(g), p.tmp.abbrev_trimmer && this.parallel_last_to_first)
            ) {
              p.tmp.abbrev_trimmer.LAST_TO_FIRST || (p.tmp.abbrev_trimmer.LAST_TO_FIRST = {})
              for (var D in this.parallel_last_to_first) p.tmp.abbrev_trimmer.LAST_TO_FIRST[D] = !0
            }
          }
        }),
        (n = []),
        n.push(i),
        (this.execs = n.concat(this.execs)),
        this.strings['has-publisher-and-publisher-place'] &&
          ((e.build['publisher-special'] = !0),
          this.strings['subgroup-delimiter'] &&
            ((i = function (p, m) {
              if (m.publisher && m['publisher-place']) {
                var v = m.publisher.split(/;\s*/),
                  b = m['publisher-place'].split(/;\s*/)
                v.length > 1 &&
                  v.length === b.length &&
                  ((p.publisherOutput = new l.PublisherOutput(p, this)),
                  (p.publisherOutput['publisher-list'] = v),
                  (p.publisherOutput['publisher-place-list'] = b))
              }
            }),
            this.execs.push(i))),
        this.juris))
    ) {
      var s = new l.Token('choose', l.START)
      l.Node.choose.build.call(s, e, t)
      var a = new l.Token('if', l.START)
      ;(i = (function (p) {
        return function (m, v) {
          return l.INIT_JURISDICTION_MACROS(e, m, v, p)
        }
      })(this.juris)),
        a.tests || (a.tests = []),
        a.tests.push(i),
        (a.test = e.fun.match.any(a, e, a.tests)),
        t.push(a)
      var o = new l.Token('text', l.SINGLETON)
      ;(i = function (p, m, v) {
        var b = m
        v && v['best-jurisdiction'] && this.juris === 'juris-locator' && (b = v)
        var S = 0
        if (p.juris[b['best-jurisdiction']][this.juris])
          for (; S < p.juris[b['best-jurisdiction']][this.juris].length; )
            S = l.tokenExec.call(p, p.juris[b['best-jurisdiction']][this.juris][S], m, v)
      }),
        (o.juris = this.juris),
        o.execs.push(i),
        t.push(o)
      var u = new l.Token('if', l.END)
      l.Node.if.build.call(u, e, t)
      var c = new l.Token('else', l.START)
      l.Node.else.build.call(c, e, t)
    }
    if (
      this.tokentype === l.END &&
      (e.build['publisher-special'] &&
        ((e.build['publisher-special'] = !1),
        (i = function (p) {
          p.publisherOutput && (p.publisherOutput.render(), (p.publisherOutput = !1))
        }),
        this.execs.push(i)),
      (i = function (p, m, v) {
        if (
          (p.tmp.group_context.tip.condition ||
            (p.output.current.tip.strings.suffix && (p.tmp.just_did_number = !1)),
          p.output.endTag(),
          this.realGroup)
        ) {
          var b = p.tmp.group_context.pop()
          if (
            (b.parallel_delimiter_override &&
              ((p.tmp.group_context.tip.parallel_delimiter_override =
                b.parallel_delimiter_override),
              !p.tmp.just_looking &&
                p.registry.registry[m.id].master &&
                (p.registry.registry[m.id].parallel_delimiter_override =
                  b.parallel_delimiter_override)),
            b.parallel_delimiter_override_on_suppress &&
              (p.tmp.group_context.tip.parallel_delimiter_override_on_suppress =
                b.parallel_delimiter_override_on_suppress),
            p.tmp.area === 'bibliography_sort')
          ) {
            var S = b.done_vars.indexOf('citation-number')
            this.strings.sort_direction &&
              S > -1 &&
              p.tmp.group_context.length() == 1 &&
              (this.strings.sort_direction === l.DESCENDING
                ? (p.bibliography_sort.opt.citation_number_sort_direction = l.DESCENDING)
                : (p.bibliography_sort.opt.citation_number_sort_direction = l.ASCENDING),
              (b.done_vars = b.done_vars.slice(0, S).concat(b.done_vars.slice(S + 1))))
          }
          if (
            (b.condition && (b.force_suppress = l.EVALUATE_GROUP_CONDITION(p, b)),
            p.tmp.group_context.tip.condition &&
              (p.tmp.group_context.tip.force_suppress = b.force_suppress),
            !b.force_suppress && (b.variable_success || (b.term_intended && !b.variable_attempt)))
          ) {
            this.isJurisLocatorLabel || (p.tmp.group_context.tip.variable_success = !0)
            var g = p.output.current.value().blobs
            if (
              (p.output.current.value().blobs.length - 1,
              !p.tmp.just_looking &&
                (b.non_parallel ||
                  b.parallel_last ||
                  b.parallel_first ||
                  b.parallel_delimiter_override ||
                  b.parallel_delimiter_override_on_suppress))
            ) {
              var _ = p.parallel.checkRepeats(b)
              if (
                (_ && g && g.pop(),
                p.tmp.cite_index > 0 &&
                  (_ || (!b.parallel_first && !b.parallel_last && !b.non_parallel)))
              ) {
                var y = p.tmp.suppress_repeats[p.tmp.cite_index - 1]
                _ && b.parallel_delimiter_override_on_suppress && (y.SIBLING || y.ORPHAN)
                  ? (p.output.queue.slice(-1)[0].parallel_delimiter =
                      b.parallel_delimiter_override_on_suppress)
                  : b.parallel_delimiter_override &&
                    y.SIBLING &&
                    (p.output.queue.slice(-1)[0].parallel_delimiter = b.parallel_delimiter_override)
              }
            }
          } else {
            if (
              ((p.tmp.term_predecessor = b.old_term_predecessor),
              (p.tmp.group_context.tip.variable_attempt = b.variable_attempt),
              b.force_suppress &&
                !p.tmp.group_context.tip.condition &&
                ((p.tmp.group_context.tip.variable_attempt = !0),
                (p.tmp.group_context.tip.variable_success = b.variable_success_parent)),
              b.force_suppress)
            )
              for (var x = 0, D = b.done_vars.length; x < D; x++)
                for (var C = b.done_vars[x], H = 0, T = p.tmp.done_vars.length; H < T; H++)
                  p.tmp.done_vars[H] === C &&
                    (p.tmp.done_vars = p.tmp.done_vars
                      .slice(0, H)
                      .concat(p.tmp.done_vars.slice(H + 1)))
            p.output.current.value().blobs && p.output.current.value().blobs.pop()
          }
        }
      }),
      this.execs.push(i),
      this.juris)
    ) {
      var f = new l.Token('else', l.END)
      l.Node.else.build.call(f, e, t)
      var h = new l.Token('choose', l.END)
      l.Node.choose.build.call(h, e, t)
    }
    this.tokentype === l.END &&
      (this.juris || t.push(this),
      e.build.substitute_level.value() &&
        e.build.substitute_level.replace(e.build.substitute_level.value() - 1),
      l.Util.substituteEnd.call(this, e, t))
  },
}
l.Node.if = {
  build: function (e, t) {
    l.Conditions.TopNode.call(this, e, t), t.push(this)
  },
  configure: function (e, t) {
    l.Conditions.Configure.call(this, e, t)
  },
}
l.Node.conditions = {
  build: function (e) {
    this.tokentype === l.START && e.tmp.conditions.addMatch(this.match),
      this.tokentype === l.END && e.tmp.conditions.matchCombine()
  },
}
l.Node.condition = {
  build: function (e) {
    if (this.tokentype === l.SINGLETON) {
      var t = e.fun.match[this.match](this, e, this.tests)
      e.tmp.conditions.addTest(t)
    }
  },
}
l.Conditions = {}
l.Conditions.TopNode = function (e) {
  var t
  ;(this.tokentype === l.START || this.tokentype === l.SINGLETON) &&
    (this.locale && (e.opt.lang = this.locale),
    !this.tests || !this.tests.length
      ? (e.tmp.conditions = new l.Conditions.Engine(e, this))
      : (this.test = e.fun.match[this.match](this, e, this.tests)),
    e.build.substitute_level.value() === 0 &&
      ((t = function (r) {
        r.tmp.condition_counter++
      }),
      this.execs.push(t))),
    (this.tokentype === l.END || this.tokentype === l.SINGLETON) &&
      (e.build.substitute_level.value() === 0 &&
        ((t = function (r) {
          if ((r.tmp.condition_counter--, r.tmp.condition_lang_counter_arr.length > 0)) {
            var i = r.tmp.condition_lang_counter_arr.slice(-1)[0]
            i === r.tmp.condition_counter &&
              ((r.opt.lang = r.tmp.condition_lang_val_arr.pop()),
              r.tmp.condition_lang_counter_arr.pop())
          }
          this.locale_default &&
            ((r.output.current.value().old_locale = this.locale_default),
            r.output.closeLevel('empty'),
            (r.opt.lang = this.locale_default))
        }),
        this.execs.push(t)),
      (t = function (r) {
        var i = this[r.tmp.jump.value()]
        return i
      }),
      this.execs.push(t),
      this.locale_default && (e.opt.lang = this.locale_default))
}
l.Conditions.Configure = function (e, t) {
  this.tokentype === l.START
    ? ((this.fail = e.configure.fail.slice(-1)[0]),
      (this.succeed = this.next),
      (e.configure.fail[e.configure.fail.length - 1] = t))
    : this.tokentype === l.SINGLETON
    ? ((this.fail = this.next),
      (this.succeed = e.configure.succeed.slice(-1)[0]),
      (e.configure.fail[e.configure.fail.length - 1] = t))
    : ((this.succeed = e.configure.succeed.slice(-1)[0]), (this.fail = this.next))
}
l.Conditions.Engine = function (e, t) {
  ;(this.token = t), (this.state = e)
}
l.Conditions.Engine.prototype.addTest = function (e) {
  this.token.tests || (this.token.tests = []), this.token.tests.push(e)
}
l.Conditions.Engine.prototype.addMatch = function (e) {
  this.token.match = e
}
l.Conditions.Engine.prototype.matchCombine = function () {
  this.token.test = this.state.fun.match[this.token.match](this.token, this.state, this.token.tests)
}
l.Node.info = {
  build: function (e) {
    this.tokentype === l.START ? (e.build.skip = 'info') : (e.build.skip = !1)
  },
}
l.Node.institution = {
  build: function (e, t) {
    if ([l.SINGLETON, l.START].indexOf(this.tokentype) > -1) {
      var r = function (i) {
        typeof this.strings.delimiter == 'string'
          ? (i.tmp.institution_delimiter = this.strings.delimiter)
          : (i.tmp.institution_delimiter = i.tmp.name_delimiter),
          i.inheritOpt(this, 'and') === 'text'
            ? (this.and_term = i.getTerm('and', 'long', 0))
            : i.inheritOpt(this, 'and') === 'symbol'
            ? i.opt.development_extensions.expect_and_symbol_form
              ? (this.and_term = i.getTerm('and', 'symbol', 0))
              : (this.and_term = '&')
            : i.inheritOpt(this, 'and') === 'none' && (this.and_term = i.tmp.institution_delimiter),
          typeof this.and_term > 'u' && i.tmp.and_term && (this.and_term = i.tmp.and_term),
          l.STARTSWITH_ROMANESQUE_REGEXP.test(this.and_term)
            ? ((this.and_prefix_single = ' '),
              (this.and_prefix_multiple = ', '),
              typeof i.tmp.institution_delimiter == 'string' &&
                (this.and_prefix_multiple = i.tmp.institution_delimiter),
              (this.and_suffix = ' '))
            : ((this.and_prefix_single = ''),
              (this.and_prefix_multiple = ''),
              (this.and_suffix = '')),
          i.inheritOpt(this, 'delimiter-precedes-last') === 'always'
            ? (this.and_prefix_single = i.tmp.institution_delimiter)
            : i.inheritOpt(this, 'delimiter-precedes-last') === 'never' &&
              this.and_prefix_multiple &&
              (this.and_prefix_multiple = ' '),
          (this.and = {}),
          typeof this.and_term < 'u'
            ? (i.output.append(this.and_term, 'empty', !0),
              (this.and.single = i.output.pop()),
              (this.and.single.strings.prefix = this.and_prefix_single),
              (this.and.single.strings.suffix = this.and_suffix),
              i.output.append(this.and_term, 'empty', !0),
              (this.and.multiple = i.output.pop()),
              (this.and.multiple.strings.prefix = this.and_prefix_multiple),
              (this.and.multiple.strings.suffix = this.and_suffix))
            : this.strings.delimiter !== 'undefined' &&
              ((this.and.single = new l.Blob(i.tmp.institution_delimiter)),
              (this.and.single.strings.prefix = ''),
              (this.and.single.strings.suffix = ''),
              (this.and.multiple = new l.Blob(i.tmp.institution_delimiter)),
              (this.and.multiple.strings.prefix = ''),
              (this.and.multiple.strings.suffix = '')),
          (i.nameOutput.institution = this)
      }
      this.execs.push(r)
    }
    t.push(this)
  },
  configure: function (e) {
    ;[l.SINGLETON, l.START].indexOf(this.tokentype) > -1 && (e.build.has_institution = !0)
  },
}
l.Node['institution-part'] = {
  build: function (e, t) {
    var r
    this.strings.name === 'long'
      ? this.strings['if-short']
        ? (r = function (i) {
            i.nameOutput.institutionpart['long-with-short'] = this
          })
        : (r = function (i) {
            i.nameOutput.institutionpart.long = this
          })
      : this.strings.name === 'short' &&
        (r = function (i) {
          i.nameOutput.institutionpart.short = this
        }),
      this.execs.push(r),
      t.push(this)
  },
}
l.Node.key = {
  build: function (e, t) {
    t = e[e.build.root + '_sort'].tokens
    var r,
      i = new l.Token('key', l.START)
    ;(e.tmp.root = e.build.root),
      (i.strings['et-al-min'] = e.inheritOpt(this, 'et-al-min')),
      (i.strings['et-al-use-first'] = e.inheritOpt(this, 'et-al-use-first')),
      (i.strings['et-al-use-last'] = e.inheritOpt(this, 'et-al-use-last')),
      (r = function (g) {
        g.tmp.done_vars = []
      }),
      i.execs.push(r),
      (r = function (g) {
        g.output.openLevel('empty')
      }),
      i.execs.push(r)
    var n = []
    if (
      (this.strings.sort_direction === l.DESCENDING
        ? (n.push(1), n.push(-1))
        : (n.push(-1), n.push(1)),
      e[e.build.area].opt.sort_directions.push(n),
      l.DATE_VARIABLES.indexOf(this.variables[0]) > -1 && (e.build.date_key = !0),
      (r = function (g) {
        ;(g.tmp.sort_key_flag = !0),
          g.inheritOpt(this, 'et-al-min') && (g.tmp['et-al-min'] = g.inheritOpt(this, 'et-al-min')),
          g.inheritOpt(this, 'et-al-use-first') &&
            (g.tmp['et-al-use-first'] = g.inheritOpt(this, 'et-al-use-first')),
          typeof g.inheritOpt(this, 'et-al-use-last') == 'boolean' &&
            (g.tmp['et-al-use-last'] = g.inheritOpt(this, 'et-al-use-last'))
      }),
      i.execs.push(r),
      t.push(i),
      this.variables.length)
    ) {
      var s = this.variables[0]
      if (l.NAME_VARIABLES.indexOf(s) > -1) {
        var a = new l.Token('names', l.START)
        ;(a.tokentype = l.START), (a.variables = this.variables), l.Node.names.build.call(a, e, t)
        var o = new l.Token('name', l.SINGLETON)
        ;(o.tokentype = l.SINGLETON),
          (o.strings['name-as-sort-order'] = 'all'),
          (o.strings['sort-separator'] = ' '),
          (o.strings['et-al-use-last'] = e.inheritOpt(this, 'et-al-use-last')),
          (o.strings['et-al-min'] = e.inheritOpt(this, 'et-al-min')),
          (o.strings['et-al-use-first'] = e.inheritOpt(this, 'et-al-use-first')),
          l.Node.name.build.call(o, e, t)
        var u = new l.Token('institution', l.SINGLETON)
        ;(u.tokentype = l.SINGLETON), l.Node.institution.build.call(u, e, t)
        var c = new l.Token('names', l.END)
        ;(c.tokentype = l.END), l.Node.names.build.call(c, e, t)
      } else {
        var f = new l.Token('text', l.SINGLETON)
        if (
          ((f.strings.sort_direction = this.strings.sort_direction),
          (f.dateparts = this.dateparts),
          l.NUMERIC_VARIABLES.indexOf(s) > -1)
        )
          s === 'citation-number'
            ? (r = function (g, _) {
                if (
                  (g.tmp.area === 'bibliography_sort' &&
                    (this.strings.sort_direction === l.DESCENDING
                      ? (g.bibliography_sort.opt.citation_number_sort_direction = l.DESCENDING)
                      : (g.bibliography_sort.opt.citation_number_sort_direction = l.ASCENDING)),
                  g.tmp.area === 'citation_sort' && g.bibliography_sort.tmp.citation_number_map)
                )
                  var y = g.bibliography_sort.tmp.citation_number_map[g.registry.registry[_.id].seq]
                else var y = g.registry.registry[_.id].seq
                y && (y = l.Util.padding('' + y)), g.output.append(y, this)
              })
            : (r = function (g, _) {
                var y = !1
                ;(y = _[s]), y && (y = l.Util.padding(y)), g.output.append(y, this)
              })
        else if (s === 'citation-label')
          r = function (g, _) {
            var y = g.getCitationLabel(_)
            g.output.append(y, this)
          }
        else if (l.DATE_VARIABLES.indexOf(s) > -1)
          (r = l.dateAsSortKey), (f.variables = this.variables)
        else if (s === 'title') {
          var h = 'title',
            p = !1,
            m = !1,
            v = !0
          r = e.transform.getOutputFunction(this.variables, h, p, m, v)
        } else
          s === 'court-class'
            ? (r = function (g, _, y) {
                l.INIT_JURISDICTION_MACROS(g, _, y, 'juris-main')
                var x = l.GET_COURT_CLASS(g, _, !0)
                g.output.append(x, 'empty')
              })
            : (r = function (g, _) {
                var y = _[s]
                g.output.append(y, 'empty')
              })
        f.execs.push(r), t.push(f)
      }
    } else {
      var b = new l.Token('text', l.SINGLETON)
      ;(b.strings.sort_direction = this.strings.sort_direction),
        (b.postponed_macro = this.postponed_macro),
        l.expandMacro.call(e, b, t)
    }
    var S = new l.Token('key', l.END)
    ;(r = function (g) {
      var _ = g.output.string(g, g.output.queue)
      g.sys.normalizeUnicode && (_ = g.sys.normalizeUnicode(_)),
        (_ = _ ? _.split(' ').join(g.opt.sort_sep) + g.opt.sort_sep : ''),
        _ === '' && (_ = void 0),
        typeof _ != 'string' && (_ = void 0),
        g[g[g.tmp.area].root + '_sort'].keys.push(_),
        (g.tmp.value = [])
    }),
      S.execs.push(r),
      e.build.date_key &&
        (e.build.area === 'citation' &&
          e.build.extension === '_sort' &&
          (e[e.build.area].opt.sort_directions.push([-1, 1]),
          (r = function (g, _) {
            var y = g.registry.registry[_.id].disambig.year_suffix
            y || (y = 0)
            var x = l.Util.padding('' + y)
            g[g.tmp.area].keys.push(x)
          }),
          S.execs.push(r)),
        (e.build.date_key = !1)),
      (r = function (g) {
        ;(g.tmp['et-al-min'] = void 0),
          (g.tmp['et-al-use-first'] = void 0),
          (g.tmp['et-al-use-last'] = void 0),
          (g.tmp.sort_key_flag = !1)
      }),
      S.execs.push(r),
      t.push(S)
  },
}
l.Node.label = {
  build: function (e, t) {
    if (this.strings.term) {
      var r = function (o, u, c) {
        var f = l.evaluateLabel(this, o, u, c)
        c && this.strings.term === 'locator' && (c.section_form_override = this.strings.form),
          f && (o.tmp.group_context.tip.term_intended = !0),
          l.UPDATE_GROUP_CONTEXT_CONDITION(o, f, null, this),
          f.indexOf('%s') === -1 &&
            (this.strings.capitalize_if_first &&
              !o.tmp.term_predecessor &&
              !(o.opt.class === 'in-text' && o.tmp.area === 'citation') &&
              (f = l.Output.Formatters['capitalize-first'](o, f)),
            o.output.append(f, this))
      }
      this.execs.push(r)
    } else {
      this.strings.form || (this.strings.form = 'long')
      for (
        var i = e.build.names_variables[e.build.names_variables.length - 1],
          n = e.build.name_label[e.build.name_label.length - 1],
          s = 0,
          a = i.length;
        s < a;
        s += 1
      )
        n[i[s]] || (n[i[s]] = {})
      if (e.build.name_flag) for (var s = 0, a = i.length; s < a; s += 1) n[i[s]].after = this
      else for (var s = 0, a = i.length; s < a; s += 1) n[i[s]].before = this
    }
    t.push(this)
  },
}
l.Node.layout = {
  build: function (e, t) {
    var r, i, n, s
    function a() {
      e.build.area === 'bibliography' &&
        ((n = new l.Token('text', l.SINGLETON)),
        (r = function (c) {
          if (!c.tmp.parallel_and_not_last) {
            var f
            c.tmp.cite_affixes[c.tmp.area][c.tmp.last_cite_locale]
              ? (f = c.tmp.cite_affixes[c.tmp.area][c.tmp.last_cite_locale].suffix)
              : (f = c.bibliography.opt.layout_suffix)
            var h = c.output.current.value()
            c.opt.using_display
              ? (h.blobs[h.blobs.length - 1].strings.suffix = f)
              : (h.strings.suffix = f)
          }
          c.bibliography.opt['second-field-align'] && c.output.endTag('bib_other')
        }),
        n.execs.push(r),
        t.push(n))
    }
    this.tokentype === l.START &&
      (this.locale_raw
        ? (e.build.current_default_locale = this.locale_raw)
        : (e.build.current_default_locale = e.opt['default-locale']),
      (r = function (c, f, h) {
        if (
          c.opt.development_extensions.apply_citation_wrapper &&
          c.sys.wrapCitationEntry &&
          !c.tmp.just_looking &&
          f.system_id &&
          c.tmp.area === 'citation'
        ) {
          var p = new l.Token('group', l.START)
          ;(p.decorations = [['@cite', 'entry']]),
            c.output.startTag('cite_entry', p),
            (c.output.current.value().item_id = f.system_id),
            h &&
              ((c.output.current.value().locator_txt = h.locator_txt),
              (c.output.current.value().suffix_txt = h.suffix_txt))
        }
      }),
      this.execs.push(r)),
      this.tokentype === l.START &&
        !e.tmp.cite_affixes[e.build.area] &&
        ((r = function (c, f, h) {
          if (
            ((c.tmp.done_vars = []),
            h && h['author-only'] && c.tmp.done_vars.push('locator'),
            c.opt.suppressedJurisdictions[f.country] &&
              f.country &&
              ['treaty', 'patent'].indexOf(f.type) === -1 &&
              c.tmp.done_vars.push('country'),
            !c.tmp.just_looking &&
              c.registry.registry[f.id] &&
              c.registry.registry[f.id].parallel &&
              c.tmp.done_vars.push('first-reference-note-number'),
            !c.tmp.just_looking && c.tmp.abbrev_trimmer && f.jurisdiction)
          )
            for (var p in c.tmp.abbrev_trimmer.QUASHES[f.jurisdiction]) c.tmp.done_vars.push(p)
          c.tmp.rendered_name = !1
        }),
        this.execs.push(r),
        (r = function (c) {
          c.tmp.sort_key_flag = !1
        }),
        this.execs.push(r),
        (r = function (c) {
          c.tmp.nameset_counter = 0
        }),
        this.execs.push(r),
        (r = function (c, f) {
          var h = new l.Token()
          c.output.openLevel(h)
        }),
        this.execs.push(r),
        t.push(this),
        e.build.area === 'citation' &&
          ((i = new l.Token('text', l.SINGLETON)),
          (r = function (c, f, h) {
            if (h && h.prefix) {
              var p = l.checkPrefixSpaceAppend(c, h.prefix)
              c.tmp.just_looking || (p = c.output.checkNestedBrace.update(p))
              var m = l.checkIgnorePredecessor(c, p)
              c.output.append(p, this, !1, m)
            }
          }),
          i.execs.push(r),
          t.push(i)))
    var o
    if (
      (this.locale_raw &&
        ((o = new l.Token('dummy', l.START)),
        (o.locale = this.locale_raw),
        (o.strings.delimiter = this.strings.delimiter),
        (o.strings.suffix = this.strings.suffix),
        e.tmp.cite_affixes[e.build.area] || (e.tmp.cite_affixes[e.build.area] = {})),
      this.tokentype === l.START &&
        ((e.build.layout_flag = !0),
        this.locale_raw ||
          ((e[e.tmp.area].opt.topdecor = [this.decorations]),
          (e[e.tmp.area + '_sort'].opt.topdecor = [this.decorations]),
          (e[e.build.area].opt.layout_prefix = this.strings.prefix),
          (e[e.build.area].opt.layout_suffix = this.strings.suffix),
          (e[e.build.area].opt.layout_delimiter = this.strings.delimiter),
          (e[e.build.area].opt.layout_decorations = this.decorations),
          e.tmp.cite_affixes[e.build.area] &&
            ((s = new l.Token('else', l.START)), l.Node.else.build.call(s, e, t))),
        this.locale_raw))
    ) {
      if (e.build.layout_locale_flag)
        (o.name = 'else-if'),
          l.Attributes['@locale-internal'].call(o, e, this.locale_raw),
          l.Node['else-if'].build.call(o, e, t)
      else {
        var u = new l.Token('choose', l.START)
        l.Node.choose.build.call(u, e, t),
          (o.name = 'if'),
          l.Attributes['@locale-internal'].call(o, e, this.locale_raw),
          l.Node.if.build.call(o, e, t)
      }
      ;(e.tmp.cite_affixes[e.build.area][o.locale] = {}),
        (e.tmp.cite_affixes[e.build.area][o.locale].delimiter = this.strings.delimiter),
        (e.tmp.cite_affixes[e.build.area][o.locale].suffix = this.strings.suffix)
    }
    this.tokentype === l.END &&
      (this.locale_raw &&
        (a(),
        e.build.layout_locale_flag
          ? ((o.name = 'else-if'),
            (o.tokentype = l.END),
            l.Attributes['@locale-internal'].call(o, e, this.locale_raw),
            l.Node['else-if'].build.call(o, e, t))
          : ((o.name = 'if'),
            (o.tokentype = l.END),
            l.Attributes['@locale-internal'].call(o, e, this.locale_raw),
            l.Node.if.build.call(o, e, t),
            (e.build.layout_locale_flag = !0))),
      this.locale_raw ||
        (a(),
        e.tmp.cite_affixes[e.build.area] &&
          e.build.layout_locale_flag &&
          ((s = new l.Token('else', l.END)),
          l.Node.else.build.call(s, e, t),
          (s = new l.Token('choose', l.END)),
          l.Node.choose.build.call(s, e, t)),
        (e.build_layout_locale_flag = !0),
        e.build.area === 'citation' &&
          ((n = new l.Token('text', l.SINGLETON)),
          (r = function (c, f, h) {
            if (h && h.suffix) {
              var p = l.checkSuffixSpacePrepend(c, h.suffix)
              c.tmp.just_looking || (p = c.output.checkNestedBrace.update(p)),
                c.output.append(p, this)
            }
          }),
          n.execs.push(r),
          t.push(n)),
        (r = function (c) {
          c.output.closeLevel()
        }),
        this.execs.push(r),
        (r = function (c, f) {
          c.opt.development_extensions.apply_citation_wrapper &&
            c.sys.wrapCitationEntry &&
            !c.tmp.just_looking &&
            f.system_id &&
            c.tmp.area === 'citation' &&
            c.output.endTag()
        }),
        this.execs.push(r),
        t.push(this),
        (e.build.layout_flag = !1),
        (e.build.layout_locale_flag = !1)))
  },
}
l.Node.macro = { build: function () {} }
l.Node.alternative = {
  build: function (e, t) {
    if (this.tokentype === l.START) {
      var r = new l.Token('choose', l.START)
      l.Node.choose.build.call(r, e, t)
      var i = new l.Token('if', l.START)
      l.Attributes['@alternative-node-internal'].call(i, e), l.Node.if.build.call(i, e, t)
      var n = function (s, a) {
        if (
          ((s.tmp.oldItem = a),
          (s.tmp.oldLang = s.opt.lang),
          (s.tmp.abort_alternative = !0),
          a['language-name'] && a['language-name-original'])
        ) {
          var o = JSON.parse(JSON.stringify(a))
          o.language = o['language-name']
          var u = l.localeResolve(o.language, s.opt['default-locale'][0])
          if (s.opt.multi_layout)
            for (var c in s.opt.multi_layout) {
              var f = s.opt.multi_layout[c],
                h = !1
              for (var p in f) {
                var m = f[p]
                if (u.best === m.best || u.base === m.base || u.bare === m.bare) {
                  h = f[0].best
                  break
                }
              }
              h || (h = s.opt['default-locale'][0]), (s.opt.lang = h)
            }
          for (var v in o)
            if (['id', 'type', 'language', 'multi'].indexOf(v) === -1 && v.slice(0, 4) !== 'alt-')
              if (o.multi && o.multi._keys[v]) {
                var b = !0
                for (var S in o.multi._keys[v])
                  if (u.bare === S.replace(/^([a-zA-Z]+).*/, '$1')) {
                    b = !1
                    break
                  }
                b && delete o[v]
              } else delete o[v]
          for (var v in o)
            v.slice(0, 4) === 'alt-'
              ? ((o[v.slice(4)] = o[v]), (s.tmp.abort_alternative = !1))
              : o.multi &&
                o.multi._keys &&
                !o['alt-' + v] &&
                o.multi._keys[v] &&
                (o.multi._keys[v][u.best]
                  ? ((o[v] = o.multi._keys[v][u.best]), (s.tmp.abort_alternative = !1))
                  : o.multi._keys[v][u.base]
                  ? ((o[v] = o.multi._keys[v][u.base]), (s.tmp.abort_alternative = !1))
                  : o.multi._keys[v][u.bare] &&
                    ((o[v] = o.multi._keys[v][u.bare]), (s.tmp.abort_alternative = !1)))
        }
        s.output.openLevel(this),
          (s.registry.refhash[a.id] = o),
          (s.nameOutput = new l.NameOutput(s, o))
      }
      this.execs.push(n), t.push(this)
      var r = new l.Token('choose', l.START)
      l.Node.choose.build.call(r, e, t)
      var i = new l.Token('if', l.START)
      l.Attributes['@alternative-node-internal'].call(i, e)
      var n = function (s) {
        s.tmp.abort_alternative = !0
      }
      i.execs.push(n), l.Node.if.build.call(i, e, t)
    } else if (this.tokentype === l.END) {
      var i = new l.Token('if', l.END)
      l.Node.if.build.call(i, e, t)
      var r = new l.Token('choose', l.END)
      l.Node.choose.build.call(r, e, t)
      var n = function (u, c) {
        u.output.closeLevel(),
          (u.registry.refhash[c.id] = u.tmp.oldItem),
          (u.opt.lang = u.tmp.oldLang),
          (u.nameOutput = new l.NameOutput(u, u.tmp.oldItem)),
          (u.tmp.abort_alternative = !1)
      }
      this.execs.push(n), t.push(this)
      var i = new l.Token('if', l.END)
      l.Node.if.build.call(i, e, t)
      var r = new l.Token('choose', l.END)
      l.Node.choose.build.call(r, e, t)
    }
  },
}
l.Node['alternative-text'] = {
  build: function (e, t) {
    if (this.tokentype === l.SINGLETON) {
      var r = function (i, s) {
        var s = i.refetchItem(s.id)
        l.getCite.call(i, s)
      }
      this.execs.push(r)
    }
    t.push(this)
  },
}
l.NameOutput = function (e, t, r) {
  ;(this.debug = !1),
    (this.state = e),
    this.debug && this.state.sys.print('(1)'),
    (this.Item = t),
    (this.item = r),
    (this.nameset_base = 0),
    (this.etal_spec = {}),
    (this._first_creator_variable = !1),
    (this._please_chop = !1)
}
l.NameOutput.prototype.init = function (e) {
  ;(this.requireMatch = e.requireMatch),
    this.state.tmp.term_predecessor && (this.state.tmp.subsequent_author_substitute_ok = !1),
    this.nameset_offset && (this.nameset_base = this.nameset_base + this.nameset_offset),
    (this.nameset_offset = 0),
    (this.names = e),
    (this.variables = e.variables),
    (this.state.tmp.value = []),
    (this.state.tmp.rendered_name = []),
    (this.state.tmp.label_blob = !1),
    (this.state.tmp.etal_node = !1),
    (this.state.tmp.etal_term = !1)
  for (var t = 0, r = this.variables.length; t < r; t += 1)
    this.Item[this.variables[t]] &&
      this.Item[this.variables[t]].length &&
      (this.state.tmp.value = this.state.tmp.value.concat(this.Item[this.variables[t]]))
  if (
    ((this['et-al'] = void 0),
    (this.with = void 0),
    (this.name = void 0),
    (this.institutionpart = {}),
    (this.state.tmp.group_context.tip.variable_attempt = !0),
    (this.labelVariable = this.variables[0]),
    !!this.state.tmp.value.length)
  ) {
    var i = this.checkCommonAuthor(this.requireMatch)
    if (i) {
      this.state.tmp.can_substitute.pop(), this.state.tmp.can_substitute.push(!0)
      for (var t in this.variables) {
        var n = this.state.tmp.done_vars.indexOf(this.variables[t])
        n > -1 &&
          (this.state.tmp.done_vars = this.state.tmp.done_vars
            .slice(0, n)
            .concat(this.state.tmp.done_vars.slice(t + 1)))
      }
      ;(this.state.tmp.common_term_match_fail = !0), (this.variables = [])
    }
  }
}
l.NameOutput.prototype.reinit = function (e, t) {
  if (
    ((this.requireMatch = e.requireMatch),
    (this.labelVariable = t),
    this.state.tmp.can_substitute.value())
  ) {
    ;(this.nameset_offset = 0), (this.variables = e.variables)
    var r = this.state.tmp.value.slice()
    this.state.tmp.value = []
    for (var i = 0, n = this.variables.length; i < n; i += 1)
      this.Item[this.variables[i]] &&
        this.Item[this.variables[i]].length &&
        (this.state.tmp.value = this.state.tmp.value.concat(this.Item[this.variables[i]]))
    this.state.tmp.value.length && this.state.tmp.can_substitute.replace(!1, l.LITERAL),
      (this.state.tmp.value = r)
  }
  var s = this.checkCommonAuthor(this.requireMatch)
  if (s) {
    this.state.tmp.can_substitute.pop(), this.state.tmp.can_substitute.push(!0)
    for (var i in this.variables) {
      var a = this.state.tmp.done_vars.indexOf(this.variables[i])
      a > -1 &&
        (this.state.tmp.done_vars = this.state.tmp.done_vars
          .slice(0, a)
          .concat(this.state.tmp.done_vars.slice(i + 1)))
    }
    this.variables = []
  }
}
l.NameOutput.prototype.outputNames = function () {
  var e,
    t,
    r = this.variables
  if (
    (this.institution.and &&
      ((!this.institution.and.single.blobs || !this.institution.and.single.blobs.length) &&
        (this.institution.and.single.blobs = this.name.and.single.blobs),
      (!this.institution.and.multiple.blobs || !this.institution.and.multiple.blobs.length) &&
        (this.institution.and.multiple.blobs = this.name.and.multiple.blobs)),
    (this.variable_offset = {}),
    this.family)
  )
    for (
      this.family_decor = l.Util.cloneToken(this.family),
        this.family_decor.strings.prefix = '',
        this.family_decor.strings.suffix = '',
        e = 0,
        t = this.family.execs.length;
      e < t;
      e += 1
    )
      this.family.execs[e].call(this.family_decor, this.state, this.Item)
  else this.family_decor = !1
  if (this.given)
    for (
      this.given_decor = l.Util.cloneToken(this.given),
        this.given_decor.strings.prefix = '',
        this.given_decor.strings.suffix = '',
        e = 0,
        t = this.given.execs.length;
      e < t;
      e += 1
    )
      this.given.execs[e].call(this.given_decor, this.state, this.Item)
  else this.given_decor = !1
  if (
    (this.debug && this.state.sys.print('(2)'),
    this.getEtAlConfig(),
    this.debug && this.state.sys.print('(3)'),
    this.divideAndTransliterateNames(),
    this.debug && this.state.sys.print('(4)'),
    this.truncatePersonalNameLists(),
    this.debug && this.state.sys.print('(5)'),
    this.debug && this.state.sys.print('(6)'),
    this.disambigNames(),
    this.constrainNames(),
    this.debug && this.state.sys.print('(7)'),
    this.name.strings.form === 'count')
  ) {
    ;(this.state.tmp.extension || this.names_count != 0) &&
      (this.state.output.append(this.names_count, 'empty'),
      (this.state.tmp.group_context.tip.variable_success = !0))
    return
  }
  this.debug && this.state.sys.print('(8)'),
    this.setEtAlParameters(),
    this.debug && this.state.sys.print('(9)'),
    this.setCommonTerm(this.requireMatch),
    this.debug && this.state.sys.print('(10)'),
    this.renderAllNames(),
    this.debug && this.state.sys.print('(11)')
  var i = []
  for (e = 0, t = r.length; e < t; e += 1) {
    var n = r[e],
      s = [],
      a = !1,
      o = null
    if (!this.state.opt.development_extensions.spoof_institutional_affiliations)
      o = this._join([this.freeters[n]], '')
    else {
      this.debug && this.state.sys.print('(11a)')
      for (var u = 0, c = this.institutions[n].length; u < c; u += 1)
        s.push(this.joinPersonsAndInstitutions([this.persons[n][u], this.institutions[n][u]]))
      if ((this.debug && this.state.sys.print('(11b)'), this.institutions[n].length)) {
        var f = this.nameset_base + this.variable_offset[n]
        this.freeters[n].length && (f += 1), (a = this.joinInstitutionSets(s, f))
      }
      this.debug && this.state.sys.print('(11c)')
      var o = this.joinFreetersAndInstitutionSets([this.freeters[n], a])
      this.debug && this.state.sys.print('(11d)')
    }
    if (
      (o && (this.state.tmp.extension || (o = this._applyLabels(o, n)), i.push(o)),
      this.debug && this.state.sys.print('(11e)'),
      this.common_term)
    )
      break
  }
  for (
    this.debug && this.state.sys.print('(12)'),
      this.state.output.openLevel('empty'),
      this.state.output.current.value().strings.delimiter = this.state.inheritOpt(
        this.names,
        'delimiter',
        'names-delimiter'
      ),
      this.debug && this.state.sys.print('(13)'),
      e = 0,
      t = i.length;
    e < t;
    e += 1
  )
    this.state.output.append(i[e], 'literal', !0)
  !this.state.tmp.just_looking && i.length > 0 && (this.state.tmp.probably_rendered_something = !0),
    this.debug && this.state.sys.print('(14)'),
    this.state.output.closeLevel('empty'),
    this.debug && this.state.sys.print('(15)')
  var h = this.state.output.pop()
  ;(this.state.tmp.name_node.top = h), this.debug && this.state.sys.print('(16)')
  var p = l.Util.cloneToken(this.names)
  if (
    (this.state.tmp.group_context.tip.condition &&
      l.UPDATE_GROUP_CONTEXT_CONDITION(this.state, this.names.strings.prefix, null, this.names),
    this.state.output.append(h, p),
    this.state.tmp.term_predecessor_name && (this.state.tmp.term_predecessor = !0),
    this.debug && this.state.sys.print('(17)'),
    this.debug && this.state.sys.print('(18)'),
    r[0] !== 'authority')
  ) {
    var m = [],
      v = this.Item[r[0]]
    if (v)
      for (var e = 0, t = v.length; e < t; e += 1) {
        var b = l.Util.Names.getRawName(v[e])
        b && m.push(b)
      }
    ;(m = m.join(', ')), m && (this.state.tmp.name_node.string = m)
  }
  if (
    (this.state.tmp.name_node.string &&
      !this.state.tmp.first_name_string &&
      (this.state.tmp.first_name_string = this.state.tmp.name_node.string),
    this.Item.type === 'classic' && this.state.tmp.first_name_string)
  ) {
    var S = []
    S.push(this.state.tmp.first_name_string),
      this.Item.title && S.push(this.Item.title),
      (S = S.join(', ')),
      S &&
        this.state.sys.getAbbreviation &&
        (this.state.sys.normalizeAbbrevsKey &&
          (S = this.state.sys.normalizeAbbrevsKey('classic', S)),
        this.state.transform.loadAbbreviation('default', 'classic', S, this.Item.language),
        this.state.transform.abbrevs.default.classic[S] &&
          (this.state.tmp.done_vars.push('title'),
          this.state.output.append(this.state.transform.abbrevs.default.classic[S], 'empty', !0),
          (h = this.state.output.pop()),
          this.state.tmp.name_node.top.blobs.pop(),
          this.state.tmp.name_node.top.blobs.push(h)))
  }
  this._collapseAuthor(),
    (this.variables = []),
    (this.state.tmp.authority_stop_last = 0),
    this.debug && this.state.sys.print('(19)')
}
l.NameOutput.prototype._applyLabels = function (e, t) {
  var r
  if (!this.label || !this.label[this.labelVariable]) return e
  var i = 0,
    n = this.freeters_count[t] + this.institutions_count[t]
  if (n > 1) i = 1
  else {
    for (var s = 0, a = this.persons[t].length; s < a; s += 1) n += this.persons_count[t][s]
    n > 1 && (i = 1)
  }
  return (
    this.label[this.labelVariable].before
      ? (typeof this.label[this.labelVariable].before.strings.plural == 'number' &&
          (i = this.label[this.labelVariable].before.strings.plural),
        (r = this._buildLabel(t, i, 'before', this.labelVariable)),
        this.state.output.openLevel('empty'),
        this.state.output.append(r, this.label[this.labelVariable].before, !0),
        this.state.output.append(e, 'literal', !0),
        this.state.output.closeLevel('empty'),
        (e = this.state.output.pop()))
      : this.label[this.labelVariable].after &&
        (typeof this.label[this.labelVariable].after.strings.plural == 'number' &&
          (i = this.label[this.labelVariable].after.strings.plural),
        (r = this._buildLabel(t, i, 'after', this.labelVariable)),
        this.state.output.openLevel('empty'),
        this.state.output.append(e, 'literal', !0),
        this.state.output.append(r, this.label[this.labelVariable].after, !0),
        (this.state.tmp.label_blob = this.state.output.pop()),
        this.state.output.append(this.state.tmp.label_blob, 'literal', !0),
        this.state.output.closeLevel('empty'),
        (e = this.state.output.pop())),
    e
  )
}
l.NameOutput.prototype._buildLabel = function (e, t, r, i) {
  this.common_term && (e = this.common_term)
  var n = !1,
    s = this.label[i][r]
  return s && (n = l.castLabel(this.state, s, e, t, l.TOLERANT)), n
}
l.NameOutput.prototype._collapseAuthor = function () {
  var e, t, r
  this.state.tmp.name_node.top.blobs.length !== 0 &&
    (this.nameset_base === 0 &&
      this.Item[this.variables[0]] &&
      !this._first_creator_variable &&
      (this._first_creator_variable = this.variables[0]),
    ((this.state[this.state.tmp.area].opt.collapse &&
      this.state[this.state.tmp.area].opt.collapse.length) ||
      (this.state[this.state.tmp.area].opt.cite_group_delimiter &&
        this.state[this.state.tmp.area].opt.cite_group_delimiter.length)) &&
      (this.state.tmp.authorstring_request
        ? ((t = ''),
          (e = this.state.tmp.name_node.top.blobs.slice(-1)[0].blobs),
          (r = this.state.tmp.offset_characters),
          e && (t = this.state.output.string(this.state, e, !1)),
          (this.state.tmp.offset_characters = r),
          (this.state.registry.authorstrings[this.Item.id] = t))
        : !this.state.tmp.just_looking &&
          !this.state.tmp.suppress_decorations &&
          ((this.state[this.state.tmp.area].opt.collapse &&
            this.state[this.state.tmp.area].opt.collapse.length) ||
            (this.state[this.state.tmp.area].opt.cite_group_delimiter &&
              this.state[this.state.tmp.area].opt.cite_group_delimiter)) &&
          ((t = ''),
          (e = this.state.tmp.name_node.top.blobs.slice(-1)[0].blobs),
          (r = this.state.tmp.offset_characters),
          e && (t = this.state.output.string(this.state, e, !1)),
          t === this.state.tmp.last_primary_names_string
            ? ((this.item['suppress-author'] ||
                (this.state[this.state.tmp.area].opt.collapse &&
                  this.state[this.state.tmp.area].opt.collapse.length)) &&
                (this.state.tmp.name_node.top.blobs.pop(),
                (this.state.tmp.name_node.children = []),
                (this.state.tmp.offset_characters = r)),
              this.state[this.state.tmp.area].opt.cite_group_delimiter &&
                this.state[this.state.tmp.area].opt.cite_group_delimiter &&
                (this.state.tmp.use_cite_group_delimiter = !0))
            : ((this.state.tmp.last_primary_names_string = t),
              this.variables.indexOf(this._first_creator_variable) > -1 &&
                this.item &&
                this.item['suppress-author'] &&
                this.Item.type !== 'legal_case' &&
                (this.state.tmp.name_node.top.blobs.pop(),
                (this.state.tmp.name_node.children = []),
                (this.state.tmp.offset_characters = r),
                (this.state.tmp.term_predecessor = !1)),
              (this.state.tmp.have_collapsed = !1),
              this.state[this.state.tmp.area].opt.cite_group_delimiter &&
                this.state[this.state.tmp.area].opt.cite_group_delimiter &&
                (this.state.tmp.use_cite_group_delimiter = !1)))))
}
l.NameOutput.prototype.isPerson = function (e) {
  return !(e.literal || (!e.given && e.family && e.isInstitution))
}
l.NameOutput.prototype.truncatePersonalNameLists = function () {
  var e, t, r, i, n, s
  ;(this.freeters_count = {}), (this.persons_count = {}), (this.institutions_count = {})
  for (e in this.freeters)
    this.freeters.hasOwnProperty(e) &&
      ((this.freeters_count[e] = this.freeters[e].length),
      (this.freeters[e] = this._truncateNameList(this.freeters, e)))
  for (e in this.persons)
    if (this.persons.hasOwnProperty(e))
      for (
        this.institutions_count[e] = this.institutions[e].length,
          this._truncateNameList(this.institutions, e),
          this.persons[e] = this.persons[e].slice(0, this.institutions[e].length),
          this.persons_count[e] = [],
          i = 0,
          n = this.persons[e].length;
        i < n;
        i += 1
      )
        (this.persons_count[e][i] = this.persons[e][i].length),
          (this.persons[e][i] = this._truncateNameList(this.persons, e, i))
  if (
    (this.state.opt.development_extensions.etal_min_etal_usefirst_hack &&
    this.etal_min === 1 &&
    this.etal_use_first === 1 &&
    !(this.state.tmp.extension || this.state.tmp.just_looking)
      ? (s = e)
      : (s = !1),
    s || this._please_chop)
  )
    for (t = 0, r = this.variables.length; t < r; t += 1) {
      ;(e = this.variables[t]),
        this.freeters[e].length &&
          (this._please_chop === e
            ? ((this.freeters[e] = this.freeters[e].slice(1)),
              (this.freeters_count[e] += -1),
              (this._please_chop = !1))
            : s &&
              !this._please_chop &&
              ((this.freeters[e] = this.freeters[e].slice(0, 1)),
              (this.freeters_count[e] = 1),
              (this.institutions[e] = []),
              (this.persons[e] = []),
              (this._please_chop = s)))
      for (var i = 0, n = this.persons[e].length; i < n; i++)
        if (this.persons[e][i].length) {
          if (this._please_chop === e) {
            ;(this.persons[e][i] = this.persons[e][i].slice(1)),
              (this.persons_count[e][i] += -1),
              (this._please_chop = !1)
            break
          } else if (s && !this._please_chop) {
            ;(this.freeters[e] = this.persons[e][i].slice(0, 1)),
              (this.freeters_count[e] = 1),
              (this.institutions[e] = []),
              (this.persons[e] = []),
              (this._please_chop = s)
            break
          }
        }
      this.institutions[e].length &&
        (this._please_chop === e
          ? ((this.institutions[e] = this.institutions[e].slice(1)),
            (this.institutions_count[e] += -1),
            (this._please_chop = !1))
          : s &&
            !this._please_chop &&
            ((this.institutions[e] = this.institutions[e].slice(0, 1)),
            (this.institutions_count[e] = 1),
            (this._please_chop = s)))
    }
  for (t = 0, r = this.variables.length; t < r; t += 1) {
    this.institutions[e].length && (this.nameset_offset += 1)
    for (var i = 0, n = this.persons[e].length; i < n; i++)
      this.persons[e][i].length && (this.nameset_offset += 1)
  }
}
l.NameOutput.prototype._truncateNameList = function (e, t, r) {
  var i
  if (
    (typeof r > 'u' ? (i = e[t]) : (i = e[t][r]),
    this.state[this.state[this.state.tmp.area].root].opt.max_number_of_names &&
      i.length > 50 &&
      i.length > this.state[this.state[this.state.tmp.area].root].opt.max_number_of_names + 2)
  ) {
    var n = this.state[this.state[this.state.tmp.area].root].opt.max_number_of_names
    i = i.slice(0, n + 1).concat(i.slice(-1))
  }
  return i
}
l.NameOutput.prototype.divideAndTransliterateNames = function () {
  var e,
    t,
    r,
    i,
    n = this.Item,
    s = this.variables
  for (
    this.varnames = s.slice(),
      this.freeters = {},
      this.persons = {},
      this.institutions = {},
      e = 0,
      t = s.length;
    e < t;
    e += 1
  ) {
    var a = s[e]
    this.variable_offset[a] = this.nameset_offset
    var o = this._normalizeVariableValue(n, a)
    if (
      (this.name.strings['suppress-min'] &&
        o.length >= this.name.strings['suppress-min'] &&
        (o = []),
      this.name.strings['suppress-max'] &&
        o.length <= this.name.strings['suppress-max'] &&
        (o = []),
      this._getFreeters(a, o),
      this._getPersonsAndInstitutions(a, o),
      this.state.opt.development_extensions.spoof_institutional_affiliations)
    ) {
      if (this.name.strings['suppress-min'] === 0)
        for (this.freeters[a] = [], r = 0, i = this.persons[a].length; r < i; r += 1)
          this.persons[a][r] = []
      else if (this.institution.strings['suppress-min'] === 0) {
        for (
          this.institutions[a] = [],
            this.freeters[a] = this.freeters[a].concat(this.persons[a]),
            r = 0,
            i = this.persons[a].length;
          r < i;
          r += 1
        )
          for (var u = 0, c = this.persons[a][r].length; u < c; u += 1)
            this.freeters[a].push(this.persons[a][r][u])
        this.persons[a] = []
      }
    }
  }
}
l.NameOutput.prototype._normalizeVariableValue = function (e, t) {
  var r
  return (
    typeof e[t] == 'string' || typeof e[t] == 'number'
      ? (l.debug('name variable "' + t + '" is string or number, not array. Attempting to fix.'),
        (r = [{ literal: e[t] + '' }]))
      : e[t]
      ? (typeof e[t].length != 'number' &&
          (l.debug('name variable "' + t + '" is object, not array. Attempting to fix.'),
          (e[t] = [e[t]])),
        (r = e[t].slice()))
      : (r = []),
    r
  )
}
l.NameOutput.prototype._getFreeters = function (e, t) {
  if (
    ((this.freeters[e] = []),
    this.state.opt.development_extensions.spoof_institutional_affiliations)
  )
    for (var r = t.length - 1; r > -1 && this.isPerson(t[r]); r--) {
      var i = this._checkNickname(t.pop())
      i && this.freeters[e].push(i)
    }
  else
    for (var r = t.length - 1; r > -1; r--) {
      var i = t.pop()
      if (this.isPerson(i)) var i = this._checkNickname(i)
      this.freeters[e].push(i)
    }
  this.freeters[e].reverse(), this.freeters[e].length && (this.nameset_offset += 1)
}
l.NameOutput.prototype._getPersonsAndInstitutions = function (e, t) {
  if (
    ((this.persons[e] = []),
    (this.institutions[e] = []),
    !!this.state.opt.development_extensions.spoof_institutional_affiliations)
  ) {
    for (var r = [], i = !1, n = !0, s = t.length - 1; s > -1; s += -1)
      if (this.isPerson(t[s])) {
        var a = this._checkNickname(t[s])
        a && r.push(a)
      } else
        (i = !0),
          this.institutions[e].push(t[s]),
          n || (r.reverse(), this.persons[e].push(r), (r = [])),
          (n = !1)
    i &&
      (r.reverse(),
      this.persons[e].push(r),
      this.persons[e].reverse(),
      this.institutions[e].reverse())
  }
}
l.NameOutput.prototype._clearValues = function (e) {
  for (var t = e.length - 1; t > -1; t += -1) e.pop()
}
l.NameOutput.prototype._checkNickname = function (e) {
  if (['interview', 'personal_communication'].indexOf(this.Item.type) > -1) {
    var t = ''
    if (
      ((t = l.Util.Names.getRawName(e)),
      t && this.state.sys.getAbbreviation && !(this.item && this.item['suppress-author']))
    ) {
      var r = t
      this.state.sys.normalizeAbbrevsKey && (r = this.state.sys.normalizeAbbrevsKey('author', t)),
        this.state.transform.loadAbbreviation('default', 'nickname', r, this.Item.language)
      var i = this.state.transform.abbrevs.default.nickname[r]
      i && (i === '!here>>>' ? (e = !1) : (e = { family: i, given: '' }))
    }
  }
  return e
}
l.NameOutput.prototype._purgeEmptyBlobs = function (e) {
  for (var t = e.length - 1; t > -1; t += -1)
    (!e[t] || e[t].length === 0 || !e[t].blobs.length) && (e = e.slice(0, t).concat(e.slice(t + 1)))
  return e
}
l.NameOutput.prototype.joinPersons = function (e, t, r, i) {
  var n
  return (
    (e = this._purgeEmptyBlobs(e)),
    typeof r > 'u'
      ? this.etal_spec[t].freeters === 1
        ? (n = this._joinEtAl(e))
        : this.etal_spec[t].freeters === 2
        ? (n = this._joinEllipsis(e))
        : this.state.tmp.sort_key_flag
        ? (n = this._join(e, this.state.inheritOpt(this.name, 'delimiter', 'name-delimiter', ', ')))
        : (n = this._joinAnd(e))
      : this.etal_spec[t].persons[r] === 1
      ? (n = this._joinEtAl(e))
      : this.etal_spec[t].persons[r] === 2
      ? (n = this._joinEllipsis(e))
      : this.state.tmp.sort_key_flag
      ? (n = this._join(e, this.state.inheritOpt(this.name, 'delimiter', 'name-delimiter', ', ')))
      : (n = this._joinAnd(e)),
    n
  )
}
l.NameOutput.prototype.joinInstitutionSets = function (e, t) {
  var r
  return (
    (e = this._purgeEmptyBlobs(e)),
    this.etal_spec[t].institutions === 1
      ? (r = this._joinEtAl(e, 'institution'))
      : this.etal_spec[t].institutions === 2
      ? (r = this._joinEllipsis(e, 'institution'))
      : (r = this._joinAnd(e)),
    r
  )
}
l.NameOutput.prototype.joinPersonsAndInstitutions = function (e) {
  e = this._purgeEmptyBlobs(e)
  var t = this._join(e, this.state.tmp.name_delimiter)
  return (t.isInstitution = !0), t
}
l.NameOutput.prototype.joinFreetersAndInstitutionSets = function (e) {
  e = this._purgeEmptyBlobs(e)
  var t = this._join(e, '[never here]', this.with.single, this.with.multiple)
  return t
}
l.NameOutput.prototype._getAfterInvertedName = function (e, t, r) {
  if (
    r &&
    e.length > 1 &&
    this.state.inheritOpt(this.name, 'delimiter-precedes-last') === 'after-inverted-name'
  ) {
    var i = e[e.length - 2]
    i.blobs.length > 0 && i.blobs[0].isInverted && (r.strings.prefix = t)
  }
  return r
}
l.NameOutput.prototype._getAndJoin = function (e, t) {
  var r = !1
  if (e.length > 1) {
    var i = 'single'
    e.length > 2 && (i = 'multiple'),
      e[e.length - 1].isInstitution ? (r = this.institution.and[i]) : (r = this.name.and[i]),
      (r = JSON.parse(JSON.stringify(r))),
      (r = this._getAfterInvertedName(e, t, r))
  }
  return r
}
l.NameOutput.prototype._joinEtAl = function (e) {
  var t = this.state.inheritOpt(this.name, 'delimiter', 'name-delimiter', ', '),
    r = this._join(e, t)
  return (
    this.state.output.openLevel(this._getToken('name')),
    (this.state.output.current.value().strings.delimiter = ''),
    this.state.output.append(r, 'literal', !0),
    e.length > 1
      ? this.state.output.append(this['et-al'].multiple, 'literal', !0)
      : e.length === 1 && this.state.output.append(this['et-al'].single, 'literal', !0),
    this.state.output.closeLevel(),
    this.state.output.pop()
  )
}
l.NameOutput.prototype._joinEllipsis = function (e) {
  var t = this.state.inheritOpt(this.name, 'delimiter', 'name-delimiter', ', '),
    r = !1
  if (e.length > 1) {
    var i = 'single'
    e.length > 2 && (i = 'multiple'),
      (r = JSON.parse(JSON.stringify(this.name.ellipsis[i]))),
      (r = this._getAfterInvertedName(e, t, r))
  }
  return this._join(e, t, r)
}
l.NameOutput.prototype._joinAnd = function (e) {
  var t = this.state.inheritOpt(this.name, 'delimiter', 'name-delimiter', ', '),
    r = this._getAndJoin(e, t)
  return this._join(e, t, r)
}
l.NameOutput.prototype._join = function (e, t, r) {
  var i, n
  if (!e || ((e = this._purgeEmptyBlobs(e)), !e.length)) return !1
  if (e.length > 1)
    if (e.length === 2) r ? (e = [e[0], r, e[1]]) : (e[0].strings.suffix += t)
    else {
      var s
      r ? (s = 1) : (s = 0)
      for (var a = e.pop(), i = 0, n = e.length - s; i < n; i++) e[i].strings.suffix += t
      e.push(r), e.push(a)
    }
  for (this.state.output.openLevel(), i = 0, n = e.length; i < n; i += 1)
    this.state.output.append(e[i], !1, !0)
  return this.state.output.closeLevel(), this.state.output.pop()
}
l.NameOutput.prototype._getToken = function (e) {
  var t = this[e]
  if (e === 'institution') {
    var r = new l.Token()
    return r
  }
  return t
}
l.NameOutput.prototype.checkCommonAuthor = function (e) {
  if (!e) return !1
  var t = !1
  if (this.variables.length === 2) {
    var r = this.variables,
      i = r.slice()
    i.sort(), (t = i.join(''))
  }
  if (!t) return !1
  var n = !1
  if ((this.state.locale[this.state.opt.lang].terms[t] && (n = !0), !n))
    return (
      this.state.tmp.done_vars.push(this.variables[0]),
      this.state.tmp.done_vars.push(this.variables[1]),
      !1
    )
  var s = this.Item[this.variables[0]],
    a = this.Item[this.variables[1]],
    o = this._compareNamesets(s, a)
  return (
    o === !0 &&
      (this.state.tmp.done_vars.push(this.variables[0]),
      this.state.tmp.done_vars.push(this.variables[1])),
    !o
  )
}
l.NameOutput.prototype.setCommonTerm = function () {
  var e = this.variables,
    t = e.slice()
  if ((t.sort(), (this.common_term = t.join('')), !!this.common_term)) {
    var r = !1
    if (
      (this.label &&
        this.label[this.variables[0]] &&
        (this.label[this.variables[0]].before
          ? (r = this.state.getTerm(
              this.common_term,
              this.label[this.variables[0]].before.strings.form,
              0
            ))
          : this.label[this.variables[0]].after &&
            (r = this.state.getTerm(
              this.common_term,
              this.label[this.variables[0]].after.strings.form,
              0
            ))),
      !this.state.locale[this.state.opt.lang].terms[this.common_term] ||
        !r ||
        this.variables.length < 2)
    ) {
      this.common_term = !1
      return
    }
    for (var i = 0, n = this.variables.length - 1; i < n; i += 1) {
      var s = this.variables[i],
        a = this.variables[i + 1]
      if (
        (this.freeters[s].length || this.freeters[a].length) &&
        (this.etal_spec[s].freeters !== this.etal_spec[a].freeters ||
          !this._compareNamesets(this.freeters[s], this.freeters[a]))
      ) {
        this.common_term = !1
        return
      }
      if (this.persons[s].length !== this.persons[a].length) {
        this.common_term = !1
        return
      }
      for (var o = 0, u = this.persons[s].length; o < u; o += 1)
        if (
          this.etal_spec[s].persons[o] !== this.etal_spec[a].persons[o] ||
          !this._compareNamesets(this.persons[s][o], this.persons[a][o])
        ) {
          this.common_term = !1
          return
        }
    }
  }
}
l.NameOutput.prototype._compareNamesets = function (e, t) {
  if (!e || !t || e.length !== t.length) return !1
  for (var r = 0, i = t.length; r < i; r += 1)
    for (var n = 0, s = l.NAME_PARTS.length; n < s; n += 1) {
      var a = l.NAME_PARTS[n]
      if (!e[r] || e[r][a] != t[r][a]) return !1
    }
  return !0
}
l.NameOutput.prototype.constrainNames = function () {
  this.names_count = 0
  for (var e, t = 0, r = this.variables.length; t < r; t += 1) {
    var i = this.variables[t]
    ;(e = this.nameset_base + t),
      this.freeters[i].length &&
        (this.state.tmp.names_max.push(this.freeters[i].length, 'literal'),
        this._imposeNameConstraints(this.freeters, this.freeters_count, i, e),
        (this.names_count += this.freeters[i].length)),
      this.institutions[i].length &&
        (this.state.tmp.names_max.push(this.institutions[i].length, 'literal'),
        this._imposeNameConstraints(this.institutions, this.institutions_count, i, e),
        (this.persons[i] = this.persons[i].slice(0, this.institutions[i].length)),
        (this.names_count += this.institutions[i].length))
    for (var n = 0, s = this.persons[i].length; n < s; n += 1)
      this.persons[i][n].length &&
        (this.state.tmp.names_max.push(this.persons[i][n].length, 'literal'),
        this._imposeNameConstraints(this.persons[i], this.persons_count[i], n, e),
        (this.names_count += this.persons[i][n].length))
  }
}
l.NameOutput.prototype._imposeNameConstraints = function (e, t, r, i) {
  var n = e[r],
    s = this.state.tmp['et-al-min']
  this.state.tmp.suppress_decorations
    ? this.state.tmp.disambig_request && this.state.tmp.disambig_request.names[i]
      ? (s = this.state.tmp.disambig_request.names[i])
      : t[r] >= this.etal_min && (s = this.etal_use_first)
    : (this.state.tmp.disambig_request &&
      this.state.tmp.disambig_request.names[i] > this.etal_use_first
        ? t[r] < this.etal_min
          ? (s = t[r])
          : (s = this.state.tmp.disambig_request.names[i])
        : t[r] >= this.etal_min && (s = this.etal_use_first),
      this.etal_use_last && s > this.etal_min - 2 && (s = this.etal_min - 2))
  var a = this.etal_min >= this.etal_use_first,
    o = t[r] > s
  s > t[r] && (s = n.length),
    a &&
      o &&
      (this.etal_use_last ? (e[r] = n.slice(0, s).concat(n.slice(-1))) : (e[r] = n.slice(0, s))),
    (this.state.tmp.disambig_settings.names[i] = e[r].length),
    this.state.disambiguate.padBase(this.state.tmp.disambig_settings)
}
l.NameOutput.prototype.disambigNames = function () {
  for (var e, t = 0, r = this.variables.length; t < r; t += 1) {
    var i = this.variables[t]
    if (
      ((e = this.nameset_base + t),
      this.freeters[i].length && this._runDisambigNames(this.freeters[i], e),
      this.institutions[i].length)
    ) {
      typeof this.state.tmp.disambig_settings.givens[e] > 'u' &&
        (this.state.tmp.disambig_settings.givens[e] = [])
      for (var n = 0, s = this.institutions[i].length; n < s; n += 1)
        typeof this.state.tmp.disambig_settings.givens[e][n] > 'u' &&
          this.state.tmp.disambig_settings.givens[e].push(2)
    }
    for (var n = 0, s = this.persons[i].length; n < s; n += 1)
      this.persons[i][n].length && this._runDisambigNames(this.persons[i][n], e)
  }
}
l.NameOutput.prototype._runDisambigNames = function (e, t) {
  var r, i, n, s, a, o, u
  for (a = 0, o = e.length; a < o; a += 1)
    if (!(!e[a].given && !e[a].family)) {
      if (
        ((n = this.state.inheritOpt(this.name, 'initialize-with')),
        this.state.registry.namereg.addname('' + this.Item.id, e[a], a),
        (r = this.state.tmp.disambig_settings.givens[t]),
        typeof r > 'u')
      )
        for (var c = 0, f = t + 1; c < f; c += 1)
          this.state.tmp.disambig_settings.givens[c] ||
            (this.state.tmp.disambig_settings.givens[c] = [])
      if (
        ((r = this.state.tmp.disambig_settings.givens[t][a]),
        typeof r > 'u' &&
          ((i = this.state.inheritOpt(this.name, 'form', 'name-form', 'long')),
          (s = this.state.registry.namereg.evalname('' + this.Item.id, e[a], a, 0, i, n)),
          this.state.tmp.disambig_settings.givens[t].push(s)),
        (i = this.state.inheritOpt(this.name, 'form', 'name-form', 'long')),
        (u = this.state.registry.namereg.evalname('' + this.Item.id, e[a], a, 0, i, n)),
        this.state.tmp.disambig_request)
      ) {
        var h = this.state.tmp.disambig_settings.givens[t][a]
        h === 1 &&
          this.state.citation.opt['givenname-disambiguation-rule'] === 'by-cite' &&
          (typeof this.state.inheritOpt(this.name, 'initialize-with') > 'u' ||
            typeof e[a].given > 'u') &&
          (h = 2),
          (s = h),
          this.state.opt['disambiguate-add-givenname'] &&
            e[a].given &&
            (s = this.state.registry.namereg.evalname(
              '' + this.Item.id,
              e[a],
              a,
              s,
              this.state.inheritOpt(this.name, 'form', 'name-form', 'long'),
              this.state.inheritOpt(this.name, 'initialize-with')
            ))
      } else s = u
      !this.state.tmp.just_looking &&
        this.item &&
        this.item.position === l.POSITION_FIRST &&
        u > s &&
        (s = u),
        this.state.tmp.sort_key_flag ||
          ((this.state.tmp.disambig_settings.givens[t][a] = s),
          typeof n == 'string' &&
            (typeof this.name.strings.initialize > 'u' || this.name.strings.initialize === !0) &&
            (this.state.tmp.disambig_settings.use_initials = !0))
    }
}
l.NameOutput.prototype.getEtAlConfig = function () {
  var e = this.item
  ;(this['et-al'] = {}),
    this.state.output.append(this.etal_term, this.etal_style, !0),
    (this['et-al'].single = this.state.output.pop()),
    (this['et-al'].single.strings.suffix = this.etal_suffix),
    (this['et-al'].single.strings.prefix = this.etal_prefix_single),
    this.state.output.append(this.etal_term, this.etal_style, !0),
    (this['et-al'].multiple = this.state.output.pop()),
    (this['et-al'].multiple.strings.suffix = this.etal_suffix),
    (this['et-al'].multiple.strings.prefix = this.etal_prefix_multiple),
    typeof e > 'u' && (e = {}),
    e.position
      ? (this.state.inheritOpt(this.name, 'et-al-subsequent-min')
          ? (this.etal_min = this.state.inheritOpt(this.name, 'et-al-subsequent-min'))
          : (this.etal_min = this.state.inheritOpt(this.name, 'et-al-min')),
        this.state.inheritOpt(this.name, 'et-al-subsequent-use-first')
          ? (this.etal_use_first = this.state.inheritOpt(this.name, 'et-al-subsequent-use-first'))
          : (this.etal_use_first = this.state.inheritOpt(this.name, 'et-al-use-first')))
      : (this.state.tmp['et-al-min']
          ? (this.etal_min = this.state.tmp['et-al-min'])
          : (this.etal_min = this.state.inheritOpt(this.name, 'et-al-min')),
        this.state.tmp['et-al-use-first']
          ? (this.etal_use_first = this.state.tmp['et-al-use-first'])
          : (this.etal_use_first = this.state.inheritOpt(this.name, 'et-al-use-first')),
        typeof this.state.tmp['et-al-use-last'] == 'boolean'
          ? (this.etal_use_last = this.state.tmp['et-al-use-last'])
          : (this.etal_use_last = this.state.inheritOpt(this.name, 'et-al-use-last'))),
    this.state.tmp['et-al-min'] || (this.state.tmp['et-al-min'] = this.etal_min)
}
l.NameOutput.prototype.setEtAlParameters = function () {
  var e, t, r, i
  for (e = 0, t = this.variables.length; e < t; e += 1) {
    var n = this.variables[e]
    for (
      typeof this.etal_spec[n] > 'u' &&
        (this.etal_spec[n] = { freeters: 0, institutions: 0, persons: [] }),
        this.etal_spec[this.nameset_base + e] = this.etal_spec[n],
        this.freeters[n].length && this._setEtAlParameter('freeters', n),
        r = 0,
        i = this.persons[n].length;
      r < i;
      r += 1
    )
      typeof this.etal_spec[n][r] > 'u' && (this.etal_spec[n].persons[r] = 0),
        this._setEtAlParameter('persons', n, r)
    this.institutions[n].length && this._setEtAlParameter('institutions', n)
  }
}
l.NameOutput.prototype._setEtAlParameter = function (e, t, r) {
  var i, n
  e === 'persons'
    ? ((i = this.persons[t][r]), (n = this.persons_count[t][r]))
    : ((i = this[e][t]), (n = this[e + '_count'][t])),
    i.length < n && !this.state.tmp.sort_key_flag
      ? this.etal_use_last
        ? e === 'persons'
          ? (this.etal_spec[t].persons[r] = 2)
          : (this.etal_spec[t][e] = 2)
        : e === 'persons'
        ? (this.etal_spec[t].persons[r] = 1)
        : (this.etal_spec[t][e] = 1)
      : e === 'persons'
      ? (this.etal_spec[t].persons[r] = 0)
      : (this.etal_spec[t][e] = 0)
}
l.NameOutput.prototype.renderAllNames = function () {
  for (var e, t = 0, r = this.variables.length; t < r; t += 1) {
    var i = this.variables[t]
    ;(this.freeters[i].length || this.institutions[i].length) &&
      (this.state.tmp.group_context.tip.condition || (this.state.tmp.just_did_number = !1)),
      (e = this.nameset_base + t),
      this.freeters[i].length && (this.freeters[i] = this._renderNames(i, this.freeters[i], e))
    for (var n = 0, s = this.institutions[i].length; n < s; n += 1)
      this.persons[i][n] = this._renderNames(i, this.persons[i][n], e, n)
  }
  this.renderInstitutionNames()
}
l.NameOutput.prototype.renderInstitutionNames = function () {
  for (var e = 0, t = this.variables.length; e < t; e += 1)
    for (var r = this.variables[e], i = 0, n = this.institutions[r].length; i < n; i += 1) {
      var h,
        s = this.institutions[r][i],
        i,
        n,
        a
      this.state.tmp.extension
        ? (a = ['sort'])
        : s.isInstitution || s.literal
        ? (a = this.state.opt['cite-lang-prefs'].institutions)
        : (a = this.state.opt['cite-lang-prefs'].persons)
      var o = { primary: 'locale-orig', secondary: !1, tertiary: !1 }
      if (a)
        for (
          var u = ['primary', 'secondary', 'tertiary'], c = 0, f = u.length;
          c < f && !(a.length - 1 < c);
          c += 1
        )
          a[c] && (o[u[c]] = 'locale-' + a[c])
      else o.primary = 'locale-translat'
      this.state.tmp.area !== 'bibliography' &&
        !(
          this.state.tmp.area === 'citation' &&
          this.state.opt.xclass === 'note' &&
          this.item &&
          !this.item.position
        ) &&
        ((o.secondary = !1), (o.tertiary = !1)),
        this.setRenderedName(s)
      var h = this._renderInstitutionName(r, s, o, i)
      this.institutions[r][i] = h
    }
}
l.NameOutput.prototype._renderInstitutionName = function (e, t, r, i) {
  var n,
    s,
    a,
    o,
    u,
    c,
    f,
    h = this.getName(t, r.primary, !0),
    p = h.name,
    m = h.usedOrig
  if ((p && (p = this.fixupInstitution(p, e, i)), (n = !1), r.secondary)) {
    h = this.getName(t, r.secondary, !1, m)
    var n = h.name
    ;(m = h.usedOrig), n && (n = this.fixupInstitution(n, e, i))
  }
  ;(s = !1),
    r.tertiary &&
      ((h = this.getName(t, r.tertiary, !1, m)),
      (s = h.name),
      s && (s = this.fixupInstitution(s, e, i)))
  var v = { l: { pri: !1, sec: !1, ter: !1 }, s: { pri: !1, sec: !1, ter: !1 } }
  switch (
    (p && ((v.l.pri = p.long), (v.s.pri = p.short.length ? p.short : p.long)),
    n && ((v.l.sec = n.long), (v.s.sec = n.short.length ? n.short : n.long)),
    s && ((v.l.ter = s.long), (v.s.ter = s.short.length ? s.short : s.long)),
    this.institution.strings['institution-parts'])
  ) {
    case 'short':
      p.short.length
        ? ((o = this._getShortStyle()),
          (u = [this._composeOneInstitutionPart([v.s.pri, v.s.sec, v.s.ter], r, o, e)]))
        : ((a = this._getLongStyle(p, e, i)),
          (u = [this._composeOneInstitutionPart([v.l.pri, v.l.sec, v.l.ter], r, a, e)]))
      break
    case 'short-long':
      ;(a = this._getLongStyle(p, e, i)),
        (o = this._getShortStyle()),
        (c = this._renderOneInstitutionPart(p.short, o)),
        (f = this._composeOneInstitutionPart([v.l.pri, v.l.sec, v.l.ter], r, a, e)),
        (u = [c, f])
      break
    case 'long-short':
      ;(a = this._getLongStyle(p, e, i)),
        (o = this._getShortStyle()),
        (c = this._renderOneInstitutionPart(p.short, o)),
        (f = this._composeOneInstitutionPart([v.l.pri, v.l.sec, v.l.ter], r, a, e)),
        (u = [f, c])
      break
    default:
      ;(a = this._getLongStyle(p, e, i)),
        (u = [this._composeOneInstitutionPart([v.l.pri, v.l.sec, v.l.ter], r, a, e)])
      break
  }
  var b = this._join(u, ' ')
  return b && (b.isInstitution = !0), this.state.tmp.name_node.children.push(b), b
}
l.NameOutput.prototype._composeOneInstitutionPart = function (e, t, r) {
  var i = !1,
    n = !1,
    s = !1,
    a,
    o,
    u
  if (e[0]) {
    if (
      ((a = l.Util.cloneToken(r)),
      this.state.opt.citeAffixes[t.primary] &&
        this.state.opt.citeAffixes.institutions[t.primary].prefix === '<i>')
    ) {
      for (var c = !1, f = 0, h = a.decorations.length; f < h; f += 1)
        r.decorations[f][0] === '@font-style' && a.decorations[f][1] === 'italic' && (c = !0)
      c || a.decorations.push(['@font-style', 'italic'])
    }
    i = this._renderOneInstitutionPart(e[0], a)
  }
  e[1] && (n = this._renderOneInstitutionPart(e[1], r)),
    e[2] && (s = this._renderOneInstitutionPart(e[2], r))
  var p
  if (n || s) {
    this.state.output.openLevel('empty'),
      this.state.output.append(i),
      (o = l.Util.cloneToken(r)),
      t.secondary &&
        ((o.strings.prefix = this.state.opt.citeAffixes.institutions[t.secondary].prefix),
        (o.strings.suffix = this.state.opt.citeAffixes.institutions[t.secondary].suffix),
        o.strings.prefix || (o.strings.prefix = ' '))
    var m = new l.Token()
    m.decorations.push(['@font-style', 'normal']),
      m.decorations.push(['@font-weight', 'normal']),
      this.state.output.openLevel(m),
      this.state.output.append(n, o),
      this.state.output.closeLevel(),
      (u = l.Util.cloneToken(r)),
      t.tertiary &&
        ((u.strings.prefix = this.state.opt.citeAffixes.institutions[t.tertiary].prefix),
        (u.strings.suffix = this.state.opt.citeAffixes.institutions[t.tertiary].suffix),
        u.strings.prefix || (u.strings.prefix = ' '))
    var v = new l.Token()
    v.decorations.push(['@font-style', 'normal']),
      v.decorations.push(['@font-weight', 'normal']),
      this.state.output.openLevel(v),
      this.state.output.append(s, u),
      this.state.output.closeLevel(),
      this.state.output.closeLevel(),
      (p = this.state.output.pop())
  } else p = i
  return p
}
l.NameOutput.prototype._renderOneInstitutionPart = function (e, t) {
  for (var r = 0, i = e.length; r < i; r += 1)
    if (e[r]) {
      var n = e[r]
      if (this.state.tmp.strip_periods) n = n.replace(/\./g, '')
      else
        for (var s = 0, a = t.decorations.length; s < a; s += 1)
          if (t.decorations[s][0] === '@strip-periods' && t.decorations[s][1] === 'true') {
            n = n.replace(/\./g, '')
            break
          }
      ;(this.state.tmp.group_context.tip.variable_success = !0),
        this.state.tmp.can_substitute.replace(!1, l.LITERAL),
        n === '!here>>>'
          ? (e[r] = !1)
          : (this.state.output.append(n, t, !0), (e[r] = this.state.output.pop()))
    }
  return (
    typeof this.institution.strings['part-separator'] > 'u' &&
      (this.institution.strings['part-separator'] = this.state.tmp.name_delimiter),
    this._join(e, this.institution.strings['part-separator'])
  )
}
l.NameOutput.prototype._renderNames = function (e, t, r, i) {
  var n = !1
  if (t.length) {
    for (var s = [], a = 0, o = t.length; a < o; a += 1) {
      var u = t[a],
        n,
        c
      this.state.tmp.extension
        ? (c = ['sort'])
        : u.isInstitution || u.literal
        ? (c = this.state.opt['cite-lang-prefs'].institutions)
        : (c = this.state.opt['cite-lang-prefs'].persons)
      var f = { primary: 'locale-orig', secondary: !1, tertiary: !1 }
      if (c)
        for (
          var h = ['primary', 'secondary', 'tertiary'], p = 0, m = h.length;
          p < m && !(c.length - 1 < p);
          p += 1
        )
          f[h[p]] = 'locale-' + c[p]
      else f.primary = 'locale-translat'
      if (
        ((this.state.tmp.sort_key_flag ||
          (this.state.tmp.area !== 'bibliography' &&
            !(
              this.state.tmp.area === 'citation' &&
              this.state.opt.xclass === 'note' &&
              this.item &&
              !this.item.position
            ))) &&
          ((f.secondary = !1), (f.tertiary = !1)),
        this.setRenderedName(u),
        !u.literal && !u.isInstitution)
      ) {
        var v = this._renderPersonalName(e, u, f, r, a, i),
          b = l.Util.cloneToken(this.name)
        this.state.output.append(v, b, !0), s.push(this.state.output.pop())
      } else s.push(this._renderInstitutionName(e, u, f, i))
    }
    n = this.joinPersons(s, r, i)
  }
  return n
}
l.NameOutput.prototype._renderPersonalName = function (e, t, r, i, n, s) {
  var a = this.getName(t, r.primary, !0),
    o = this._renderOnePersonalName(a.name, i, n, s),
    u = !1
  r.secondary &&
    ((a = this.getName(t, r.secondary, !1, a.usedOrig)),
    a.name && (u = this._renderOnePersonalName(a.name, i, n, s)))
  var c = !1
  r.tertiary &&
    ((a = this.getName(t, r.tertiary, !1, a.usedOrig)),
    a.name && (c = this._renderOnePersonalName(a.name, i, n, s)))
  var f
  if (u || c) {
    this.state.output.openLevel('empty'), this.state.output.append(o)
    var h = new l.Token()
    r.secondary &&
      ((h.strings.prefix = this.state.opt.citeAffixes.persons[r.secondary].prefix),
      (h.strings.suffix = this.state.opt.citeAffixes.persons[r.secondary].suffix),
      h.strings.prefix || (h.strings.prefix = ' ')),
      this.state.output.append(u, h)
    var p = new l.Token()
    r.tertiary &&
      ((p.strings.prefix = this.state.opt.citeAffixes.persons[r.tertiary].prefix),
      (p.strings.suffix = this.state.opt.citeAffixes.persons[r.tertiary].suffix),
      p.strings.prefix || (p.strings.prefix = ' ')),
      this.state.output.append(c, p),
      this.state.output.closeLevel(),
      (f = this.state.output.pop())
  } else f = o
  return f
}
l.NameOutput.prototype._isRomanesque = function (e) {
  var t = 2
  e.family.replace(/\"/g, '').match(l.ROMANESQUE_REGEXP) || (t = 0),
    !t && e.given && e.given.match(l.STARTSWITH_ROMANESQUE_REGEXP) && (t = 1)
  var r
  return (
    t == 2 &&
      (e.multi && e.multi.main
        ? (r = e.multi.main.slice(0, 2))
        : this.Item.language && (r = this.Item.language.slice(0, 2)),
      ['ja', 'zh'].indexOf(r) > -1 && (t = 1)),
    t
  )
}
l.NameOutput.prototype._renderOnePersonalName = function (e, t, r, i) {
  var n = e,
    s = this._droppingParticle(n, t, i),
    a = this._familyName(n),
    o = this._nonDroppingParticle(n),
    u = this._givenName(n, t, r),
    c = u.blob,
    f = this._nameSuffix(n)
  c === !1 && ((s = !1), (f = !1))
  var h = this.state.inheritOpt(this.name, 'sort-separator')
  h || (h = '')
  var p
  n['comma-suffix'] ? (p = ', ') : (p = ' ')
  var m = this._isRomanesque(n)
  function v(T) {
    return T
      ? typeof T.blobs == 'string'
        ? ['', "'", '-', ' '].indexOf(T.blobs.slice(-1)) > -1
        : v(T.blobs[T.blobs.length - 1])
      : !1
  }
  var b = v(o),
    S
  ;['fr', 'ru', 'cs'].indexOf(this.state.opt['default-locale'][0].slice(0, 2)) > -1
    ? (S = '')
    : (S = ' ')
  var g, _, y, x
  if (m === 0) g = this._join([o, a, c], '')
  else if (m === 1 || n['static-ordering'])
    (_ = this._join([o, a], S)), (g = this._join([_, c], ' '))
  else if (n['reverse-ordering']) (_ = this._join([o, a], S)), (g = this._join([c, _], ' '))
  else if (this.state.tmp.sort_key_flag)
    this.state.opt['demote-non-dropping-particle'] === 'never'
      ? ((_ = this._join([o, a], S)),
        (_ = this._join([_, s], ' ')),
        (_ = this._join([_, c], this.state.opt.sort_sep)),
        (g = this._join([_, f], ' ')))
      : ((x = this._join([c, s, o], ' ')),
        (_ = this._join([a, x], this.state.opt.sort_sep)),
        (g = this._join([_, f], ' ')))
  else if (
    this.state.inheritOpt(this.name, 'name-as-sort-order') === 'all' ||
    (this.state.inheritOpt(this.name, 'name-as-sort-order') === 'first' &&
      r === 0 &&
      (i === 0 || typeof i > 'u'))
  )
    ['Lord', 'Lady'].indexOf(n.given) > -1 && (h = ', '),
      ['always', 'display-and-sort'].indexOf(this.state.opt['demote-non-dropping-particle']) > -1
        ? ((x = this._join([c, s], n['comma-dropping-particle'] + ' ')),
          (x = this._join([x, o], ' ')),
          x &&
            this.given &&
            ((x.strings.prefix = this.given.strings.prefix),
            (x.strings.suffix = this.given.strings.suffix)),
          a &&
            this.family &&
            ((a.strings.prefix = this.family.strings.prefix),
            (a.strings.suffix = this.family.strings.suffix)),
          (_ = this._join([a, x], h)),
          (g = this._join([_, f], h)))
        : (b ? (y = this._join([o, a], '')) : (y = this._join([o, a], S)),
          y &&
            this.family &&
            ((y.strings.prefix = this.family.strings.prefix),
            (y.strings.suffix = this.family.strings.suffix)),
          (x = this._join([c, s], n['comma-dropping-particle'] + ' ')),
          x &&
            this.given &&
            ((x.strings.prefix = this.given.strings.prefix),
            (x.strings.suffix = this.given.strings.suffix)),
          (_ = this._join([y, x], h)),
          (g = this._join([_, f], h))),
      (g.isInverted = !0)
  else {
    if (n['dropping-particle'] && n.family && !n['non-dropping-particle']) {
      var D = n['dropping-particle'],
        C = ["'", '', '', '-']
      C.indexOf(D.slice(-1)) > -1 &&
        D.slice(0, -1) !== 'de' &&
        ((a = this._join([s, a], '')), (s = !1))
    }
    b
      ? ((x = this._join([o, a], '')), (x = this._join([s, x], S)))
      : (x = this._join([s, o, a], S)),
      (x = this._join([x, f], p)),
      x &&
        this.family &&
        ((x.strings.prefix = this.family.strings.prefix),
        (x.strings.suffix = this.family.strings.suffix)),
      c &&
        this.given &&
        ((c.strings.prefix = this.given.strings.prefix),
        (c.strings.suffix = this.given.strings.suffix)),
      x.strings.prefix && (n['comma-dropping-particle'] = '')
    var H
    this.state.inheritOpt(this.name, 'initialize-with') &&
    this.state.inheritOpt(this.name, 'initialize-with').match(/[\u00a0\ufeff]/) &&
    u.initializationLevel === 1
      ? (H = S)
      : (H = ' '),
      (g = this._join([c, x], n['comma-dropping-particle'] + H))
  }
  return (
    (this.state.tmp.group_context.tip.variable_success = !0),
    this.state.tmp.can_substitute.replace(!1, l.LITERAL),
    (this.state.tmp.term_predecessor = !0),
    this.state.tmp.name_node.children.push(g),
    g
  )
}
l.NameOutput.prototype._normalizeNameInput = function (e) {
  var t = {
    literal: e.literal,
    family: e.family,
    isInstitution: e.isInstitution,
    given: e.given,
    suffix: e.suffix,
    'comma-suffix': e['comma-suffix'],
    'non-dropping-particle': e['non-dropping-particle'],
    'dropping-particle': e['dropping-particle'],
    'static-ordering': e['static-ordering'],
    'static-particles': e['static-particles'],
    'reverse-ordering': e['reverse-ordering'],
    'full-form-always': e['full-form-always'],
    'parse-names': e['parse-names'],
    'comma-dropping-particle': '',
    block_initialize: e.block_initialize,
    multi: e.multi,
  }
  return this._parseName(t), t
}
l.NameOutput.prototype._stripPeriods = function (e, t) {
  var r = this[e + '_decor']
  if (t) {
    if (this.state.tmp.strip_periods) t = t.replace(/\./g, '')
    else if (r) {
      for (var i = 0, n = r.decorations.length; i < n; i += 1)
        if (r.decorations[i][0] === '@strip-periods' && r.decorations[i][1] === 'true') {
          t = t.replace(/\./g, '')
          break
        }
    }
  }
  return t
}
l.NameOutput.prototype._nonDroppingParticle = function (e) {
  var t = e['non-dropping-particle']
  t && this.state.tmp.sort_key_flag && (t = t.replace(/[\'\u2019]/, ''))
  var r = this._stripPeriods('family', t)
  return this.state.output.append(r, this.family_decor, !0) ? this.state.output.pop() : !1
}
l.NameOutput.prototype._droppingParticle = function (e, t, r) {
  var i = e['dropping-particle']
  i && this.state.tmp.sort_key_flag && (i = i.replace(/[\'\u2019]/, ''))
  var n = this._stripPeriods('given', i)
  if (e['dropping-particle'] && e['dropping-particle'].match(/^et.?al[^a-z]$/))
    this.state.inheritOpt(this.name, 'et-al-use-last')
      ? typeof r > 'u'
        ? (this.etal_spec[t].freeters = 2)
        : (this.etal_spec[t].persons = 2)
      : typeof r > 'u'
      ? (this.etal_spec[t].freeters = 1)
      : (this.etal_spec[t].persons = 1),
      (e['comma-dropping-particle'] = '')
  else if (this.state.output.append(n, this.given_decor, !0)) return this.state.output.pop()
  return !1
}
l.NameOutput.prototype._familyName = function (e) {
  var t = this._stripPeriods('family', e.family)
  return this.state.output.append(t, this.family_decor, !0) ? this.state.output.pop() : !1
}
l.NameOutput.prototype._givenName = function (e, t, r) {
  var i,
    n = this.state.inheritOpt(this.name, 'form', 'name-form', 'long') !== 'long',
    s = this.state.inheritOpt(this.name, 'initialize') !== !1,
    a =
      typeof this.state.inheritOpt(this.name, 'initialize-with') == 'string' && !e.block_initialize,
    o,
    u
  if (e['full-form-always']) u = 2
  else {
    n ? (o = 0) : a ? (o = 1) : (o = 2)
    var c = this.state.tmp.disambig_settings.givens[t][r]
    c > o ? (u = c) : (u = o)
  }
  var f = this.state.citation.opt['givenname-disambiguation-rule']
  if ((f && f.slice(-14) === '-with-initials' && (a = !0), e.family && u === 1))
    if (a) {
      var h = this.state.inheritOpt(this.name, 'initialize-with', !1, '')
      e.given = l.Util.Names.initializeWith(this.state, e.given, h, !s)
    } else e.given = l.Util.Names.unInitialize(this.state, e.given)
  else {
    if (u === 0) return { blob: !1 }
    u === 2 && (e.given = l.Util.Names.unInitialize(this.state, e.given))
  }
  var p = this._stripPeriods('given', e.given),
    m = this.state.output.append(p, this.given_decor, !0)
  return m ? ((i = this.state.output.pop()), { blob: i, initializationLevel: u }) : { blob: !1 }
}
l.NameOutput.prototype._nameSuffix = function (e) {
  var t = e.suffix,
    r
  t &&
    typeof this.state.inheritOpt(this.name, 'initialize-with') == 'string' &&
    (t = l.Util.Names.initializeWith(
      this.state,
      t,
      this.state.inheritOpt(this.name, 'initialize-with'),
      !0
    )),
    (t = this._stripPeriods('family', t))
  var i = ''
  t && t.slice(-1) === '.' && ((t = t.slice(0, -1)), (i = '.'))
  var n = this.state.output.append(t, 'empty', !0)
  return n ? ((r = this.state.output.pop()), (r.strings.suffix = i + r.strings.suffix), r) : !1
}
l.NameOutput.prototype._getLongStyle = function (e) {
  var t
  return (
    e.short.length
      ? this.institutionpart['long-with-short']
        ? (t = this.institutionpart['long-with-short'])
        : (t = this.institutionpart.long)
      : (t = this.institutionpart.long),
    t || (t = new l.Token()),
    t
  )
}
l.NameOutput.prototype._getShortStyle = function () {
  var e
  return this.institutionpart.short ? (e = this.institutionpart.short) : (e = new l.Token()), e
}
l.NameOutput.prototype._parseName = function (e) {
  if (!e['parse-names'] && typeof e['parse-names'] < 'u') return e
  e.family &&
    !e.given &&
    e.isInstitution &&
    ((e.literal = e.family), (e.family = void 0), (e.isInstitution = void 0))
  var t
  ;(e.family && e.family.slice(0, 1) === '"' && e.family.slice(-1) === '"') ||
  (!e['parse-names'] && typeof e['parse-names'] < 'u')
    ? ((e.family = e.family.slice(1, -1)), (t = !0), (e['parse-names'] = 0))
    : (t = !1),
    this.state.opt.development_extensions.parse_names &&
      !e['non-dropping-particle'] &&
      e.family &&
      !t &&
      e.given &&
      (e['static-particles'] || l.parseParticles(e, !0))
}
l.NameOutput.prototype.getName = function (e, t, r, i) {
  if (i && t === 'locale-orig') return { name: !1, usedOrig: i }
  e.family || (e.family = ''), e.given || (e.given = '')
  var n = {}
  n['static-ordering'] = this.getStaticOrder(e)
  var s = !0,
    a
  if (t !== 'locale-orig' && ((s = !1), e.multi)) {
    for (var o = this.state.opt[t], u = 0, c = o.length; u < c; u += 1)
      if (((a = o[u]), e.multi._key[a])) {
        s = !0
        var f = e.isInstitution
        ;(e = e.multi._key[a]),
          (e.isInstitution = f),
          (n = this.getNameParams(a)),
          (n.transliterated = !0)
        break
      }
  }
  if (
    (s ||
      ((a = !1),
      e.multi && e.multi.main ? (a = e.multi.main) : this.Item.language && (a = this.Item.language),
      a && (n = this.getNameParams(a))),
    !r && !s)
  )
    return { name: !1, usedOrig: i }
  e.family || (e.family = ''),
    e.given || (e.given = ''),
    e.literal && (delete e.family, delete e.given),
    (e = {
      family: e.family,
      given: e.given,
      'non-dropping-particle': e['non-dropping-particle'],
      'dropping-particle': e['dropping-particle'],
      suffix: e.suffix,
      'static-ordering': n['static-ordering'],
      'static-particles': e['static-particles'],
      'reverse-ordering': n['reverse-ordering'],
      'full-form-always': n['full-form-always'],
      'parse-names': e['parse-names'],
      'comma-suffix': e['comma-suffix'],
      'comma-dropping-particle': e['comma-dropping-particle'],
      transliterated: n.transliterated,
      block_initialize: n['block-initialize'],
      literal: e.literal,
      isInstitution: e.isInstitution,
      multi: e.multi,
    }),
    !e.literal && !e.given && e.family && e.isInstitution && (e.literal = e.family),
    e.literal && (delete e.family, delete e.given),
    (e = this._normalizeNameInput(e))
  var h
  return i ? (h = i) : (h = !s), { name: e, usedOrig: h }
}
l.NameOutput.prototype.getNameParams = function (e) {
  var t = {},
    r = l.localeResolve(this.Item.language, this.state.opt['default-locale'][0]),
    i = this.state.locale[r.best] ? r.best : this.state.opt['default-locale'][0],
    n = this.state.locale[i].opts['name-as-sort-order'],
    s = this.state.locale[i].opts['name-as-reverse-order'],
    a = this.state.locale[i].opts['name-never-short'],
    o = e.split('-')[0]
  return (
    n && n[o] && ((t['static-ordering'] = !0), (t['reverse-ordering'] = !1)),
    s && s[o] && ((t['reverse-ordering'] = !0), (t['static-ordering'] = !1)),
    a && a[o] && (t['full-form-always'] = !0),
    t['static-ordering'] && (t['block-initialize'] = !0),
    t
  )
}
l.NameOutput.prototype.setRenderedName = function (e) {
  if (this.state.tmp.area === 'bibliography') {
    for (var t = '', r = 0, i = l.NAME_PARTS.length; r < i; r += 1)
      e[l.NAME_PARTS[r]] && (t += e[l.NAME_PARTS[r]])
    this.state.tmp.rendered_name.push(t)
  }
}
l.NameOutput.prototype.fixupInstitution = function (e, t, r) {
  !e.literal && e.family && ((e.literal = e.family), delete e.family)
  var i = e.literal,
    n = i,
    s = { long: i.split(/\s*\|\s*/), short: n.split(/\s*\|\s*/) }
  if (this.state.sys.getAbbreviation) {
    if (this.institution.strings.form === 'short') {
      let p = this.Item.jurisdiction
      ;(p = this.state.transform.loadAbbreviation(p, 'institution-entire', i, this.Item.language)),
        this.state.transform.abbrevs[p]['institution-entire'][i]
          ? (i = this.state.transform.abbrevs[p]['institution-entire'][i])
          : ((p = this.Item.jurisdiction),
            (p = this.state.transform.loadAbbreviation(
              p,
              'institution-part',
              i,
              this.Item.language
            )),
            this.state.transform.abbrevs[p]['institution-part'][i] &&
              (i = this.state.transform.abbrevs[p]['institution-part'][i])),
        (i = this._quashChecks(p, i))
    }
    if (
      ['short', 'short-long', 'long-short'].indexOf(this.institution.strings['institution-parts']) >
      -1
    ) {
      let p = this.Item.jurisdiction
      ;(p = this.state.transform.loadAbbreviation(p, 'institution-part', n, this.Item.language)),
        this.state.transform.abbrevs[p]['institution-part'][n] &&
          (n = this.state.transform.abbrevs[p]['institution-part'][n]),
        (n = this._quashChecks(p, n)),
        ['short-long', 'long-short'].indexOf(this.institution.strings['institution-parts']) > -1 &&
          n === i &&
          (n = '')
    }
    if (
      ((s.long = i.split(/\s*\|\s*/)),
      (s.short = n.split(/\s*\|\s*/)),
      ['short', 'short-long', 'long-short'].indexOf(this.institution.strings['institution-parts']) >
        -1)
    )
      for (var a = s.short.length - 1; a > -1; a--) {
        let p = this.Item.jurisdiction
        var o = s.short[a]
        if (
          ((p = this.state.transform.loadAbbreviation(
            p,
            'institution-part',
            o,
            this.Item.language
          )),
          this.state.transform.abbrevs[p]['institution-part'][o] &&
            (s.short[a] = this.state.transform.abbrevs[p]['institution-part'][o]),
          s.short[a].indexOf('|') > -1)
        ) {
          let m = s.short,
            v = m[a].split(/\s*\|\s*/)
          s.short = m
            .slice(0, a)
            .concat(v)
            .concat(m.slice(a + 1))
        }
      }
    if (
      (this.state.opt.development_extensions.legacy_institution_name_ordering && s.short.reverse(),
      (s.short = this._trimInstitution(s.short)),
      this.institution.strings['reverse-order'] && s.short.reverse(),
      !this.state.tmp.just_looking && this.Item.jurisdiction)
    ) {
      let p = this.Item.jurisdiction
      var u = this.state.tmp.abbrev_trimmer
      if (u && u[p] && u[p][t])
        for (var c = 0, f = s.short.length; c < f; c++) {
          var h = s.short[c]
          s.short[c] = h.replace(u[p][t], '').trim()
        }
    }
  }
  return (
    this.state.opt.development_extensions.legacy_institution_name_ordering && s.long.reverse(),
    (s.long = this._trimInstitution(s.long)),
    this.institution.strings['reverse-order'] && s.long.reverse(),
    s
  )
}
l.NameOutput.prototype.getStaticOrder = function (e, t) {
  var r = !1
  return (
    ((!t && e['static-ordering']) ||
      this._isRomanesque(e) === 0 ||
      ((!e.multi || !e.multi.main) &&
        this.Item.language &&
        ['vi', 'hu'].indexOf(this.Item.language) > -1) ||
      (e.multi && e.multi.main && ['vi', 'hu'].indexOf(e.multi.main.slice(0, 2)) > -1) ||
      (this.state.opt['auto-vietnamese-names'] &&
        l.VIETNAMESE_NAMES.exec(e.family + ' ' + e.given) &&
        l.VIETNAMESE_SPECIALS.exec(e.family + e.given))) &&
      (r = !0),
    r
  )
}
l.NameOutput.prototype._quashChecks = function (e, r) {
  var r = this.state.transform.quashCheck(e, r),
    i = r.split(/>>[0-9]{4}>>/),
    n = r.match(/>>([0-9]{4})>>/)
  r = i.pop()
  var s = this.Item['original-date'] ? this.Item['original-date'] : this.Item.issued
  if ((s && ((s = parseInt(s.year, 10)), (s = isNaN(s) ? !1 : s)), s)) {
    if (i.length > 0)
      for (var a = n.length - 1; a > 0 && !(s >= parseInt(n[a], 10)); a--) r = i.pop()
    r = r.replace(/\s*\|\s*/g, '|')
  }
  return r
}
l.NameOutput.prototype._trimInstitution = function (e) {
  var t = !1,
    r = !1,
    i = !1,
    n = !1,
    s = e.slice()
  if (this.institution) {
    if (
      (typeof this.institution.strings['use-first'] < 'u' &&
        (t = this.institution.strings['use-first']),
      typeof this.institution.strings['use-last'] < 'u' &&
        (i = this.institution.strings['use-last']),
      typeof this.institution.strings['stop-first'] < 'u' &&
        (n = this.institution.strings['stop-first']),
      typeof this.institution.strings['stop-last'] < 'u' &&
        (r = this.institution.strings['stop-last']),
      t && (r && (s = s.slice(0, r * -1)), (s = s.slice(0, t))),
      i)
    ) {
      var a = e.slice()
      t ? (n = t) : (s = []), n && (a = a.slice(n)), (a = a.slice(i * -1)), (s = s.concat(a))
    }
    e = s
  }
  return e
}
l.PublisherOutput = function (e, t) {
  ;(this.state = e), (this.group_tok = t), (this.varlist = [])
}
l.PublisherOutput.prototype.render = function () {
  this.clearVars(),
    this.composeAndBlob(),
    this.composeElements(),
    this.composePublishers(),
    this.joinPublishers()
}
l.PublisherOutput.prototype.composeAndBlob = function () {
  this.and_blob = {}
  var e = !1
  this.group_tok.strings.and === 'text'
    ? (e = this.state.getTerm('and'))
    : this.group_tok.strings.and === 'symbol' && (e = '&')
  var t = new l.Token()
  ;(t.strings.suffix = ' '), (t.strings.prefix = ' '), this.state.output.append(e, t, !0)
  var r = this.state.output.pop()
  ;(t.strings.prefix = this.group_tok.strings['subgroup-delimiter']),
    this.state.output.append(e, t, !0)
  var i = this.state.output.pop()
  ;(this.and_blob.single = !1),
    (this.and_blob.multiple = !1),
    e &&
      (this.group_tok.strings['subgroup-delimiter-precedes-last'] === 'always'
        ? (this.and_blob.single = i)
        : this.group_tok.strings['subgroup-delimiter-precedes-last'] === 'never'
        ? ((this.and_blob.single = r), (this.and_blob.multiple = r))
        : ((this.and_blob.single = r), (this.and_blob.multiple = i)))
}
l.PublisherOutput.prototype.composeElements = function () {
  for (var e = 0, t = 2; e < t; e += 1)
    for (
      var r = ['publisher', 'publisher-place'][e], i = 0, n = this['publisher-list'].length;
      i < n;
      i += 1
    ) {
      var s = this[r + '-list'][i],
        a = this[r + '-token']
      this.state.output.append(s, a, !0), (this[r + '-list'][i] = this.state.output.pop())
    }
}
l.PublisherOutput.prototype.composePublishers = function () {
  for (var e, t = 0, r = this['publisher-list'].length; t < r; t += 1)
    (e = [this[this.varlist[0] + '-list'][t], this[this.varlist[1] + '-list'][t]]),
      (this['publisher-list'][t] = this._join(e, this.group_tok.strings.delimiter))
}
l.PublisherOutput.prototype.joinPublishers = function () {
  var e = this['publisher-list'],
    t = this._join(
      e,
      this.group_tok.strings['subgroup-delimiter'],
      this.and_blob.single,
      this.and_blob.multiple,
      this.group_tok
    )
  this.state.output.append(t, 'literal')
}
l.PublisherOutput.prototype._join = l.NameOutput.prototype._join
l.PublisherOutput.prototype._getToken = l.NameOutput.prototype._getToken
l.PublisherOutput.prototype.clearVars = function () {
  ;(this.state.tmp['publisher-list'] = !1),
    (this.state.tmp['publisher-place-list'] = !1),
    (this.state.tmp['publisher-group-token'] = !1),
    (this.state.tmp['publisher-token'] = !1),
    (this.state.tmp['publisher-place-token'] = !1)
}
l.evaluateLabel = function (e, t, r, i) {
  var n
  e.strings.term === 'locator'
    ? (i && i.label && (i.label === 'sub verbo' ? (n = 'sub-verbo') : (n = i.label)),
      n || (n = 'page'))
    : (n = e.strings.term)
  var s = e.strings.plural
  if (typeof s != 'number') {
    var a = i && e.strings.term === 'locator' ? i : r
    a[e.strings.term] &&
      (t.processNumber(!1, a, e.strings.term, r.type),
      (s = t.tmp.shadow_numbers[e.strings.term].plural),
      !t.tmp.shadow_numbers[e.strings.term].labelForm &&
        !t.tmp.shadow_numbers[e.strings.term].labelDecorations &&
        (e.strings.form
          ? (t.tmp.shadow_numbers[e.strings.term].labelForm = e.strings.form)
          : t.tmp.group_context.tip.label_form &&
            (t.tmp.shadow_numbers[e.strings.term].labelForm = t.tmp.group_context.tip.label_form),
        (t.tmp.shadow_numbers[e.strings.term].labelCapitalizeIfFirst =
          e.strings.capitalize_if_first),
        (t.tmp.shadow_numbers[e.strings.term].labelDecorations = e.decorations.slice())),
      ['locator', 'number', 'page'].indexOf(e.strings.term) > -1 &&
        t.tmp.shadow_numbers[e.strings.term].label &&
        (n = t.tmp.shadow_numbers[e.strings.term].label),
      e.decorations &&
        t.opt.development_extensions.csl_reverse_lookup_support &&
        (e.decorations.reverse(),
        e.decorations.push(['@showid', 'true', e.cslid]),
        e.decorations.reverse()))
  }
  return l.castLabel(t, e, n, s, l.TOLERANT)
}
l.castLabel = function (e, t, r, i, n) {
  var s = t.strings.form,
    a = t.strings.capitalize_if_first
  e.tmp.group_context.tip.label_form &&
    (s === 'static'
      ? (e.tmp.group_context.tip.label_static = !0)
      : (s = e.tmp.group_context.tip.label_form)),
    e.tmp.group_context.tip.label_capitalize_if_first &&
      (a = e.tmp.group_context.tip.label_capitalize_if_first)
  var o = e.getTerm(r, s, i, !1, n, t.default_locale)
  if ((a && (o = l.Output.Formatters['capitalize-first'](e, o)), e.tmp.strip_periods))
    o = o.replace(/\./g, '')
  else
    for (var u = 0, c = t.decorations.length; u < c; u += 1)
      if (t.decorations[u][0] === '@strip-periods' && t.decorations[u][1] === 'true') {
        o = o.replace(/\./g, '')
        break
      }
  return o
}
l.Node.name = {
  build: function (e, t) {
    var r
    if ([l.SINGLETON, l.START].indexOf(this.tokentype) > -1) {
      var i
      typeof e.tmp.root > 'u' ? ((i = void 0), (e.tmp.root = 'citation')) : (i = e.tmp.root),
        e.inheritOpt(this, 'et-al-subsequent-min') &&
          e.inheritOpt(this, 'et-al-subsequent-min') !== e.inheritOpt(this, 'et-al-min') &&
          (e.opt.update_mode = l.POSITION),
        e.inheritOpt(this, 'et-al-subsequent-use-first') &&
          e.inheritOpt(this, 'et-al-subsequent-use-first') !==
            e.inheritOpt(this, 'et-al-use-first') &&
          (e.opt.update_mode = l.POSITION),
        (e.tmp.root = i),
        (r = function (n) {
          ;(n.tmp.etal_term = 'et-al'),
            (n.tmp.name_delimiter = n.inheritOpt(this, 'delimiter', 'name-delimiter', ', ')),
            (n.tmp['delimiter-precedes-et-al'] = n.inheritOpt(this, 'delimiter-precedes-et-al')),
            n.inheritOpt(this, 'and') === 'text'
              ? (this.and_term = n.getTerm('and', 'long', 0))
              : n.inheritOpt(this, 'and') === 'symbol' &&
                (n.opt.development_extensions.expect_and_symbol_form
                  ? (this.and_term = n.getTerm('and', 'symbol', 0))
                  : (this.and_term = '&')),
            (n.tmp.and_term = this.and_term),
            l.STARTSWITH_ROMANESQUE_REGEXP.test(this.and_term)
              ? ((this.and_prefix_single = ' '),
                (this.and_prefix_multiple = ', '),
                typeof n.tmp.name_delimiter == 'string' &&
                  (this.and_prefix_multiple = n.tmp.name_delimiter),
                (this.and_suffix = ' '))
              : ((this.and_prefix_single = ''),
                (this.and_prefix_multiple = ''),
                (this.and_suffix = '')),
            n.inheritOpt(this, 'delimiter-precedes-last') === 'always'
              ? (this.and_prefix_single = n.tmp.name_delimiter)
              : n.inheritOpt(this, 'delimiter-precedes-last') === 'never'
              ? this.and_prefix_multiple && (this.and_prefix_multiple = ' ')
              : n.inheritOpt(this, 'delimiter-precedes-last') === 'after-inverted-name' &&
                (this.and_prefix_single && (this.and_prefix_single = n.tmp.name_delimiter),
                this.and_prefix_multiple && (this.and_prefix_multiple = ' ')),
            (this.and = {}),
            n.inheritOpt(this, 'and')
              ? (n.output.append(this.and_term, 'empty', !0),
                (this.and.single = n.output.pop()),
                (this.and.single.strings.prefix = this.and_prefix_single),
                (this.and.single.strings.suffix = this.and_suffix),
                n.output.append(this.and_term, 'empty', !0),
                (this.and.multiple = n.output.pop()),
                (this.and.multiple.strings.prefix = this.and_prefix_multiple),
                (this.and.multiple.strings.suffix = this.and_suffix))
              : n.tmp.name_delimiter &&
                ((this.and.single = new l.Blob(n.tmp.name_delimiter)),
                (this.and.single.strings.prefix = ''),
                (this.and.single.strings.suffix = ''),
                (this.and.multiple = new l.Blob(n.tmp.name_delimiter)),
                (this.and.multiple.strings.prefix = ''),
                (this.and.multiple.strings.suffix = '')),
            (this.ellipsis = {}),
            n.inheritOpt(this, 'et-al-use-last') &&
              ((this.ellipsis_term = ''),
              (this.ellipsis_prefix_single = ' '),
              (this.ellipsis_prefix_multiple = n.inheritOpt(
                this,
                'delimiter',
                'name-delimiter',
                ', '
              )),
              (this.ellipsis_suffix = ' '),
              (this.ellipsis.single = new l.Blob(this.ellipsis_term)),
              (this.ellipsis.single.strings.prefix = this.ellipsis_prefix_single),
              (this.ellipsis.single.strings.suffix = this.ellipsis_suffix),
              (this.ellipsis.multiple = new l.Blob(this.ellipsis_term)),
              (this.ellipsis.multiple.strings.prefix = this.ellipsis_prefix_multiple),
              (this.ellipsis.multiple.strings.suffix = this.ellipsis_suffix)),
            typeof n.tmp['et-al-min'] > 'u' &&
              (n.tmp['et-al-min'] = n.inheritOpt(this, 'et-al-min')),
            typeof n.tmp['et-al-use-first'] > 'u' &&
              (n.tmp['et-al-use-first'] = n.inheritOpt(this, 'et-al-use-first')),
            typeof n.tmp['et-al-use-last'] > 'u' &&
              (n.tmp['et-al-use-last'] = n.inheritOpt(this, 'et-al-use-last')),
            (n.nameOutput.name = this)
        }),
        (e.build.name_flag = !0),
        this.execs.push(r)
    }
    t.push(this)
  },
}
l.Node['name-part'] = {
  build: function (e) {
    e.build[this.strings.name] = this
  },
}
l.Node.names = {
  build: function (e, t) {
    var r
    if (
      ((this.tokentype === l.START || this.tokentype === l.SINGLETON) &&
        (l.Util.substituteStart.call(this, e, t), e.build.substitute_level.push(1)),
      this.tokentype === l.SINGLETON)
    ) {
      e.build.names_variables[e.build.names_variables.length - 1].concat(this.variables)
      for (var i in this.variables) {
        var n = this.variables[i],
          s = e.build.name_label[e.build.name_label.length - 1]
        Object.keys(s).length && (s[n] = s[Object.keys(s)[0]])
      }
      ;(r = function (u) {
        u.nameOutput.reinit(this, this.variables_real[0])
      }),
        this.execs.push(r)
    }
    if (
      (this.tokentype === l.START &&
        ((e.build.names_flag = !0),
        (e.build.name_flag = !1),
        (e.build.names_level += 1),
        e.build.names_variables.push(this.variables),
        e.build.name_label.push({}),
        (r = function (u) {
          u.tmp.can_substitute.push(!0),
            (u.tmp.name_node = {}),
            (u.tmp.name_node.children = []),
            u.nameOutput.init(this)
        }),
        this.execs.push(r)),
      this.tokentype === l.END)
    ) {
      for (var i = 0, a = 3; i < a; i += 1) {
        var o = ['family', 'given', 'et-al'][i]
        ;(this[o] = e.build[o]), e.build.names_level === 1 && (e.build[o] = void 0)
      }
      ;(this.label = e.build.name_label[e.build.name_label.length - 1]),
        (e.build.names_level += -1),
        e.build.names_variables.pop(),
        e.build.name_label.pop(),
        (r = function (u) {
          u.tmp.etal_node ? (this.etal_style = u.tmp.etal_node) : (this.etal_style = 'empty'),
            (this.etal_term = u.getTerm(u.tmp.etal_term, 'long', 0)),
            (this.etal_prefix_single = ' '),
            (this.etal_prefix_multiple = u.tmp.name_delimiter),
            u.tmp['delimiter-precedes-et-al'] === 'always'
              ? (this.etal_prefix_single = u.tmp.name_delimiter)
              : u.tmp['delimiter-precedes-et-al'] === 'never'
              ? (this.etal_prefix_multiple = ' ')
              : u.tmp['delimiter-precedes-et-al'] === 'after-inverted-name' &&
                ((this.etal_prefix_single = u.tmp.name_delimiter),
                (this.etal_prefix_multiple = ' ')),
            (this.etal_suffix = ''),
            l.STARTSWITH_ROMANESQUE_REGEXP.test(this.etal_term) ||
              (this.etal_prefix_single === ' ' && (this.etal_prefix_single = ''),
              this.etal_prefix_multiple === ' ' && (this.etal_prefix_multiple = ''),
              this.etal_suffix === ' ' && (this.etal_suffix = ''))
          for (var c = 0, f = 3; c < f; c += 1) {
            var h = ['family', 'given'][c]
            u.nameOutput[h] = this[h]
          }
          u.nameOutput.with = this.with
          var p = 'with',
            m = '',
            v = ''
          l.STARTSWITH_ROMANESQUE_REGEXP.test(p) && ((m = ' '), (v = ' '))
          var b = {}
          ;(b.single = new l.Blob(p)),
            (b.single.strings.suffix = v),
            (b.multiple = new l.Blob(p)),
            (b.multiple.strings.suffix = v),
            u.inheritOpt(u.nameOutput.name, 'delimiter-precedes-last') === 'always'
              ? ((b.single.strings.prefix = u.inheritOpt(this, 'delimiter', 'names-delimiter')),
                (b.multiple.strings.prefix = u.inheritOpt(this, 'delimiter', 'names-delimiter')))
              : u.inheritOpt(u.nameOutput.name, 'delimiter-precedes-last') === 'contextual'
              ? ((b.single.strings.prefix = m),
                (b.multiple.strings.prefix = u.inheritOpt(this, 'delimiter', 'names-delimiter')))
              : u.inheritOpt(u.nameOutput.name, 'delimiter-precedes-last') === 'after-inverted-name'
              ? ((b.single.strings.prefix = u.inheritOpt(this, 'delimiter', 'names-delimiter')),
                (b.multiple.strings.prefix = m))
              : ((b.single.strings.prefix = m), (b.multiple.strings.prefix = m)),
            (u.nameOutput.with = b),
            (u.nameOutput.label = this.label),
            (u.nameOutput.etal_style = this.etal_style),
            (u.nameOutput.etal_term = this.etal_term),
            (u.nameOutput.etal_prefix_single = this.etal_prefix_single),
            (u.nameOutput.etal_prefix_multiple = this.etal_prefix_multiple),
            (u.nameOutput.etal_suffix = this.etal_suffix),
            u.nameOutput.outputNames(),
            (u.tmp['et-al-use-first'] = void 0),
            (u.tmp['et-al-min'] = void 0),
            (u.tmp['et-al-use-last'] = void 0)
        }),
        this.execs.push(r),
        (r = function (u) {
          u.tmp.can_substitute.pop() || u.tmp.can_substitute.replace(!1, l.LITERAL),
            u.tmp.can_substitute.mystack.length === 1 && (u.tmp.can_block_substitute = !1)
        }),
        this.execs.push(r),
        (e.build.name_flag = !1)
    }
    t.push(this),
      (this.tokentype === l.END || this.tokentype === l.SINGLETON) &&
        (e.build.substitute_level.pop(), l.Util.substituteEnd.call(this, e, t))
  },
}
l.Node.number = {
  build: function (e, t) {
    var r
    l.Util.substituteStart.call(this, e, t),
      this.strings.form === 'roman'
        ? (this.formatter = e.fun.romanizer)
        : this.strings.form === 'ordinal'
        ? (this.formatter = e.fun.ordinalizer)
        : this.strings.form === 'long-ordinal' && (this.formatter = e.fun.long_ordinalizer),
      typeof this.successor_prefix > 'u' &&
        (this.successor_prefix = e[e.build.area].opt.layout_delimiter),
      typeof this.splice_prefix > 'u' &&
        (this.splice_prefix = e[e.build.area].opt.layout_delimiter),
      (r = function (i, n, s) {
        if (this.variables.length !== 0) {
          var a
          if (((a = this.variables[0]), typeof s > 'u')) var s = {}
          if (['locator', 'locator-extra'].indexOf(a) > -1) {
            if (i.tmp.just_looking || !s[a]) return
          } else if (!n[a]) return
          a === 'collection-number' &&
            n.type === 'legal_case' &&
            (i.tmp.renders_collection_number = !0)
          var o = this
          if (i.tmp.group_context.tip.force_suppress) return !1
          if (
            (['locator', 'locator-extra'].indexOf(a) > -1
              ? i.processNumber.call(i, o, s, a, n.type)
              : (!i.tmp.group_context.tip.condition &&
                  n[a] &&
                  (i.tmp.just_did_number = ('' + n[a]).match(/[0-9]$/)),
                i.processNumber.call(i, o, n, a, n.type)),
            this.substring)
          ) {
            var u = n[a].slice(this.substring)
            i.output.append(u, o)
          } else l.Util.outputNumericField(i, a, n.id)
          ;['locator', 'locator-extra'].indexOf(this.variables_real[0]) > -1 &&
            !i.tmp.just_looking &&
            (i.tmp.done_vars.push(this.variables_real[0]),
            i.tmp.group_context.tip.done_vars.push(this.variables_real[0]))
        }
      }),
      this.execs.push(r),
      t.push(this),
      l.Util.substituteEnd.call(this, e, t)
  },
}
l.Node.sort = {
  build: function (e, t) {
    if (((t = e[e.build.root + '_sort'].tokens), this.tokentype === l.START)) {
      e.build.area === 'citation' && (e.opt.sort_citations = !0),
        (e.build.area = e.build.root + '_sort'),
        (e.build.extension = '_sort')
      var r = function (i, n) {
        if (i.opt.has_layout_locale) {
          for (
            var s = l.localeResolve(n.language, i.opt['default-locale'][0]),
              a = i[i.tmp.area.slice(0, -5)].opt.sort_locales,
              o,
              u = 0,
              c = a.length;
            u < c && ((o = a[u][s.bare]), o || (o = a[u][s.best]), !o);
            u += 1
          );
          o || (o = i.opt['default-locale'][0]),
            (i.tmp.lang_sort_hold = i.opt.lang),
            (i.opt.lang = o)
        }
      }
      this.execs.push(r)
    }
    if (this.tokentype === l.END) {
      ;(e.build.area = e.build.root), (e.build.extension = '')
      var r = function (n) {
        n.opt.has_layout_locale &&
          ((n.opt.lang = n.tmp.lang_sort_hold), delete n.tmp.lang_sort_hold)
      }
      this.execs.push(r)
    }
    t.push(this)
  },
}
l.Node.substitute = {
  build: function (e, t) {
    var r
    if (this.tokentype === l.START) {
      var i = new l.Token('choose', l.START)
      l.Node.choose.build.call(i, e, t)
      var n = new l.Token('if', l.SINGLETON)
      ;(r = function () {
        return !!(e.tmp.value.length && !e.tmp.common_term_match_fail)
      }),
        (n.tests = [r]),
        (n.test = e.fun.match.any(n, e, n.tests)),
        t.push(n),
        (r = function (a) {
          ;(a.tmp.can_block_substitute = !0),
            a.tmp.value.length &&
              !a.tmp.common_term_match_fail &&
              a.tmp.can_substitute.replace(!1, l.LITERAL),
            (a.tmp.common_term_match_fail = !1)
        }),
        this.execs.push(r),
        t.push(this)
    }
    if (this.tokentype === l.END) {
      t.push(this)
      var s = new l.Token('choose', l.END)
      l.Node.choose.build.call(s, e, t)
    }
  },
}
l.Node.text = {
  build: function (e, t) {
    var r, i, n, s, a, o, u, c, f, h, p
    if (this.postponed_macro) {
      var m = l.Util.cloneToken(this)
      ;(m.name = 'group'),
        (m.tokentype = l.START),
        l.Node.group.build.call(m, e, t),
        l.expandMacro.call(e, this, t)
      var v = l.Util.cloneToken(this)
      ;(v.name = 'group'),
        (v.tokentype = l.END),
        this.postponed_macro === 'juris-locator-label' && (v.isJurisLocatorLabel = !0),
        l.Node.group.build.call(v, e, t)
    } else {
      if (
        (l.Util.substituteStart.call(this, e, t),
        this.variables_real || (this.variables_real = []),
        this.variables || (this.variables = []),
        (i = 'long'),
        (n = 0),
        this.strings.form && (i = this.strings.form),
        this.strings.plural && (n = this.strings.plural),
        this.variables_real[0] === 'citation-number' ||
          this.variables_real[0] === 'year-suffix' ||
          this.variables_real[0] === 'citation-label')
      )
        this.variables_real[0] === 'citation-number'
          ? (e.build.root === 'citation' && (e.opt.update_mode = l.NUMERIC),
            e.build.root === 'bibliography' && (e.opt.bib_mode = l.NUMERIC),
            e[e.tmp.area].opt.collapse === 'citation-number' &&
              (this.range_prefix = e.getTerm('citation-range-delimiter')),
            (this.successor_prefix = e[e.build.area].opt.layout_delimiter),
            (this.splice_prefix = e[e.build.area].opt.layout_delimiter),
            (r = function (y, x, D) {
              if (((s = '' + x.id), !y.tmp.just_looking)) {
                if (y.tmp.area.slice(-5) === '_sort' && this.variables[0] === 'citation-number') {
                  if (
                    (y.tmp.area === 'bibliography_sort' &&
                      y.tmp.group_context.tip.done_vars.push('citation-number'),
                    y.tmp.area === 'citation_sort' && y.bibliography_sort.tmp.citation_number_map)
                  )
                    var C =
                      y.bibliography_sort.tmp.citation_number_map[y.registry.registry[x.id].seq]
                  else var C = y.registry.registry[x.id].seq
                  C && (C = l.Util.padding('' + C)), y.output.append(C, this)
                  return
                }
                D && D['author-only'] && y.tmp.element_trace.replace('suppress-me'),
                  y.tmp.area !== 'bibliography_sort' &&
                  y.bibliography_sort.tmp.citation_number_map &&
                  y.bibliography_sort.opt.citation_number_sort_direction === l.DESCENDING
                    ? (C = y.bibliography_sort.tmp.citation_number_map[y.registry.registry[s].seq])
                    : (C = y.registry.registry[s].seq),
                  y.opt.citation_number_slug
                    ? y.output.append(y.opt.citation_number_slug, this)
                    : ((o = new l.NumericBlob(y, !1, C, this, x.id)),
                      y.tmp.in_cite_predecessor && (o.suppress_splice_prefix = !0),
                      y.output.append(o, 'literal'))
              }
            }),
            this.execs.push(r))
          : this.variables_real[0] === 'year-suffix'
          ? ((e.opt.has_year_suffix = !0),
            e[e.tmp.area].opt.collapse === 'year-suffix-ranged' &&
              (this.range_prefix = e.getTerm('citation-range-delimiter')),
            (this.successor_prefix = e[e.build.area].opt.layout_delimiter),
            e[e.tmp.area].opt['year-suffix-delimiter'] &&
              (this.successor_prefix = e[e.build.area].opt['year-suffix-delimiter']),
            (r = function (y, x) {
              if (
                y.registry.registry[x.id] &&
                y.registry.registry[x.id].disambig.year_suffix !== !1 &&
                !y.tmp.just_looking
              ) {
                ;(a = parseInt(y.registry.registry[x.id].disambig.year_suffix, 10)),
                  y[y.tmp.area].opt.cite_group_delimiter &&
                    (this.successor_prefix = y[y.tmp.area].opt.cite_group_delimiter),
                  (o = new l.NumericBlob(y, !1, a, this, x.id)),
                  (u = new l.Util.Suffixator(l.SUFFIX_CHARS)),
                  o.setFormatter(u),
                  y.output.append(o, 'literal'),
                  (c = !1)
                for (var D = 0, C = y.tmp.group_context.mystack.length; D < C; D++) {
                  var H = y.tmp.group_context.mystack[D]
                  if (
                    !H.variable_success &&
                    (H.variable_attempt || (!H.variable_attempt && !H.term_intended))
                  ) {
                    c = !0
                    break
                  }
                }
                ;(f = y[y.tmp.area].opt['year-suffix-delimiter']),
                  c &&
                    f &&
                    !y.tmp.sort_key_flag &&
                    (y.tmp.splice_delimiter = y[y.tmp.area].opt['year-suffix-delimiter'])
              }
            }),
            this.execs.push(r))
          : this.variables_real[0] === 'citation-label' &&
            (e.build.root === 'bibliography' && (e.opt.bib_mode = l.TRIGRAPH),
            (e.opt.has_year_suffix = !0),
            (r = function (y, x) {
              ;(h = x['citation-label']),
                h || (h = y.getCitationLabel(x)),
                y.tmp.just_looking ||
                  ((p = ''),
                  y.registry.registry[x.id] &&
                    y.registry.registry[x.id].disambig.year_suffix !== !1 &&
                    ((a = parseInt(y.registry.registry[x.id].disambig.year_suffix, 10)),
                    (p = y.fun.suffixator.format(a))),
                  (h += p)),
                y.output.append(h, this)
            }),
            this.execs.push(r))
      else if (this.strings.term)
        (r = function (y, x) {
          var D = y.opt.gender[x.type],
            C = this.strings.term
          C = y.getTerm(C, i, n, D, l.TOLERANT, this.default_locale)
          var H
          if (
            (C !== '' && (y.tmp.group_context.tip.term_intended = !0),
            l.UPDATE_GROUP_CONTEXT_CONDITION(y, C, null, this),
            !y.tmp.term_predecessor && !(y.opt.class === 'in-text' && y.tmp.area === 'citation')
              ? (H = l.Output.Formatters['capitalize-first'](y, C))
              : (H = C),
            y.tmp.strip_periods)
          )
            H = H.replace(/\./g, '')
          else
            for (var T = 0, k = this.decorations.length; T < k; T += 1)
              if (
                this.decorations[T][0] === '@strip-periods' &&
                this.decorations[T][1] === 'true'
              ) {
                H = H.replace(/\./g, '')
                break
              }
          y.output.append(H, this),
            y.tmp.can_block_substitute && y.tmp.can_substitute.replace(!1, l.LITERAL)
        }),
          this.execs.push(r),
          (e.build.term = !1),
          (e.build.form = !1),
          (e.build.plural = !1)
      else if (this.variables_real.length) {
        if (
          ((r = function (y, x) {
            this.variables_real[0] !== 'locator' && (y.tmp.have_collapsed = !1),
              !y.tmp.group_context.tip.condition &&
                x[this.variables[0]] &&
                (y.tmp.just_did_number = !1)
            var D = x[this.variables[0]]
            D &&
              !y.tmp.group_context.tip.condition &&
              (('' + D).slice(-1).match(/[0-9]/)
                ? (y.tmp.just_did_number = !0)
                : (y.tmp.just_did_number = !1))
          }),
          this.execs.push(r),
          l.MULTI_FIELDS.indexOf(this.variables_real[0]) > -1 ||
            this.variables_real[0].indexOf('-main') > -1 ||
            this.variables_real[0].indexOf('-sub') > -1 ||
            ['language-name', 'language-name-original'].indexOf(this.variables_real[0]) > -1)
        ) {
          var b = this.variables[0],
            S = !1,
            g = !1,
            _ = !1
          i === 'short'
            ? this.variables_real[0].slice(-6) !== '-short' &&
              (g = this.variables_real[0] + '-short')
            : (b = !1),
            e.build.extension ? (_ = !0) : ((_ = !0), (S = !0)),
            (r = e.transform.getOutputFunction(this.variables, b, S, g, _))
        } else
          l.CITE_FIELDS.indexOf(this.variables_real[0]) > -1
            ? (r = function (y, x, D) {
                D &&
                  D[this.variables[0]] &&
                  (y.processNumber(this, D, this.variables[0], x.type),
                  l.Util.outputNumericField(y, this.variables[0], x.id),
                  ['locator', 'locator-extra'].indexOf(this.variables_real[0]) > -1 &&
                    !y.tmp.just_looking &&
                    y.tmp.done_vars.push(this.variables_real[0]))
              })
            : [
                'page',
                'page-first',
                'chapter-number',
                'collection-number',
                'edition',
                'issue',
                'number',
                'number-of-pages',
                'number-of-volumes',
                'volume',
              ].indexOf(this.variables_real[0]) > -1
            ? (r = function (y, x) {
                y.processNumber(this, x, this.variables[0], x.type),
                  l.Util.outputNumericField(y, this.variables[0], x.id)
              })
            : ['URL', 'DOI'].indexOf(this.variables_real[0]) > -1
            ? (r = function (y, x) {
                var D
                if (this.variables[0] && ((D = y.getVariable(x, this.variables[0], i)), D))
                  if (
                    (this.variables[0] === 'URL' &&
                      i === 'short' &&
                      ((D = D.replace(/(.*\.[^\/]+)\/.*/, '$1')),
                      D.match(/\/\/www\./) && (D = D.replace(/https?:\/\//, ''))),
                    y.opt.development_extensions.wrap_url_and_doi)
                  )
                    if (
                      !this.decorations.length ||
                      this.decorations[0][0] !== '@' + this.variables[0]
                    ) {
                      var C = l.Util.cloneToken(this),
                        H = new l.Blob(null, null, 'url-wrapper')
                      if (
                        (H.decorations.push(['@DOI', 'true']), this.variables_real[0] === 'DOI')
                      ) {
                        var T
                        this.strings.prefix &&
                          this.strings.prefix.match(/^.*https:\/\/doi\.org\/$/) &&
                          ((D = D.replace(/^https?:\/\/doi\.org\//, '')),
                          D.match(/^https?:\/\//) ? (T = '') : (T = 'https://doi.org/'),
                          (C.strings.prefix = this.strings.prefix.slice(
                            0,
                            C.strings.prefix.length - 16
                          )))
                        var k = new l.Blob(T),
                          O = new l.Blob(D)
                        H.push(k), H.push(O), y.output.append(H, C, !1, !1, !0)
                      } else {
                        var O = new l.Blob(D)
                        H.push(O), y.output.append(H, C, !1, !1, !0)
                      }
                    } else y.output.append(D, this, !1, !1, !0)
                  else {
                    if (this.decorations.length)
                      for (var N = this.decorations.length - 1; N > -1; N--)
                        this.decorations[N][0] === '@' + this.variables[0] &&
                          (this.decorations = this.decorations
                            .slice(0, N)
                            .concat(this.decorations.slice(N + 1)))
                    y.output.append(D, this, !1, !1, !0)
                  }
              })
            : this.variables_real[0] === 'section'
            ? (r = function (y, x) {
                var D
                ;(D = y.getVariable(x, this.variables[0], i)), D && y.output.append(D, this)
              })
            : this.variables_real[0] === 'hereinafter'
            ? (r = function (y, x) {
                var D = y.transform.abbrevs.default.hereinafter[x.id]
                D && (y.output.append(D, this), (y.tmp.group_context.tip.variable_success = !0))
              })
            : (r = function (y, x) {
                var D
                this.variables[0] &&
                  ((D = y.getVariable(x, this.variables[0], i)),
                  D && ((D = '' + D), (D = D.split('\\').join('')), y.output.append(D, this)))
              })
        this.execs.push(r)
      } else
        this.strings.value &&
          ((r = function (y) {
            ;(y.tmp.group_context.tip.term_intended = !0),
              l.UPDATE_GROUP_CONTEXT_CONDITION(y, this.strings.value, !0, this),
              y.output.append(this.strings.value, this),
              y.tmp.can_block_substitute && y.tmp.can_substitute.replace(!1, l.LITERAL)
          }),
          this.execs.push(r))
      t.push(this), l.Util.substituteEnd.call(this, e, t)
    }
  },
}
l.Node.intext = {
  build: function (e, t) {
    if (this.tokentype === l.START) {
      ;(e.build.area = 'intext'), (e.build.root = 'intext'), (e.build.extension = '')
      var r = function (i, n) {
        ;(i.tmp.area = 'intext'), (i.tmp.root = 'intext'), (i.tmp.extension = '')
      }
      this.execs.push(r)
    }
    this.tokentype === l.END &&
      ((e.intext_sort = { opt: { sort_directions: e.citation_sort.opt.sort_directions } }),
      (e.intext.srt = e.citation.srt)),
      t.push(this)
  },
}
l.Attributes = {}
l.Attributes['@disambiguate'] = function (e, t) {
  if ((this.tests || (this.tests = []), t === 'true')) {
    e.opt.has_disambiguate = !0
    var r = function (i) {
      if (e.tmp.area === 'bibliography') {
        if (e.tmp.disambiguate_count < e.registry.registry[i.id].disambig.disambiguate)
          return (e.tmp.disambiguate_count += 1), !0
      } else if (
        ((e.tmp.disambiguate_maxMax += 1),
        e.tmp.disambig_settings.disambiguate &&
          e.tmp.disambiguate_count < e.tmp.disambig_settings.disambiguate)
      )
        return (e.tmp.disambiguate_count += 1), !0
      return !1
    }
    this.tests.push(r)
  } else if (t === 'check-ambiguity-and-backreference') {
    var r = function (n) {
      return !!(
        e.registry.registry[n.id].disambig.disambiguate &&
        e.registry.registry[n.id]['citation-count'] > 1
      )
    }
    this.tests.push(r)
  }
}
l.Attributes['@is-numeric'] = function (e, t) {
  this.tests || (this.tests = [])
  for (
    var r = t.split(/\s+/),
      i = function (s) {
        return function (a, o) {
          var u = a
          if ((o && ['locator', 'locator-extra'].indexOf(s) > -1 && (u = o), !u[s])) return !1
          if (l.NUMERIC_VARIABLES.indexOf(s) > -1) {
            if (
              (e.tmp.shadow_numbers[s] || e.processNumber(!1, u, s, a.type),
              e.tmp.shadow_numbers[s].numeric)
            )
              return !0
          } else if (
            ['title', 'version'].indexOf(s) > -1 &&
            u[s].slice(-1) === '' + parseInt(u[s].slice(-1), 10)
          )
            return !0
          return !1
        }
      },
      n = 0;
    n < r.length;
    n += 1
  )
    this.tests.push(i(r[n]))
}
l.Attributes['@is-uncertain-date'] = function (e, t) {
  this.tests || (this.tests = [])
  for (
    var r = t.split(/\s+/),
      i = function (a) {
        return function (o) {
          return !!(o[a] && o[a].circa)
        }
      },
      n = 0,
      s = r.length;
    n < s;
    n += 1
  )
    this.tests.push(i(r[n]))
}
l.Attributes['@locator'] = function (e, t) {
  this.tests || (this.tests = [])
  var r = t.replace('sub verbo', 'sub-verbo')
  r = r.split(/\s+/)
  for (
    var i = function (a) {
        return function (o, u) {
          var c
          return (
            e.processNumber(!1, u, 'locator'),
            (c = e.tmp.shadow_numbers.locator.label),
            !!(c && a === c)
          )
        }
      },
      n = 0,
      s = r.length;
    n < s;
    n += 1
  )
    this.tests.push(i(r[n]))
}
l.Attributes['@position'] = function (e, t) {
  this.tests || (this.tests = [])
  var r
  e.opt.update_mode = l.POSITION
  for (
    var i = t.split(/\s+/),
      n = function (c, f) {
        return !!(
          f &&
          l.POSITION_MAP[f.position] >= l.POSITION_MAP[l.POSITION_SUBSEQUENT] &&
          f['near-note']
        )
      },
      s = function (c, f) {
        return !!(
          f &&
          l.POSITION_MAP[f.position] == l.POSITION_MAP[l.POSITION_SUBSEQUENT] &&
          !f['near-note']
        )
      },
      a = function (c) {
        return function (f, h) {
          if (e.tmp.area === 'bibliography') return !1
          if (
            (h && typeof h.position > 'u' && (h.position = 0), h && typeof h.position == 'number')
          ) {
            if (h.position === 0 && c === 0) return !0
            if (c > 0 && l.POSITION_MAP[h.position] >= l.POSITION_MAP[c]) return !0
          } else if (c === 0) return !0
          return !1
        }
      },
      o = 0,
      u = i.length;
    o < u;
    o += 1
  ) {
    var r = i[o]
    r === 'first'
      ? (r = l.POSITION_FIRST)
      : r === 'container-subsequent'
      ? (r = l.POSITION_CONTAINER_SUBSEQUENT)
      : r === 'subsequent'
      ? (r = l.POSITION_SUBSEQUENT)
      : r === 'ibid'
      ? (r = l.POSITION_IBID)
      : r === 'ibid-with-locator' && (r = l.POSITION_IBID_WITH_LOCATOR),
      r === 'near-note'
        ? this.tests.push(n)
        : r === 'far-note'
        ? this.tests.push(s)
        : this.tests.push(a(r))
  }
}
l.Attributes['@type'] = function (e, t) {
  this.tests || (this.tests = [])
  for (
    var r = t.split(/\s+/),
      i = function (o) {
        return function (u) {
          var c = u.type === o
          return !!c
        }
      },
      n = [],
      s = 0,
      a = r.length;
    s < a;
    s += 1
  )
    n.push(i(r[s]))
  this.tests.push(e.fun.match.any(this, e, n))
}
l.Attributes['@variable'] = function (e, t) {
  this.tests || (this.tests = [])
  var r
  if (
    ((this.variables = t.split(/\s+/)),
    (this.variables_real = this.variables.slice()),
    this.name === 'label' && this.variables[0])
  )
    this.strings.term = this.variables[0]
  else if (['names', 'date', 'text', 'number'].indexOf(this.name) > -1)
    (r = function (a, o, u) {
      for (var c = this.variables.length - 1; c > -1; c += -1) this.variables.pop()
      for (var c = 0, f = this.variables_real.length; c < f; c++)
        a.tmp.done_vars.indexOf(this.variables_real[c]) === -1 &&
          this.variables.push(this.variables_real[c]),
          a.tmp.can_block_substitute && a.tmp.done_vars.push(this.variables_real[c])
    }),
      this.execs.push(r),
      (r = function (a, o, u) {
        for (var c = !1, f = 0, h = this.variables.length; f < h; f++) {
          var p = this.variables[f]
          if (
            ['authority', 'committee'].indexOf(p) > -1 &&
            typeof o[p] == 'string' &&
            this.name === 'names'
          ) {
            var m = !0,
              v = o[p].split(/\s*;\s*/),
              b = {}
            if (o.multi && o.multi._keys[p]) {
              for (var S in o.multi._keys[p])
                if (((b[S] = o.multi._keys[p][S].split(/\s*;\s*/)), b[S].length !== v.length)) {
                  m = !1
                  break
                }
            }
            m || ((v = [o[p]]), (b = o.multi._keys[p]))
            for (var g = 0, _ = v.length; g < _; g++) {
              var y = { literal: v[g], multi: { _key: {} } }
              for (var S in b) {
                var x = { literal: b[S][g] }
                y.multi._key[S] = x
              }
              v[g] = y
            }
            o[p] = v
          }
          if (
            (this.strings.form === 'short' &&
              !o[p] &&
              (p === 'title'
                ? (p = 'title-short')
                : p === 'container-title' && (p = 'container-title-short')),
            p === 'year-suffix')
          ) {
            c = !0
            break
          } else if (l.DATE_VARIABLES.indexOf(p) > -1) {
            if (a.opt.development_extensions.locator_date_and_revision && p === 'locator-date') {
              c = !0
              break
            }
            if (o[p]) {
              for (var D in o[p])
                if (!(this.dateparts.indexOf(D) === -1 && D !== 'literal') && o[p][D]) {
                  c = !0
                  break
                }
              if (c) break
            }
          } else if (p === 'locator') {
            u && u.locator && (c = !0)
            break
          } else if (p === 'locator-extra') {
            u && u['locator-extra'] && (c = !0)
            break
          } else if (['citation-number', 'citation-label'].indexOf(p) > -1) {
            c = !0
            break
          } else if (p === 'first-reference-note-number') {
            u && u['first-reference-note-number'] && (c = !0)
            break
          } else if (p === 'first-container-reference-note-number') {
            u && u['first-container-reference-note-number'] && (c = !0)
            break
          } else if (p === 'hereinafter') {
            a.transform.abbrevs.default.hereinafter[o.id] &&
              a.sys.getAbbreviation &&
              o.id &&
              (c = !0)
            break
          } else {
            if (typeof o[p] == 'object') break
            if (typeof o[p] == 'string' && o[p]) {
              c = !0
              break
            } else if (typeof o[p] == 'number') {
              c = !0
              break
            }
          }
          if (c) break
        }
        if (c) {
          for (var f = 0, h = this.variables_real.length; f < h; f++) {
            var p = this.variables_real[f]
            ;(p !== 'citation-number' || a.tmp.area !== 'bibliography') &&
              (a.tmp.cite_renders_content = !0),
              (a.tmp.group_context.tip.variable_success = !0),
              a.tmp.can_substitute.value() &&
                a.tmp.area === 'bibliography' &&
                typeof o[p] == 'string' &&
                ((a.tmp.name_node.top = a.output.current.value()), a.tmp.rendered_name.push(o[p]))
          }
          a.tmp.can_substitute.replace(!1, l.LITERAL)
        } else a.tmp.group_context.tip.variable_attempt = !0
      }),
      this.execs.push(r)
  else if (['if', 'else-if', 'condition'].indexOf(this.name) > -1)
    for (
      var i = function (a) {
          return function (o, u) {
            var c = o
            if (
              (u &&
                [
                  'locator',
                  'locator-extra',
                  'first-reference-note-number',
                  'first-container-reference-note-number',
                  'locator-date',
                ].indexOf(a) > -1 &&
                (c = u),
              a === 'hereinafter' && e.sys.getAbbreviation && c.id)
            ) {
              if (e.transform.abbrevs.default.hereinafter[c.id]) return !0
            } else if (c[a]) {
              if (typeof c[a] == 'number' || typeof c[a] == 'string') return !0
              if (typeof c[a] == 'object') {
                for (var f in c[a]) if (c[a][f]) return !0
              }
            }
            return !1
          }
        },
        n = 0,
        s = this.variables.length;
      n < s;
      n += 1
    )
      this.tests.push(i(this.variables[n]))
}
l.Attributes['@page'] = function (e, t) {
  this.tests || (this.tests = [])
  var r = t.replace('sub verbo', 'sub-verbo')
  r = r.split(/\s+/)
  for (
    var i = function (a) {
        return function (o) {
          var u
          return (
            e.processNumber(!1, o, 'page', o.type),
            e.tmp.shadow_numbers.page.label
              ? e.tmp.shadow_numbers.page.label === 'sub verbo'
                ? (u = 'sub-verbo')
                : (u = e.tmp.shadow_numbers.page.label)
              : (u = 'page'),
            e.tmp.shadow_numbers.page.values.length > 0 &&
              e.tmp.shadow_numbers.page.values[0].gotosleepability &&
              (e.tmp.shadow_numbers.page.values[0].labelVisibility = !1),
            a === u
          )
        }
      },
      n = 0,
      s = r.length;
    n < s;
    n += 1
  )
    this.tests.push(i(r[n]))
}
l.Attributes['@number'] = function (e, t) {
  this.tests || (this.tests = [])
  for (
    var r = t.split(/\s+/),
      i = function (a) {
        return function (o) {
          var u
          return (
            e.processNumber(!1, o, 'number', o.type),
            e.tmp.shadow_numbers.number.label
              ? (u = e.tmp.shadow_numbers.number.label)
              : (u = 'number'),
            a === u
          )
        }
      },
      n = 0,
      s = r.length;
    n < s;
    n += 1
  )
    this.tests.push(i(r[n]))
}
l.Attributes['@jurisdiction'] = function (e, t) {
  this.tests || (this.tests = [])
  var r = t.split(/\s+/),
    i = function (n) {
      return function (s) {
        if (!s.jurisdiction) return !1
        for (var a = s.jurisdiction, o = 0, u = n.length; o < u; o++) if (a === n[o]) return !0
        return !1
      }
    }
  this.tests.push(i(r))
}
l.Attributes['@country'] = function (e, t) {
  this.tests || (this.tests = [])
  var r = t.split(/\s+/),
    i = function (n) {
      return function (s) {
        if (!s.country) return !1
        for (var a = s.country, o = 0, u = n.length; o < u; o++) if (a === n[o]) return !0
        return !1
      }
    }
  this.tests.push(i(r))
}
l.Attributes['@context'] = function (e, t) {
  this.tests || (this.tests = [])
  var r = function () {
    if (['bibliography', 'citation'].indexOf(t) > -1) {
      var i = e.tmp.area.slice(0, t.length)
      return i === t
    } else if (t === 'alternative') return !!e.tmp.abort_alternative
  }
  this.tests.push(r)
}
l.Attributes['@has-year-only'] = function (e, t) {
  this.tests || (this.tests = [])
  for (
    var r = t.split(/\s+/),
      i = function (a) {
        return function (o) {
          var u = o[a]
          return !(!u || u.month || u.season)
        }
      },
      n = 0,
      s = r.length;
    n < s;
    n += 1
  )
    this.tests.push(i(r[n]))
}
l.Attributes['@has-to-month-or-season'] = function (e, t) {
  this.tests || (this.tests = [])
  for (
    var r = t.split(/\s+/),
      i = function (a) {
        return function (o) {
          var u = o[a]
          return !(!u || (!u.month && !u.season) || u.day)
        }
      },
      n = 0,
      s = r.length;
    n < s;
    n += 1
  )
    this.tests.push(i(r[n]))
}
l.Attributes['@has-day'] = function (e, t) {
  this.tests || (this.tests = [])
  for (
    var r = t.split(/\s+/),
      i = function (a) {
        return function (o) {
          var u = o[a]
          return !(!u || !u.day)
        }
      },
      n = 0,
      s = r.length;
    n < s;
    n += 1
  )
    this.tests.push(i(r[n]))
}
l.Attributes['@is-plural'] = function (e, t) {
  this.tests || (this.tests = [])
  var r = function (i) {
    var n = i[t]
    if (n && n.length) {
      for (var s = 0, a = 0, o = !1, u = 0, c = n.length; u < c; u += 1)
        e.opt.development_extensions.spoof_institutional_affiliations &&
        (n[u].literal || (n[u].isInstitution && n[u].family && !n[u].given))
          ? ((a += 1), (o = !1))
          : ((s += 1), (o = !0))
      if (s > 1) return !0
      if (a > 1) return !0
      if (a && o) return !0
    }
    return !1
  }
  this.tests.push(r)
}
l.Attributes['@is-multiple'] = function (e, t) {
  this.tests || (this.tests = [])
  var r = function (i) {
    var n = '' + i[t],
      s = n.split(
        /(?:,\s|\s(?:tot\sen\smet|ldz|oraz|and|bis|||och|a|do|en|et|in|ir|ja|og|sa|to|un|und|s|i|i|u|y||e|a||-|)\s||\&)/
      )
    return s.length > 1
  }
  this.tests.push(r)
}
l.Attributes['@locale'] = function (e, t) {
  this.tests || (this.tests = [])
  var r,
    i,
    n,
    s,
    a,
    o = e.opt['default-locale'][0]
  if (this.name === 'layout') {
    if (((this.locale_raw = t), this.tokentype === l.START)) {
      e.opt.multi_layout || (e.opt.multi_layout = [])
      var u = [],
        c = t.split(/\s+/),
        f = {},
        h = l.localeResolve(c[0], o)
      u.push(h), h.generic ? (f[h.generic] = h.best) : (f[h.best] = h.best)
      for (var s = 1, a = c.length; s < a; s += 1) {
        var p = l.localeResolve(c[s], o)
        u.push(p), p.generic ? (f[p.generic] = h.best) : (f[p.best] = h.best)
      }
      e[e.build.area].opt.sort_locales.push(f), e.opt.multi_layout.push(u)
    }
    e.opt.has_layout_locale = !0
  } else {
    n = t.split(/\s+/)
    var m = []
    for (s = 0, a = n.length; s < a; s += 1)
      (i = n[s]),
        (r = l.localeResolve(i, o)),
        n[s].length === 2 && m.push(r.bare),
        e.localeConfigure(r, !0),
        (n[s] = r)
    var v = n.slice(),
      b = function (S, g, _) {
        return function (y) {
          var x
          x = !1
          var D = !1,
            C
          for (
            y.language ? (C = y.language) : (C = g), D = l.localeResolve(C, g), s = 0, a = S.length;
            s < a;
            s += 1
          )
            if (D.best === S[s].best) {
              e.tmp.condition_lang_counter_arr.push(e.tmp.condition_counter),
                e.tmp.condition_lang_val_arr.push(e.opt.lang),
                (e.opt.lang = S[0].best),
                (x = !0)
              break
            }
          return (
            !x &&
              _.indexOf(D.bare) > -1 &&
              (e.tmp.condition_lang_counter_arr.push(e.tmp.condition_counter),
              e.tmp.condition_lang_val_arr.push(e.opt.lang),
              (e.opt.lang = S[0].best),
              (x = !0)),
            x
          )
        }
      }
    this.tests.push(b(v, o, m))
  }
}
l.Attributes['@alternative-node-internal'] = function (e) {
  this.tests || (this.tests = [])
  var t = function () {
    return function () {
      return !e.tmp.abort_alternative
    }
  }
  this.tests.push(t())
}
l.Attributes['@locale-internal'] = function (e, t) {
  this.tests || (this.tests = [])
  var r, i, n, s, a
  for (n = t.split(/\s+/), this.locale_bares = [], s = 0, a = n.length; s < a; s += 1)
    (i = n[s]),
      (r = l.localeResolve(i, e.opt['default-locale'][0])),
      n[s].length === 2 && this.locale_bares.push(r.bare),
      e.localeConfigure(r),
      (n[s] = r)
  ;(this.locale_default = e.opt['default-locale'][0]),
    (this.locale = n[0].best),
    (this.locale_list = n.slice())
  var o = function (c) {
      return function (f) {
        var h
        h = !1
        var p = !1
        if (
          (f.language &&
            ((i = f.language),
            (p = l.localeResolve(i, e.opt['default-locale'][0])),
            p.best === e.opt['default-locale'][0] && (p = !1)),
          p)
        ) {
          for (s = 0, a = c.locale_list.length; s < a; s += 1)
            if (p.best === c.locale_list[s].best) {
              ;(e.opt.lang = c.locale),
                (e.tmp.last_cite_locale = c.locale),
                e.output.openLevel('empty'),
                (e.output.current.value().new_locale = c.locale),
                (h = !0)
              break
            }
          !h &&
            c.locale_bares.indexOf(p.bare) > -1 &&
            ((e.opt.lang = c.locale),
            (e.tmp.last_cite_locale = c.locale),
            e.output.openLevel('empty'),
            (e.output.current.value().new_locale = c.locale),
            (h = !0))
        }
        return h
      }
    },
    u = this
  this.tests.push(o(u))
}
l.Attributes['@court-class'] = function (e, t) {
  this.tests || (this.tests = [])
  for (
    var r = t.split(/\s+/),
      i = function (a) {
        return function (o) {
          var u = l.GET_COURT_CLASS(e, o)
          return u === a
        }
      },
      n = 0,
      s = r.length;
    n < s;
    n++
  )
    this.tests.push(i(r[n]))
}
l.Attributes['@container-multiple'] = function (e, t) {
  this.tests || (this.tests = [])
  var r = t === 'true',
    i = function (n) {
      return function (s) {
        if (e.tmp.container_item_count[s.container_id]) {
          if (e.tmp.container_item_count[s.container_id] > 1) return n
        } else return !n
        return !n
      }
    }
  this.tests.push(i(r))
}
l.Attributes['@container-subsequent'] = function (e, t) {
  this.tests || (this.tests = [])
  var r = t === 'true',
    i = function (n) {
      return function (s) {
        return e.tmp.container_item_pos[s.container_id] > 1 ? n : !n
      }
    }
  this.tests.push(i(r))
}
l.Attributes['@has-subunit'] = function (e, t) {
  this.tests || (this.tests = [])
  var r = function (i) {
    return function (n) {
      var s = 0
      for (var a in n[i]) {
        var o = n[i][a]
        if (!o.given) {
          var u = o.literal ? o.literal : o.family,
            c = u.split('|').length
          ;(s === 0 || c < s) && (s = c)
        }
      }
      return s > 1
    }
  }
  this.tests.push(r(t))
}
l.Attributes['@cite-form'] = function (e, t) {
  this.tests || (this.tests = [])
  var r = function (i) {
    return function (n) {
      return n['cite-form'] === i
    }
  }
  this.tests.push(r(t))
}
l.Attributes['@disable-duplicate-year-suppression'] = function (e, t) {
  e.opt.disable_duplicate_year_suppression = t.split(/\s+/)
}
l.Attributes['@consolidate-containers'] = function (e, t) {
  l.Attributes['@track-containers'](e, t)
  var r = t.split(/\s+/)
  e.bibliography.opt.consolidate_containers = r
}
l.Attributes['@track-containers'] = function (e, t) {
  var r = t.split(/\s+/)
  e.bibliography.opt.track_container_items || (e.bibliography.opt.track_container_items = []),
    e.bibliography.opt.consolidate_containers || (e.bibliography.opt.consolidate_containers = []),
    (e.bibliography.opt.track_container_items = e.bibliography.opt.track_container_items.concat(r))
}
l.Attributes['@parallel-first'] = function (e, t) {
  e.opt.parallel.enable = !0
  var r = t.split(/\s+/)
  e.opt.track_repeat || (e.opt.track_repeat = {}), (this.parallel_first = {})
  for (var i in r) {
    var n = r[i]
    ;(this.parallel_first[n] = !0), (e.opt.track_repeat[n] = !0)
  }
}
l.Attributes['@parallel-last'] = function (e, t) {
  e.opt.parallel.enable = !0
  var r = t.split(/\s+/)
  e.opt.track_repeat || (e.opt.track_repeat = {}), (this.parallel_last = {})
  for (var i in r) {
    var n = r[i]
    ;(this.parallel_last[n] = !0), (e.opt.track_repeat[n] = !0)
  }
}
l.Attributes['@parallel-last-to-first'] = function (e, t) {
  e.opt.parallel.enable = !0
  var r = t.split(/\s+/)
  this.parallel_last_to_first = {}
  for (var i = 0, n = r.length; i < n; i++) this.parallel_last_to_first[r[i]] = !0
}
l.Attributes['@parallel-delimiter-override'] = function (e, t) {
  ;(e.opt.parallel.enable = !0), (this.strings.set_parallel_delimiter_override = t)
}
l.Attributes['@parallel-delimiter-override-on-suppress'] = function (e, t) {
  ;(e.opt.parallel.enable = !0), (this.strings.set_parallel_delimiter_override_on_suppress = t)
}
l.Attributes['@no-repeat'] = function (e, t) {
  e.opt.parallel.enable = !0
  var r = t.split(/\s+/)
  e.opt.track_repeat || (e.opt.track_repeat = {}), (this.non_parallel = {})
  for (var i in r) {
    var n = r[i]
    ;(this.non_parallel[n] = !0), (e.opt.track_repeat[n] = !0)
  }
}
l.Attributes['@require'] = function (e, t) {
  ;(e.opt.use_context_condition = !0), (this.strings.require = t)
}
l.Attributes['@reject'] = function (e, t) {
  ;(e.opt.use_context_condition = !0), (this.strings.reject = t)
}
l.Attributes['@require-comma-on-symbol'] = function (e, t) {
  e.opt.require_comma_on_symbol = t
}
l.Attributes['@gender'] = function (e, t) {
  this.gender = t
}
l.Attributes['@cslid'] = function (e, t) {
  this.cslid = parseInt(t, 10)
}
l.Attributes['@capitalize-if-first'] = function (e, t) {
  this.strings.capitalize_if_first_override = t
}
l.Attributes['@label-capitalize-if-first'] = function (e, t) {
  this.strings.label_capitalize_if_first_override = t
}
l.Attributes['@label-form'] = function (e, t) {
  this.strings.label_form_override = t
}
l.Attributes['@part-separator'] = function (e, t) {
  this.strings['part-separator'] = t
}
l.Attributes['@leading-noise-words'] = function (e, t) {
  this['leading-noise-words'] = t
}
l.Attributes['@name-never-short'] = function (e, t) {
  this['name-never-short'] = t
}
l.Attributes['@class'] = function (e, t) {
  e.opt.class = t
}
l.Attributes['@version'] = function (e, t) {
  e.opt.version = t
}
l.Attributes['@value'] = function (e, t) {
  this.strings.value = t
}
l.Attributes['@name'] = function (e, t) {
  this.strings.name = t
}
l.Attributes['@form'] = function (e, t) {
  this.strings.form = t
}
l.Attributes['@date-parts'] = function (e, t) {
  this.strings['date-parts'] = t
}
l.Attributes['@range-delimiter'] = function (e, t) {
  this.strings['range-delimiter'] = t
}
l.Attributes['@macro'] = function (e, t) {
  this.postponed_macro = t
}
l.Attributes['@term'] = function (e, t) {
  t === 'sub verbo' ? (this.strings.term = 'sub-verbo') : (this.strings.term = t)
}
l.Attributes['@xmlns'] = function () {}
l.Attributes['@lang'] = function (e, t) {
  t && (e.build.lang = t)
}
l.Attributes['@lingo'] = function () {}
l.Attributes['@macro-has-date'] = function () {
  this['macro-has-date'] = !0
}
l.Attributes['@suffix'] = function (e, t) {
  this.strings.suffix = t
}
l.Attributes['@prefix'] = function (e, t) {
  this.strings.prefix = t
}
l.Attributes['@delimiter'] = function (e, t) {
  this.strings.delimiter = t
}
l.Attributes['@match'] = function (e, t) {
  this.match = t
}
l.Attributes['@names-min'] = function (e, t) {
  var r = parseInt(t, 10)
  e[e.build.area].opt.max_number_of_names < r && (e[e.build.area].opt.max_number_of_names = r),
    (this.strings['et-al-min'] = r)
}
l.Attributes['@names-use-first'] = function (e, t) {
  this.strings['et-al-use-first'] = parseInt(t, 10)
}
l.Attributes['@names-use-last'] = function (e, t) {
  t === 'true' ? (this.strings['et-al-use-last'] = !0) : (this.strings['et-al-use-last'] = !1)
}
l.Attributes['@sort'] = function (e, t) {
  t === 'descending' && (this.strings.sort_direction = l.DESCENDING)
}
l.Attributes['@plural'] = function (e, t) {
  t === 'always' || t === 'true'
    ? (this.strings.plural = 1)
    : t === 'never' || t === 'false'
    ? (this.strings.plural = 0)
    : t === 'contextual' && (this.strings.plural = !1)
}
l.Attributes['@has-publisher-and-publisher-place'] = function () {
  this.strings['has-publisher-and-publisher-place'] = !0
}
l.Attributes['@publisher-delimiter-precedes-last'] = function (e, t) {
  this.strings['publisher-delimiter-precedes-last'] = t
}
l.Attributes['@publisher-delimiter'] = function (e, t) {
  this.strings['publisher-delimiter'] = t
}
l.Attributes['@publisher-and'] = function (e, t) {
  this.strings['publisher-and'] = t
}
l.Attributes['@givenname-disambiguation-rule'] = function (e, t) {
  l.GIVENNAME_DISAMBIGUATION_RULES.indexOf(t) > -1 &&
    (e.citation.opt['givenname-disambiguation-rule'] = t)
}
l.Attributes['@collapse'] = function (e, t) {
  t && (e[this.name].opt.collapse = t)
}
l.Attributes['@cite-group-delimiter'] = function (e, t) {
  t && (e[e.tmp.area].opt.cite_group_delimiter = t)
}
l.Attributes['@names-delimiter'] = function (e, t) {
  e.setOpt(this, 'names-delimiter', t)
}
l.Attributes['@name-form'] = function (e, t) {
  e.setOpt(this, 'name-form', t)
}
l.Attributes['@subgroup-delimiter'] = function (e, t) {
  this.strings['subgroup-delimiter'] = t
}
l.Attributes['@subgroup-delimiter-precedes-last'] = function (e, t) {
  this.strings['subgroup-delimiter-precedes-last'] = t
}
l.Attributes['@name-delimiter'] = function (e, t) {
  e.setOpt(this, 'name-delimiter', t)
}
l.Attributes['@et-al-min'] = function (e, t) {
  var r = parseInt(t, 10)
  e[e.build.area].opt.max_number_of_names < r && (e[e.build.area].opt.max_number_of_names = r),
    e.setOpt(this, 'et-al-min', r)
}
l.Attributes['@et-al-use-first'] = function (e, t) {
  e.setOpt(this, 'et-al-use-first', parseInt(t, 10))
}
l.Attributes['@et-al-use-last'] = function (e, t) {
  t === 'true' ? e.setOpt(this, 'et-al-use-last', !0) : e.setOpt(this, 'et-al-use-last', !1)
}
l.Attributes['@et-al-subsequent-min'] = function (e, t) {
  var r = parseInt(t, 10)
  e[e.build.area].opt.max_number_of_names < r && (e[e.build.area].opt.max_number_of_names = r),
    e.setOpt(this, 'et-al-subsequent-min', r)
}
l.Attributes['@et-al-subsequent-use-first'] = function (e, t) {
  e.setOpt(this, 'et-al-subsequent-use-first', parseInt(t, 10))
}
l.Attributes['@suppress-min'] = function (e, t) {
  this.strings['suppress-min'] = parseInt(t, 10)
}
l.Attributes['@suppress-max'] = function (e, t) {
  this.strings['suppress-max'] = parseInt(t, 10)
}
l.Attributes['@and'] = function (e, t) {
  e.setOpt(this, 'and', t)
}
l.Attributes['@delimiter-precedes-last'] = function (e, t) {
  e.setOpt(this, 'delimiter-precedes-last', t)
}
l.Attributes['@delimiter-precedes-et-al'] = function (e, t) {
  e.setOpt(this, 'delimiter-precedes-et-al', t)
}
l.Attributes['@initialize-with'] = function (e, t) {
  e.setOpt(this, 'initialize-with', t)
}
l.Attributes['@initialize'] = function (e, t) {
  t === 'false' && e.setOpt(this, 'initialize', !1)
}
l.Attributes['@name-as-reverse-order'] = function (e, t) {
  this['name-as-reverse-order'] = t
}
l.Attributes['@name-as-sort-order'] = function (e, t) {
  this.name === 'style-options'
    ? (this['name-as-sort-order'] = t)
    : e.setOpt(this, 'name-as-sort-order', t)
}
l.Attributes['@sort-separator'] = function (e, t) {
  e.setOpt(this, 'sort-separator', t)
}
l.Attributes['@require-match'] = function (e, t) {
  t === 'true' && (this.requireMatch = !0)
}
l.Attributes['@exclude-types'] = function (e, t) {
  e.bibliography.opt.exclude_types = t.split(/\s+/)
}
l.Attributes['@exclude-with-fields'] = function (e, t) {
  e.bibliography.opt.exclude_with_fields = t.split(/\s+/)
}
l.Attributes['@year-suffix-delimiter'] = function (e, t) {
  e[this.name].opt['year-suffix-delimiter'] = t
}
l.Attributes['@after-collapse-delimiter'] = function (e, t) {
  e[this.name].opt['after-collapse-delimiter'] = t
}
l.Attributes['@subsequent-author-substitute'] = function (e, t) {
  e[this.name].opt['subsequent-author-substitute'] = t
}
l.Attributes['@subsequent-author-substitute-rule'] = function (e, t) {
  e[this.name].opt['subsequent-author-substitute-rule'] = t
}
l.Attributes['@disambiguate-add-names'] = function (e, t) {
  t === 'true' && (e.opt['disambiguate-add-names'] = !0)
}
l.Attributes['@disambiguate-add-givenname'] = function (e, t) {
  t === 'true' && (e.opt['disambiguate-add-givenname'] = !0)
}
l.Attributes['@disambiguate-add-year-suffix'] = function (e, t) {
  t === 'true' && e.opt.xclass !== 'numeric' && (e.opt['disambiguate-add-year-suffix'] = !0)
}
l.Attributes['@second-field-align'] = function (e, t) {
  ;(t === 'flush' || t === 'margin') && (e[this.name].opt['second-field-align'] = t)
}
l.Attributes['@hanging-indent'] = function (e, t) {
  t === 'true' &&
    (e.opt.development_extensions.hanging_indent_legacy_number
      ? (e[this.name].opt.hangingindent = 2)
      : (e[this.name].opt.hangingindent = !0))
}
l.Attributes['@line-spacing'] = function (e, t) {
  t && t.match(/^[.0-9]+$/) && (e[this.name].opt['line-spacing'] = parseFloat(t, 10))
}
l.Attributes['@entry-spacing'] = function (e, t) {
  t && t.match(/^[.0-9]+$/) && (e[this.name].opt['entry-spacing'] = parseFloat(t, 10))
}
l.Attributes['@near-note-distance'] = function (e, t) {
  e[this.name].opt['near-note-distance'] = parseInt(t, 10)
}
l.Attributes['@substring'] = function (e, t) {
  this.substring = parseInt(t, 10)
}
l.Attributes['@text-case'] = function (e, t) {
  var r = function (i, n) {
    t === 'normal'
      ? (this.text_case_normal = !0)
      : ((this.strings['text-case'] = t),
        t === 'title' && n.jurisdiction && (this.strings['text-case'] = 'passthrough'))
  }
  this.execs.push(r)
}
l.Attributes['@page-range-format'] = function (e, t) {
  e.opt['page-range-format'] = t
}
l.Attributes['@year-range-format'] = function (e, t) {
  e.opt['year-range-format'] = t
}
l.Attributes['@default-locale'] = function (e, t) {
  if (this.name === 'style') {
    var r,
      i,
      n,
      a,
      s,
      a = t.match(/-x-(sort|translit|translat)-/g)
    if (a)
      for (n = 0, i = a.length; n < i; n += 1) a[n] = a[n].replace(/^-x-/, '').replace(/-$/, '')
    for (
      r = t.split(/-x-(?:sort|translit|translat)-/), s = [r[0]], n = 1, i = r.length;
      n < i;
      n += 1
    )
      s.push(a[n - 1]), s.push(r[n])
    for (r = s.slice(), i = r.length, n = 1; n < i; n += 2)
      e.opt['locale-' + r[n]].push(r[n + 1].replace(/^\s*/g, '').replace(/\s*$/g, ''))
    r.length ? (e.opt['default-locale'] = r.slice(0, 1)) : (e.opt['default-locale'] = ['en'])
  } else t === 'true' && (this.default_locale = !0)
}
l.Attributes['@default-locale-sort'] = function (e, t) {
  e.opt['default-locale-sort'] = t
}
l.Attributes['@demote-non-dropping-particle'] = function (e, t) {
  e.opt['demote-non-dropping-particle'] = t
}
l.Attributes['@initialize-with-hyphen'] = function (e, t) {
  t === 'false' && (e.opt['initialize-with-hyphen'] = !1)
}
l.Attributes['@institution-parts'] = function (e, t) {
  this.strings['institution-parts'] = t
}
l.Attributes['@if-short'] = function (e, t) {
  t === 'true' && (this.strings['if-short'] = !0)
}
l.Attributes['@substitute-use-first'] = function (e, t) {
  this.strings['substitute-use-first'] = parseInt(t, 10)
}
l.Attributes['@use-first'] = function (e, t) {
  this.strings['use-first'] = parseInt(t, 10)
}
l.Attributes['@use-last'] = function (e, t) {
  this.strings['use-last'] = parseInt(t, 10)
}
l.Attributes['@stop-first'] = function (e, t) {
  this.strings['stop-first'] = parseInt(t, 10)
}
l.Attributes['@stop-last'] = function (e, t) {
  this.strings['stop-last'] = parseInt(t, 10) * -1
}
l.Attributes['@reverse-order'] = function (e, t) {
  t === 'true' && (this.strings['reverse-order'] = !0)
}
l.Attributes['@display'] = function (e, t) {
  e.bibliography.tokens.length === 2 && (e.opt.using_display = !0), (this.strings.cls = t)
}
l.Stack = function (e, t) {
  ;(this.mystack = []), (t || e) && this.mystack.push(e), (this.tip = this.mystack[0])
}
l.Stack.prototype.push = function (e, t) {
  t || e ? this.mystack.push(e) : this.mystack.push(''),
    (this.tip = this.mystack[this.mystack.length - 1])
}
l.Stack.prototype.clear = function () {
  ;(this.mystack = []), (this.tip = {})
}
l.Stack.prototype.replace = function (e, t) {
  this.mystack.length === 0 &&
    l.error('Internal CSL processor error: attempt to replace nonexistent stack item with ' + e),
    t || e
      ? (this.mystack[this.mystack.length - 1] = e)
      : (this.mystack[this.mystack.length - 1] = ''),
    (this.tip = this.mystack[this.mystack.length - 1])
}
l.Stack.prototype.pop = function () {
  var e = this.mystack.pop()
  return (
    this.mystack.length ? (this.tip = this.mystack[this.mystack.length - 1]) : (this.tip = {}), e
  )
}
l.Stack.prototype.value = function () {
  return this.mystack.slice(-1)[0]
}
l.Stack.prototype.length = function () {
  return this.mystack.length
}
l.Parallel = function (e) {
  this.state = e
}
l.Parallel.prototype.StartCitation = function (e, t) {
  if (((this.state.tmp.suppress_repeats = []), !(e.length < 2))) {
    for (var r = 0, i = !1, n = [], s = 0, a = e.length - 1; s < a; s++) {
      var o = e[s][0],
        u = e[s + 1][0],
        c = !1,
        f = {}
      if (e[s][0].seeAlso && e[s][0].seeAlso.length > 0 && !i) {
        ;(c = !0), (i = [e[s][0].id].concat(e[s][0].seeAlso))
        var h = i.slice(),
          p = e.slice(s)
        p[0][1].parallel = 'first'
        for (var m = 0, v = p.length; m < v; m++) {
          var b = p[m][0].id,
            S = h.indexOf(b)
          if (((r = !1), S === -1 ? (r = s + m - 1) : s + m === e.length - 1 && (r = s + m), r)) {
            n.push([s, r])
            break
          } else h = h.slice(0, S).concat(h.slice(S + 1))
        }
      }
      s > 0 && c && ((this.state.tmp.suppress_repeats[s - 1].START = !0), (c = !1))
      for (var g in this.state.opt.track_repeat)
        if (!o[g] || !u[g]) f[g] = !1
        else if (typeof u[g] == 'string' || typeof u[g] == 'number') {
          if (g === 'title' && o['title-short'] && u['title-short'])
            var _ = o['title-short'],
              y = u['title-short']
          else
            var _ = o[g],
              y = u[g]
          _ == y ? (f[g] = !0) : (f[g] = !1)
        } else if (typeof o[g].length > 'u') {
          f[g] = !1
          var x = o[g].year,
            D = u[g].year
          x && D && x == D && (f[g] = !0)
        } else {
          var _ = JSON.stringify(o[g]),
            y = JSON.stringify(u[g])
          _ === y ? (f[g] = !0) : (f[g] = !1)
        }
      i || (f.ORPHAN = !0),
        r === s && ((f.END = !0), (i = !1)),
        this.state.tmp.suppress_repeats.push(f)
    }
    for (var m = 0, v = n.length; m < v; m++) {
      var C = e[n[m][0]][0].id
      ;(this.state.registry.registry[C].master = !0),
        (this.state.registry.registry[C].siblings = [])
      for (var H = n[m][0], T = n[m][1], k = H; k < T; k++) {
        this.state.tmp.suppress_repeats[k].SIBLING = !0
        var O = e[k + 1][0].id
        ;(e[k + 1][1].parallel = 'other'), this.state.registry.registry[C].siblings.push(O)
      }
    }
  }
}
l.Parallel.prototype.checkRepeats = function (e) {
  var t = this.state.tmp.cite_index
  if (this.state.tmp.suppress_repeats) {
    if (e.parallel_first && Object.keys(e.parallel_first).length > 0) {
      var r = [{}].concat(this.state.tmp.suppress_repeats),
        i = !0
      for (var n in e.parallel_first) (!r[t][n] || r[t].START) && (i = !1)
      return i
    }
    if (e.parallel_last && Object.keys(e.parallel_last).length > 0) {
      var r = this.state.tmp.suppress_repeats.concat([{}]),
        i = Object.keys(e.parallel_last).length > 0
      for (var n in e.parallel_last) (!r[t][n] || r[t].END) && (i = !1)
      return i
    }
    if (e.non_parallel && Object.keys(e.non_parallel).length > 0) {
      var r = [{}].concat(this.state.tmp.suppress_repeats),
        i = !0
      for (var n in e.non_parallel) r[t][n] || (i = !1)
      return i
    }
  }
  return !1
}
l.Util = {}
l.Util.Match = function () {
  ;(this.any = function (e, t, r) {
    return function (i, n) {
      for (var s = 0, a = r.length; s < a; s += 1) {
        var o = r[s](i, n)
        if (o) return !0
      }
      return !1
    }
  }),
    (this.none = function (e, t, r) {
      return function (i, n) {
        for (var s = 0, a = r.length; s < a; s += 1) {
          var o = r[s](i, n)
          if (o) return !1
        }
        return !0
      }
    }),
    (this.all = function (e, t, r) {
      return function (i, n) {
        for (var s = 0, a = r.length; s < a; s += 1) {
          var o = r[s](i, n)
          if (!o) return !1
        }
        return !0
      }
    }),
    (this[void 0] = this.all),
    (this.nand = function (e, t, r) {
      return function (i, n) {
        for (var s = 0, a = r.length; s < a; s += 1) {
          var o = r[s](i, n)
          if (!o) return !0
        }
        return !1
      }
    })
}
l.Transform = function (e) {
  ;(this.abbrevs = {}), (this.abbrevs.default = new e.sys.AbbreviationSegments())
  function t(f, h, p) {
    var m = ''
    return (
      e.sys.getHumanForm &&
        (f === 'country'
          ? ((m = e.sys.getHumanForm(h.toLowerCase(), !1, !0)), (m = m.split('|')[0]))
          : f === 'jurisdiction' &&
            ((m = e.sys.getHumanForm(h.toLowerCase(), !1, !0)),
            p ? (m = '') : (m = m.split('|').slice(1).join(', ')))),
      m
    )
  }
  function r(f, h, p, m, v, b, S) {
    var g = '',
      _ = l.FIELD_CATEGORY_REMAP[b],
      y
    if (!_) return v
    var x = b,
      D = v
    f.sys.normalizeAbbrevsKey && (D = f.sys.normalizeAbbrevsKey(b, v))
    var C = !1
    if (
      (x === 'jurisdiction' && D && (C = D.indexOf(':') === -1),
      ['jurisdiction', 'country'].indexOf(b) > -1 && v === v.toLowerCase() && (D = v.toUpperCase()),
      f.sys.getAbbreviation)
    ) {
      ;['jurisdiction', 'country', 'language-name', 'language-name-original'].indexOf(x) > -1
        ? (y = 'default')
        : p.jurisdiction
        ? (y = p.jurisdiction)
        : (y = 'default')
      var H = f.transform.loadAbbreviation(y, _, D, p.language)
      if (f.transform.abbrevs[H][_] && D) {
        var T = f.transform.abbrevs[H][_][D]
        h.strings.form === 'short' && T ? (C ? (g = '') : (g = T)) : (g = t(x, D, C))
      }
    }
    return (
      !g &&
        (!f.opt.development_extensions.require_explicit_legal_case_title_short ||
          p.type !== 'legal_case') &&
        m &&
        p[m] &&
        S &&
        (g = p[m]),
      !g && !f.sys.getAbbreviation && f.sys.getHumanForm && (g = t(x, D, C)),
      !g && !C && (!f.sys.getHumanForm || x !== 'jurisdiction') && (g = v),
      f.opt.development_extensions.force_title_abbrev_fallback &&
        x === 'title' &&
        g === v &&
        p['title-short'] &&
        (g = p['title-short']),
      g
    )
  }
  function i(f, h) {
    var p = e.opt['default-locale'][0].slice(0, 2),
      m
    if (
      (e.opt.development_extensions.strict_text_case_locales
        ? (m = new RegExp('^([a-zA-Z]{2})(?:$|-.*| .*)'))
        : (m = new RegExp('^([a-zA-Z]{2})(?:$|-.*|.*)')),
      f.language)
    ) {
      var v = ('' + f.language).match(m)
      v ? (p = v[1]) : (p = 'tlh')
    }
    return (
      f.multi && f.multi && f.multi.main && f.multi.main[h] && (p = f.multi.main[h]),
      (!e.opt.development_extensions.strict_text_case_locales ||
        e.opt.development_extensions.normalize_lang_keys_to_lowercase) &&
        (p = p.toLowerCase()),
      p
    )
  }
  function n(f, h, p, m, v, b) {
    var S,
      g,
      _,
      y,
      x = v,
      D = !1
    if (!f[h]) return { name: '', usedOrig: v, token: l.Util.cloneToken(this) }
    var C = !1
    l.VARIABLES_WITH_SHORT_FORM.indexOf(h) > -1 && b && ((h = h + '-short'), (C = !0))
    var H = !1,
      T = null,
      k = []
    h.slice(-6) === '-short' ? (k.push(h), k.push(h.slice(0, -6))) : k.push(h)
    for (var O = 0, N = k.length; O < N; O++) {
      var M = !1,
        h = k[O]
      ;(_ = { name: '', usedOrig: v, locale: i(f, h) }), (y = e.opt[p] ? e.opt[p].slice() : [])
      var V = !1
      if (
        (p === 'locale-orig'
          ? (v || ((_.name = f[h]), (_.usedOrig = !1)), (V = !0), (D = !0))
          : m &&
            (typeof y > 'u' || y.length === 0) &&
            ((_.name = f[h]), (_.usedOrig = !0), (V = !0), (D = !0)),
        !V)
      ) {
        for (var j = 0, R = y.length; j < R; j += 1)
          if (
            ((S = y[j]),
            (g = S.split(/[\-_]/)[0]),
            S && f.multi && f.multi._keys[h] && f.multi._keys[h][S])
          ) {
            ;(_.name = f.multi._keys[h][S]), (_.locale = S), (V = !0), (M = !0), (D = !1)
            break
          } else if (g && f.multi && f.multi._keys[h] && f.multi._keys[h][g]) {
            ;(_.name = f.multi._keys[h][g]), (_.locale = g), (V = !0), (M = !0), (D = !1)
            break
          }
        !_.name && m && ((_ = { name: f[h], usedOrig: !0, locale: i(f, h) }), (D = !0))
      }
      if (
        ((_.token = l.Util.cloneToken(this)),
        O === 0
          ? (M && (_.found_variant_ok = !0),
            (T = _),
            !C && (typeof y > 'u' || y.length === 0) && (H = !0),
            M && (H = !0))
          : !C && !M && T
          ? ((_ = T), (h = k[0]))
          : M && (_.found_variant_ok = !0),
        ['title', 'container-title'].indexOf(h) > -1 &&
          !x &&
          (!_.token.strings['text-case'] ||
            _.token.strings['text-case'] === 'sentence' ||
            _.token.strings['text-case'] === 'normal'))
      ) {
        e.opt.lang
        var $
        D ? ($ = !1) : ($ = _.locale)
        var L = h.slice(0, -5),
          P = _.token.strings['text-case'] === 'sentence'
        ;(_.name = l.titlecaseSentenceOrNormal(e, f, L, $, P)), delete _.token.strings['text-case']
      }
      if (H) break
    }
    return _
  }
  this.getTextSubField = n
  function s(f, h, p, m) {
    f || (f = 'default')
    var v = f.split(':')[0],
      b = l.getAbbrevsDomain(e, v, m)
    return (
      b && (f += '@' + b),
      p
        ? (e.sys.getAbbreviation &&
            ((f = e.sys.getAbbreviation(e.opt.styleID, e.transform.abbrevs, f, h, p)),
            f || ((f = 'default'), b && (f += '@' + b))),
          f)
        : (e.transform.abbrevs[f] || (e.transform.abbrevs[f] = new e.sys.AbbreviationSegments()),
          e.transform.abbrevs[f][h] || (e.transform.abbrevs[f][h] = {}),
          f)
    )
  }
  this.loadAbbreviation = s
  function a(f, h, p, m) {
    var v = f.variables[0]
    if (e.publisherOutput && p) {
      if (['publisher', 'publisher-place'].indexOf(v) === -1) return !1
      ;(e.publisherOutput[v + '-token'] = f), e.publisherOutput.varlist.push(v)
      var b = p.split(/;\s*/)
      b.length === e.publisherOutput[v + '-list'].length && (e.publisherOutput[v + '-list'] = b)
      for (var S = 0, g = b.length; S < g; S += 1) b[S] = r(e, f, h, !1, b[S], m, !0)
      return (e.tmp[v + '-token'] = f), !0
    }
    return !1
  }
  function o(f, h) {
    var p = h.match(/^#([0-9]+).*>>>/)
    p && p[1] && (f['cite-form'] = p[1])
  }
  function u(f, h) {
    var p = h.match(/^(?:#[0-9]+)*(?:!((?:[-_a-z]+(?:(?:.*)))(?:,(?:[-_a-z]+(?:(?:.*))))*))*>>>/)
    if (p && ((h = h.slice(p[0].length)), p[1]))
      for (var m = p[1].split(','), v = 0, b = m.length; v < b; v += 1) {
        var S = m[v],
          g = S.match(/^([-_a-z]+)(?:\:(.*))*$/),
          _ = g[1],
          y = e.tmp.abbrev_trimmer
        g[2]
          ? y && f && (y[f] || (y[f] = {}), (y[f][_] = g[2]))
          : e.tmp.done_vars.indexOf(_) === -1 &&
            (y && f && (y.QUASHES[f] || (y.QUASHES[f] = {}), (y.QUASHES[f][_] = !0)),
            e.tmp.done_vars.push(_))
      }
    return h
  }
  this.quashCheck = u
  function c(f, h, p, m) {
    var v,
      b = l.LangPrefsMap[f[0]]
    return (
      b ? (v = e.opt['cite-lang-prefs'][b]) : (v = !1),
      function (S, g, _) {
        var y, x, D, C, H, T, R
        if (
          !f[0] ||
          (!g[f[0]] && !g[m]) ||
          (!S.tmp.just_looking &&
            _ &&
            _['suppress-author'] &&
            !S.tmp.probably_rendered_something &&
            S.tmp.can_substitute.length() > 1)
        )
          return null
        var k = { primary: !1, secondary: !1, tertiary: !1 }
        if (S.tmp.area.slice(-5) === '_sort') k.primary = 'locale-sort'
        else if (v && v.length === 1 && v[0] === 'locale-orig')
          (k.primary = 'locale-orig'), (v = !1)
        else if (v && !S.tmp.multi_layout)
          for (
            var O = ['primary', 'secondary', 'tertiary'], N = 0, M = O.length;
            N < M && !(v.length - 1 < N);
            N += 1
          )
            v[N] && (k[O[N]] = 'locale-' + v[N])
        else k.primary = 'locale-orig'
        if (
          ((f[0] === 'title-short' ||
            (S.tmp.area !== 'bibliography' &&
              !(S.tmp.area === 'citation' && S.opt.xclass === 'note' && _ && !_.position))) &&
            ((k.secondary = !1), (k.tertiary = !1)),
          S.tmp.multi_layout && ((k.secondary = !1), (k.tertiary = !1)),
          S.tmp['publisher-list'])
        )
          return (
            f[0] === 'publisher'
              ? (S.tmp['publisher-token'] = this)
              : f[0] === 'publisher-place' && (S.tmp['publisher-place-token'] = this),
            null
          )
        var V = S.tmp.lang_array.slice(),
          j = n.call(this, g, f[0], k.primary, !0, null, h)
        ;(y = j.name), (x = j.locale)
        var R = j.token,
          $ = j.usedOrig
        if (
          (h &&
            !j.found_variant_ok &&
            ((y = r(S, R, g, m, y, h, !0)),
            y && (o(g, y), S.tmp.just_looking || (y = u(g.jurisdiction, y)))),
          a(this, g, y, h))
        )
          return (S.tmp.lang_array = V), null
        ;(D = !1), (H = !1)
        var L, P
        k.secondary &&
          ((j = n.call(this, g, f[0], k.secondary, !1, j.usedOrig, null, h)),
          (D = j.name),
          (C = j.locale),
          (L = j.token),
          h && !j.found_variant_ok && D && (D = r(S, L, g, !1, D, h, !0))),
          k.tertiary &&
            ((j = n.call(this, g, f[0], k.tertiary, !1, j.usedOrig, null, h)),
            (H = j.name),
            (T = j.locale),
            (P = j.token),
            h && !j.found_variant_ok && H && (H = r(S, P, g, !1, H, h, !0)))
        var Y
        if (
          (k.primary === 'locale-translit' && (Y = S.opt.citeAffixes[b][k.primary].prefix),
          Y === '<i>' && f[0] === 'title' && !$)
        ) {
          for (var w = !1, N = 0, M = R.decorations.length; N < M; N += 1)
            R.decorations[N][0] === '@font-style' && R.decorations[N][1] === 'italic' && (w = !0)
          w || R.decorations.push(['@font-style', 'italic'])
        }
        if (
          (x !== 'en' &&
            R.strings['text-case'] === 'title' &&
            (R.strings['text-case'] = 'passthrough'),
          f[0] === 'title' && (y = l.demoteNoiseWords(S, y, this['leading-noise-words'])),
          D || H)
        ) {
          if (
            (S.output.openLevel('empty'),
            (R.strings.suffix = R.strings.suffix.replace(/[ .,]+$/, '')),
            x && (S.tmp.lang_array = [x].concat(V)),
            l.UPDATE_GROUP_CONTEXT_CONDITION(S, null, null, R, R.strings.prefix + y),
            S.output.append(y, R),
            (S.tmp.probably_rendered_something = !0),
            y === D && (D = !1),
            D)
          ) {
            ;(L.strings.prefix = S.opt.citeAffixes[b][k.secondary].prefix),
              (L.strings.suffix = S.opt.citeAffixes[b][k.secondary].suffix),
              L.strings.prefix || (L.strings.prefix = ' ')
            for (var N = L.decorations.length - 1; N > -1; N += -1)
              [
                '@quotes/true',
                '@font-style/italic',
                '@font-style/oblique',
                '@font-weight/bold',
              ].indexOf(L.decorations[N].join('/')) > -1 &&
                (L.decorations = L.decorations.slice(0, N).concat(L.decorations.slice(N + 1)))
            C !== 'en' &&
              L.strings['text-case'] === 'title' &&
              (L.strings['text-case'] = 'passthrough'),
              C && (S.tmp.lang_array = [C].concat(V))
            var q = new l.Token()
            q.decorations.push(['@font-style', 'normal']),
              q.decorations.push(['@font-weight', 'normal']),
              S.output.openLevel(q),
              S.output.append(D, L),
              S.output.closeLevel(),
              S.output.current.value(),
              S.output.current.value().blobs.length - 1
          }
          if ((y === H && (H = !1), H)) {
            ;(P.strings.prefix = S.opt.citeAffixes[b][k.tertiary].prefix),
              (P.strings.suffix = S.opt.citeAffixes[b][k.tertiary].suffix),
              P.strings.prefix || (P.strings.prefix = ' ')
            for (var N = P.decorations.length - 1; N > -1; N += -1)
              [
                '@quotes/true',
                '@font-style/italic',
                '@font-style/oblique',
                '@font-weight/bold',
              ].indexOf(P.decorations[N].join('/')) > -1 &&
                (P.decorations = P.decorations.slice(0, N).concat(P.decorations.slice(N + 1)))
            T !== 'en' &&
              P.strings['text-case'] === 'title' &&
              (P.strings['text-case'] = 'passthrough'),
              T && (S.tmp.lang_array = [T].concat(V))
            var X = new l.Token()
            X.decorations.push(['@font-style', 'normal']),
              X.decorations.push(['@font-weight', 'normal']),
              S.output.openLevel(X),
              S.output.append(H, P),
              S.output.closeLevel(),
              S.output.current.value(),
              S.output.current.value().blobs.length - 1
          }
          S.output.closeLevel()
        } else
          x && (S.tmp.lang_array = [x].concat(V)),
            l.UPDATE_GROUP_CONTEXT_CONDITION(S, null, null, R, R.strings.prefix + y),
            S.output.append(y, R),
            (S.tmp.probably_rendered_something = !0)
        return (
          (S.tmp.lang_array = V),
          S.tmp.can_block_substitute && S.tmp.name_node.children.push(S.output.current.value()),
          null
        )
      }
    )
  }
  this.getOutputFunction = c
}
l.Token = function (e, t, r) {
  ;(this.name = e),
    (this.strings = {}),
    (this.strings.delimiter = void 0),
    (this.strings.prefix = ''),
    (this.strings.suffix = ''),
    (this.decorations = []),
    (this.variables = []),
    (this.execs = []),
    (this.tokentype = t)
}
l.Util.cloneToken = function (e) {
  var t, r, i, n
  if (typeof e == 'string') return e
  t = new l.Token(e.name, e.tokentype)
  for (var r in e.strings) e.strings.hasOwnProperty(r) && (t.strings[r] = e.strings[r])
  if (e.decorations)
    for (t.decorations = [], i = 0, n = e.decorations.length; i < n; i += 1)
      t.decorations.push(e.decorations[i].slice())
  return (
    e.variables && (t.variables = e.variables.slice()),
    e.execs && ((t.execs = e.execs.slice()), e.tests && (t.tests = e.tests.slice())),
    t
  )
}
l.AmbigConfig = function () {
  ;(this.maxvals = []),
    (this.minval = 1),
    (this.names = []),
    (this.givens = []),
    (this.year_suffix = !1),
    (this.disambiguate = 0)
}
l.Blob = function (e, t, r) {
  var i, n, s
  if (((this.levelname = r), t)) {
    this.strings = { prefix: '', suffix: '' }
    for (var s in t.strings) t.strings.hasOwnProperty(s) && (this.strings[s] = t.strings[s])
    for (
      this.decorations = [], t.decorations === void 0 ? (i = 0) : (i = t.decorations.length), n = 0;
      n < i;
      n += 1
    )
      this.decorations.push(t.decorations[n].slice())
  } else
    (this.strings = {}),
      (this.strings.prefix = ''),
      (this.strings.suffix = ''),
      (this.strings.delimiter = ''),
      (this.decorations = [])
  typeof e == 'string' ? (this.blobs = e) : e ? (this.blobs = [e]) : (this.blobs = []),
    (this.alldecor = [this.decorations])
}
l.Blob.prototype.push = function (e) {
  typeof this.blobs == 'string'
    ? l.error('Attempt to push blob onto string object')
    : e !== !1 && ((e.alldecor = e.alldecor.concat(this.alldecor)), this.blobs.push(e))
}
l.NumericBlob = function (e, t, r, i, n) {
  if (
    ((this.id = n),
    (this.alldecor = []),
    (this.num = r),
    (this.particle = t),
    (this.blobs = r.toString()),
    (this.status = l.START),
    (this.strings = {}),
    i)
  ) {
    if (i.strings['text-case']) {
      var s = i.strings['text-case']
      ;(this.particle = l.Output.Formatters[s](e, this.particle)),
        (this.blobs = l.Output.Formatters[s](e, this.blobs))
    }
    ;(this.gender = i.gender),
      (this.decorations = i.decorations),
      (this.strings.prefix = i.strings.prefix),
      (this.strings.suffix = i.strings.suffix),
      (this.strings['text-case'] = i.strings['text-case']),
      (this.successor_prefix = i.successor_prefix),
      (this.range_prefix = i.range_prefix),
      (this.splice_prefix = i.splice_prefix),
      (this.formatter = i.formatter),
      this.formatter || (this.formatter = new l.Output.DefaultFormatter()),
      this.formatter && (this.type = this.formatter.format(1))
  } else
    (this.decorations = []),
      (this.strings.prefix = ''),
      (this.strings.suffix = ''),
      (this.successor_prefix = ''),
      (this.range_prefix = ''),
      (this.splice_prefix = ''),
      (this.formatter = new l.Output.DefaultFormatter())
}
l.NumericBlob.prototype.setFormatter = function (e) {
  ;(this.formatter = e), (this.type = this.formatter.format(1))
}
l.Output.DefaultFormatter = function () {}
l.Output.DefaultFormatter.prototype.format = function (e) {
  return e.toString()
}
l.NumericBlob.prototype.checkNext = function (e, t) {
  t
    ? ((this.status = l.START),
      typeof e == 'object' &&
        (e.num === this.num + 1 ? (e.status = l.SUCCESSOR) : (e.status = l.SEEN)))
    : !e || !e.num || this.type !== e.type || e.num !== this.num + 1
    ? (this.status === l.SUCCESSOR_OF_SUCCESSOR && (this.status = l.END),
      typeof e == 'object' && (e.status = l.SEEN))
    : this.status === l.START || this.status === l.SEEN
    ? (e.status = l.SUCCESSOR)
    : (this.status === l.SUCCESSOR || this.status === l.SUCCESSOR_OF_SUCCESSOR) &&
      (this.range_prefix
        ? ((e.status = l.SUCCESSOR_OF_SUCCESSOR), (this.status = l.SUPPRESS))
        : (e.status = l.SUCCESSOR))
}
l.NumericBlob.prototype.checkLast = function (e) {
  return this.status === l.SEEN || (e.num !== this.num - 1 && this.status === l.SUCCESSOR)
    ? ((this.status = l.SUCCESSOR), !0)
    : !1
}
l.Util.fixDateNode = function (e, t, r) {
  var i,
    n,
    s,
    a,
    o,
    u,
    c,
    f,
    h,
    p,
    m,
    v,
    b,
    g = this.cslXml.getAttributeValue(r, 'lingo'),
    S = this.cslXml.getAttributeValue(r, 'default-locale')
  ;(this.build.date_key = !0), (i = this.cslXml.getAttributeValue(r, 'form'))
  var g
  if (
    (S ? (g = this.opt['default-locale'][0]) : (g = this.cslXml.getAttributeValue(r, 'lingo')),
    !this.getDate(i, S))
  )
    return e
  var _ = this.cslXml.getAttributeValue(r, 'date-parts')
  ;(n = this.cslXml.getAttributeValue(r, 'variable')),
    (f = this.cslXml.getAttributeValue(r, 'prefix')),
    (h = this.cslXml.getAttributeValue(r, 'suffix')),
    (v = this.cslXml.getAttributeValue(r, 'display')),
    (b = this.cslXml.getAttributeValue(r, 'cslid')),
    (s = this.cslXml.nodeCopy(this.getDate(i, S))),
    this.cslXml.setAttribute(s, 'lingo', this.opt.lang),
    this.cslXml.setAttribute(s, 'form', i),
    this.cslXml.setAttribute(s, 'date-parts', _),
    this.cslXml.setAttribute(s, 'cslid', b),
    this.cslXml.setAttribute(s, 'variable', n),
    this.cslXml.setAttribute(s, 'default-locale', S),
    f && this.cslXml.setAttribute(s, 'prefix', f),
    h && this.cslXml.setAttribute(s, 'suffix', h),
    v && this.cslXml.setAttribute(s, 'display', v),
    (p = this.cslXml.children(s))
  for (var y in p)
    (a = p[y]),
      this.cslXml.nodename(a) === 'date-part' &&
        ((o = this.cslXml.getAttributeValue(a, 'name')),
        S &&
          this.cslXml.setAttributeOnNodeIdentifiedByNameAttribute(
            s,
            'date-part',
            o,
            '@default-locale',
            'true'
          ))
  p = this.cslXml.children(r)
  for (var y in p)
    if (((a = p[y]), this.cslXml.nodename(a) === 'date-part')) {
      ;(o = this.cslXml.getAttributeValue(a, 'name')), (m = this.cslXml.attributes(a))
      for (u in m)
        u !== '@name' &&
          ((g && g !== this.opt.lang && ['@suffix', '@prefix', '@form'].indexOf(u) > -1) ||
            ((c = m[u]),
            this.cslXml.setAttributeOnNodeIdentifiedByNameAttribute(s, 'date-part', o, u, c)))
    }
  if (this.cslXml.getAttributeValue(r, 'date-parts') === 'year')
    this.cslXml.deleteNodeByNameAttribute(s, 'month'),
      this.cslXml.deleteNodeByNameAttribute(s, 'day')
  else if (this.cslXml.getAttributeValue(r, 'date-parts') === 'year-month')
    this.cslXml.deleteNodeByNameAttribute(s, 'day')
  else if (this.cslXml.getAttributeValue(r, 'date-parts') === 'month-day') {
    for (var x = this.cslXml.children(s), D = 1, C = this.cslXml.numberofnodes(x); D < C; D++)
      if (this.cslXml.getAttributeValue(x[D], 'name') === 'year') {
        this.cslXml.setAttribute(x[D - 1], 'suffix', '')
        break
      }
    this.cslXml.deleteNodeByNameAttribute(s, 'year')
  }
  return this.cslXml.insertChildNodeAfter(e, r, t, s)
}
l.dateMacroAsSortKey = function (e, t) {
  l.dateAsSortKey.call(this, e, t, !0)
}
l.dateAsSortKey = function (e, t, r) {
  var i,
    n,
    s,
    a,
    o,
    u,
    c,
    f,
    h = this.variables[0],
    p = 'empty'
  if (
    (r && e.tmp.extension && (p = 'macro-with-date'),
    (i = t[h]),
    typeof i > 'u' && (i = { 'date-parts': [[0]] }),
    typeof this.dateparts > 'u' && (this.dateparts = ['year', 'month', 'day']),
    i.raw
      ? (i = e.fun.dateparser.parseDateToArray(i.raw))
      : i['date-parts'] && (i = e.dateParseArray(i)),
    typeof i > 'u' && (i = {}),
    i.year)
  )
    for (c = 0, f = l.DATE_PARTS_INTERNAL.length; c < f; c += 1)
      if (
        ((n = l.DATE_PARTS_INTERNAL[c]),
        (s = 0),
        (a = n),
        a.slice(-4) === '_end' && (a = a.slice(0, -4)),
        i[n] && this.dateparts.indexOf(a) > -1 && (s = i[n]),
        n.slice(0, 4) === 'year')
      ) {
        o = l.Util.Dates[a].numeric(e, s)
        var u = '1'
        o[0] === '-' && ((u = '0'), (o = o.slice(1)), (o = 9999 - parseInt(o, 10))),
          e.output.append(l.Util.Dates[n.slice(0, 4)].numeric(e, u + o), p)
      } else
        (s = l.Util.Dates[a]['numeric-leading-zeros'](e, s)), s || (s = '00'), e.output.append(s, p)
}
l.Engine.prototype.dateParseArray = function (e) {
  var t, r, i, n
  t = {}
  for (r in e)
    if (r === 'date-parts') {
      ;(i = e['date-parts']),
        i.length > 1 &&
          i[0].length !== i[1].length &&
          l.error('CSL data error: element mismatch in date range input.'),
        (n = ['', '_end'])
      for (var s = 0, a = i.length; s < a; s += 1)
        for (var o = 0, u = l.DATE_PARTS.length; o < u; o += 1)
          isNaN(parseInt(i[s][o], 10))
            ? (t[l.DATE_PARTS[o] + n[s]] = void 0)
            : (t[l.DATE_PARTS[o] + n[s]] = parseInt(i[s][o], 10))
    } else
      e.hasOwnProperty(r) &&
        (r === 'literal' && typeof e.literal == 'object' && typeof e.literal.part == 'string'
          ? (l.debug('Warning: fixing up weird literal date value'), (t.literal = e.literal.part))
          : (t[r] = e[r]))
  return t
}
l.Util.Names = {}
l.Util.Names.compareNamesets = l.NameOutput.prototype._compareNamesets
l.Util.Names.unInitialize = function (e, t) {
  var r, i, n, s, a
  if (!t) return ''
  for (
    n = t.split(/(?:\-|\s+)/), s = t.match(/(\-|\s+)/g), a = '', r = 0, i = n.length;
    r < i;
    r += 1
  )
    (a += n[r]), r < i - 1 && (a += s[r])
  return a
}
l.Util.Names.initializeWith = function (e, t, r, i) {
  var n, s, a
  if (!t) return ''
  if (
    (r || (r = ''),
    ['Lord', 'Lady'].indexOf(t) > -1 ||
      (!t.replace(/^(?:<[^>]+>)*/, '').match(l.STARTSWITH_ROMANESQUE_REGEXP) && !r.match('%s')))
  )
    return t
  e.opt['initialize-with-hyphen'] === !1 && (t = t.replace(/\-/g, ' ')),
    (t = t.replace(/\s*\-\s*/g, '-').replace(/\s+/g, ' ')),
    (t = t.replace(/-([a-z])/g, '$1'))
  for (var n = t.length - 2; n > -1; n += -1)
    t.slice(n, n + 1) === '.' &&
      t.slice(n + 1, n + 2) !== ' ' &&
      (t = t.slice(0, n) + '. ' + t.slice(n + 1))
  var o = l.Output.Formatters.nameDoppel.split(t),
    u = []
  if (((u = [o.strings[0]]), o.tags.length === 0)) {
    var c = u[0].match(/[^\.]+$/)
    c && c[0].length === 1 && c[0] !== c[0].toLowerCase() && (u[0] += '.')
  }
  for (n = 1, s = o.strings.length; n < s; n += 1) u.push(o.tags[n - 1]), u.push(o.strings[n])
  return (
    i ? (a = this.doNormalize(e, u, r)) : (a = this.doInitialize(e, u, r)),
    (a = a.replace(/\u2013([a-z])/g, '-$1')),
    a
  )
}
l.Util.Names.notag = function (e) {
  return e.replace(/^(?:<[^>]+>)*/, '')
}
l.Util.Names.mergetag = function (e, t, r) {
  var i = t.match(/(?:-*<[^>]+>-*)/g)
  if (i) t = i.join('')
  else return r
  return (
    (i = r.match(/^(.*[^\s])*(\s+)$/)),
    i ? ((i[1] = i[1] ? i[1] : ''), (r = i[1] + t + i[2])) : (r = r + t),
    r
  )
}
l.Util.Names.tagonly = function (e, t) {
  var r = t.match(/(?:<[^>]+>)+/)
  return r ? r.join('') : t
}
l.Util.Names.doNormalize = function (e, t, r) {
  var i, n
  r = r || ''
  var s = []
  for (i = 0, n = t.length; i < n; i += 1)
    this.notag(t[i]).length > 1 && this.notag(t[i]).slice(-1) === '.'
      ? ((t[i] = t[i].replace(/^(.*)\.(.*)$/, '$1$2')), s.push(!0))
      : t[i].length === 1 && t[i].toUpperCase() === t[i]
      ? s.push(!0)
      : s.push(!1)
  for (i = 0, n = t.length; i < n; i += 2)
    s[i] &&
      (i < t.length - 2 &&
        ((t[i + 1] = this.tagonly(e, t[i + 1])),
        s[i + 2] || (t[i + 1] = this.tagonly(e, t[i + 1]) + ' '),
        t[i + 2].length > 1
          ? (t[i + 1] = r.replace(/\ufeff$/, '') + t[i + 1])
          : (t[i + 1] = this.mergetag(e, t[i + 1], r))),
      i === t.length - 1 && (t[i] = t[i] + r))
  return t
    .join('')
    .replace(/[\u0009\u000a\u000b\u000c\u000d\u0020\ufeff\u00a0]+$/, '')
    .replace(/\s*\-\s*/g, '-')
    .replace(/[\u0009\u000a\u000b\u000c\u000d\u0020]+/g, ' ')
}
l.Util.Names.doInitialize = function (e, t, r) {
  var i, n, s, a, o, u, c
  for (i = 0, n = t.length; i < n; i += 2)
    if (((c = t[i]), !!c))
      if (
        ((s = c.match(l.NAME_INITIAL_REGEXP)),
        !s &&
          !c.match(l.STARTSWITH_ROMANESQUE_REGEXP) &&
          c.length > 1 &&
          r.match('%s') &&
          (s = c.match(/(.)(.*)/)),
        s && s[2] && s[3] && ((s[1] = s[1] + s[2]), (s[2] = '')),
        s && s[1].slice(0, 1) === s[1].slice(0, 1).toUpperCase())
      ) {
        var f = ''
        if (s[2]) {
          var h = ''
          for (u = s[2].split(''), a = 0, o = u.length; a < o; a += 1) {
            var p = u[a]
            if (p === p.toUpperCase()) h += p
            else break
          }
          h.length < s[2].length && (f = l.toLocaleLowerCase.call(e, h))
        }
        ;(t[i] = s[1] + f),
          i < n - 1
            ? r.match('%s')
              ? (t[i] = r.replace('%s', t[i]))
              : t[i + 1].indexOf('-') > -1
              ? (t[i + 1] = this.mergetag(e, t[i + 1].replace('-', ''), r) + '-')
              : (t[i + 1] = this.mergetag(e, t[i + 1], r))
            : r.match('%s')
            ? (t[i] = r.replace('%s', t[i]))
            : t.push(r)
      } else c.match(l.ROMANESQUE_REGEXP) && (!s || !s[3]) && (t[i] = ' ' + c)
  var m = t.join('')
  return (
    (m = m
      .replace(/[\u0009\u000a\u000b\u000c\u000d\u0020\ufeff\u00a0]+$/, '')
      .replace(/\s*\-\s*/g, '-')
      .replace(/[\u0009\u000a\u000b\u000c\u000d\u0020]+/g, ' ')),
    m
  )
}
l.Util.Names.getRawName = function (e) {
  var t = []
  return (
    e.literal ? t.push(e.literal) : (e.given && t.push(e.given), e.family && t.push(e.family)),
    t.join(' ')
  )
}
l.Util.Dates = {}
l.Util.Dates.year = {}
l.Util.Dates.year.long = function (e, t) {
  return t || (typeof t == 'boolean' ? (t = '') : (t = 0)), t.toString()
}
l.Util.Dates.year.imperial = function (e, t, r) {
  var i = ''
  t || (typeof t == 'boolean' ? (t = '') : (t = 0)), (r = r ? '_end' : '')
  var n = e.tmp.date_object['month' + r]
  for (n = n ? '' + n : '1'; n.length < 2; ) n = '0' + n
  var s = e.tmp.date_object['day' + r]
  for (s = s ? '' + s : '1'; s.length < 2; ) s = '0' + s
  var a = parseInt(t + n + s, 10),
    o,
    u
  if (
    (a >= 18680908 && a < 19120730
      ? ((o = ''), (u = 1867))
      : a >= 19120730 && a < 19261225
      ? ((o = ''), (u = 1911))
      : a >= 19261225 && a < 19890108
      ? ((o = ''), (u = 1925))
      : a >= 19890108 && ((o = ''), (u = 1988)),
    o && u)
  ) {
    var c = o
    e.sys.normalizeAbbrevsKey && (c = e.sys.normalizeAbbrevsKey('number', o)),
      e.transform.abbrevs.default.number[c] ||
        e.transform.loadAbbreviation('default', 'number', c, null),
      e.transform.abbrevs.default.number[c] && (o = e.transform.abbrevs.default.number[c]),
      (i = o + (t - u))
  }
  return i
}
l.Util.Dates.year.short = function (e, t) {
  if (((t = t.toString()), t && t.length === 4)) return t.substr(2)
}
l.Util.Dates.year.numeric = function (e, t) {
  var i, r
  t = '' + t
  var i = t.match(/([0-9]*)$/)
  for (i ? ((r = t.slice(0, i[1].length * -1)), (t = i[1])) : ((r = t), (t = '')); t.length < 4; )
    t = '0' + t
  return r + t
}
l.Util.Dates.normalizeMonth = function (e, t) {
  var r
  if ((e || (e = 0), (e = '' + e), e.match(/^[0-9]+$/) || (e = 0), (e = parseInt(e, 10)), t)) {
    var i = { stub: 'month-', num: e }
    if (i.num < 1 || i.num > 24) i.num = 0
    else {
      for (; i.num > 16; ) i.num = i.num - 4
      i.num > 12 && ((i.stub = 'season-'), (i.num = i.num - 12))
    }
    r = i
  } else (e < 1 || e > 12) && (e = 0), (r = e)
  return r
}
l.Util.Dates.month = {}
l.Util.Dates.month.numeric = function (e, r) {
  var r = l.Util.Dates.normalizeMonth(r)
  return r || (r = ''), r
}
l.Util.Dates.month['numeric-leading-zeros'] = function (e, r) {
  var r = l.Util.Dates.normalizeMonth(r)
  if (!r) r = ''
  else for (r = '' + r; r.length < 2; ) r = '0' + r
  return r
}
l.Util.Dates.month.long = function (e, s, r, i) {
  var n = l.Util.Dates.normalizeMonth(s, !0),
    s = n.num
  if (!s) s = ''
  else {
    for (s = '' + s; s.length < 2; ) s = '0' + s
    s = e.getTerm(n.stub + s, 'long', 0, 0, !1, i)
  }
  return s
}
l.Util.Dates.month.short = function (e, s, r, i) {
  var n = l.Util.Dates.normalizeMonth(s, !0),
    s = n.num
  if (!s) s = ''
  else {
    for (s = '' + s; s.length < 2; ) s = '0' + s
    s = e.getTerm(n.stub + s, 'short', 0, 0, !1, i)
  }
  return s
}
l.Util.Dates.day = {}
l.Util.Dates.day.numeric = function (e, t) {
  return t.toString()
}
l.Util.Dates.day.long = l.Util.Dates.day.numeric
l.Util.Dates.day['numeric-leading-zeros'] = function (e, t) {
  for (t || (t = 0), t = t.toString(); t.length < 2; ) t = '0' + t
  return t.toString()
}
l.Util.Dates.day.ordinal = function (e, t, r) {
  return e.fun.ordinalizer.format(t, r)
}
l.Util.Sort = {}
l.Util.Sort.strip_prepositions = function (e) {
  var t
  return (
    typeof e == 'string' && (t = e.match(/^(([aA]|[aA][nN]|[tT][hH][eE])\s+)/)),
    t && (e = e.substr(t[1].length)),
    e
  )
}
l.Util.substituteStart = function (e, t) {
  var r, i, n, s, a, o, u
  ;(s = function (c, f, h) {
    for (var p = 0, m = this.decorations.length; p < m; p += 1)
      if (this.decorations[p][0] === '@strip-periods' && this.decorations[p][1] === 'true') {
        c.tmp.strip_periods += 1
        break
      }
  }),
    this.execs.push(s),
    this.decorations &&
      e.opt.development_extensions.csl_reverse_lookup_support &&
      (this.decorations.reverse(),
      this.decorations.push(['@showid', 'true', this.cslid]),
      this.decorations.reverse()),
    (u = ['number', 'date', 'names']),
    ((this.name === 'text' && !this.postponed_macro) || u.indexOf(this.name) > -1) &&
      ((r = function (c, f, h) {
        c.tmp.element_trace.value() === 'author' || this.name === 'names'
          ? (!c.tmp.just_looking &&
              h &&
              h['author-only'] &&
              c.tmp.area !== 'intext' &&
              c.tmp.probably_rendered_something &&
              c.tmp.element_trace.push('suppress-me'),
            !c.tmp.just_looking &&
              h &&
              h['suppress-author'] &&
              (c.tmp.probably_rendered_something || c.tmp.element_trace.push('suppress-me')))
          : this.name === 'date'
          ? !c.tmp.just_looking &&
            h &&
            h['author-only'] &&
            c.tmp.area !== 'intext' &&
            c.tmp.probably_rendered_something &&
            c.tmp.element_trace.push('suppress-me')
          : !c.tmp.just_looking && h && h['author-only'] && c.tmp.area !== 'intext'
          ? (!c.tmp.probably_rendered_something && c.tmp.can_block_substitute) ||
            c.tmp.element_trace.push('suppress-me')
          : h && h['suppress-author'] && c.tmp.element_trace.push('do-not-suppress-me')
      }),
      this.execs.push(r)),
    (i = this.strings.cls),
    (this.strings.cls = !1),
    e.build.render_nesting_level === 0 &&
      (e.build.area === 'bibliography' && e.bibliography.opt['second-field-align']
        ? ((n = new l.Token('group', l.START)),
          (n.decorations = [['@display', 'left-margin']]),
          (s = function (c, f) {
            c.tmp.render_seen || ((n.strings.first_blob = f.id), c.output.startTag('bib_first', n))
          }),
          n.execs.push(s),
          t.push(n))
        : l.DISPLAY_CLASSES.indexOf(i) > -1 &&
          ((n = new l.Token('group', l.START)),
          (n.decorations = [['@display', i]]),
          (s = function (c, f) {
            ;(n.strings.first_blob = f.id), c.output.startTag('bib_first', n)
          }),
          n.execs.push(s),
          t.push(n)),
      (e.build.cls = i)),
    (e.build.render_nesting_level += 1),
    e.build.substitute_level.value() === 1 &&
      ((a = new l.Token('choose', l.START)),
      l.Node.choose.build.call(a, e, t),
      (o = new l.Token('if', l.START)),
      (s = function () {
        return !!e.tmp.can_substitute.value()
      }),
      o.tests || (o.tests = []),
      o.tests.push(s),
      (o.test = e.fun.match.any(this, e, o.tests)),
      t.push(o)),
    e.sys.variableWrapper &&
      this.variables_real &&
      this.variables_real.length &&
      ((s = function (c, f, h) {
        if (!c.tmp.just_looking && !c.tmp.suppress_decorations) {
          var p = new l.Token('text', l.START)
          ;(p.decorations = [['@showid', 'true']]), c.output.startTag('variable_entry', p)
          var m = null
          h && (m = h.position), m || (m = 0)
          var v = ['first', 'container-subsequent', 'subsequent', 'ibid', 'ibid-with-locator'],
            b = 0
          h && h.noteIndex && (b = h.noteIndex)
          var S = 0
          h && h['first-reference-note-number'] && (S = h['first-reference-note-number'])
          var g = 0
          h &&
            h['first-container-reference-note-number'] &&
            (g = h['first-container-reference-note-number'])
          var _ = 0
          h && h['citation-number'] && (_ = h['citation-number'])
          var y = 0
          h && h.index && (y = h.index)
          var x = {
            itemData: f,
            variableNames: this.variables,
            context: c.tmp.area,
            xclass: c.opt.xclass,
            position: v[m],
            'note-number': b,
            'first-reference-note-number': S,
            'first-container-reference-note-number': g,
            'citation-number': _,
            index: y,
            mode: c.opt.mode,
          }
          c.output.current.value().params = x
        }
      }),
      this.execs.push(s))
}
l.Util.substituteEnd = function (e, t) {
  var r, i, n, s, a, o
  if (
    (e.sys.variableWrapper &&
      (this.hasVariable || (this.variables_real && this.variables_real.length)) &&
      ((r = function (c) {
        !c.tmp.just_looking && !c.tmp.suppress_decorations && c.output.endTag('variable_entry')
      }),
      this.execs.push(r)),
    (r = function (c) {
      for (var f = 0, h = this.decorations.length; f < h; f += 1)
        if (this.decorations[f][0] === '@strip-periods' && this.decorations[f][1] === 'true') {
          c.tmp.strip_periods += -1
          break
        }
    }),
    this.execs.push(r),
    (e.build.render_nesting_level += -1),
    e.build.render_nesting_level === 0 &&
      (e.build.cls
        ? ((r = function (c) {
            c.output.endTag('bib_first')
          }),
          this.execs.push(r),
          (e.build.cls = !1))
        : e.build.area === 'bibliography' &&
          e.bibliography.opt['second-field-align'] &&
          ((i = new l.Token('group', l.END)),
          (r = function (c) {
            c.tmp.render_seen || c.output.endTag('bib_first')
          }),
          i.execs.push(r),
          t.push(i),
          (n = new l.Token('group', l.START)),
          (n.decorations = [['@display', 'right-inline']]),
          (r = function (c) {
            c.tmp.render_seen || ((c.tmp.render_seen = !0), c.output.startTag('bib_other', n))
          }),
          n.execs.push(r),
          t.push(n))),
    e.build.substitute_level.value() === 1 &&
      ((s = new l.Token('if', l.END)),
      t.push(s),
      (a = new l.Token('choose', l.END)),
      l.Node.choose.build.call(a, e, t)),
    this.name === 'names' || (this.name === 'text' && this.variables_real !== 'title'))
  ) {
    new l.Token('text', l.SINGLETON)
    var u = this.name
    ;(r = function (c, f) {
      if (
        c.tmp.area === 'bibliography' &&
        typeof c.bibliography.opt['subsequent-author-substitute'] == 'string' &&
        !(this.variables_real && !f[this.variables_real]) &&
        !(this.variables_real && u === 'names')
      ) {
        var h = c.bibliography.opt['subsequent-author-substitute-rule'],
          p,
          m,
          v = !c.tmp.suppress_decorations
        if (v && c.tmp.subsequent_author_substitute_ok && c.tmp.rendered_name) {
          if (h === 'partial-each' || h === 'partial-first') {
            var b = !0,
              S = []
            for (p = 0, m = c.tmp.name_node.children.length; p < m; p += 1) {
              var g = c.tmp.rendered_name[p]
              b &&
              c.tmp.last_rendered_name &&
              c.tmp.last_rendered_name.length > p - 1 &&
              g &&
              !g.localeCompare(c.tmp.last_rendered_name[p])
                ? ((o = new l.Blob(c[c.tmp.area].opt['subsequent-author-substitute'])),
                  (c.tmp.name_node.children[p].blobs = [o]),
                  h === 'partial-first' && (b = !1))
                : (b = !1),
                S.push(g)
            }
            c.tmp.last_rendered_name = S
          } else if (h === 'complete-each') {
            var S = c.tmp.rendered_name.join(',')
            if (S) {
              if (c.tmp.last_rendered_name && !S.localeCompare(c.tmp.last_rendered_name))
                for (p = 0, m = c.tmp.name_node.children.length; p < m; p += 1)
                  (o = new l.Blob(c[c.tmp.area].opt['subsequent-author-substitute'])),
                    (c.tmp.name_node.children[p].blobs = [o])
              c.tmp.last_rendered_name = S
            }
          } else {
            var S = c.tmp.rendered_name.join(',')
            S &&
              (c.tmp.last_rendered_name &&
                !S.localeCompare(c.tmp.last_rendered_name) &&
                ((o = new l.Blob(c[c.tmp.area].opt['subsequent-author-substitute'])),
                c.tmp.label_blob
                  ? (c.tmp.name_node.top.blobs = [o, c.tmp.label_blob])
                  : c.tmp.name_node.top.blobs.length
                  ? (c.tmp.name_node.top.blobs[0].blobs = [o])
                  : (c.tmp.name_node.top.blobs = [o]),
                (c.tmp.substituted_variable = u)),
              (c.tmp.last_rendered_name = S))
          }
          c.tmp.subsequent_author_substitute_ok = !1
        }
      }
    }),
      this.execs.push(r)
  }
  ;((this.name === 'text' && !this.postponed_macro) ||
    ['number', 'date', 'names'].indexOf(this.name) > -1) &&
    ((r = function (c, f) {
      c.tmp.element_trace.mystack.length > 1 && c.tmp.element_trace.pop()
    }),
    this.execs.push(r))
}
l.Util.padding = function (e) {
  var t = e.match(/\s*(-{0,1}[0-9]+)/)
  if (t)
    for (e = parseInt(t[1], 10), e < 0 && (e = 1e20 + e), e = '' + e; e.length < 20; ) e = '0' + e
  return e
}
l.Util.LongOrdinalizer = function () {}
l.Util.LongOrdinalizer.prototype.init = function (e) {
  this.state = e
}
l.Util.LongOrdinalizer.prototype.format = function (e, t) {
  e < 10 && (e = '0' + e)
  var r = l.Engine.getField(
    l.LOOSE,
    this.state.locale[this.state.opt.lang].terms,
    'long-ordinal-' + e,
    'long',
    0,
    t
  )
  return (
    r || (r = this.state.fun.ordinalizer.format(e, t)),
    (this.state.tmp.cite_renders_content = !0),
    r
  )
}
l.Util.Ordinalizer = function (e) {
  ;(this.state = e), (this.suffixes = {})
}
l.Util.Ordinalizer.prototype.init = function () {
  if (!this.suffixes[this.state.opt.lang]) {
    this.suffixes[this.state.opt.lang] = {}
    for (var e = 0, t = 3; e < t; e += 1) {
      var r = [void 0, 'masculine', 'feminine'][e]
      this.suffixes[this.state.opt.lang][r] = []
      for (var i = 1; i < 5; i += 1) {
        var n = this.state.getTerm('ordinal-0' + i, 'long', !1, r)
        if (typeof n > 'u') {
          delete this.suffixes[this.state.opt.lang][r]
          break
        }
        this.suffixes[this.state.opt.lang][r].push(n)
      }
    }
  }
}
l.Util.Ordinalizer.prototype.format = function (e, t) {
  var r
  ;(e = parseInt(e, 10)), (r = '' + e)
  var i = '',
    n = []
  if ((t && n.push(t), n.push('neuter'), this.state.locale[this.state.opt.lang].ord['1.0.1'])) {
    i = this.state.getTerm('ordinal', !1, 0, t)
    for (var s, a = 0, o = n.length; a < o; a += 1) {
      s = n[a]
      var u = this.state.locale[this.state.opt.lang].ord['1.0.1']
      if (
        (u['whole-number'][r] && u['whole-number'][r][s]
          ? (i = this.state.getTerm(
              this.state.locale[this.state.opt.lang].ord['1.0.1']['whole-number'][r][s],
              !1,
              0,
              t
            ))
          : u['last-two-digits'][r.slice(r.length - 2)] &&
            u['last-two-digits'][r.slice(r.length - 2)][s]
          ? (i = this.state.getTerm(
              this.state.locale[this.state.opt.lang].ord['1.0.1']['last-two-digits'][
                r.slice(r.length - 2)
              ][s],
              !1,
              0,
              t
            ))
          : u['last-digit'][r.slice(r.length - 1)] &&
            u['last-digit'][r.slice(r.length - 1)][s] &&
            (i = this.state.getTerm(
              this.state.locale[this.state.opt.lang].ord['1.0.1']['last-digit'][
                r.slice(r.length - 1)
              ][s],
              !1,
              0,
              t
            )),
        i)
      )
        break
    }
  } else
    t || (t = void 0),
      this.state.fun.ordinalizer.init(),
      (e / 10) % 10 === 1 || (e > 10 && e < 20)
        ? (i = this.suffixes[this.state.opt.lang][t][3])
        : e % 10 === 1 && e % 100 !== 11
        ? (i = this.suffixes[this.state.opt.lang][t][0])
        : e % 10 === 2 && e % 100 !== 12
        ? (i = this.suffixes[this.state.opt.lang][t][1])
        : e % 10 === 3 && e % 100 !== 13
        ? (i = this.suffixes[this.state.opt.lang][t][2])
        : (i = this.suffixes[this.state.opt.lang][t][3])
  return (r = r += i), r
}
l.Util.Romanizer = function () {}
l.Util.Romanizer.prototype.format = function (e) {
  var t, r, i, n, s
  if (((t = ''), e < 6e3))
    for (n = e.toString().split(''), n.reverse(), r = 0, i = 0, s = n.length, r = 0; r < s; r += 1)
      (i = parseInt(n[r], 10)), (t = l.ROMAN_NUMERALS[r][i] + t)
  return t
}
l.Util.Suffixator = function (e) {
  e || (e = l.SUFFIX_CHARS), (this.slist = e.split(','))
}
l.Util.Suffixator.prototype.format = function (e) {
  var t
  e += 1
  var r = ''
  do {
    t = e % 26 === 0 ? 26 : e % 26
    var r = this.slist[t - 1] + r
    e = (e - t) / 26
  } while (e !== 0)
  return r
}
l.Engine.prototype.processNumber = function (e, t, r) {
  var i,
    n = this,
    s = r
  r = r === 'page-first' ? 'page' : r
  var a = ',\\s+and\\s+|\\s+and\\s+'
  this.opt.lang.slice(0, 2) !== 'en' &&
    (a += '|,\\s+' + this.getTerm('and') + '\\s+|\\s+' + this.getTerm('and') + '\\s+')
  var o = '\\s*&\\s*',
    u = new RegExp('^' + o + '$'),
    c = new RegExp('(' + o + '|' + a + '|;\\s+|,\\s+|\\s*\\\\*[\\-\\u2013]+\\s*)', 'g'),
    f = new RegExp('(?:' + o + '|' + a + '|;\\s+|,\\s+|\\s*\\\\*[\\-\\u2013]+\\s*)'),
    h = this.getTerm('and'),
    p = this.getTerm('and', 'symbol')
  h === p && (p = '&')
  function m(q) {
    q = q.trim()
    var X = q.match(/^([^ ]+)/)
    if (X && !l.STATUTE_SUBDIV_STRINGS[X[1]]) {
      var I = null
      ;['locator', 'locator-extra', 'page'].indexOf(r) > -1
        ? t.label
          ? (I = l.STATUTE_SUBDIV_STRINGS_REVERSE[t.label])
          : (I = 'p.')
        : (I = l.STATUTE_SUBDIV_STRINGS_REVERSE[r]),
        I && (q = I + ' ' + q)
    }
    return q
  }
  function v(q, X, I, re, ie) {
    re = re || ''
    var Z = {}
    if ((!X && !l.STATUTE_SUBDIV_STRINGS_REVERSE[r] && (X = 'var:' + r), X)) {
      var oe = X.match(/(\s*)([^\s]+)(\s*)/)
      s === 'page' && ie === 0 && ['p.', 'pp.'].indexOf(oe[2]) === -1
        ? ((Z.gotosleepability = !0), (Z.labelVisibility = !0))
        : (Z.labelVisibility = !1),
        (Z.label = oe[2]),
        (Z.origLabel = q),
        (Z.labelSuffix = oe[3] ? oe[3] : ''),
        (Z.plural = 0)
    }
    var oe = I.match(/^([0-9]*[a-zA-Z]+0*)?([0-9]+(?:[a-zA-Z]*|[-,a-zA-Z]+))$/)
    return (
      oe
        ? ((Z.particle = oe[1] ? oe[1] : ''), (Z.value = oe[2]))
        : ((Z.particle = ''), (Z.value = I)),
      (Z.joiningSuffix = re.replace(/\s*-\s*/, '-')),
      Z
    )
  }
  function b(q) {
    for (var X = q.length - 2; X > -1; X -= 2)
      q[X] === '-' &&
        q[X - 1].match(
          /^(?:(?:[a-z]|[a-z][a-z]|[a-z][a-z][a-z]|[a-z][a-z][a-z][a-z])\.  *)*[0-9]+[,a-zA-Z]+$/
        ) &&
        q[X + 1].match(/^[,a-zA-Z]+$/) &&
        ((q[X - 1] = q.slice(X - 1, X + 2).join('')), (q = q.slice(0, X).concat(q.slice(X + 2))))
    return q
  }
  function S(q, X) {
    ;(X = X || ''), (q = m(q))
    var I, re, ie
    if (
      (r === 'page' && q.indexOf('') > -1 && (q = q.replace(/\u2013/g, '-')),
      q.indexOf('\\-') > -1)
    ) {
      ;(I = new RegExp(c.source.replace('\\-', ''))), (re = new RegExp(f.source.replace('\\-', '')))
      for (var Z = q.split('\\-'), oe = 0, ce = Z.length; oe < ce; oe++)
        Z[oe] = Z[oe].replace(/\-/g, '')
      ;(ie = Z.join('\\-')), (ie = ie.replace(/\\/g, ''))
    } else (I = c), (re = f), (ie = q)
    var fe = [],
      ge = ie.match(I)
    if (ge) {
      for (var Z = ie.split(re), oe = 0, ce = ge.length; oe < ce; oe++)
        ge[oe].match(u) &&
          (Z[oe].match(/[a-zA-Z]$/) && Z[oe].match(/^[a-zA-Z]/)
            ? (ge[oe] = p)
            : (ge[oe] = ' ' + p + ' '))
      var me = !1
      for (var oe in Z)
        if (('' + Z[oe]).replace(/^[a-z]\.\s+/, '').match(/[^\s0-9ivxlcmIVXLCM]/)) break
      if (me) fe = [ie]
      else {
        for (var oe = 0, ce = Z.length - 1; oe < ce; oe++) fe.push(Z[oe]), fe.push(ge[oe])
        fe.push(Z[Z.length - 1]), (fe = b(fe))
      }
    } else var fe = [ie]
    for (var be = [], Ne = X, Oe = '', oe = 0, ce = fe.length; oe < ce; oe += 2) {
      var ge = fe[oe].match(
        /((?:^| )(?:[a-z]|[a-z][a-z]|[a-z][a-z][a-z]|[a-z][a-z][a-z][a-z]|subpara|subch|amend|bibliog|annot|illus|princ|intro|sched|subdiv|subsec)(?:\.| ) *)/g
      )
      if (ge) {
        for (
          var Z = fe[oe].split(
              /(?:(?:^| )(?:[a-z]|[a-z][a-z]|[a-z][a-z][a-z]|[a-z][a-z][a-z][a-z]|subpara|subch|amend|bibliog|annot|illus|princ|intro|sched|subdiv|subsec)(?:\.| ) *)/
            ),
            _e = Z.length - 1;
          _e > 0;
          _e--
        )
          Z[_e - 1] &&
            (!Z[_e].match(/^[0-9]+([-;,:a-zA-Z]*)$/) ||
              !Z[_e - 1].match(/^[0-9]+([-;,:a-zA-Z]*)$/)) &&
            ((Z[_e - 1] = Z[_e - 1] + ge[_e - 1] + Z[_e]),
            (Z = Z.slice(0, _e).concat(Z.slice(_e + 1))),
            (ge = ge.slice(0, _e - 1).concat(ge.slice(_e))))
        if (ge.length > 0) {
          var F = ge[0].trim(),
            E =
              !l.STATUTE_SUBDIV_STRINGS[F] ||
              typeof n.getTerm(l.STATUTE_SUBDIV_STRINGS[F]) > 'u' ||
              (['locator', 'number', 'locator-extra', 'page'].indexOf(r) === -1 &&
                l.STATUTE_SUBDIV_STRINGS[F] !== r)
          E
            ? oe === 0 &&
              ((ge = ge.slice(1)),
              (Z[0] = Z[0] + ' ' + F + ' ' + Z[1]),
              (Z = Z.slice(0, 1).concat(Z.slice(2))))
            : (Oe = F)
        }
        for (var _e = 0, A = Z.length; _e < A; _e++)
          if (Z[_e] || _e === Z.length - 1) {
            var z
            ;(Ne = ge[_e - 1] ? ge[_e - 1] : Ne),
              Oe === Ne.trim() ? (z = '') : (z = Oe),
              (ie = Z[_e] ? Z[_e].trim() : ''),
              _e === Z.length - 1
                ? be.push(v(z, Ne, ie, fe[oe + 1], oe))
                : be.push(v(z, Ne, ie, null, oe))
          }
      } else {
        var z
        Oe === Ne.trim() ? (z = '') : (z = Oe), be.push(v(z, Ne, fe[oe], fe[oe + 1]))
      }
    }
    return be
  }
  function g(q) {
    for (var X = 0, I = q.length - 1; X < I; X++)
      !q[X].joiningSuffix && q[X + 1].label && (q[X].joiningSuffix = ' ')
  }
  function _(q, X, I) {
    var re = q[I.pos],
      ie = q[X].value,
      Z = re.joiningSuffix === '\\-'
    ie.particle && ie.particle !== re.particle && (I.collapsible = !1)
    var oe = ie.match(/^[0-9]+([-,:a-zA-Z]*)$/),
      ce = re.value.match(/^(?:[0-9]+|[ixv]+)([-,:a-zA-Z]*|\-[\-0-9]+)$/)
    if (
      ((!ie || !oe || !ce || Z) &&
        ((I.collapsible = !1), (!ie || !ce) && (I.numeric = !1), Z && I.count--),
      ((oe && oe[1]) || (ce && ce[1])) && (I.collapsible = !1),
      q[X].collapsible === void 0)
    ) {
      for (var fe = X, ge = X + I.count; fe < ge; fe++)
        isNaN(parseInt(q[fe].value)) && !q[fe].value.match(/^[ivxlcmIVXLCM]+$/)
          ? (q[fe].collapsible = !1)
          : (q[fe].collapsible = !0)
      I.collapsible = q[X].collapsible
    }
    for (var me = I.collapsible, fe = I.pos, ge = I.pos + I.count; fe < ge; fe++)
      I.count > 1 && me && (q[fe].plural = 1),
        (q[fe].numeric = I.numeric),
        (q[fe].collapsible = I.collapsible)
  }
  function y(q, X, I) {
    I.label.slice(0, 4) !== 'var:' &&
      (I.pos === 0
        ? (['locator', 'number', 'locator-extra', 'page'].indexOf(r) > -1 &&
            typeof n.getTerm(l.STATUTE_SUBDIV_STRINGS[I.label]) > 'u' &&
            (q[I.pos].labelVisibility = !0),
          ['locator', 'number', 'locator-extra', 'page'].indexOf(r) === -1 &&
            l.STATUTE_SUBDIV_STRINGS[I.label] !== r &&
            (q[0].labelVisibility = !0))
        : (q[I.pos].labelVisibility = !0))
  }
  function x(q) {
    if (q.length !== 0) {
      for (var X = 0, I = 1, re = 1, ie = q.length; re < ie; re++) {
        var Z = q[re - 1],
          oe = q[re]
        if (Z.label === oe.label && Z.particle === Z.particle) I++
        else {
          var ce = JSON.parse(JSON.stringify(q[X]))
          ;(ce.pos = X),
            (ce.count = I),
            (ce.numeric = !0),
            _(q, X, ce),
            Z.label !== oe.label && y(q, X, ce),
            (X = re),
            (I = 1)
        }
      }
      var ce = JSON.parse(JSON.stringify(q[X]))
      ;(ce.pos = X),
        (ce.count = I),
        (ce.numeric = !0),
        _(q, X, ce),
        y(q, X, ce),
        q.length &&
          q[0].numeric &&
          r.slice(0, 10) === 'number-of-' &&
          parseInt(t[s], 10) > 1 &&
          (q[0].plural = 1)
    }
  }
  function D(q) {
    return q.replace('\\-', '-')
  }
  function C(q) {
    var X = l.Util.cloneToken(e),
      I = new l.Token()
    n.tmp.just_looking ||
      ((I.decorations = X.decorations),
      (X.decorations = []),
      (I.strings.prefix = X.strings.prefix),
      (X.strings.prefix = ''),
      (I.strings.suffix = X.strings.suffix),
      (X.strings.suffix = ''))
    var re = q.length ? q[0].label : null
    if (q.length) {
      for (var ie = 0, Z = q.length; ie < Z; ie++) {
        var oe = q[ie],
          ce = l.Util.cloneToken(X)
        ;(ce.gender = e.gender),
          re === oe.label && (ce.formatter = e.formatter),
          oe.numeric && (ce.successor_prefix = oe.successor_prefix),
          (ce.strings.suffix = ce.strings.suffix + D(oe.joiningSuffix)),
          (oe.styling = ce)
      }
      n.tmp.just_looking ||
        (q[0].value.slice(0, 1) === '"' &&
          q[q.length - 1].value.slice(-1) === '"' &&
          ((q[0].value = q[0].value.slice(1)),
          (q[q.length - 1].value = q[q.length - 1].value.slice(0, -1)),
          I.decorations.push(['@quotes', !0])))
    }
    return I
  }
  function H(q, X) {
    var I = !0
    if (['locator', 'locator-extra', 'page'].indexOf(q) > -1) {
      var re
      X.origLabel ? (re = X.origLabel) : (re = X.label),
        (I = !!n.getTerm(l.STATUTE_SUBDIV_STRINGS[re]))
    }
    return I
  }
  function T(q, X) {
    return (
      q === 'page' ||
      (['locator', 'locator-extra'].indexOf(q) > -1 &&
        (['p.'].indexOf(X.label) > -1 || ['p.'].indexOf(X.origLabel) > -1))
    )
  }
  function k(q, X, I, re) {
    var ie = T(q, X),
      Z = H(q, X)
    return (
      Z &&
        I === '-' &&
        re &&
        ((ie ||
          ['locator', 'locator-extra', 'issue', 'volume', 'edition', 'number'].indexOf(q) > -1) &&
          ((I = n.getTerm('page-range-delimiter')), I || (I = '')),
        q === 'collection-number' && ((I = n.getTerm('year-range-delimiter')), I || (I = ''))),
      I
    )
  }
  function O(q, X, I) {
    if (!(X < 1) && I.count === 2 && q[X - 1].particle === q[X].particle) {
      if (q[X - 1].joiningSuffix !== '-') {
        I.count = 1
        return
      }
      if (!n.opt['page-range-format'] && parseInt(q[X - 1].value, 10) > parseInt(q[X].value, 10)) {
        q[X - 1].joiningSuffix = k(r, q[X], q[X - 1].joiningSuffix, !0)
        return
      }
      var re = q[X],
        ie = T(r, re),
        Z
      ie && !isNaN(parseInt(q[X - 1].value)) && !isNaN(parseInt(q[X].value))
        ? ((Z = q[X - 1].particle + q[X - 1].value + ' - ' + q[X].particle + q[X].value),
          (Z = n.fun.page_mangler(Z)))
        : (('' + q[X - 1].value).match(/^([0-9]+|[ivxlcmIVXLCM]+)$/) &&
            ('' + q[X].value).match(/^([0-9]+|[ivxlcmIVXLCM]+)$/) &&
            (q[X - 1].joiningSuffix = n.getTerm('page-range-delimiter')),
          (Z = q[X - 1].value + D(q[X - 1].joiningSuffix) + q[X].value))
      var oe = Z.match(
        /^((?:[0-9]*[a-zA-Z]+0*))?([0-9]+[a-z]*)(\s*[^0-9]+\s*)([-,a-zA-Z]?0*)([0-9]+[a-z]*)$/
      )
      if (oe) {
        var ce = oe[3]
        ;(ce = k(r, re, ce, q[X].numeric)),
          (q[X - 1].particle = oe[1]),
          (q[X - 1].value = oe[2]),
          (q[X - 1].joiningSuffix = ce),
          (q[X].particle = oe[4]),
          (q[X].value = oe[5])
      }
      I.count = 0
    }
  }
  function N(q) {
    if (
      e &&
      [
        'page',
        'chapter-number',
        'collection-number',
        'edition',
        'issue',
        'number',
        'number-of-pages',
        'number-of-volumes',
        'volume',
        'locator',
        'locator-extra',
      ].indexOf(r) !== -1
    ) {
      for (
        var X = { count: 0, label: null, lastHadRangeDelimiter: !1 }, I = 0, re = q.length;
        I < re;
        I++
      ) {
        var ie = q[I]
        if (ie.collapsible)
          X.label === ie.label && ie.joiningSuffix === '-'
            ? (X.count = 1)
            : X.label === ie.label && ie.joiningSuffix !== '-'
            ? (X.count++, X.count === 2 && O(q, I, X))
            : X.label !== ie.label
            ? ((X.label = ie.label), (X.count = 1))
            : ((X.count = 1), (X.label = ie.label))
        else {
          ;(X.count = 0), (X.label = null)
          var Z = ie.numeric
          ie.joiningSuffix = k(r, ie, ie.joiningSuffix, Z)
        }
      }
      X.count === 2 && O(q, q.length - 1, X)
    }
  }
  function M(q, X, I) {
    var re = q[X]
    I.length &&
      ((re.numeric = I[0].numeric),
      (re.collapsible = I[0].collapsible),
      (re.plural = I[0].plural),
      (re.label = l.STATUTE_SUBDIV_STRINGS[I[0].label]),
      r === 'number' && re.label === 'issue' && n.getTerm('number') && (re.label = 'number'))
  }
  if (e && this.tmp.shadow_numbers[s] && this.tmp.shadow_numbers[s].values.length) {
    var V = this.tmp.shadow_numbers[s].values
    N(V), (this.tmp.shadow_numbers[s].masterStyling = C(V))
    return
  }
  if ((this.tmp.shadow_numbers[s] || (this.tmp.shadow_numbers[s] = { values: [] }), !!t)) {
    var j = l.LangPrefsMap[r]
    if (j) {
      var R = this.opt['cite-lang-prefs'][j][0]
      ;(i = this.transform.getTextSubField(t, s, 'locale-' + R, !0)), (i = i.name)
    } else i = t[s]
    if (
      (i && s === 'number' && t.type === 'legal_case' && (i = i.replace(/[\\]*-/g, '\\-')),
      i && this.sys.getAbbreviation)
    ) {
      if (this.sys.normalizeAbbrevsKey) var $ = this.sys.normalizeAbbrevsKey(s, i)
      else var $ = i
      var L = this.transform.loadAbbreviation(t.jurisdiction, 'number', $, t.language)
      this.transform.abbrevs[L].number &&
        (this.transform.abbrevs[L].number[$]
          ? (i = this.transform.abbrevs[L].number[$])
          : typeof this.transform.abbrevs[L].number[$] < 'u' &&
            delete this.transform.abbrevs[L].number[$])
    }
    if (typeof i < 'u' && (typeof i == 'string' || typeof i == 'number')) {
      typeof i == 'number' && (i = '' + i)
      var P = l.STATUTE_SUBDIV_STRINGS_REVERSE[r]
      if (this.tmp.shadow_numbers[s].values.length === 0) {
        var V = S(i, P)
        g(V), x(V)
        for (var Y of V) Y.numeric || (Y.plural = 0)
        ;(this.tmp.shadow_numbers[s].values = V),
          e && (N(V), (this.tmp.shadow_numbers[s].masterStyling = C(V))),
          M(this.tmp.shadow_numbers, s, V)
      }
      var w = this.tmp.shadow_numbers[s]
      r === 'number' &&
        w.values.length === 1 &&
        w.values[0].value.indexOf('|') > -1 &&
        ((w.values[0].value = w.values[0].value.replace(/\|/g, ', ')),
        (w.values[0].numeric = !0),
        (w.values[0].plural = 1),
        (w.values[0].collapsible = !1),
        (w.numeric = !0),
        (w.plural = 1),
        (w.collapsible = !1)),
        w.values.length === 1 &&
          w.values[0].value.match(/^[0-9]+(?:\/[0-9]+)+$/) &&
          ((w.values[0].numeric = !0),
          (w.values[0].plural = 0),
          (w.values[0].collapsible = !1),
          (w.numeric = !0),
          (w.plural = 0),
          (w.collapsible = !1)),
        r === 'page' &&
          w.values.length > 0 &&
          w.values[0].gotosleepability &&
          (w.labelForm = 'short')
    }
  }
}
l.Util.outputNumericField = function (e, t, r) {
  e.output.openLevel(e.tmp.shadow_numbers[t].masterStyling)
  var i = e.tmp.shadow_numbers[t].masterStyling,
    n = e.tmp.shadow_numbers[t].values,
    s = n.length ? n[0].label : null,
    a = e.tmp.shadow_numbers[t].labelForm,
    o = e.tmp.group_context.tip.label_static,
    u
  a ? (u = a) : (u = 'short')
  for (
    var c = e.tmp.shadow_numbers[t].labelCapitalizeIfFirst,
      f = e.tmp.shadow_numbers[t].labelDecorations,
      h = null,
      p = 0,
      m = n.length;
    p < m;
    p++
  ) {
    var v = n[p],
      b = '',
      S
    v.label &&
      (v.label.slice(0, 4) === 'var:'
        ? (S = v.label.slice(4))
        : (S = l.STATUTE_SUBDIV_STRINGS[v.label]),
      S &&
        (v.label === s
          ? (o && ((b = e.getTerm(S, 'static', v.plural)), b.indexOf('%s') === -1 && (b = '')),
            b || (b = e.getTerm(S, a, v.plural)))
          : (o && ((b = e.getTerm(S, 'static', v.plural)), b.indexOf('%s') === -1 && (b = '')),
            b || (b = e.getTerm(S, u, v.plural))),
        c && (b = l.Output.Formatters['capitalize-first'](e, b))))
    var g = -1
    b && (g = b.indexOf('%s'))
    var _ = l.Util.cloneToken(v.styling)
    if (
      ((_.formatter = v.styling.formatter),
      (_.type = v.styling.type),
      (_.num = v.styling.num),
      (_.gender = v.styling.gender),
      g > 0 && g < b.length - 2)
    )
      (_.strings.prefix += b.slice(0, g)), (_.strings.suffix = b.slice(g + 2) + _.strings.suffix)
    else if (v.labelVisibility)
      if ((b || ((b = v.label), (S = v.label)), g > 0)) {
        var y = new l.Token()
        ;(y.decorations = f), e.output.append(b.slice(0, g), y)
      } else (g === b.length - 2 || g === -1) && e.output.append(b + v.labelSuffix, 'empty')
    if (
      (l.UPDATE_GROUP_CONTEXT_CONDITION(e, i.strings.prefix, null, i, `${v.particle}${v.value}`),
      v.collapsible)
    ) {
      var x
      v.value.match(/^[1-9][0-9]*$/) && Number.isSafeInteger(parseInt(v.value, 10))
        ? (x = new l.NumericBlob(e, v.particle, parseInt(v.value, 10), _, r))
        : (x = new l.NumericBlob(e, v.particle, v.value, _, r)),
        typeof x.gender > 'u' && (x.gender = e.locale[e.opt.lang]['noun-genders'][t]),
        e.output.append(x, 'literal')
    } else e.output.append(v.particle + v.value, _)
    if (g === 0 && g < b.length - 2 && (h === null && (h = S), S !== h || p === n.length - 1)) {
      var D = new l.Token()
      ;(D.decorations = f), e.output.append(b.slice(g + 2), D)
    }
    ;(h = S), (e.tmp.term_predecessor = !0)
  }
  e.output.closeLevel()
}
l.Util.PageRangeMangler = {}
l.Util.PageRangeMangler.getFunction = function (e, t) {
  var r,
    i,
    n,
    s,
    a,
    o,
    u,
    c,
    f,
    h,
    p,
    m,
    v,
    b,
    S,
    g,
    _,
    y,
    x = e.getTerm(t + '-range-delimiter')
  ;(r = /([0-9]*[a-zA-Z]+0*)?([0-9]+[a-z]*)\s*(?:\u2013|-)\s*([0-9]*[a-zA-Z]+0*)?([0-9]+[a-z]*)/),
    (s = function (C) {
      for (n = C.length, i = 1; i < n; i += 2) typeof C[i] == 'object' && (C[i] = C[i].join(''))
      var H = C.join('')
      return (H = H.replace(/([^\\])\-/g, '$1' + e.getTerm(t + '-range-delimiter'))), H
    }),
    (a = function (C) {
      var H,
        T,
        k,
        O = '\\s+\\-\\s+',
        N = x === '-' ? '' : x,
        M = new RegExp('([^\\\\])[-' + N + '\\u2013]', 'g')
      C = C.replace(M, '$1 - ').replace(/\s+-\s+/g, ' - ')
      var V = new RegExp(
          '((?:[0-9]*[a-zA-Z]+0*)?[0-9]+[a-z]*' + O + '(?:[0-9]*[a-zA-Z]+0*)?[0-9]+[a-z]*)',
          'g'
        ),
        j = new RegExp(
          '(?:[0-9]*[a-zA-Z]+0*)?[0-9]+[a-z]*' + O + '(?:[0-9]*[a-zA-Z]+0*)?[0-9]+[a-z]*'
        )
      if (((H = C.match(V)), (T = C.split(j)), T.length === 0)) k = H
      else
        for (k = [T[0]], i = 1, n = T.length; i < n; i += 1)
          k.push(H[i - 1].replace(/\s*\-\s*/g, '-')), k.push(T[i])
      return k
    }),
    (o = function (C) {
      for (C = '' + C, p = a(C), n = p.length, i = 1; i < n; i += 2)
        (m = p[i].match(r)),
          m &&
            (!m[3] || m[1] === m[3]) &&
            (m[4].length < m[2].length && (m[4] = m[2].slice(0, m[2].length - m[4].length) + m[4]),
            parseInt(m[2], 10) < parseInt(m[4], 10) &&
              ((m[3] = x + (m[1] ? m[1] : '')), (p[i] = m.slice(1)))),
          typeof p[i] == 'string' && (p[i] = p[i].replace(/\-/g, x))
      return p
    }),
    (u = function (C, H, T) {
      n = C.length
      for (var k = 1, O = C.length; k < O; k += 2)
        typeof C[k] == 'object' &&
          ((C[k][3] = c(C[k][1], C[k][3], H, T)), C[k][2].slice(1) === C[k][0] && (C[k][2] = x))
      return s(C)
    }),
    (c = function (C, H, T, k) {
      if (
        (T || (T = 0),
        (v = ('' + C).split('')),
        (b = ('' + H).split('')),
        (S = b.slice()),
        S.reverse(),
        v.length === b.length)
      )
        for (var O = 0, N = v.length; O < N; O += 1)
          if (v[O] === b[O] && S.length > T) S.pop()
          else {
            if (T && k && S.length === 3) {
              var M = v.slice(0, O)
              M.reverse(), (S = S.concat(M))
            }
            break
          }
      return S.reverse(), S.join('')
    }),
    (f = function (C) {
      for (n = C.length, i = 1; i < n; i += 2)
        typeof C[i] == 'object' &&
          ((m = C[i]),
          (g = parseInt(m[1], 10)),
          (_ = parseInt(m[3], 10)),
          g > 100 && g % 100 && parseInt(g / 100, 10) === parseInt(_ / 100, 10)
            ? (m[3] = '' + (_ % 100))
            : g >= 1e4 && (m[3] = '' + (_ % 1e3))),
          m[2].slice(1) === m[0] && (m[2] = x)
      return s(C)
    }),
    (h = function (C) {
      for (n = C.length, i = 1; i < n; i += 2) {
        if (
          typeof C[i] == 'object' &&
          ((m = C[i]),
          (g = parseInt(m[1], 10)),
          (_ = parseInt(m[3], 10)),
          (b = '' + _),
          g > 100 && g % 100)
        )
          for (var H = 2; H < b.length; H++) {
            var T = Math.pow(10, H)
            if (Math.floor(g / T) === Math.floor(_ / T)) {
              m[3] = '' + (_ % T)
              break
            }
          }
        m[2].slice(1) === m[0] && (m[2] = x)
      }
      return s(C)
    })
  var D = function (C, H, T, k) {
    var N
    C = '' + C
    var O = o(C),
      N = H(O, T, k)
    return N
  }
  return (
    e.opt[t + '-range-format']
      ? e.opt[t + '-range-format'] === 'expanded'
        ? (y = function (C) {
            return D(C, s)
          })
        : e.opt[t + '-range-format'] === 'minimal'
        ? (y = function (C) {
            return D(C, u)
          })
        : e.opt[t + '-range-format'] === 'minimal-two'
        ? (y = function (C, H) {
            return D(C, u, 2, H)
          })
        : e.opt[t + '-range-format'] === 'chicago'
        ? (y = function (C) {
            return D(C, f)
          })
        : e.opt[t + '-range-format'] === 'chicago-15'
        ? (y = function (C) {
            return D(C, f)
          })
        : e.opt[t + '-range-format'] === 'chicago-16' &&
          (y = function (C) {
            return D(C, h)
          })
      : (y = function (C) {
          return D(C, s)
        }),
    y
  )
}
l.Util.FlipFlopper = function (e) {
  var t = [],
    r = {
      '<span class="nocase">': {
        type: 'nocase',
        opener: '<span class="nocase">',
        closer: '</span>',
        attr: null,
        outer: null,
        flipflop: null,
      },
      '<span class="nodecor">': {
        type: 'nodecor',
        opener: '<span class="nodecor">',
        closer: '</span>',
        attr: '@class',
        outer: 'nodecor',
        flipflop: { nodecor: 'nodecor' },
      },
      '<span style="font-variant:small-caps;">': {
        type: 'tag',
        opener: '<span style="font-variant:small-caps;">',
        closer: '</span>',
        attr: '@font-variant',
        outer: 'small-caps',
        flipflop: { 'small-caps': 'normal', normal: 'small-caps' },
      },
      '<sc>': {
        type: 'tag',
        opener: '<sc>',
        closer: '</sc>',
        attr: '@font-variant',
        outer: 'small-caps',
        flipflop: { 'small-caps': 'normal', normal: 'small-caps' },
      },
      '<i>': {
        type: 'tag',
        opener: '<i>',
        closer: '</i>',
        attr: '@font-style',
        outer: 'italic',
        flipflop: { italic: 'normal', normal: 'italic' },
      },
      '<b>': {
        type: 'tag',
        opener: '<b>',
        closer: '</b>',
        attr: '@font-weight',
        outer: 'bold',
        flipflop: { bold: 'normal', normal: 'bold' },
      },
      '<sup>': {
        type: 'tag',
        opener: '<sup>',
        closer: '</sup>',
        attr: '@vertical-align',
        outer: 'sup',
        flipflop: { sub: 'sup', sup: 'sup' },
      },
      '<sub>': {
        type: 'tag',
        opener: '<sub>',
        closer: '</sub>',
        attr: '@vertical-align',
        outer: 'sub',
        flipflop: { sup: 'sub', sub: 'sub' },
      },
      ' "': {
        type: 'quote',
        opener: ' "',
        closer: '"',
        attr: '@quotes',
        outer: 'true',
        flipflop: { true: 'inner', inner: 'true', false: 'true' },
      },
      " '": {
        type: 'quote',
        opener: " '",
        closer: "'",
        attr: '@quotes',
        outer: 'inner',
        flipflop: { true: 'inner', inner: 'true', false: 'true' },
      },
    }
  ;(r['("'] = r[' "']), (r["('"] = r[" '"])
  var i = e.getTerm('open-quote'),
    n = e.getTerm('close-quote'),
    s = e.getTerm('open-inner-quote'),
    a = e.getTerm('close-inner-quote')
  i &&
    n &&
    [' "', " '", '"', "'"].indexOf(i) === -1 &&
    ((r[i] = JSON.parse(JSON.stringify(r[' "']))), (r[i].opener = i), (r[i].closer = n)),
    s &&
      a &&
      [' "', " '", '"', "'"].indexOf(s) === -1 &&
      ((r[s] = JSON.parse(JSON.stringify(r[" '"]))), (r[s].opener = s), (r[s].closer = a))
  function o(_) {
    var y = { " '": ' "', ' "': " '", '("': "('", "('": '("' }
    ;(r[_].outer = 'true'), (r[y[_]].outer = 'inner')
  }
  function u(_) {
    for (var y = [], x = Object.keys(r), D = 0, C = x.length; D < C; D++) {
      var H = x[D]
      ;(r[_].type !== 'quote' || !r[_]) && y.push(H)
    }
    var T = r[_]
    return (
      (T.opener = new RegExp(
        '^(?:' +
          y
            .map(function (k) {
              return k.replace('(', '\\(')
            })
            .join('|') +
          ')'
      )),
      T
    )
  }
  var c = (function () {
      for (var _ = {}, y = Object.keys(r), x = 0, D = y.length; x < D; x++) {
        var C = y[x]
        _[C] = u(C)
      }
      return _
    })(),
    f = (function () {
      var _ = [],
        y = [],
        x = {}
      for (var D in c) _.push(D), (x[c[D].closer] = !0)
      for (var C = Object.keys(x), H = 0, T = C.length; H < T; H++) {
        var k = C[H]
        y.push(k)
      }
      var O = _.concat(y)
        .map(function (N) {
          return N.replace('(', '\\(')
        })
        .join('|')
      return {
        matchAll: new RegExp('((?:' + O + '))', 'g'),
        splitAll: new RegExp('(?:' + O + ')', 'g'),
        open: new RegExp(
          '(^(?:' +
            _.map(function (N) {
              return N.replace('(', '\\(')
            }).join('|') +
            ')$)'
        ),
        close: new RegExp('(^(?:' + y.join('|') + ')$)'),
      }
    })()
  function h(_, y) {
    var x = t[t.length - 1]
    return !x || _.match(x.opener)
      ? (t.push({ type: c[_].type, opener: c[_].opener, closer: c[_].closer, pos: y }), !1)
      : (t.pop(),
        t.push({ type: c[_].type, opener: c[_].opener, closer: c[_].closer, pos: y }),
        { fixtag: x.pos })
  }
  function p(_, y) {
    var x = t[t.length - 1]
    return x && _ === x.closer
      ? (t.pop(), x.type === 'nocase' ? { nocase: { open: x.pos, close: y } } : !1)
      : x
      ? { fixtag: x.pos }
      : { fixtag: y }
  }
  function m(_, y) {
    return _.match(f.open) ? h(_, y) : p(_, y)
  }
  function v(_) {
    var y = []
    ;(_ = _.replace(
      /(<span)\s+(style=\"font-variant:)\s*(small-caps);?\"[^>]*(>)/g,
      '$1 $2$3;"$4'
    )),
      (_ = _.replace(/(<span)\s+(class=\"no(?:case|decor)\")[^>]*(>)/g, '$1 $2$3'))
    var x = _.match(f.matchAll)
    if (!x) return { tags: [], strings: [_], forcedSpaces: [] }
    for (var D = _.split(f.splitAll), C = 0, H = x.length - 1; C < H; C++)
      r[x[C]] &&
        (D[C + 1] === '' && ['"', "'"].indexOf(x[C + 1]) > -1
          ? ((x[C + 1] = ' ' + x[C + 1]), y.push(!0))
          : y.push(!1))
    return { tags: x, strings: D, forcedSpaces: y }
  }
  var b = function (_) {
    var y = []
    ;(this.set = function (x) {
      for (var D = r[x].attr, C = null, H = y.length - 1; H > -1; H--) {
        var T = y[H]
        if (T[0] === D) {
          C = T
          break
        }
      }
      if (!C) {
        var k = [e[e.tmp.area].opt.layout_decorations].concat(_.alldecor)
        e: for (var H = k.length - 1; H > -1; H--) {
          var O = k[H]
          if (O)
            for (var N = O.length - 1; N > -1; N--) {
              var T = O[N]
              if (T[0] === D) {
                C = T
                break e
              }
            }
        }
      }
      C ? (C = [D, r[x].flipflop[C[1]]]) : (C = [D, r[x].outer]), y.push(C)
    }),
      (this.pair = function () {
        return y[y.length - 1]
      }),
      (this.pop = function () {
        y.pop()
      })
  }
  function S(_, y) {
    if (_ === "'") {
      if (y && y.match(/^[^\,\.\?\:\;\ ]/)) return ''
    } else if (_ === " '" && y && y.match(/^[\ ]/)) return ' '
    return !1
  }
  function g(_, y, x) {
    var D = !0,
      C = new b(_)
    _.blobs = []
    function H(V) {
      ;(this.stack = [V]),
        (this.latest = V),
        (this.addStyling = function (j, R) {
          if (
            (D &&
              (j.slice(0, 1) === ' ' && (j = j.slice(1)),
              j.slice(0, 1) === ' ' && (j = j.slice(1)),
              (D = !1)),
            (this.latest = this.stack[this.stack.length - 1]),
            R)
          ) {
            if (typeof this.latest.blobs == 'string') {
              var $ = new l.Blob()
              ;($.blobs = this.latest.blobs),
                ($.alldecor = this.latest.alldecor.slice()),
                (this.latest.blobs = [$])
            }
            var L = new l.Token(),
              P = new l.Blob(null, L)
            if (
              ((P.alldecor = this.latest.alldecor.slice()), R[0] === '@class' && R[1] === 'nodecor')
            ) {
              for (
                var Y = [],
                  w = {},
                  q = [e[e.tmp.area].opt.layout_decorations].concat(P.alldecor),
                  X = q.length - 1;
                X > -1;
                X--
              ) {
                var I = q[X]
                if (I)
                  for (var re = I.length - 1; re > -1; re--) {
                    var ie = I[re]
                    ;['@font-weight', '@font-style', '@font-variant'].indexOf(ie[0]) > -1 &&
                      !w[ie[0]] &&
                      (R[1] !== 'normal' &&
                        (P.decorations.push([ie[0], 'normal']), Y.push([ie[0], 'normal'])),
                      (w[ie[0]] = !0))
                  }
              }
              P.alldecor.push(Y)
            } else P.decorations.push(R), P.alldecor.push([R])
            if ((this.latest.blobs.push(P), this.stack.push(P), (this.latest = P), j)) {
              var L = new l.Token(),
                P = new l.Blob(null, L)
              ;(P.blobs = j), (P.alldecor = this.latest.alldecor.slice()), this.latest.blobs.push(P)
            }
          } else if (j) {
            var $ = new l.Blob()
            ;($.blobs = j), ($.alldecor = this.latest.alldecor.slice()), this.latest.blobs.push($)
          }
        }),
        (this.popStyling = function () {
          this.stack.pop()
        })
    }
    var T = new H(_)
    if (y.strings.length) {
      var k = y.strings[0]
      x && (k = ' ' + k), T.addStyling(k)
    }
    for (var O = 0, N = y.tags.length; O < N; O++) {
      var M = y.tags[O],
        k = y.strings[O + 1]
      M.match(f.open)
        ? (C.set(M), T.addStyling(k, C.pair()))
        : (C.pop(), T.popStyling(), T.addStyling(k))
    }
  }
  this.processTags = function (_) {
    var D = _.blobs,
      y = !1
    D.slice(0, 1) === ' ' && !D.match(/^\s+[\'\"]/) && (y = !0)
    var x = new RegExp(
        '(' + l.ROMANESQUE_REGEXP.source + ')(' + l.ROMANESQUE_REGEXP.source + ')',
        'g'
      ),
      D = ' ' + D.replace(x, "$1'$2"),
      C = v(D)
    if (C.tags.length !== 0) {
      for (var H = !1, T = 0, k = C.tags.length; T < k; T++) {
        var O = C.tags[T],
          D = C.strings[T + 1],
          N = S(O, D)
        if (N) (C.strings[T + 1] = N + C.strings[T + 1]), (C.tags[T] = '')
        else {
          for (var M; (M = m(O, T)), M; )
            if (Object.keys(M).indexOf('fixtag') > -1) {
              if (O.match(f.close) && O === "'")
                (C.strings[T + 1] = '' + C.strings[T + 1]), (C.tags[T] = '')
              else {
                var V = C.tags[M.fixtag]
                C.forcedSpaces[M.fixtag - 1] && (V = V.slice(1)),
                  (C.strings[M.fixtag + 1] = V + C.strings[M.fixtag + 1]),
                  (C.tags[M.fixtag] = '')
              }
              if (t.length > 0)
                if (O !== "'") t.pop()
                else break
              else break
            } else if (M.nocase) {
              ;(C.tags[M.nocase.open] = ''), (C.tags[M.nocase.close] = '')
              break
            } else break
          M &&
            (M.fixtag || M.fixtag === 0) &&
            ((C.strings[T + 1] = C.tags[T] + C.strings[T + 1]), (C.tags[T] = ''))
        }
      }
      for (var T = t.length - 1; T > -1; T--) {
        var j = t[T].pos,
          O = C.tags[j]
        O === " '" || O === "'"
          ? (C.strings[j + 1] = ' ' + C.strings[j + 1])
          : (C.strings[j + 1] = C.tags[j] + C.strings[j + 1]),
          (C.tags[j] = ''),
          t.pop()
      }
      for (var T = C.tags.length - 1; T > -1; T--)
        C.tags[T] ||
          ((C.tags = C.tags.slice(0, T).concat(C.tags.slice(T + 1))),
          (C.strings[T] = C.strings[T] + C.strings[T + 1]),
          (C.strings = C.strings.slice(0, T + 1).concat(C.strings.slice(T + 2))))
      for (var T = 0, k = C.tags.length; T < k; T++) {
        var O = C.tags[T],
          R = C.forcedSpaces[T - 1]
        ;[' "', " '", '("', "('"].indexOf(O) > -1 &&
          (H || (o(O), (H = !0)), R || (C.strings[T] += O.slice(0, 1)))
      }
      g(_, C, y)
    }
  }
}
l.Output.Formatters = (function () {
  var e = `(?:|||| "| '|"|'|[-/.,;?!:]|\\[|\\]|\\(|\\)|<span style="font-variant: small-caps;">|<span class="no(?:case|decor)">|</span>|</?(?:i|sc|b|sub|sup)>)`,
    t = new l.Doppeler(e, function (b) {
      return b
        .replace(/(<span)\s+(class=\"no(?:case|decor)\")[^>]*(>)/g, '$1 $2$3')
        .replace(/(<span)\s+(style=\"font-variant:)\s*(small-caps);?(\")[^>]*(>)/g, '$1 $2 $3;$4$5')
    }),
    r = '(?:[-\\s]*<\\/*(?:spans+class="no(?:case|decor)"|i|sc|b|sub|sup)>[-\\s]*|[-\\s]+)',
    i = new l.Doppeler(r),
    n = new l.Doppeler('(?:[ -]+)'),
    s = {
      '<span style="font-variant: small-caps;">': '</span>',
      '<span class="nocase">': '</span>',
      '<span class="nodecor">': '</span>',
      '<sc>': '</sc>',
      '<sub>': '</sub>',
      '<sup>': '</sup>',
    }
  function a(b) {
    var S = b.match(
      /(^\s*)((?:[\0-\t\x0B\f\x0E-\u2027\u202A-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF][\uDC00-\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]))(.*)/
    )
    return S && !(S[2].match(/^[\u0370-\u03FF]$/) && !S[3])
      ? S[1] + l.toLocaleUpperCase.call(this, S[2]) + S[3]
      : b
  }
  function o(b, S) {
    if (!S) return ''
    b.doppel = t.split(S)
    var g = {
      ' "': { opener: " '", closer: '"' },
      " '": { opener: ' "', closer: "'" },
      '': { opener: '', closer: '' },
      '': { opener: '', closer: '' },
    }
    function _(j, R) {
      if (b.quoteState.length === 0 || j === b.quoteState[b.quoteState.length - 1].opener)
        return b.quoteState.push({ opener: g[j].opener, closer: g[j].closer, pos: R }), !1
      var $ = b.quoteState[b.quoteState.length - 1].pos
      return (
        b.quoteState.pop(),
        b.quoteState.push({ opener: g[j].opener, closer: g[j].closer, positions: R }),
        $
      )
    }
    function y(j, R) {
      if (b.quoteState.length > 0 && j === b.quoteState[b.quoteState.length - 1].closer)
        b.quoteState.pop()
      else return R
    }
    function x(j, R) {
      var $ = ['', '', ' "', " '"].indexOf(j) > -1
      return $ ? _(j, R) : y(j, R)
    }
    function D(j, R) {
      var $ = j.match(/(^(?:\u2018|\u2019|\u201C|\u201D|\"|\')|(?: \"| \')$)/)
      if ($) return x($[1], R)
    }
    b.doppel.strings.length &&
      b.doppel.strings[0].trim() &&
      (b.doppel.strings[0] = b.capitaliseWords(b.doppel.strings[0], 0, b.doppel.tags[0]))
    for (var C = 0, H = b.doppel.tags.length; C < H; C++) {
      var T = b.doppel.tags[C],
        k = b.doppel.strings[C + 1]
      if (
        (b.tagState !== null &&
          (s[T]
            ? b.tagState.push(s[T])
            : b.tagState.length && T === b.tagState[b.tagState.length - 1] && b.tagState.pop()),
        b.afterPunct !== null && T.match(/[\!\?\:]$/) && (b.afterPunct = !0),
        b.tagState.length === 0
          ? (b.doppel.strings[C + 1] = b.capitaliseWords(k, C + 1, b.doppel, b.doppel.tags[C + 1]))
          : b.doppel.strings[C + 1].trim() && (b.lastWordPos = null),
        b.quoteState !== null)
      ) {
        var O = D(T, C)
        if (O || O === 0) {
          var N = b.doppel.origStrings[O + 1].slice(0, 1)
          ;(b.doppel.strings[O + 1] = N + b.doppel.strings[O + 1].slice(1)), (b.lastWordPos = null)
        }
      }
      b.isFirst && k.trim() && (b.isFirst = !1), b.afterPunct && k.trim() && (b.afterPunct = !1)
    }
    if (b.quoteState)
      for (var C = 0, H = b.quoteState.length; C < H; C++) {
        var O = b.quoteState[C].pos
        if (typeof O < 'u') {
          var N = b.doppel.origStrings[O + 1].slice(0, 1)
          b.doppel.strings[O + 1] = N + b.doppel.strings[O + 1].slice(1)
        }
      }
    if (b.lastWordPos) {
      var M = n.split(b.doppel.strings[b.lastWordPos.strings]),
        V = M.strings[b.lastWordPos.words]
      V.length > 1 &&
        l.toLocaleLowerCase.call(this, V).match(b.skipWordsRex) &&
        ((V = a.call(this, V)), (M.strings[b.lastWordPos.words] = V)),
        (b.doppel.strings[b.lastWordPos.strings] = n.join(M))
    }
    return t.join(b.doppel)
  }
  function u(b, S) {
    return S
  }
  function c(b, S) {
    var g = {
      quoteState: null,
      capitaliseWords: function (_) {
        for (var y = _.split(' '), x = 0, D = y.length; x < D; x++) {
          var C = y[x]
          C && (y[x] = l.toLocaleLowerCase.call(b, C))
        }
        return y.join(' ')
      },
      skipWordsRex: null,
      tagState: [],
      afterPunct: null,
      isFirst: null,
    }
    return o.call(b, g, S)
  }
  function f(b, S) {
    var g = {
      quoteState: null,
      capitaliseWords: function (_) {
        for (var y = _.split(' '), x = 0, D = y.length; x < D; x++) {
          var C = y[x]
          C && (y[x] = l.toLocaleUpperCase.call(b, C))
        }
        return y.join(' ')
      },
      skipWordsRex: null,
      tagState: [],
      afterPunct: null,
      isFirst: null,
    }
    return o.call(b, g, S)
  }
  function h(b, S) {
    var g = {
      quoteState: [],
      capitaliseWords: function (_) {
        for (var y = _.split(' '), x = 0, D = y.length; x < D; x++) {
          var C = y[x]
          C &&
            (g.isFirst
              ? ((y[x] = a.call(b, C)), (g.isFirst = !1))
              : (y[x] = l.toLocaleLowerCase.call(b, C)))
        }
        return y.join(' ')
      },
      skipWordsRex: null,
      tagState: [],
      afterPunct: null,
      isFirst: !0,
    }
    return o.call(b, g, S)
  }
  function p(b, S) {
    var g = {
      quoteState: [],
      capitaliseWords: function (_, y, x) {
        if (_.trim()) {
          for (var D = n.split(_), C = D.strings, H = 0, T = C.length; H < T; H++) {
            var k = C[H]
            if (!k) continue
            let O = l.toLocaleLowerCase.call(b, k),
              N = !1
            ;((k.length > 1 && !O.match(g.skipWordsRex)) ||
              (H === C.length - 1 && x === '-') ||
              g.isFirst ||
              g.afterPunct) &&
              (N = !0),
              N && k === O && (C[H] = a.call(b, k)),
              (g.afterPunct = !1),
              (g.isFirst = !1),
              (g.lastWordPos = { strings: y, words: H })
          }
          _ = n.join(D)
        }
        return _
      },
      skipWordsRex: b.locale[b.opt.lang].opts['skip-words-regexp'],
      tagState: [],
      afterPunct: !1,
      isFirst: !0,
    }
    return o.call(b, g, S)
  }
  function m(b, S) {
    var g = {
      quoteState: [],
      capitaliseWords: function (_) {
        for (var y = n.split(_), x = y.strings, D = 0, C = x.length; D < C; D++) {
          var H = x[D]
          if (H && g.isFirst) {
            H === l.toLocaleLowerCase.call(b, H) && (x[D] = a.call(b, H)), (g.isFirst = !1)
            break
          }
        }
        return n.join(y)
      },
      skipWordsRex: null,
      tagState: [],
      afterPunct: null,
      isFirst: !0,
    }
    return o.call(b, g, S)
  }
  function v(b, S) {
    var g = {
      quoteState: [],
      capitaliseWords: function (_) {
        for (var y = n.split(_), x = y.strings, D = 0, C = x.length; D < C; D++) {
          var H = x[D]
          H && H === l.toLocaleLowerCase.call(b, H) && (x[D] = a.call(b, H))
        }
        return n.join(y)
      },
      skipWordsRex: null,
      tagState: [],
      afterPunct: null,
      isFirst: null,
    }
    return o.call(b, g, S)
  }
  return {
    nameDoppel: i,
    passthrough: u,
    lowercase: c,
    uppercase: f,
    sentence: h,
    title: p,
    'capitalize-first': m,
    'capitalize-all': v,
  }
})()
l.Output.Formats = function () {}
l.Output.Formats.prototype.html = {
  text_escape: function (e) {
    return (
      e || (e = ''),
      e
        .replace(/&/g, '&#38;')
        .replace(/</g, '&#60;')
        .replace(/>/g, '&#62;')
        .replace(/\s\s/g, ' ')
        .replace(l.SUPERSCRIPTS_REGEXP, function (t) {
          return '<sup>' + l.SUPERSCRIPTS[t] + '</sup>'
        })
    )
  },
  bibstart: `<div class="csl-bib-body">
`,
  bibend: '</div>',
  '@font-style/italic': '<i>%%STRING%%</i>',
  '@font-style/oblique': '<em>%%STRING%%</em>',
  '@font-style/normal': '<span style="font-style:normal;">%%STRING%%</span>',
  '@font-variant/small-caps': '<span style="font-variant:small-caps;">%%STRING%%</span>',
  '@passthrough/true': l.Output.Formatters.passthrough,
  '@font-variant/normal': '<span style="font-variant:normal;">%%STRING%%</span>',
  '@font-weight/bold': '<b>%%STRING%%</b>',
  '@font-weight/normal': '<span style="font-weight:normal;">%%STRING%%</span>',
  '@font-weight/light': !1,
  '@text-decoration/none': '<span style="text-decoration:none;">%%STRING%%</span>',
  '@text-decoration/underline': '<span style="text-decoration:underline;">%%STRING%%</span>',
  '@vertical-align/sup': '<sup>%%STRING%%</sup>',
  '@vertical-align/sub': '<sub>%%STRING%%</sub>',
  '@vertical-align/baseline': '<span style="baseline">%%STRING%%</span>',
  '@strip-periods/true': l.Output.Formatters.passthrough,
  '@strip-periods/false': l.Output.Formatters.passthrough,
  '@quotes/true': function (e, t) {
    return typeof t > 'u'
      ? e.getTerm('open-quote')
      : e.getTerm('open-quote') + t + e.getTerm('close-quote')
  },
  '@quotes/inner': function (e, t) {
    return typeof t > 'u' ? '' : e.getTerm('open-inner-quote') + t + e.getTerm('close-inner-quote')
  },
  '@quotes/false': !1,
  '@cite/entry': function (e, t) {
    return e.sys.wrapCitationEntry(t, this.item_id, this.locator_txt, this.suffix_txt)
  },
  '@bibliography/entry': function (e, t) {
    var r = ''
    return (
      e.sys.embedBibliographyEntry &&
        (r =
          e.sys.embedBibliographyEntry(this.item_id) +
          `
`),
      '  <div class="csl-entry">' +
        t +
        `</div>
` +
        r
    )
  },
  '@display/block': function (e, t) {
    return (
      `

    <div class="csl-block">` +
      t +
      `</div>
`
    )
  },
  '@display/left-margin': function (e, t) {
    return (
      `
    <div class="csl-left-margin">` +
      t +
      '</div>'
    )
  },
  '@display/right-inline': function (e, t) {
    return (
      '<div class="csl-right-inline">' +
      t +
      `</div>
  `
    )
  },
  '@display/indent': function (e, t) {
    return (
      '<div class="csl-indent">' +
      t +
      `</div>
  `
    )
  },
  '@showid/true': function (e, t, r) {
    if (!e.tmp.just_looking && !e.tmp.suppress_decorations) {
      if (r) return '<span class="' + e.opt.nodenames[r] + '" cslid="' + r + '">' + t + '</span>'
      if (this.params && typeof t == 'string') {
        var i = ''
        if (t) {
          var n = t.match(l.VARIABLE_WRAPPER_PREPUNCT_REX)
          ;(i = n[1]), (t = n[2])
        }
        var s = ''
        return (
          t &&
            l.SWAPPING_PUNCTUATION.indexOf(t.slice(-1)) > -1 &&
            ((s = t.slice(-1)), (t = t.slice(0, -1))),
          e.sys.variableWrapper(this.params, i, t, s)
        )
      } else return t
    } else return t
  },
  '@URL/true': function (e, t) {
    return '<a href="' + t + '">' + t + '</a>'
  },
  '@DOI/true': function (e, t) {
    var r = t
    return (
      t.match(/^https?:\/\//) || (r = 'https://doi.org/' + t), '<a href="' + r + '">' + t + '</a>'
    )
  },
}
l.Output.Formats.prototype.text = {
  text_escape: function (e) {
    return e || (e = ''), e
  },
  bibstart: '',
  bibend: '',
  '@font-style/italic': !1,
  '@font-style/oblique': !1,
  '@font-style/normal': !1,
  '@font-variant/small-caps': !1,
  '@passthrough/true': l.Output.Formatters.passthrough,
  '@font-variant/normal': !1,
  '@font-weight/bold': !1,
  '@font-weight/normal': !1,
  '@font-weight/light': !1,
  '@text-decoration/none': !1,
  '@text-decoration/underline': !1,
  '@vertical-align/baseline': !1,
  '@vertical-align/sup': !1,
  '@vertical-align/sub': !1,
  '@strip-periods/true': l.Output.Formatters.passthrough,
  '@strip-periods/false': l.Output.Formatters.passthrough,
  '@quotes/true': function (e, t) {
    return typeof t > 'u'
      ? e.getTerm('open-quote')
      : e.getTerm('open-quote') + t + e.getTerm('close-quote')
  },
  '@quotes/inner': function (e, t) {
    return typeof t > 'u' ? '' : e.getTerm('open-inner-quote') + t + e.getTerm('close-inner-quote')
  },
  '@quotes/false': !1,
  '@cite/entry': function (e, t) {
    return e.sys.wrapCitationEntry(t, this.item_id, this.locator_txt, this.suffix_txt)
  },
  '@bibliography/entry': function (e, t) {
    return (
      t +
      `
`
    )
  },
  '@display/block': function (e, t) {
    return (
      `
` + t
    )
  },
  '@display/left-margin': function (e, t) {
    return t + ' '
  },
  '@display/right-inline': function (e, t) {
    return t
  },
  '@display/indent': function (e, t) {
    return (
      `
    ` + t
    )
  },
  '@showid/true': function (e, t) {
    return t
  },
  '@URL/true': function (e, t) {
    return t
  },
  '@DOI/true': function (e, t) {
    return t
  },
}
l.Output.Formats.prototype.rtf = {
  text_escape: function (e) {
    return (
      e || (e = ''),
      e
        .replace(/([\\{}])/g, '\\$1')
        .replace(l.SUPERSCRIPTS_REGEXP, function (t) {
          return '\\super ' + l.SUPERSCRIPTS[t] + '\\nosupersub{}'
        })
        .replace(/[\u007F-\uFFFF]/g, function (t) {
          return '\\uc0\\u' + t.charCodeAt(0).toString() + '{}'
        })
        .split('	')
        .join('\\tab{}')
    )
  },
  '@passthrough/true': l.Output.Formatters.passthrough,
  '@font-style/italic': '{\\i{}%%STRING%%}',
  '@font-style/normal': '{\\i0{}%%STRING%%}',
  '@font-style/oblique': '{\\i{}%%STRING%%}',
  '@font-variant/small-caps': '{\\scaps %%STRING%%}',
  '@font-variant/normal': '{\\scaps0{}%%STRING%%}',
  '@font-weight/bold': '{\\b{}%%STRING%%}',
  '@font-weight/normal': '{\\b0{}%%STRING%%}',
  '@font-weight/light': !1,
  '@text-decoration/none': !1,
  '@text-decoration/underline': '{\\ul{}%%STRING%%}',
  '@vertical-align/baseline': !1,
  '@vertical-align/sup': '\\super %%STRING%%\\nosupersub{}',
  '@vertical-align/sub': '\\sub %%STRING%%\\nosupersub{}',
  '@strip-periods/true': l.Output.Formatters.passthrough,
  '@strip-periods/false': l.Output.Formatters.passthrough,
  '@quotes/true': function (e, t) {
    return typeof t > 'u'
      ? l.Output.Formats.rtf.text_escape(e.getTerm('open-quote'))
      : l.Output.Formats.rtf.text_escape(e.getTerm('open-quote')) +
          t +
          l.Output.Formats.rtf.text_escape(e.getTerm('close-quote'))
  },
  '@quotes/inner': function (e, t) {
    return typeof t > 'u'
      ? l.Output.Formats.rtf.text_escape('')
      : l.Output.Formats.rtf.text_escape(e.getTerm('open-inner-quote')) +
          t +
          l.Output.Formats.rtf.text_escape(e.getTerm('close-inner-quote'))
  },
  '@quotes/false': !1,
  bibstart: '{\\rtf ',
  bibend: '}',
  '@display/block': `\\line{}%%STRING%%\\line\r
`,
  '@cite/entry': function (e, t) {
    return e.sys.wrapCitationEntry(t, this.item_id, this.locator_txt, this.suffix_txt)
  },
  '@bibliography/entry': function (e, t) {
    return t
  },
  '@display/left-margin': function (e, t) {
    return t + '\\tab '
  },
  '@display/right-inline': function (e, t) {
    return (
      t +
      `\r
`
    )
  },
  '@display/indent': function (e, t) {
    return (
      `
\\tab ` +
      t +
      `\\line\r
`
    )
  },
  '@showid/true': function (e, t) {
    if (!e.tmp.just_looking && !e.tmp.suppress_decorations) {
      var r = ''
      if (t) {
        var i = t.match(l.VARIABLE_WRAPPER_PREPUNCT_REX)
        ;(r = i[1]), (t = i[2])
      }
      var n = ''
      return (
        t &&
          l.SWAPPING_PUNCTUATION.indexOf(t.slice(-1)) > -1 &&
          ((n = t.slice(-1)), (t = t.slice(0, -1))),
        e.sys.variableWrapper(this.params, r, t, n)
      )
    } else return t
  },
  '@URL/true': function (e, t) {
    return t
  },
  '@DOI/true': function (e, t) {
    return t
  },
}
l.Output.Formats.prototype.asciidoc = {
  text_escape: function (e) {
    return (
      e || (e = ''),
      e
        .replace('*', 'pass:[*]', 'g')
        .replace('_', 'pass:[_]', 'g')
        .replace('#', 'pass:[#]', 'g')
        .replace('^', 'pass:[^]', 'g')
        .replace('~', 'pass:[~]', 'g')
        .replace('[[', 'pass:[[[]', 'g')
        .replace('  ', '&#160; ', 'g')
        .replace(l.SUPERSCRIPTS_REGEXP, function (t) {
          return '^' + l.SUPERSCRIPTS[t] + '^'
        })
    )
  },
  bibstart: '',
  bibend: '',
  '@passthrough/true': l.Output.Formatters.passthrough,
  '@font-style/italic': '__%%STRING%%__',
  '@font-style/oblique': '__%%STRING%%__',
  '@font-style/normal': !1,
  '@font-variant/small-caps': '[small-caps]#%%STRING%%#',
  '@font-variant/normal': !1,
  '@font-weight/bold': '**%%STRING%%**',
  '@font-weight/normal': !1,
  '@font-weight/light': !1,
  '@text-decoration/none': !1,
  '@text-decoration/underline': '[underline]##%%STRING%%##',
  '@vertical-align/sup': '^^%%STRING%%^^',
  '@vertical-align/sub': '~~%%STRING%%~~',
  '@vertical-align/baseline': !1,
  '@strip-periods/true': l.Output.Formatters.passthrough,
  '@strip-periods/false': l.Output.Formatters.passthrough,
  '@quotes/true': function (e, t) {
    return typeof t > 'u' ? '``' : '``' + t + "''"
  },
  '@quotes/inner': function (e, t) {
    return typeof t > 'u' ? '`' : '`' + t + "'"
  },
  '@quotes/false': !1,
  '@cite/entry': function (e, t) {
    return e.sys.wrapCitationEntry(t, this.item_id, this.locator_txt, this.suffix_txt)
  },
  '@bibliography/entry': function (e, t) {
    return (
      t +
      `
`
    )
  },
  '@display/block': function (e, t) {
    return t
  },
  '@display/left-margin': function (e, t) {
    return t
  },
  '@display/right-inline': function (e, t) {
    return ' ' + t
  },
  '@display/indent': function (e, t) {
    return ' ' + t
  },
  '@showid/true': function (e, t) {
    if (!e.tmp.just_looking && !e.tmp.suppress_decorations && this.params && typeof t == 'string') {
      var r = ''
      if (t) {
        var i = t.match(l.VARIABLE_WRAPPER_PREPUNCT_REX)
        ;(r = i[1]), (t = i[2])
      }
      var n = ''
      return (
        t &&
          l.SWAPPING_PUNCTUATION.indexOf(t.slice(-1)) > -1 &&
          ((n = t.slice(-1)), (t = t.slice(0, -1))),
        e.sys.variableWrapper(this.params, r, t, n)
      )
    } else return t
  },
  '@URL/true': function (e, t) {
    return t
  },
  '@DOI/true': function (e, t) {
    var r = t
    return t.match(/^https?:\/\//) || (r = 'https://doi.org/' + t), r + '[' + t + ']'
  },
}
l.Output.Formats.prototype.fo = {
  text_escape: function (e) {
    return (
      e || (e = ''),
      e
        .replace(/&/g, '&#38;')
        .replace(/</g, '&#60;')
        .replace(/>/g, '&#62;')
        .replace('  ', '&#160; ', 'g')
        .replace(l.SUPERSCRIPTS_REGEXP, function (t) {
          return '<fo:inline vertical-align="super">' + l.SUPERSCRIPTS[t] + '</fo:inline>'
        })
    )
  },
  bibstart: '',
  bibend: '',
  '@passthrough/true': l.Output.Formatters.passthrough,
  '@font-style/italic': '<fo:inline font-style="italic">%%STRING%%</fo:inline>',
  '@font-style/oblique': '<fo:inline font-style="oblique">%%STRING%%</fo:inline>',
  '@font-style/normal': '<fo:inline font-style="normal">%%STRING%%</fo:inline>',
  '@font-variant/small-caps': '<fo:inline font-variant="small-caps">%%STRING%%</fo:inline>',
  '@font-variant/normal': '<fo:inline font-variant="normal">%%STRING%%</fo:inline>',
  '@font-weight/bold': '<fo:inline font-weight="bold">%%STRING%%</fo:inline>',
  '@font-weight/normal': '<fo:inline font-weight="normal">%%STRING%%</fo:inline>',
  '@font-weight/light': '<fo:inline font-weight="lighter">%%STRING%%</fo:inline>',
  '@text-decoration/none': '<fo:inline text-decoration="none">%%STRING%%</fo:inline>',
  '@text-decoration/underline': '<fo:inline text-decoration="underline">%%STRING%%</fo:inline>',
  '@vertical-align/sup': '<fo:inline vertical-align="super">%%STRING%%</fo:inline>',
  '@vertical-align/sub': '<fo:inline vertical-align="sub">%%STRING%%</fo:inline>',
  '@vertical-align/baseline': '<fo:inline vertical-align="baseline">%%STRING%%</fo:inline>',
  '@strip-periods/true': l.Output.Formatters.passthrough,
  '@strip-periods/false': l.Output.Formatters.passthrough,
  '@quotes/true': function (e, t) {
    return typeof t > 'u'
      ? e.getTerm('open-quote')
      : e.getTerm('open-quote') + t + e.getTerm('close-quote')
  },
  '@quotes/inner': function (e, t) {
    return typeof t > 'u' ? '' : e.getTerm('open-inner-quote') + t + e.getTerm('close-inner-quote')
  },
  '@quotes/false': !1,
  '@cite/entry': function (e, t) {
    return e.sys.wrapCitationEntry(t, this.item_id, this.locator_txt, this.suffix_txt)
  },
  '@bibliography/entry': function (e, t) {
    var r = ''
    if (e.bibliography && e.bibliography.opt && e.bibliography.opt.hangingindent) {
      var i = e.bibliography.opt.hangingindent
      r = ' start-indent="' + i + 'em" text-indent="-' + i + 'em"'
    }
    var n = ''
    return (
      e.sys.embedBibliographyEntry &&
        (n =
          e.sys.embedBibliographyEntry(this.item_id) +
          `
`),
      '<fo:block id="' +
        this.system_id +
        '"' +
        r +
        '>' +
        t +
        `</fo:block>
` +
        n
    )
  },
  '@display/block': function (e, t) {
    return (
      `
  <fo:block>` +
      t +
      `</fo:block>
`
    )
  },
  '@display/left-margin': function (e, t) {
    return (
      `
  <fo:table table-layout="fixed" width="100%">
    <fo:table-column column-number="1" column-width="$$$__COLUMN_WIDTH_1__$$$"/>
    <fo:table-column column-number="2" column-width="proportional-column-width(1)"/>
    <fo:table-body>
      <fo:table-row>
        <fo:table-cell>
          <fo:block>` +
      t +
      `</fo:block>
        </fo:table-cell>
        `
    )
  },
  '@display/right-inline': function (e, t) {
    return (
      `<fo:table-cell>
          <fo:block>` +
      t +
      `</fo:block>
        </fo:table-cell>
      </fo:table-row>
    </fo:table-body>
  </fo:table>
`
    )
  },
  '@display/indent': function (e, t) {
    return (
      '<fo:block margin-left="2em">' +
      t +
      `</fo:block>
`
    )
  },
  '@showid/true': function (e, t) {
    if (!e.tmp.just_looking && !e.tmp.suppress_decorations && this.params && typeof t == 'string') {
      var r = ''
      if (t) {
        var i = t.match(l.VARIABLE_WRAPPER_PREPUNCT_REX)
        ;(r = i[1]), (t = i[2])
      }
      var n = ''
      return (
        t &&
          l.SWAPPING_PUNCTUATION.indexOf(t.slice(-1)) > -1 &&
          ((n = t.slice(-1)), (t = t.slice(0, -1))),
        e.sys.variableWrapper(this.params, r, t, n)
      )
    } else return t
  },
  '@URL/true': function (e, t) {
    return `<fo:basic-link external-destination="url('` + t + `')">` + t + '</fo:basic-link>'
  },
  '@DOI/true': function (e, t) {
    var r = t
    return (
      t.match(/^https?:\/\//) || (r = 'https://doi.org/' + t),
      `<fo:basic-link external-destination="url('` + r + `')">` + t + '</fo:basic-link>'
    )
  },
}
l.Output.Formats.prototype.latex = {
  text_escape: function (e) {
    return e || (e = ''), e
  },
  bibstart: '\\begin{thebibliography}{4}',
  bibend: '\\end{thebibliography}',
  '@font-style/italic': '{\\em %%STRING%%}',
  '@font-style/oblique': !1,
  '@font-style/normal': !1,
  '@font-variant/small-caps': !1,
  '@passthrough/true': l.Output.Formatters.passthrough,
  '@font-variant/normal': !1,
  '@font-weight/bold': '{\\bf %%STRING%%}',
  '@font-weight/normal': !1,
  '@font-weight/light': !1,
  '@text-decoration/none': !1,
  '@text-decoration/underline': !1,
  '@vertical-align/baseline': !1,
  '@vertical-align/sup': !1,
  '@vertical-align/sub': !1,
  '@strip-periods/true': l.Output.Formatters.passthrough,
  '@strip-periods/false': l.Output.Formatters.passthrough,
  '@quotes/true': function (e, t) {
    return typeof t > 'u'
      ? e.getTerm('open-quote')
      : e.getTerm('open-quote') + t + e.getTerm('close-quote')
  },
  '@quotes/inner': function (e, t) {
    return typeof t > 'u' ? '' : e.getTerm('open-inner-quote') + t + e.getTerm('close-inner-quote')
  },
  '@quotes/false': !1,
  '@cite/entry': function (e, t) {
    return e.sys.wrapCitationEntry(t, this.item_id, this.locator_txt, this.suffix_txt)
  },
  '@bibliography/entry': function (e, t) {
    return (
      '\\bibitem{' +
      e.sys.embedBibliographyEntry(this.item_id) +
      `}
`
    )
  },
  '@display/block': function (e, t) {
    return (
      `
` + t
    )
  },
  '@display/left-margin': function (e, t) {
    return t
  },
  '@display/right-inline': function (e, t) {
    return t
  },
  '@display/indent': function (e, t) {
    return (
      `
    ` + t
    )
  },
  '@showid/true': function (e, t, r) {
    return t
  },
  '@URL/true': function (e, t) {
    return t
  },
  '@DOI/true': function (e, t) {
    return t
  },
}
l.Output.Formats = new l.Output.Formats()
l.Registry = function (e) {
  ;(this.debug = !1),
    (this.state = e),
    (this.registry = {}),
    (this.reflist = []),
    (this.refhash = {}),
    (this.namereg = new l.Registry.NameReg(e)),
    (this.citationreg = new l.Registry.CitationReg(e)),
    (this.authorstrings = {}),
    (this.masterMap = {}),
    (this.mylist = []),
    (this.myhash = {}),
    (this.deletes = []),
    (this.inserts = []),
    (this.uncited = {}),
    (this.refreshes = {}),
    (this.akeys = {}),
    (this.oldseq = {}),
    (this.return_data = {}),
    (this.ambigcites = {}),
    (this.ambigresets = {}),
    (this.sorter = new l.Registry.Comparifier(e, 'bibliography_sort')),
    (this.getSortedIds = function () {
      for (var t = [], r = 0, i = this.reflist.length; r < i; r += 1)
        t.push('' + this.reflist[r].id)
      return t
    }),
    (this.getSortedRegistryItems = function () {
      for (var t = [], r = 0, i = this.reflist.length; r < i; r += 1) t.push(this.reflist[r])
      return t
    })
}
l.Registry.prototype.init = function (e, t) {
  var r, i
  if (((this.oldseq = {}), t)) {
    this.uncited = {}
    for (var r = 0, i = e.length; r < i; r += 1)
      this.myhash[e[r]] || this.mylist.push('' + e[r]),
        (this.uncited[e[r]] = !0),
        (this.myhash[e[r]] = !0)
  } else {
    for (var n in this.uncited) e.push(n)
    var s = {}
    for (r = e.length - 1; r > -1; r += -1)
      s[e[r]] ? (e = e.slice(0, r).concat(e.slice(r + 1))) : (s[e[r]] = !0)
    ;(this.mylist = e), (this.myhash = s)
  }
  ;(this.refreshes = {}), (this.touched = {}), (this.ambigsTouched = {}), (this.ambigresets = {})
}
l.Registry.prototype.dopurge = function (e) {
  for (var t = this.mylist.length - 1; t > -1; t += -1)
    this.citationreg.citationsByItemId &&
      (!this.citationreg.citationsByItemId ||
        !this.citationreg.citationsByItemId[this.mylist[t]]) &&
      !e[this.mylist[t]] &&
      (delete this.myhash[this.mylist[t]],
      delete this.uncited[this.mylist[t]],
      (this.mylist = this.mylist.slice(0, t).concat(this.mylist.slice(t + 1))))
  this.dodeletes(this.myhash)
}
l.Registry.prototype.dodeletes = function (e) {
  var t, r, i, n, s, a, o, u, c
  if (typeof e == 'string') {
    var r = e
    ;(e = {}), (e[r] = !0)
  }
  for (var r in this.registry)
    if (!e[r]) {
      if (this.uncited[r]) continue
      t = this.namereg.delitems(r)
      for (o in t) this.refreshes[o] = !0
      for (
        i = this.registry[r].ambig,
          u = this.ambigcites[i].indexOf(r),
          u > -1 &&
            ((a = this.ambigcites[i].slice()),
            (this.ambigcites[i] = a.slice(0, u).concat(a.slice(u + 1, a.length))),
            (this.ambigresets[i] = this.ambigcites[i].length)),
          s = this.ambigcites[i].length,
          n = 0;
        n < s;
        n += 1
      )
        (c = '' + this.ambigcites[i][n]), (this.refreshes[c] = !0)
      if (this.registry[r].siblings) {
        if (this.registry[r].siblings.length == 1) {
          var f = this.registry[r].siblings[0]
          this.registry[f].siblings &&
            (this.registry[f].siblings.pop(), (this.registry[f].master = !0))
        } else if (this.registry[r].siblings.length > 1) {
          var h = [r]
          if (this.registry[r].master) {
            var p = this.registry[r].siblings[0],
              m = this.registry[p]
            ;(m.master = !0), h.push(p)
          }
          for (var v = [], b = this.registry[r].siblings.length - 1; b > -1; b += -1) {
            var S = this.registry[r].siblings.pop()
            h.indexOf(S) === -1 && v.push(S)
          }
          for (var b = v.length - 1; b > -1; b += -1) this.registry[r].siblings.push(v[b])
        }
      }
      for (var g = this.reflist.length - 1; g > -1; g--)
        this.reflist[g].id === r &&
          (this.reflist = this.reflist.slice(0, g).concat(this.reflist.slice(g + 1)))
      delete this.registry[r], delete this.refhash[r], (this.return_data.bibchange = !0)
    }
}
l.Registry.prototype.doinserts = function (e) {
  var t, r, i, n, s, a, o
  typeof e == 'string' && (e = [e])
  for (var a = 0, o = e.length; a < o; a += 1)
    (t = e[a]),
      this.registry[t] ||
        ((r = this.state.retrieveItem(t)),
        (i = l.getAmbiguousCite.call(this.state, r)),
        (this.ambigsTouched[i] = !0),
        r.legislation_id || (this.akeys[i] = !0),
        (n = {
          id: '' + t,
          seq: 0,
          offset: 0,
          sortkeys: !1,
          ambig: !1,
          rendered: !1,
          disambig: !1,
          ref: r,
          newItem: !0,
        }),
        (this.registry[t] = n),
        this.citationreg.citationsByItemId &&
          this.citationreg.citationsByItemId[t] &&
          (this.registry[t]['first-reference-note-number'] =
            this.citationreg.citationsByItemId[t][0].properties.noteIndex),
        (s = l.getAmbigConfig.call(this.state)),
        this.registerAmbigToken(i, t, s),
        (this.touched[t] = !0),
        (this.return_data.bibchange = !0))
}
l.Registry.prototype.rebuildlist = function (e) {
  var t, r, i, n
  if (e)
    for (this.reflist = [], t = this.mylist.length, r = 0; r < t; r += 1)
      (i = this.mylist[r]),
        (n = this.registry[i]),
        this.reflist.push(n),
        (this.oldseq[i] = this.registry[i].seq),
        (this.registry[i].seq = r + 1)
  else
    for (this.reflist_inserts = [], t = this.mylist.length, r = 0; r < t; r += 1)
      (i = this.mylist[r]),
        (n = this.registry[i]),
        n.newItem && this.reflist_inserts.push(n),
        (this.oldseq[i] = this.registry[i].seq),
        (this.registry[i].seq = r + 1)
}
l.Registry.prototype.dorefreshes = function () {
  var e, t, r, i, n
  for (var e in this.refreshes)
    if (((t = this.registry[e]), !!t)) {
      ;(t.sortkeys = void 0), (r = this.state.refetchItem(e))
      var i = t.ambig
      typeof i > 'u' &&
        ((this.state.tmp.disambig_settings = !1),
        (i = l.getAmbiguousCite.call(this.state, r)),
        (n = l.getAmbigConfig.call(this.state)),
        this.registerAmbigToken(i, e, n))
      for (var s in this.ambigresets)
        if (this.ambigresets[s] === 1) {
          var a = this.ambigcites[i][0],
            r = this.state.refetchItem(a)
          ;(this.registry[a].disambig = new l.AmbigConfig()),
            (this.state.tmp.disambig_settings = !1)
          var i = l.getAmbiguousCite.call(this.state, r),
            n = l.getAmbigConfig.call(this.state)
          this.registerAmbigToken(i, a, n)
        }
      ;(this.state.tmp.taintedItemIDs[e] = !0),
        (this.ambigsTouched[i] = !0),
        r.legislation_id || (this.akeys[i] = !0),
        (this.touched[e] = !0)
    }
}
l.Registry.prototype.setdisambigs = function () {
  for (var e in this.ambigsTouched) this.state.disambiguate.run(e)
  ;(this.ambigsTouched = {}), (this.akeys = {})
}
l.Registry.prototype.renumber = function () {
  var e, t, r
  for (
    this.state.bibliography_sort.opt.citation_number_sort_direction === l.DESCENDING &&
      (this.state.bibliography_sort.tmp.citation_number_map = {}),
      e = this.reflist.length,
      t = 0;
    t < e;
    t += 1
  )
    (r = this.reflist[t]),
      (r.seq = t + 1),
      this.state.bibliography_sort.opt.citation_number_sort_direction === l.DESCENDING &&
        (this.state.bibliography_sort.tmp.citation_number_map[r.seq] =
          this.reflist.length - r.seq + 1),
      this.state.opt.update_mode === l.NUMERIC &&
        r.seq != this.oldseq[r.id] &&
        (this.state.tmp.taintedItemIDs[r.id] = !0),
      r.seq != this.oldseq[r.id] && (this.return_data.bibchange = !0)
}
l.Registry.prototype.setsortkeys = function () {
  for (var e, t = 0, r = this.mylist.length; t < r; t += 1) {
    var e = this.mylist[t]
    ;(this.touched[e] || this.state.tmp.taintedItemIDs[e] || !this.registry[e].sortkeys) &&
      (this.registry[e].sortkeys = l.getSortKeys.call(
        this.state,
        this.state.retrieveItem(e),
        'bibliography_sort'
      ))
  }
}
l.Registry.prototype._insertItem = function (e, t) {
  return t.splice(this._locationOf(e, t) + 1, 0, e), t
}
l.Registry.prototype._locationOf = function (e, t, r, i) {
  if (t.length === 0) return -1
  ;(r = r || 0), (i = i || t.length)
  var n = (r + i) >> 1,
    s = this.sorter.compareKeys(e, t[n])
  if (i - r <= 1) return s == -1 ? n - 1 : n
  switch (s) {
    case -1:
      return this._locationOf(e, t, r, n)
    case 0:
      return n
    case 1:
      return this._locationOf(e, t, n, i)
  }
}
l.Registry.prototype.sorttokens = function (e) {
  var t, r, i, n
  if (!e) {
    for (this.reflist_inserts = [], t = this.mylist.length, n = 0; n < t; n += 1)
      (r = this.mylist[n]), (i = this.registry[r]), i.newItem && this.reflist_inserts.push(i)
    for (var s in this.state.tmp.taintedItemIDs)
      if (this.registry[s] && !this.registry[s].newItem)
        for (var a = this.reflist.length - 1; a > -1; a--)
          this.reflist[a].id === s &&
            (this.reflist_inserts.push(this.reflist[a]),
            (this.reflist = this.reflist.slice(0, a).concat(this.reflist.slice(a + 1))))
    for (var a = 0, o = this.reflist_inserts.length; a < o; a++) {
      var i = this.reflist_inserts[a]
      delete i.newItem, (this.reflist = this._insertItem(i, this.reflist))
    }
    for (n = 0; n < t; n += 1)
      (r = this.mylist[n]), (i = this.registry[r]), (this.registry[r].seq = n + 1)
  }
}
l.Registry.Comparifier = function (e, t) {
  var r,
    i,
    n,
    s,
    a = l.getSortCompare.call(e, e.opt['default-locale-sort'])
  ;(r = e[t].opt.sort_directions),
    (this.compareKeys = function (o, u) {
      for (i = o.sortkeys ? o.sortkeys.length : 0, n = 0; n < i; n += 1) {
        var c = 0
        if (
          (o.sortkeys[n] === u.sortkeys[n]
            ? (c = 0)
            : typeof o.sortkeys[n] > 'u'
            ? (c = r[n][1])
            : typeof u.sortkeys[n] > 'u'
            ? (c = r[n][0])
            : (c = a(o.sortkeys[n], u.sortkeys[n])),
          0 < c)
        )
          return r[n][1]
        if (0 > c) return r[n][0]
      }
      return o.seq > u.seq ? 1 : o.seq < u.seq ? -1 : 0
    }),
    (s = this.compareKeys),
    (this.compareCompositeKeys = function (o, u) {
      return s(o[1], u[1])
    })
}
l.Registry.prototype.compareRegistryTokens = function (e, t) {
  return e.seq > t.seq ? 1 : e.seq < t.seq ? -1 : 0
}
l.Registry.prototype.registerAmbigToken = function (e, t, r) {
  if (
    (this.registry[t] ||
      l.debug('Warning: unregistered item: itemID=(' + t + '), akey=(' + e + ')'),
    this.registry[t] && this.registry[t].disambig && this.registry[t].disambig.names)
  )
    for (var i = 0, n = r.names.length; i < n; i += 1) {
      var s = r.names[i],
        a = this.registry[t].disambig.names[i]
      if (s !== a) this.state.tmp.taintedItemIDs[t] = !0
      else if (r.givens[i])
        for (var o = 0, u = r.givens[i].length; o < u; o += 1) {
          var c = r.givens[i][o],
            f = this.registry[t].disambig.givens[i][o]
          c !== f && (this.state.tmp.taintedItemIDs[t] = !0)
        }
    }
  this.ambigcites[e] || (this.ambigcites[e] = []),
    this.ambigcites[e].indexOf('' + t) === -1 && this.ambigcites[e].push('' + t),
    (this.registry[t].ambig = e),
    (this.registry[t].disambig = l.cloneAmbigConfig(r))
}
l.getSortKeys = function (e, t) {
  var r, i, n, s, a, o
  for (
    r = this.tmp.area,
      i = this.tmp.root,
      n = this.tmp.extension,
      s = l.Util.Sort.strip_prepositions,
      this.tmp.area = t,
      this.tmp.root = t.indexOf('_') > -1 ? t.slice(0, -5) : t,
      this.tmp.extension = '_sort',
      this.tmp.disambig_override = !0,
      this.tmp.disambig_request = !1,
      this.tmp.suppress_decorations = !0,
      l.getCite.call(this, e),
      this.tmp.suppress_decorations = !1,
      this.tmp.disambig_override = !1,
      a = this[t].keys.length,
      o = 0;
    o < a;
    o += 1
  )
    this[t].keys[o] = s(this[t].keys[o])
  return (this.tmp.area = r), (this.tmp.root = i), (this.tmp.extension = n), this[t].keys
}
l.Registry.NameReg = function (e) {
  var t, r, i, n, s, a, o, u, c, f, h, p
  ;(this.state = e),
    (this.namereg = {}),
    (this.nameind = {}),
    (this.nameindpkeys = {}),
    (this.itemkeyreg = {}),
    (o = function (m) {
      return m || (m = ''), m.replace(/\./g, ' ').replace(/\s+/g, ' ').replace(/\s+$/, '')
    }),
    (u = function (m, v, b) {
      ;(t = o(b.family)),
        m.opt['demote-non-dropping-particle'] === 'never' &&
          b['non-dropping-particle'] &&
          b.family &&
          (t = `${t} ${b['non-dropping-particle']}`),
        (i = o(b.given))
      var S = i.match(/[,\!]* ([^,]+)$/)
      S && S[1] === S[1].toLowerCase() && (i = i.replace(/[,\!]* [^,]+$/, '')),
        (r = l.Util.Names.initializeWith(m, i, '%s')),
        m.citation.opt['givenname-disambiguation-rule'] === 'by-cite' && (t = '' + v + t)
    }),
    (c = function (m, v, b, S, g, _) {
      var y
      if (e.tmp.area.slice(0, 12) === 'bibliography' && !g) return typeof _ == 'string' ? 1 : 2
      var x = e.nameOutput.getName(v, 'locale-translit', !0)
      ;(v = x.name),
        u(this.state, '' + m, v),
        (y = 2),
        (n = e.opt['disambiguate-add-givenname']),
        (s = e.citation.opt['givenname-disambiguation-rule'])
      var D = s
      if (
        (s === 'by-cite' && (s = 'all-names'),
        g === 'short' ? (y = 0) : typeof _ == 'string' && (y = 1),
        typeof this.namereg[t] > 'u' || typeof this.namereg[t].ikey[r] > 'u')
      )
        return y
      if (D === 'by-cite' && y <= S) return S
      if (
        !n ||
        (typeof s == 'string' && s.slice(0, 12) === 'primary-name' && b > 0) ||
        (!s || s === 'all-names' || s === 'primary-name'
          ? (this.namereg[t].count > 1 && (y = 1),
            ((this.namereg[t].ikey && this.namereg[t].ikey[r].count > 1) ||
              (this.namereg[t].count > 1 && typeof _ != 'string')) &&
              (y = 2))
          : (s === 'all-names-with-initials' || s === 'primary-name-with-initials') &&
            (this.namereg[t].count > 1 ? (y = 1) : (y = 0)),
        e.registry.registry[m])
      )
        return y
      if (g == 'short') return 0
      if (typeof _ == 'string') return 1
    }),
    (f = function (m) {
      var v, b, S, g, _
      ;(typeof m == 'string' || typeof m == 'number') && (m = ['' + m])
      var y = {}
      for (b = m.length, v = 0; v < b; v += 1)
        if (((g = '' + m[v]), !!this.nameind[g])) {
          for (_ in this.nameind[g])
            if (this.nameind[g].hasOwnProperty(_)) {
              var x = _.split('::')
              if (((t = x[0]), (r = x[1]), (i = x[2]), typeof this.namereg[t] > 'u')) continue
              if (
                ((a = this.namereg[t].items),
                i &&
                  this.namereg[t].ikey[r] &&
                  this.namereg[t].ikey[r].skey[i] &&
                  ((p = this.namereg[t].ikey[r].skey[i].items),
                  (S = p.indexOf('' + g)),
                  S > -1 &&
                    (this.namereg[t].ikey[r].skey[i].items = p
                      .slice(0, S)
                      .concat(p.slice([S + 1]))),
                  this.namereg[t].ikey[r].skey[i].items.length === 0 &&
                    (delete this.namereg[t].ikey[r].skey[i],
                    (this.namereg[t].ikey[r].count += -1),
                    this.namereg[t].ikey[r].count < 2)))
              )
                for (var D = 0, C = this.namereg[t].ikey[r].items.length; D < C; D += 1)
                  e.tmp.taintedItemIDs[this.namereg[t].ikey[r].items[D]] = !0
              if (
                r &&
                this.namereg[t].ikey[r] &&
                ((S = this.namereg[t].ikey[r].items.indexOf('' + g)),
                S > -1 &&
                  ((a = this.namereg[t].ikey[r].items.slice()),
                  (this.namereg[t].ikey[r].items = a.slice(0, S).concat(a.slice([S + 1])))),
                this.namereg[t].ikey[r].items.length === 0 &&
                  (delete this.namereg[t].ikey[r],
                  (this.namereg[t].count += -1),
                  this.namereg[t].count < 2))
              )
                for (var D = 0, C = this.namereg[t].items.length; D < C; D += 1)
                  e.tmp.taintedItemIDs[this.namereg[t].items[D]] = !0
              t &&
                ((S = this.namereg[t].items.indexOf('' + g)),
                S > -1 &&
                  ((a = this.namereg[t].items.slice()),
                  (this.namereg[t].items = a.slice(0, S).concat(a.slice([S + 1], a.length)))),
                this.namereg[t].items.length < 2 && delete this.namereg[t]),
                delete this.nameind[g][_]
            }
          delete this.nameind[g], delete this.nameindpkeys[g]
        }
      return y
    }),
    (h = function (m, v, b) {
      var S,
        g,
        _ = e.nameOutput.getName(v, 'locale-translit', !0)
      if (
        ((v = _.name),
        !(
          e.citation.opt['givenname-disambiguation-rule'] &&
          e.citation.opt['givenname-disambiguation-rule'].slice(0, 8) === 'primary-' &&
          b !== 0
        ))
      ) {
        if (
          (u(this.state, '' + m, v),
          t &&
            (typeof this.namereg[t] > 'u'
              ? ((this.namereg[t] = {}),
                (this.namereg[t].count = 0),
                (this.namereg[t].ikey = {}),
                (this.namereg[t].items = [m]))
              : this.namereg[t].items.indexOf(m) === -1 && this.namereg[t].items.push(m)),
          t && r)
        )
          if (typeof this.namereg[t].ikey[r] > 'u') {
            if (
              ((this.namereg[t].ikey[r] = {}),
              (this.namereg[t].ikey[r].count = 0),
              (this.namereg[t].ikey[r].skey = {}),
              (this.namereg[t].ikey[r].items = [m]),
              (this.namereg[t].count += 1),
              this.namereg[t].count === 2)
            )
              for (var S = 0, g = this.namereg[t].items.length; S < g; S += 1)
                e.tmp.taintedItemIDs[this.namereg[t].items[S]] = !0
          } else
            this.namereg[t].ikey[r].items.indexOf(m) === -1 && this.namereg[t].ikey[r].items.push(m)
        if (t && r && i)
          if (typeof this.namereg[t].ikey[r].skey[i] > 'u') {
            if (
              ((this.namereg[t].ikey[r].skey[i] = {}),
              (this.namereg[t].ikey[r].skey[i].items = [m]),
              (this.namereg[t].ikey[r].count += 1),
              this.namereg[t].ikey[r].count === 2)
            )
              for (var S = 0, g = this.namereg[t].ikey[r].items.length; S < g; S += 1)
                e.tmp.taintedItemIDs[this.namereg[t].ikey[r].items[S]] = !0
          } else
            this.namereg[t].ikey[r].skey[i].items.indexOf(m) === -1 &&
              this.namereg[t].ikey[r].skey[i].items.push(m)
        typeof this.nameind[m] > 'u' && ((this.nameind[m] = {}), (this.nameindpkeys[m] = {})),
          t &&
            ((this.nameind[m][t + '::' + r + '::' + i] = !0),
            (this.nameindpkeys[m][t] = this.namereg[t]))
      }
    }),
    (this.addname = h),
    (this.delitems = f),
    (this.evalname = c)
}
l.Registry.CitationReg = function () {
  ;(this.citationById = {}), (this.citationByIndex = [])
}
l.Disambiguation = function (e) {
  ;(this.state = e),
    (this.sys = this.state.sys),
    (this.registry = e.registry.registry),
    (this.ambigcites = e.registry.ambigcites),
    this.configModes(),
    (this.debug = !1)
}
l.Disambiguation.prototype.run = function (e) {
  this.modes.length &&
    (this.debug && this.state.sys.print('[A] === RUN ==='),
    (this.akey = e),
    this.initVars(e) && this.runDisambig())
}
l.Disambiguation.prototype.runDisambig = function () {
  var e
  for (
    this.debug && this.state.sys.print('[C] === runDisambig() ==='), this.initGivens = !0;
    this.lists.length;

  ) {
    for (this.gnameset = 0, this.gname = 0, this.clashes = [1, 0]; this.lists[0][1].length; )
      (this.listpos = 0),
        this.base || (this.base = this.lists[0][0]),
        (e = this.incrementDisambig()),
        this.scanItems(this.lists[0]),
        this.evalScan(e)
    this.lists = this.lists.slice(1)
  }
}
l.Disambiguation.prototype.scanItems = function (e) {
  var t, r, i
  this.debug && this.state.sys.print('[2] === scanItems() ==='),
    (this.Item = e[1][0]),
    (this.ItemCite = l.getAmbiguousCite.call(this.state, this.Item, this.base, !0)),
    (this.scanlist = e[1]),
    (this.partners = []),
    this.partners.push(this.Item),
    (this.nonpartners = [])
  for (var n = 0, t = 1, r = e[1].length; t < r; t += 1) {
    i = e[1][t]
    var s = l.getAmbiguousCite.call(this.state, i, this.base, !0)
    this.debug && t > 1 && this.state.sys.print('  -----------'),
      this.ItemCite === s
        ? (this.debug &&
            (this.state.sys.print('  [CLASH]--> ' + this.Item.id + ': ' + this.ItemCite),
            this.state.sys.print('             ' + i.id + ': ' + s)),
          (n += 1),
          this.partners.push(i))
        : (this.debug &&
            (this.state.sys.print('  [clear]--> ' + this.Item.id + ': ' + this.ItemCite),
            this.state.sys.print('             ' + i.id + ': ' + s)),
          this.nonpartners.push(i))
  }
  ;(this.clashes[0] = this.clashes[1]), (this.clashes[1] = n)
}
l.Disambiguation.prototype.evalScan = function (e) {
  this[this.modes[this.modeindex]](e),
    e &&
      (this.modeindex < this.modes.length - 1
        ? (this.modeindex += 1)
        : (this.lists[this.listpos + 1] = [this.base, []]))
}
l.Disambiguation.prototype.disNames = function (e) {
  var t, r
  if (
    (this.debug && this.state.sys.print('[3] == disNames() =='),
    this.clashes[1] === 0 && this.nonpartners.length === 1)
  )
    this.captureStepToBase(),
      this.debug &&
        (this.state.sys.print('  ** RESOLUTION [a]: lone partner, one nonpartner'),
        this.state.sys.print(
          '  registering ' + this.partners[0].id + ' and ' + this.nonpartners[0].id
        )),
      this.state.registry.registerAmbigToken(
        this.akey,
        '' + this.nonpartners[0].id,
        this.betterbase
      ),
      this.state.registry.registerAmbigToken(this.akey, '' + this.partners[0].id, this.betterbase),
      (this.lists[this.listpos] = [this.betterbase, []])
  else if (this.clashes[1] === 0)
    this.captureStepToBase(),
      this.debug &&
        (this.state.sys.print(
          '  ** RESOLUTION [b]: lone partner, unknown number of remaining nonpartners'
        ),
        this.state.sys.print('  registering ' + this.partners[0].id)),
      this.state.registry.registerAmbigToken(this.akey, '' + this.partners[0].id, this.betterbase),
      (this.lists[this.listpos] = [this.betterbase, this.nonpartners]),
      this.nonpartners.length && (this.initGivens = !0)
  else if (this.nonpartners.length === 1)
    this.captureStepToBase(),
      this.debug &&
        (this.state.sys.print(
          '  ** RESOLUTION [c]: lone nonpartner, unknown number of partners remaining'
        ),
        this.state.sys.print('  registering ' + this.nonpartners[0].id)),
      this.state.registry.registerAmbigToken(
        this.akey,
        '' + this.nonpartners[0].id,
        this.betterbase
      ),
      (this.lists[this.listpos] = [this.betterbase, this.partners])
  else if (this.clashes[1] < this.clashes[0])
    this.captureStepToBase(),
      this.debug &&
        this.state.sys.print('  ** RESOLUTION [d]: better result, but no entries safe to register'),
      (this.lists[this.listpos] = [this.betterbase, this.partners]),
      this.lists.push([this.betterbase, this.nonpartners])
  else if (
    (this.debug && this.state.sys.print('  ** RESOLUTION [e]: no improvement, and clashes remain'),
    e &&
      ((this.lists[this.listpos] = [this.betterbase, this.nonpartners]),
      this.lists.push([this.betterbase, this.partners]),
      this.modeindex === this.modes.length - 1))
  ) {
    this.debug &&
      this.state.sys.print("     (registering clashing entries because we've run out of options)")
    for (var t = 0, r = this.partners.length; t < r; t += 1)
      this.state.registry.registerAmbigToken(this.akey, '' + this.partners[t].id, this.betterbase)
    this.lists[this.listpos] = [this.betterbase, []]
  }
}
l.Disambiguation.prototype.disExtraText = function () {
  this.debug && this.state.sys.print('[3] === disExtraText ==')
  var e = !1
  if (
    (this.clashes[1] === 0 && this.nonpartners.length < 2 && (e = !0),
    !e &&
      (!this.base.disambiguate ||
        this.state.tmp.disambiguate_count !== this.state.tmp.disambiguate_maxMax))
  )
    if (
      ((this.modeindex = 0),
      (this.base.disambiguate = this.state.tmp.disambiguate_count),
      (this.betterbase.disambiguate = this.state.tmp.disambiguate_count),
      this.base.disambiguate)
    )
      this.disNames()
    else {
      ;(this.initGivens = !0), (this.base.disambiguate = 1)
      for (var t = 0, r = this.lists[this.listpos][1].length; t < r; t += 1)
        this.state.tmp.taintedItemIDs[this.lists[this.listpos][1][t].id] = !0
    }
  else if (e || this.state.tmp.disambiguate_count === this.state.tmp.disambiguate_maxMax)
    if (e || this.modeindex === this.modes.length - 1) {
      for (
        var i = this.lists[this.listpos][0], t = 0, r = this.lists[this.listpos][1].length;
        t < r;
        t += 1
      )
        (this.state.tmp.taintedItemIDs[this.lists[this.listpos][1][t].id] = !0),
          this.state.registry.registerAmbigToken(
            this.akey,
            '' + this.lists[this.listpos][1][t].id,
            i
          )
      this.lists[this.listpos] = [this.betterbase, []]
    } else {
      this.modeindex = this.modes.length - 1
      var i = this.lists[this.listpos][0]
      i.disambiguate = !0
      for (var t = 0, r = this.lists[this.listpos][1].length; t < r; t += 1)
        (this.state.tmp.taintedItemIDs[this.lists[this.listpos][1][t].id] = !0),
          this.state.registry.registerAmbigToken(
            this.akey,
            '' + this.lists[this.listpos][1][t].id,
            i
          )
    }
}
l.Disambiguation.prototype.disYears = function () {
  var e, t, r, i
  this.debug && this.state.sys.print('[3] === disYears =='), (r = [])
  var n = this.lists[this.listpos][0]
  if (this.clashes[1])
    for (var s = 0, a = this.state.registry.mylist.length; s < a; s += 1)
      for (
        var o = this.state.registry.mylist[s], u = 0, c = this.lists[this.listpos][1].length;
        u < c;
        u += 1
      ) {
        var i = this.lists[this.listpos][1][u]
        if (i.id == o) {
          r.push(this.registry[i.id])
          break
        }
      }
  r.sort(this.state.registry.sorter.compareKeys)
  for (var e = 0, t = r.length; e < t; e += 1) {
    n.year_suffix = '' + e
    var f = this.state.registry.registry[r[e].id].disambig
    this.state.registry.registerAmbigToken(this.akey, '' + r[e].id, n),
      l.ambigConfigDiff(f, n) && (this.state.tmp.taintedItemIDs[r[e].id] = !0)
  }
  this.lists[this.listpos] = [this.betterbase, []]
}
l.Disambiguation.prototype.incrementDisambig = function () {
  if (
    (this.debug &&
      this.state.sys.print(`
[1] === incrementDisambig() ===`),
    this.initGivens)
  )
    return (this.initGivens = !1), !1
  var e = !1,
    t = !0
  if (this.modes[this.modeindex] === 'disNames') {
    ;(t = !1), typeof this.givensMax != 'number' && (t = !0)
    var r = !1
    typeof this.namesMax != 'number' && (r = !0),
      typeof this.givensMax == 'number' &&
        (this.base.givens.length && this.base.givens[this.gnameset][this.gname] < this.givensMax
          ? (this.base.givens[this.gnameset][this.gname] += 1)
          : (t = !0)),
      typeof this.namesMax == 'number' &&
        t &&
        (this.state.opt['disambiguate-add-names']
          ? ((r = !1),
            this.gname < this.namesMax
              ? ((this.base.names[this.gnameset] += 1), (this.gname += 1))
              : (r = !0))
          : (r = !0)),
      typeof this.namesetsMax == 'number' &&
        r &&
        this.gnameset < this.namesetsMax &&
        ((this.gnameset += 1), (this.base.names[this.gnameset] = 1), (this.gname = 0)),
      this.debug &&
        (this.state.sys.print('    ------------------'),
        this.state.sys.print('    incremented values'),
        this.state.sys.print('    ------------------'),
        this.state.sys.print('    | gnameset: ' + this.gnameset),
        this.state.sys.print('    | gname: ' + this.gname),
        this.state.sys.print('    | names value: ' + this.base.names[this.gnameset]),
        this.base.givens.length
          ? this.state.sys.print(
              '    | givens value: ' + this.base.givens[this.gnameset][this.gname]
            )
          : this.state.sys.print('    | givens value: nil'),
        this.state.sys.print('    | namesetsMax: ' + this.namesetsMax),
        this.state.sys.print('    | namesMax: ' + this.namesMax),
        this.state.sys.print('    | givensMax: ' + this.givensMax)),
      (typeof this.namesetsMax != 'number' ||
        this.namesetsMax === -1 ||
        this.gnameset === this.namesetsMax) &&
        (!this.state.opt['disambiguate-add-names'] ||
          typeof this.namesMax != 'number' ||
          this.gname === this.namesMax) &&
        (typeof this.givensMax != 'number' ||
          typeof this.base.givens[this.gnameset] > 'u' ||
          typeof this.base.givens[this.gnameset][this.gname] > 'u' ||
          this.base.givens[this.gnameset][this.gname] === this.givensMax) &&
        ((e = !0), this.debug && this.state.sys.print('    MAXED'))
  } else
    this.modes[this.modeindex] === 'disExtraText' &&
      ((this.base.disambiguate += 1), (this.betterbase.disambiguate += 1))
  return e
}
l.Disambiguation.prototype.initVars = function (e) {
  var t, r, i, n, s
  if (
    (this.debug && this.state.sys.print('[B] === initVars() ==='),
    (this.lists = []),
    (this.base = !1),
    (this.betterbase = !1),
    (this.akey = e),
    (this.maxNamesByItemId = {}),
    (n = []),
    (i = this.ambigcites[e]),
    !i || !i.length)
  )
    return !1
  var a = this.state.refetchItem('' + i[0])
  if ((this.getCiteData(a), (this.base = l.getAmbigConfig.call(this.state)), i && i.length > 1)) {
    n.push([this.maxNamesByItemId[a.id], a])
    for (var t = 1, r = i.length; t < r; t += 1)
      (a = this.state.refetchItem('' + i[t])),
        this.getCiteData(a, this.base),
        n.push([this.maxNamesByItemId[a.id], a])
    n.sort(function (u, c) {
      return u[0] > c[0] ? 1 : u[0] < c[0] ? -1 : u[1].id > c[1].id ? 1 : u[1].id < c[1].id ? -1 : 0
    }),
      (s = [])
    for (var t = 0, r = n.length; t < r; t += 1) s.push(n[t][1])
    this.lists.push([this.base, s]), (this.Item = this.lists[0][1][0])
  } else this.Item = this.state.refetchItem('' + i[0])
  if (((this.modeindex = 0), this.state.citation.opt['disambiguate-add-names'] || !0))
    this.namesMax = this.maxNamesByItemId[this.Item.id][0]
  else {
    var o
    for (var t, r; t < r; t += 1);
  }
  return (
    this.padBase(this.base),
    this.padBase(this.betterbase),
    (this.base.year_suffix = !1),
    (this.base.disambiguate = !1),
    (this.betterbase.year_suffix = !1),
    (this.betterbase.disambiguate = !1),
    this.state.citation.opt['givenname-disambiguation-rule'] === 'by-cite' &&
      this.state.opt['disambiguate-add-givenname'] &&
      (this.givensMax = 2),
    !0
  )
}
l.Disambiguation.prototype.padBase = function (e) {
  for (var t = 0, r = e.names.length; t < r; t += 1) {
    e.givens[t] || (e.givens[t] = [])
    for (var i = 0, n = e.names[t]; i < n; i += 1) e.givens[t][i] || (e.givens[t][i] = 0)
  }
}
l.Disambiguation.prototype.configModes = function () {
  var e, t
  ;(this.modes = []),
    (e = this.state.opt['disambiguate-add-givenname']),
    (t = this.state.citation.opt['givenname-disambiguation-rule']),
    (this.state.opt['disambiguate-add-names'] || (e && t === 'by-cite')) &&
      this.modes.push('disNames'),
    this.state.opt.development_extensions.prioritize_disambiguate_condition
      ? (this.state.opt.has_disambiguate && this.modes.push('disExtraText'),
        this.state.opt['disambiguate-add-year-suffix'] && this.modes.push('disYears'))
      : (this.state.opt['disambiguate-add-year-suffix'] && this.modes.push('disYears'),
        this.state.opt.has_disambiguate && this.modes.push('disExtraText'))
}
l.Disambiguation.prototype.getCiteData = function (e, t) {
  if (!this.maxNamesByItemId[e.id]) {
    l.getAmbiguousCite.call(this.state, e, t),
      (t = l.getAmbigConfig.call(this.state)),
      (this.maxNamesByItemId[e.id] = l.getMaxVals.call(this.state)),
      (this.state.registry.registry[e.id].disambig.givens =
        this.state.tmp.disambig_settings.givens.slice())
    for (var r = 0, i = this.state.registry.registry[e.id].disambig.givens.length; r < i; r += 1)
      this.state.registry.registry[e.id].disambig.givens[r] =
        this.state.tmp.disambig_settings.givens[r].slice()
    ;(this.namesetsMax = this.state.registry.registry[e.id].disambig.names.length - 1),
      this.base || ((this.base = t), (this.betterbase = l.cloneAmbigConfig(t))),
      t.names.length < this.base.names.length && (this.base = t)
    for (var r = 0, i = t.names.length; r < i; r += 1)
      t.names[r] > this.base.names[r] &&
        ((this.base.givens[r] = t.givens[r].slice()),
        (this.base.names[r] = t.names[r]),
        (this.betterbase.names = this.base.names.slice()),
        (this.betterbase.givens = this.base.givens.slice()),
        this.padBase(this.base),
        this.padBase(this.betterbase))
    this.betterbase.givens = this.base.givens.slice()
    for (var n = 0, s = this.base.givens.length; n < s; n += 1)
      this.betterbase.givens[n] = this.base.givens[n].slice()
  }
}
l.Disambiguation.prototype.captureStepToBase = function () {
  this.state.citation.opt['givenname-disambiguation-rule'] === 'by-cite' &&
    this.base.givens &&
    this.base.givens.length &&
    typeof this.base.givens[this.gnameset][this.gname] < 'u' &&
    (this.betterbase.givens.length < this.base.givens.length &&
      (this.betterbase.givens = JSON.parse(JSON.stringify(this.base.givens))),
    (this.betterbase.givens[this.gnameset][this.gname] =
      this.base.givens[this.gnameset][this.gname])),
    (this.betterbase.names[this.gnameset] = this.base.names[this.gnameset])
}
l.Engine.prototype.getJurisdictionList = function (e) {
  for (var t = [], r = e.split(':'), i = r.length; i > 0; i--) {
    var n = r.slice(0, i).join(':')
    if ((t.push(n), this.opt.jurisdiction_fallbacks[n])) {
      var s = this.opt.jurisdiction_fallbacks[n]
      t.push(s)
    }
  }
  return t.indexOf('us') === -1 && t.push('us'), t
}
l.Engine.prototype.loadStyleModule = function (e, t, r) {
  var i = null
  this.juris[e] = {}
  var n = l.setupXml(t)
  n.addMissingNameNodes(n.dataObj),
    n.addInstitutionNodes(n.dataObj),
    n.insertPublisherAndPlace(n.dataObj),
    n.flagDateMacros(n.dataObj)
  for (var h = n.getNodesByName(n.dataObj, 'law-module'), s = 0, a = h.length; s < a; s++) {
    var o = n.getAttributeValue(h[s], 'types')
    if (o) {
      ;(this.juris[e].types = {}), (o = o.split(/\s+/))
      for (var u = 0, c = o.length; u < c; u++) this.juris[e].types[o[u]] = !0
    }
    r ||
      ((i = n.getAttributeValue(h[s], 'fallback')),
      i && e !== 'us' && (this.opt.jurisdiction_fallbacks[e] = i))
  }
  var f = this.opt.lang ? this.opt.lang : this.opt['default-locale'][0]
  l.SET_COURT_CLASSES(this, f, n, n.dataObj),
    this.juris[e].types || (this.juris[e].types = l.MODULE_TYPES)
  for (var h = n.getNodesByName(n.dataObj, 'macro'), s = 0, a = h.length; s < a; s++) {
    var p = n.getAttributeValue(h[s], 'name')
    if (!l.MODULE_MACROS[p]) {
      l.debug('CSL: skipping non-modular macro name "' + p + '" in module context')
      continue
    }
    ;(this.juris[e][p] = []),
      this.buildTokenLists(h[s], this.juris[e][p]),
      this.configureTokenList(this.juris[e][p])
  }
  return i
}
l.Engine.prototype.retrieveAllStyleModules = function (e) {
  var t = {},
    r = this.locale[this.opt.lang].opts['jurisdiction-preference']
  ;(r = r || []), (r = [''].concat(r))
  for (var i = r.length - 1; i > -1; i--)
    for (var n = r[i], s = 0, a = e.length; s < a; s++) {
      var o = e[s]
      if (!this.opt.jurisdictions_seen[o]) {
        var u = this.sys.retrieveStyleModule(o, n)
        ;((!u && !n) || u) && (this.opt.jurisdictions_seen[o] = !0), u && (t[o] = u)
      }
    }
  return t
}
l.ParticleList = (function () {
  var e = [[[0, 1], null]],
    t = [[[0, 3], null]],
    r = [[null, [0, 1]]],
    i = [[null, [0, 2]]],
    n = [[null, [0, 3]]],
    s = [
      [null, [0, 1]],
      [[0, 1], null],
    ],
    a = [
      [null, [0, 2]],
      [[0, 2], null],
    ],
    o = [
      [[0, 1], null],
      [null, [0, 1]],
    ],
    u = [
      [[0, 2], null],
      [null, [0, 2]],
    ],
    c = [
      [[0, 3], null],
      [null, [0, 3]],
    ],
    f = [
      [null, [0, 2]],
      [
        [0, 1],
        [1, 2],
      ],
    ],
    h = [
      ["'s", r],
      ["'s-", r],
      ["'t", r],
      ['a', r],
      ["aan 't", i],
      ['aan de', i],
      ['aan den', i],
      ['aan der', i],
      ['aan het', i],
      ['aan t', i],
      ['aan', r],
      ['ad-', s],
      ['adh-', s],
      ['af', s],
      ['al', s],
      ['al-', s],
      ['am de', i],
      ['am', r],
      ['an-', s],
      ['ar-', s],
      ['as-', s],
      ['ash-', s],
      ['at-', s],
      ['ath-', s],
      ['auf dem', u],
      ['auf den', u],
      ['auf der', u],
      ['auf ter', i],
      ['auf', o],
      ["aus 'm", u],
      ['aus dem', u],
      ['aus den', u],
      ['aus der', u],
      ['aus m', u],
      ['aus', o],
      ["aus'm", u],
      ['az-', s],
      ['a-', s],
      ['a-', s],
      ['a-', s],
      ['a-', s],
      ['a-', s],
      ['a-', s],
      ['a-', s],
      ['ben', r],
      ["bij 't", i],
      ['bij de', i],
      ['bij den', i],
      ['bij het', i],
      ['bij t', i],
      ['bij', r],
      ['bin', r],
      ['boven d', i],
      ["boven d'", i],
      ['d', r],
      ["d'", s],
      ['da', s],
      ['dal', r],
      ["dal'", r],
      ["dall'", r],
      ['dalla', r],
      ['das', s],
      ['de die le', n],
      ['de die', i],
      ['de l', i],
      ["de l'", i],
      ['de la', f],
      ['de las', f],
      ['de le', i],
      ['de li', a],
      ['de van der', n],
      ['de', s],
      ["de'", s],
      ['deca', r],
      ['degli', s],
      ['dei', s],
      ['del', s],
      ['dela', e],
      ["dell'", s],
      ['della', s],
      ['delle', s],
      ['dello', s],
      ['den', s],
      ['der', s],
      ['des', s],
      ['di', s],
      ['die le', i],
      ['do', r],
      ['don', r],
      ['dos', s],
      ['du', s],
      ['ed-', s],
      ['edh-', s],
      ['el', s],
      ['el-', s],
      ['en-', s],
      ['er-', s],
      ['es-', s],
      ['esh-', s],
      ['et-', s],
      ['eth-', s],
      ['ez-', s],
      ['e-', s],
      ['e-', s],
      ['e-', s],
      ['e-', s],
      ['e-', s],
      ['e-', s],
      ['e-', s],
      ['het', r],
      ['i', r],
      ['il', e],
      ['im', r],
      ["in 't", i],
      ['in de', i],
      ['in den', i],
      ['in der', a],
      ['in het', i],
      ['in t', i],
      ['in', r],
      ['l', r],
      ["l'", r],
      ['la', r],
      ['las', r],
      ['le', r],
      ['les', s],
      ['lo', s],
      ['los', r],
      ['lou', r],
      ['of', r],
      ["onder 't", i],
      ['onder de', i],
      ['onder den', i],
      ['onder het', i],
      ['onder t', i],
      ['onder', r],
      ["op 't", i],
      ['op de', a],
      ['op den', i],
      ['op der', i],
      ['op gen', i],
      ['op het', i],
      ['op t', i],
      ['op ten', i],
      ['op', r],
      ["over 't", i],
      ['over de', i],
      ['over den', i],
      ['over het', i],
      ['over t', i],
      ['over', r],
      ['s', r],
      ["s'", r],
      ['sen', e],
      ['t', r],
      ['te', r],
      ['ten', r],
      ['ter', r],
      ['tho', r],
      ['thoe', r],
      ['thor', r],
      ['to', r],
      ['toe', r],
      ['tot', r],
      ["uijt 't", i],
      ['uijt de', i],
      ['uijt den', i],
      ['uijt te de', n],
      ['uijt ten', i],
      ['uijt', r],
      ["uit 't", i],
      ['uit de', i],
      ['uit den', i],
      ['uit het', i],
      ['uit t', i],
      ['uit te de', n],
      ['uit ten', i],
      ['uit', r],
      ['unter', r],
      ['v', r],
      ['v.', r],
      ['v.d.', r],
      ["van 't", i],
      ['van de l', n],
      ["van de l'", n],
      ['van de', i],
      ['van de', i],
      ['van den', i],
      ['van der', i],
      ['van gen', i],
      ['van het', i],
      ['van la', i],
      ['van t', i],
      ['van ter', i],
      ['van van de', n],
      ['van', s],
      ['vander', r],
      ['vd', r],
      ['ver', r],
      ['vom und zum', t],
      ['vom', s],
      ["von 't", i],
      ['von dem', u],
      ['von den', u],
      ['von der', u],
      ['von t', i],
      ['von und zu', c],
      ['von zu', u],
      ['von', o],
      ["voor 't", i],
      ['voor de', i],
      ['voor den', i],
      ["voor in 't", n],
      ['voor in t', n],
      ['voor', r],
      ['vor der', u],
      ['vor', o],
      ['z', e],
      ['ze', e],
      ['zu', o],
      ['zum', s],
      ['zur', s],
    ]
  return h
})()
l.parseParticles = (function () {
  function e(i, n, s) {
    var a = i
    i = s ? i.toLowerCase() : i
    var o = [],
      u,
      c
    n
      ? ((i = i.split('').reverse().join('')), (u = l.PARTICLE_GIVEN_REGEXP))
      : (u = l.PARTICLE_FAMILY_REGEXP)
    for (var f = i.match(u); f; ) {
      var h = n ? f[1].split('').reverse().join('') : f[1],
        p = f ? h : !1,
        p = p ? h.replace(/^[-\'\u02bb\u2019\s]*(.).*$/, '$1') : !1
      if (((c = p ? p.toUpperCase() !== p : !1), !c)) break
      n
        ? (o.push(a.slice(h.length * -1)), (a = a.slice(0, h.length * -1)))
        : (o.push(a.slice(0, h.length)), (a = a.slice(h.length))),
        (i = f[2]),
        (f = i.match(u))
    }
    if (n) {
      ;(i = i.split('').reverse().join('')), o.reverse()
      for (var m = 1, v = o.length; m < v; m++) o[m].slice(0, 1) == ' ' && (o[m - 1] += ' ')
      for (var m = 0, v = o.length; m < v; m++) o[m].slice(0, 1) == ' ' && (o[m] = o[m].slice(1))
      i = a.slice(0, i.length)
    } else i = a.slice(i.length * -1)
    return [c, i, o]
  }
  function t(i) {
    var n = i.slice(-1)
    return (i = i.trim()), n === ' ' && ["'", ''].indexOf(i.slice(-1)) > -1 && (i += ' '), i
  }
  function r(i) {
    if (!i.suffix && i.given) {
      var n = i.given.match(/(\s*,!*\s*)/)
      if (n) {
        var s = i.given.indexOf(n[1]),
          a = i.given.slice(s + n[1].length),
          o = i.given.slice(s, s + n[1].length).replace(/\s*/g, '')
        a.replace(/\./g, '') === 'et al' && !i['dropping-particle']
          ? ((i['dropping-particle'] = a), (i['comma-dropping-particle'] = ','))
          : (o.length === 2 && (i['comma-suffix'] = !0), (i.suffix = a)),
          (i.given = i.given.slice(0, s))
      }
    }
  }
  return function (i) {
    var o = e(i.family),
      n = o[1],
      s = o[2]
    i.family = n
    var a = t(s.join(''))
    a && (i['non-dropping-particle'] = a), r(i)
    var o = e(i.given, !0),
      u = o[1],
      c = o[2]
    i.given = u
    var f = c.join('').trim()
    f && (i['dropping-particle'] = f)
  }
})()
var ND = l
const ki = ci(ND),
  Sy = Symbol.for('proxied'),
  OD = function (e) {
    const t = function (r, i) {
      if (r.sys.wrapBibliographyEntry) {
        const [n, s] = r.sys.wrapBibliographyEntry(this.system_id)
        i = [n, i, s].join('')
      }
      return e.call(this, r, i)
    }
    return (t[Sy] = !0), t
  }
for (const e in ki.Output.Formats) {
  const t = ki.Output.Formats[e]['@bibliography/entry']
  !t || t[Sy] || (ki.Output.Formats[e]['@bibliography/entry'] = OD(t))
}
function ID(e) {
  if (hn.has(e)) return hn.get(e)
  const t = e.replace('-', '_')
  return hn.has(t) ? hn.get(t) : {}
}
const Il = {},
  DD = function (e, t, r, i, n) {
    const s = `${e}|${t}`
    let a
    return (
      Il[s] instanceof ki.Engine
        ? ((a = Il[s]),
          (a.sys.retrieveItem = i),
          (a.sys.wrapBibliographyEntry = void 0),
          a.updateItems([]))
        : (a = Il[s] = new ki.Engine({ retrieveLocale: n, retrieveItem: i }, r, t, !0)),
      a
    )
  },
  Rp = function (e, t, r, i) {
    if (!ki.Output.Formats[i] || !ki.Output.Formats[i]['@bibliography/entry'])
      throw new TypeError(`Cannot find format '${i}'`)
    const n = e.reduce((u, c) => ((u[c.id] = c), u), {}),
      s = nf.get(nf.has(t) ? t : 'apa')
    r = hn.has(r) ? r : void 0
    const o = DD(
      t,
      r,
      s,
      function (u) {
        if (Object.prototype.hasOwnProperty.call(n, u)) return n[u]
        throw new Error(`Cannot find entry with id '${u}'`)
      },
      ID
    )
    return o.setOutputFormat(i), o
  },
  RD = (e, t, r) => e.replace(/^\s*<[a-z]+/i, `$& data-${t}="${r}"`),
  LD = (e, t) => RD(e, 'csl-entry-id', t),
  Sd = (e, t) => (typeof t == 'function' ? t(e) : t || '')
function PD(e, t = {}) {
  const { template: r = 'apa', lang: i, format: n = 'text', nosort: s = !1 } = t,
    a = t.entry ? [].concat(t.entry) : e.map(({ id: v }) => v)
  e = qs(e)
  const o = Rp(e, r, i, n),
    u = o.updateItems(a, s)
  if (t.append || t.prepend) {
    const v = e.reduce((b, S) => ((b[S.id] = S), b), {})
    o.sys.wrapBibliographyEntry = function (b) {
      const S = v[b]
      return [Sd(S, t.prepend), Sd(S, t.append)]
    }
  }
  const c = o.makeBibliography(),
    [{ bibstart: f, bibend: h }, p] = c,
    m = p.map((v, b) => LD(v, u[b]))
  return t.asEntryArray ? m.map((v, b) => [u[b], v]) : f + m.join('') + h
}
function BD(e) {
  return typeof e == 'object' ? e : { id: e }
}
function Cy(e) {
  return e.citationItems ? e : { citationItems: [].concat(e).map(BD), properties: { noteIndex: 0 } }
}
function Cd(e) {
  return e ? e.map(Cy) : []
}
function FD(e, t = {}) {
  const { template: r = 'apa', lang: i, format: n = 'text' } = t,
    s = e.map(({ id: p }) => p),
    a = t.entry ? t.entry : s
  e = qs(e)
  const o = Rp(e, r, i, n),
    u = Cd(t.citationsPre),
    c = Cy(a),
    f = Cd(t.citationsPost)
  return o.rebuildProcessorState([...u, c, ...f], n, [])[u.length][2]
}
ha('@csl', {
  output: { bibliography: PD, citation: FD },
  config: { engine: Rp, locales: hn, templates: nf },
})
function ky(e) {
  const t = {}
  for (const r in e) t[r] = typeof e[r] == 'object' ? ky(e[r]) : e[r]
  return t
}
function Js(e, t) {
  if (!(this instanceof Js)) return new Js(e, t)
  const r = new li(e, t)
  ;(this._options = r._options), (this.log = r.log), (this.data = r.data)
}
Js.plugins = ky(GO)
const MD =
    '<?xml version="1.0" encoding="utf-8"?><style xmlns="http://purl.org/net/xbiblio/csl" class="in-text" version="1.0" demote-non-dropping-particle="never" page-range-format="minimal-two"><info><title>Modern Language Association 9th edition</title><title-short>MLA</title-short><id>http://www.zotero.org/styles/modern-language-association</id><link href="http://www.zotero.org/styles/modern-language-association" rel="self"/><link href="http://style.mla.org" rel="documentation"/><author><name>Sebastian Karcher</name></author><category citation-format="author"/><category field="generic-base"/><summary>This style adheres to the MLA 9th edition handbook. Follows the structure of references as outlined in the MLA Manual closely</summary><updated>2021-07-13T20:05:10+00:00</updated><rights license="http://creativecommons.org/licenses/by-sa/3.0/">This work is licensed under a Creative Commons Attribution-ShareAlike 3.0 License</rights></info><locale xml:lang="en"><date form="text"><date-part name="day" suffix=" "/><date-part name="month" suffix=" " form="short"/><date-part name="year"/></date><terms><term name="month-01" form="short">Jan.</term><term name="month-02" form="short">Feb.</term><term name="month-03" form="short">Mar.</term><term name="month-04" form="short">Apr.</term><term name="month-05" form="short">May</term><term name="month-06" form="short">June</term><term name="month-07" form="short">July</term><term name="month-08" form="short">Aug.</term><term name="month-09" form="short">Sept.</term><term name="month-10" form="short">Oct.</term><term name="month-11" form="short">Nov.</term><term name="month-12" form="short">Dec.</term><term name="translator" form="short">trans.</term></terms></locale><macro name="author"><names variable="author"><name name-as-sort-order="first" and="text" delimiter-precedes-last="always" delimiter-precedes-et-al="always" initialize="false" initialize-with=". "/><label form="long" prefix=", "/><substitute><names variable="editor"/><names variable="translator"/><text macro="title"/></substitute></names></macro><macro name="author-short"><group delimiter=", "><names variable="author"><name form="short" initialize-with=". " and="text"/><substitute><names variable="editor"/><names variable="translator"/><text macro="title-short"/></substitute></names><choose><if disambiguate="true"><text macro="title-short"/></if></choose></group></macro><macro name="title"><choose><if variable="container-title" match="any"><text variable="title" quotes="true" text-case="title"/></if><else><text variable="title" font-style="italic" text-case="title"/></else></choose></macro><macro name="title-short"><choose><if variable="container-title" match="any"><text variable="title" form="short" quotes="true" text-case="title"/></if><else><text variable="title" form="short" font-style="italic" text-case="title"/></else></choose></macro><macro name="container-title"><text variable="container-title" font-style="italic" text-case="title"/></macro><macro name="other-contributors"><choose><if variable="container-title" match="any"><group delimiter=", "><names variable="container-author" delimiter=", "><label form="verb" suffix=" "/><name and="text"/></names><names variable="editor translator" delimiter=", "><label form="verb" suffix=" "/><name and="text"/></names><names variable="director illustrator interviewer" delimiter=", "><label form="verb" suffix=" "/><name and="text"/></names></group></if><else><group delimiter=", "><names variable="container-author" delimiter=", "><label form="verb" suffix=" " text-case="capitalize-first"/><name and="text"/></names><names variable="editor translator" delimiter=", "><label form="verb" suffix=" " text-case="capitalize-first"/><name and="text"/></names><names variable="director illustrator interviewer" delimiter=", "><label form="verb" suffix=" " text-case="capitalize-first"/><name and="text"/></names></group></else></choose></macro><macro name="version"><group delimiter=", "><choose><if is-numeric="edition"><group delimiter=" "><number variable="edition" form="ordinal"/><text term="edition" form="short"/></group></if><else><text variable="edition" text-case="capitalize-first"/></else></choose><text variable="version"/></group></macro><macro name="volume-lowercase"><group delimiter=" "><text term="volume" form="short"/><text variable="volume"/></group></macro><macro name="number"><group delimiter=", "><group><choose><if variable="edition container-title" match="any"><text macro="volume-lowercase"/></if><else-if variable="author" match="all"><choose><if variable="editor translator container-author illustrator interviewer director" match="any"><text macro="volume-lowercase"/></if></choose></else-if><else-if variable="editor" match="all"><choose><if variable="translator container-author illustrator interviewer director" match="any"><text macro="volume-lowercase"/></if></choose></else-if><else-if variable="container-author illustrator interviewer director" match="any"><text macro="volume-lowercase"/></else-if><else><group delimiter=" "><text term="volume" form="short" text-case="capitalize-first"/><text variable="volume"/></group></else></choose></group><group delimiter=" "><text term="issue" form="short"/><text variable="issue"/></group><choose><if type="report"><text variable="genre"/></if></choose><text variable="number"/></group></macro><macro name="publisher"><text variable="publisher"/></macro><macro name="publication-date"><choose><if type="book chapter paper-conference motion_picture" match="any"><date variable="issued" form="numeric" date-parts="year"/></if><else-if type="article-journal article-magazine" match="any"><date variable="issued" form="text" date-parts="year-month"/></else-if><else-if type="speech" match="none"><date variable="issued" form="text"/></else-if></choose></macro><macro name="location"><group delimiter=", "><group delimiter=" "><label variable="page" form="short"/><text variable="page"/></group><choose><if variable="source" match="none"><text macro="URI"/></if></choose></group></macro><macro name="container2-title"><group delimiter=", "><choose><if type="speech"><text variable="event"/><date variable="event-date" form="text"/><text variable="event-place"/></if></choose><text variable="archive"/><text variable="archive-place"/><text variable="archive_location"/></group></macro><macro name="container2-location"><choose><if variable="source"><choose><if variable="DOI URL" match="any"><group delimiter=", "><text variable="source" font-style="italic"/><text macro="URI"/></group></if></choose></if></choose></macro><macro name="URI"><choose><if variable="DOI"><text variable="DOI" prefix="https://doi.org/"/></if><else><text variable="URL"/></else></choose></macro><macro name="accessed"><choose><if variable="issued" match="none"><group delimiter=" "><text term="accessed" text-case="capitalize-first"/><date variable="accessed" form="text"/></group></if></choose></macro><citation et-al-min="3" et-al-use-first="1" disambiguate-add-names="true" disambiguate-add-givenname="true"><layout prefix="(" suffix=")" delimiter="; "><choose><if locator="page line" match="any"><group delimiter=" "><text macro="author-short"/><text variable="locator"/></group></if><else><group delimiter=", "><text macro="author-short"/><group><label variable="locator" form="short"/><text variable="locator"/></group></group></else></choose></layout></citation><bibliography hanging-indent="true" et-al-min="3" et-al-use-first="1" line-spacing="2" entry-spacing="0" subsequent-author-substitute="---"><sort><key macro="author"/><key variable="title"/></sort><layout suffix="."><group delimiter=". "><text macro="author"/><text macro="title"/><date variable="original-date" form="numeric" date-parts="year"/><group delimiter=", "><text macro="container-title"/><text macro="other-contributors"/><text macro="version"/><text macro="number"/><text macro="publisher"/><text macro="publication-date"/><text macro="location"/></group><group delimiter=", "><text macro="container2-title"/><text macro="container2-location"/></group><text macro="accessed"/></group></layout></bibliography></style>',
  UD =
    '<?xml version="1.0" encoding="utf-8"?><style xmlns="http://purl.org/net/xbiblio/csl" class="in-text" version="1.0" demote-non-dropping-particle="display-and-sort" page-range-format="chicago"><info><title>Chicago Manual of Style 17th edition (author-date)</title><id>http://www.zotero.org/styles/chicago-author-date</id><link href="http://www.zotero.org/styles/chicago-author-date" rel="self"/><link href="http://www.chicagomanualofstyle.org/tools_citationguide.html" rel="documentation"/><author><name>Julian Onions</name><email>julian.onions@gmail.com</email></author><contributor><name>Sebastian Karcher</name></contributor><contributor><name>Richard Karnesky</name><email>karnesky+zotero@gmail.com</email><uri>http://arc.nucapt.northwestern.edu/Richard_Karnesky</uri></contributor><contributor><name>Andrew Dunning</name><email>andrew.dunning@utoronto.ca</email><uri>https://orcid.org/0000-0003-0464-5036</uri></contributor><contributor><name>Matthew Roth</name><email>matthew.g.roth@yale.edu</email><uri> https://orcid.org/0000-0001-7902-6331</uri></contributor><contributor><name>Brenton M. Wiernik</name></contributor><category citation-format="author-date"/><category field="generic-base"/><summary>The author-date variant of the Chicago style</summary><updated>2018-01-24T12:00:00+00:00</updated><rights license="http://creativecommons.org/licenses/by-sa/3.0/">This work is licensed under a Creative Commons Attribution-ShareAlike 3.0 License</rights></info><locale xml:lang="en"><terms><term name="editor" form="verb-short">ed.</term><term name="container-author" form="verb">by</term><term name="translator" form="verb-short">trans.</term><term name="editortranslator" form="verb">edited and translated by</term><term name="translator" form="short">trans.</term></terms></locale><macro name="secondary-contributors"><choose><if type="chapter entry-dictionary entry-encyclopedia paper-conference" match="none"><group delimiter=". "><names variable="editor translator" delimiter=". "><label form="verb" text-case="capitalize-first" suffix=" "/><name and="text" delimiter=", "/></names><names variable="director" delimiter=". "><label form="verb" text-case="capitalize-first" suffix=" "/><name and="text" delimiter=", "/></names></group></if></choose></macro><macro name="container-contributors"><choose><if type="chapter entry-dictionary entry-encyclopedia paper-conference" match="any"><group prefix=", " delimiter=", "><names variable="container-author" delimiter=", "><label form="verb" suffix=" "/><name and="text" delimiter=", "/></names><names variable="editor translator" delimiter=", "><label form="verb" suffix=" "/><name and="text" delimiter=", "/></names></group></if></choose></macro><macro name="editor"><names variable="editor"><name name-as-sort-order="first" and="text" sort-separator=", " delimiter=", " delimiter-precedes-last="always"/><label form="short" prefix=", "/></names></macro><macro name="translator"><names variable="translator"><name name-as-sort-order="first" and="text" sort-separator=", " delimiter=", " delimiter-precedes-last="always"/><label form="short" prefix=", "/></names></macro><macro name="recipient"><choose><if type="personal_communication"><choose><if variable="genre"><text variable="genre" text-case="capitalize-first"/></if><else><text term="letter" text-case="capitalize-first"/></else></choose></if></choose><names variable="recipient" delimiter=", "><label form="verb" prefix=" " text-case="lowercase" suffix=" "/><name and="text" delimiter=", "/></names></macro><macro name="substitute-title"><choose><if type="article-magazine article-newspaper review review-book" match="any"><text macro="container-title"/></if></choose></macro><macro name="contributors"><group delimiter=". "><names variable="author"><name and="text" name-as-sort-order="first" sort-separator=", " delimiter=", " delimiter-precedes-last="always"/><label form="short" prefix=", "/><substitute><names variable="editor"/><names variable="translator"/><names variable="director"/><text macro="substitute-title"/><text macro="title"/></substitute></names><text macro="recipient"/></group></macro><macro name="contributors-short"><names variable="author"><name form="short" and="text" delimiter=", " initialize-with=". "/><substitute><names variable="editor"/><names variable="translator"/><names variable="director"/><text macro="substitute-title"/><text macro="title"/></substitute></names></macro><macro name="interviewer"><names variable="interviewer" delimiter=", "><label form="verb" prefix=" " text-case="capitalize-first" suffix=" "/><name and="text" delimiter=", "/></names></macro><macro name="archive"><group delimiter=". "><text variable="archive_location" text-case="capitalize-first"/><text variable="archive"/><text variable="archive-place"/></group></macro><macro name="access"><group delimiter=". "><choose><if type="graphic report" match="any"><text macro="archive"/></if><else-if type="article-journal bill book chapter legal_case legislation motion_picture paper-conference" match="none"><text macro="archive"/></else-if></choose><choose><if type="webpage post-weblog" match="any"><date variable="issued" form="text"/></if></choose><choose><if variable="issued" match="none"><group delimiter=" "><text term="accessed" text-case="capitalize-first"/><date variable="accessed" form="text"/></group></if></choose><choose><if type="legal_case" match="none"><choose><if variable="DOI"><text variable="DOI" prefix="https://doi.org/"/></if><else><text variable="URL"/></else></choose></if></choose></group></macro><macro name="title"><choose><if variable="title" match="none"><choose><if type="personal_communication" match="none"><text variable="genre" text-case="capitalize-first"/></if></choose></if><else-if type="bill book graphic legislation motion_picture song" match="any"><text variable="title" text-case="title" font-style="italic"/><group prefix=" (" suffix=")" delimiter=" "><text term="version"/><text variable="version"/></group></else-if><else-if variable="reviewed-author"><choose><if variable="reviewed-title"><group delimiter=". "><text variable="title" text-case="title" quotes="true"/><group delimiter=", "><text variable="reviewed-title" text-case="title" font-style="italic" prefix="Review of "/><names variable="reviewed-author"><label form="verb-short" text-case="lowercase" suffix=" "/><name and="text" delimiter=", "/></names></group></group></if><else><group delimiter=", "><text variable="title" text-case="title" font-style="italic" prefix="Review of "/><names variable="reviewed-author"><label form="verb-short" text-case="lowercase" suffix=" "/><name and="text" delimiter=", "/></names></group></else></choose></else-if><else-if type="legal_case interview patent" match="any"><text variable="title"/></else-if><else><text variable="title" text-case="title" quotes="true"/></else></choose></macro><macro name="edition"><choose><if type="bill book graphic legal_case legislation motion_picture report song" match="any"><choose><if is-numeric="edition"><group delimiter=" " prefix=". "><number variable="edition" form="ordinal"/><text term="edition" form="short" strip-periods="true"/></group></if><else><text variable="edition" text-case="capitalize-first" prefix=". "/></else></choose></if><else-if type="chapter entry-dictionary entry-encyclopedia paper-conference" match="any"><choose><if is-numeric="edition"><group delimiter=" " prefix=", "><number variable="edition" form="ordinal"/><text term="edition" form="short"/></group></if><else><text variable="edition" prefix=", "/></else></choose></else-if></choose></macro><macro name="locators"><choose><if type="article-journal"><choose><if variable="volume"><text variable="volume" prefix=" "/><group prefix=" (" suffix=")"><choose><if variable="issue"><text variable="issue"/></if><else><date variable="issued"><date-part name="month"/></date></else></choose></group></if><else-if variable="issue"><group delimiter=" " prefix=", "><text term="issue" form="short"/><text variable="issue"/><date variable="issued" prefix="(" suffix=")"><date-part name="month"/></date></group></else-if><else><date variable="issued" prefix=", "><date-part name="month"/></date></else></choose></if><else-if type="legal_case"><text variable="volume" prefix=", "/><text variable="container-title" prefix=" "/><text variable="page" prefix=" "/></else-if><else-if type="bill book graphic legal_case legislation motion_picture report song" match="any"><group prefix=". " delimiter=". "><group><text term="volume" form="short" text-case="capitalize-first" suffix=" "/><number variable="volume" form="numeric"/></group><group><number variable="number-of-volumes" form="numeric"/><text term="volume" form="short" prefix=" " plural="true"/></group></group></else-if><else-if type="chapter entry-dictionary entry-encyclopedia paper-conference" match="any"><choose><if variable="page" match="none"><group prefix=". "><text term="volume" form="short" text-case="capitalize-first" suffix=" "/><number variable="volume" form="numeric"/></group></if></choose></else-if></choose></macro><macro name="locators-chapter"><choose><if type="chapter entry-dictionary entry-encyclopedia paper-conference" match="any"><choose><if variable="page"><group prefix=", "><text variable="volume" suffix=":"/><text variable="page"/></group></if></choose></if></choose></macro><macro name="locators-article"><choose><if type="article-newspaper"><group prefix=", " delimiter=", "><group delimiter=" "><text variable="edition"/><text term="edition"/></group><group><text term="section" form="short" suffix=" "/><text variable="section"/></group></group></if><else-if type="article-journal"><choose><if variable="volume issue" match="any"><text variable="page" prefix=": "/></if><else><text variable="page" prefix=", "/></else></choose></else-if></choose></macro><macro name="point-locators"><choose><if variable="locator"><choose><if locator="page" match="none"><choose><if type="bill book graphic legal_case legislation motion_picture report song" match="any"><choose><if variable="volume"><group><text term="volume" form="short" suffix=" "/><number variable="volume" form="numeric"/><label variable="locator" form="short" prefix=", " suffix=" "/></group></if><else><label variable="locator" form="short" suffix=" "/></else></choose></if><else><label variable="locator" form="short" suffix=" "/></else></choose></if><else-if type="bill book graphic legal_case legislation motion_picture report song" match="any"><number variable="volume" form="numeric" suffix=":"/></else-if></choose><text variable="locator"/></if></choose></macro><macro name="container-prefix"><text term="in" text-case="capitalize-first"/></macro><macro name="container-title"><choose><if type="chapter entry-dictionary entry-encyclopedia paper-conference" match="any"><text macro="container-prefix" suffix=" "/></if></choose><choose><if type="webpage"><text variable="container-title" text-case="title"/></if><else-if type="legal_case" match="none"><group delimiter=" "><text variable="container-title" text-case="title" font-style="italic"/><choose><if type="post-weblog"><text value="(blog)"/></if></choose></group></else-if></choose></macro><macro name="publisher"><group delimiter=": "><text variable="publisher-place"/><text variable="publisher"/></group></macro><macro name="date"><choose><if variable="issued"><group delimiter=" "><date variable="original-date" form="text" date-parts="year" prefix="(" suffix=")"/><date variable="issued"><date-part name="year"/></date></group></if><else-if variable="status"><text variable="status" text-case="capitalize-first"/></else-if><else><text term="no date" form="short"/></else></choose></macro><macro name="date-in-text"><choose><if variable="issued"><group delimiter=" "><date variable="original-date" form="text" date-parts="year" prefix="[" suffix="]"/><date variable="issued"><date-part name="year"/></date></group></if><else-if variable="status"><text variable="status"/></else-if><else><text term="no date" form="short"/></else></choose></macro><macro name="day-month"><date variable="issued"><date-part name="month"/><date-part name="day" prefix=" "/></date></macro><macro name="collection-title"><choose><if match="none" type="article-journal"><choose><if match="none" is-numeric="collection-number"><group delimiter=", "><text variable="collection-title" text-case="title"/><text variable="collection-number"/></group></if><else><group delimiter=" "><text variable="collection-title" text-case="title"/><text variable="collection-number"/></group></else></choose></if></choose></macro><macro name="collection-title-journal"><choose><if type="article-journal"><group delimiter=" "><text variable="collection-title"/><text variable="collection-number"/></group></if></choose></macro><macro name="event"><group delimiter=" "><choose><if variable="genre"><text term="presented at"/></if><else><text term="presented at" text-case="capitalize-first"/></else></choose><text variable="event"/></group></macro><macro name="description"><choose><if variable="interviewer" type="interview" match="any"><group delimiter=". "><text macro="interviewer"/><text variable="medium" text-case="capitalize-first"/></group></if><else-if type="patent"><group delimiter=" " prefix=". "><text variable="authority"/><text variable="number"/></group></else-if><else><text variable="medium" text-case="capitalize-first" prefix=". "/></else></choose><choose><if variable="title" match="none"/><else-if type="thesis personal_communication speech" match="any"/><else><group delimiter=" " prefix=". "><text variable="genre" text-case="capitalize-first"/><choose><if type="report"><text variable="number"/></if></choose></group></else></choose></macro><macro name="issue"><choose><if type="legal_case"><text variable="authority" prefix=". "/></if><else-if type="speech"><group prefix=". " delimiter=", "><group delimiter=" "><text variable="genre" text-case="capitalize-first"/><text macro="event"/></group><text variable="event-place"/><text macro="day-month"/></group></else-if><else-if type="article-newspaper article-magazine personal_communication" match="any"><date variable="issued" form="text" prefix=", "/></else-if><else-if type="patent"><group delimiter=", " prefix=", "><group delimiter=" "><text value="filed"/><date variable="submitted" form="text"/></group><group delimiter=" "><choose><if variable="issued submitted" match="all"><text term="and"/></if></choose><text value="issued"/><date variable="issued" form="text"/></group></group></else-if><else-if type="article-journal" match="any"/><else><group prefix=". " delimiter=", "><choose><if type="thesis"><text variable="genre" text-case="capitalize-first"/></if></choose><text macro="publisher"/></group></else></choose></macro><citation et-al-min="4" et-al-use-first="1" disambiguate-add-year-suffix="true" disambiguate-add-names="true" disambiguate-add-givenname="true" givenname-disambiguation-rule="primary-name" collapse="year" after-collapse-delimiter="; "><layout prefix="(" suffix=")" delimiter="; "><group delimiter=", "><choose><if variable="issued accessed" match="any"><group delimiter=" "><text macro="contributors-short"/><text macro="date-in-text"/></group></if><else><group delimiter=", "><text macro="contributors-short"/><text macro="date-in-text"/></group></else></choose><text macro="point-locators"/></group></layout></citation><bibliography hanging-indent="true" et-al-min="11" et-al-use-first="7" subsequent-author-substitute="&#8212;&#8212;&#8212;" entry-spacing="0"><sort><key macro="contributors"/><key variable="issued"/><key variable="title"/></sort><layout suffix="."><group delimiter=". "><text macro="contributors"/><text macro="date"/><text macro="title"/></group><text macro="description"/><text macro="secondary-contributors" prefix=". "/><text macro="container-title" prefix=". "/><text macro="container-contributors"/><text macro="edition"/><text macro="locators-chapter"/><text macro="collection-title-journal" prefix=", " suffix=", "/><text macro="locators"/><text macro="collection-title" prefix=". "/><text macro="issue"/><text macro="locators-article"/><text macro="access" prefix=". "/></layout></bibliography></style>',
  HD =
    '<?xml version="1.0" encoding="utf-8"?><style xmlns="http://purl.org/net/xbiblio/csl" class="in-text" version="1.0" demote-non-dropping-particle="sort-only"><info><title>Harvard Reference format 1 (author-date)</title><id>http://www.zotero.org/styles/harvard1</id><link href="http://www.zotero.org/styles/harvard1" rel="self"/><link href="http://libweb.anglia.ac.uk/referencing/harvard.htm" rel="documentation"/><author><name>Julian Onions</name><email>julian.onions@gmail.com</email></author><category citation-format="author-date"/><category field="generic-base"/><summary>The Harvard author-date style</summary><updated>2012-09-27T22:06:38+00:00</updated><rights license="http://creativecommons.org/licenses/by-sa/3.0/">This work is licensed under a Creative Commons Attribution-ShareAlike 3.0 License</rights></info><macro name="editor"><names variable="editor" delimiter=", "><name and="symbol" initialize-with=". " delimiter=", "/><label form="short" prefix=", " text-case="lowercase"/></names></macro><macro name="anon"><text term="anonymous" form="short" text-case="capitalize-first" strip-periods="true"/></macro><macro name="author"><names variable="author"><name name-as-sort-order="all" and="symbol" sort-separator=", " initialize-with="." delimiter-precedes-last="never" delimiter=", "/><label form="short" prefix=" " text-case="lowercase"/><substitute><names variable="editor"/><text macro="anon"/></substitute></names></macro><macro name="author-short"><names variable="author"><name form="short" and="symbol" delimiter=", " delimiter-precedes-last="never" initialize-with=". "/><substitute><names variable="editor"/><names variable="translator"/><text macro="anon"/></substitute></names></macro><macro name="access"><choose><if variable="URL"><text value="Available at:" suffix=" "/><text variable="URL"/><group prefix=" [" suffix="]"><text term="accessed" text-case="capitalize-first" suffix=" "/><date variable="accessed"><date-part name="month" suffix=" "/><date-part name="day" suffix=", "/><date-part name="year"/></date></group></if></choose></macro><macro name="title"><choose><if type="bill book graphic legal_case legislation motion_picture report song thesis" match="any"><text variable="title" font-style="italic"/></if><else><text variable="title"/></else></choose></macro><macro name="publisher"><group delimiter=": "><text variable="publisher-place"/><text variable="publisher"/></group></macro><macro name="year-date"><choose><if variable="issued"><date variable="issued"><date-part name="year"/></date></if><else><text term="no date" form="short"/></else></choose></macro><macro name="edition"><choose><if is-numeric="edition"><group delimiter=" "><number variable="edition" form="ordinal"/><text term="edition" form="short"/></group></if><else><text variable="edition" suffix="."/></else></choose></macro><macro name="pages"><group><label variable="page" form="short" suffix=" "/><text variable="page"/></group></macro><citation et-al-min="3" et-al-use-first="1" disambiguate-add-year-suffix="true" disambiguate-add-names="true" disambiguate-add-givenname="true"><layout prefix="(" suffix=")" delimiter="; "><group delimiter=", "><group delimiter=" "><text macro="author-short"/><text macro="year-date"/></group><group><label variable="locator" form="short"/><text variable="locator"/></group></group></layout></citation><bibliography hanging-indent="true" et-al-min="4" et-al-use-first="1"><sort><key macro="author"/><key variable="title"/></sort><layout><text macro="author" suffix=","/><date variable="issued" prefix=" " suffix="."><date-part name="year"/></date><choose><if type="bill book graphic legal_case legislation motion_picture report song" match="any"><group prefix=" " delimiter=" " suffix=","><text macro="title"/><text macro="edition"/><text macro="editor"/></group><text prefix=" " suffix="." macro="publisher"/></if><else-if type="chapter paper-conference" match="any"><text macro="title" prefix=" " suffix="."/><group prefix=" " delimiter=" "><text term="in" text-case="capitalize-first"/><text macro="editor"/><text variable="container-title" font-style="italic" suffix="."/><text variable="collection-title" suffix="."/><text variable="event" suffix="."/><group suffix="." delimiter=", "><text macro="publisher" prefix=" "/><text macro="pages"/></group></group></else-if><else-if type="thesis"><group prefix=" " suffix="." delimiter=". "><text macro="title"/><text variable="genre"/><text macro="publisher"/></group></else-if><else><group suffix="."><text macro="title" prefix=" "/><text macro="editor" prefix=" "/></group><group prefix=" " suffix="."><text variable="container-title" font-style="italic"/><group prefix=", "><text variable="volume"/><text variable="issue" prefix="(" suffix=")"/></group><group prefix=", "><label variable="page" form="short"/><text variable="page"/></group></group></else></choose><text prefix=" " macro="access" suffix="."/></layout></bibliography></style>',
  zD =
    '<?xml version="1.0" encoding="utf-8"?><style xmlns="http://purl.org/net/xbiblio/csl" class="in-text" version="1.0" demote-non-dropping-particle="sort-only" page-range-format="minimal"><info><title>Vancouver</title><id>http://www.zotero.org/styles/vancouver</id><link href="http://www.zotero.org/styles/vancouver" rel="self"/><link href="http://www.nlm.nih.gov/bsd/uniform_requirements.html" rel="documentation"/><author><name>Michael Berkowitz</name><email>mberkowi@gmu.edu</email></author><contributor><name>Sean Takats</name><email>stakats@gmu.edu</email></contributor><contributor><name>Sebastian Karcher</name></contributor><category citation-format="numeric"/><category field="medicine"/><summary>Vancouver style as outlined by International Committee of Medical Journal Editors Uniform Requirements for Manuscripts Submitted to Biomedical Journals: Sample References</summary><updated>2014-09-06T16:03:01+00:00</updated><rights license="http://creativecommons.org/licenses/by-sa/3.0/">This work is licensed under a Creative Commons Attribution-ShareAlike 3.0 License</rights></info><locale xml:lang="en"><date form="text" delimiter=" "><date-part name="year"/><date-part name="month" form="short" strip-periods="true"/><date-part name="day"/></date><terms><term name="collection-editor" form="long"><single>editor</single><multiple>editors</multiple></term><term name="presented at">presented at</term><term name="available at">available from</term><term name="section" form="short">sect.</term></terms></locale><locale xml:lang="fr"><date form="text" delimiter=" "><date-part name="day"/><date-part name="month" form="short" strip-periods="true"/><date-part name="year"/></date></locale><macro name="author"><names variable="author"><name sort-separator=" " initialize-with="" name-as-sort-order="all" delimiter=", " delimiter-precedes-last="always"/><label form="long" prefix=", "/><substitute><names variable="editor"/></substitute></names></macro><macro name="editor"><names variable="editor" suffix="."><name sort-separator=" " initialize-with="" name-as-sort-order="all" delimiter=", " delimiter-precedes-last="always"/><label form="long" prefix=", "/></names></macro><macro name="chapter-marker"><choose><if type="chapter paper-conference entry-dictionary entry-encyclopedia" match="any"><text term="in" text-case="capitalize-first"/></if></choose></macro><macro name="publisher"><choose><if type="article-journal article-magazine article-newspaper" match="none"><group delimiter=": " suffix=";"><choose><if type="thesis"><text variable="publisher-place" prefix="[" suffix="]"/></if><else-if type="speech"/><else><text variable="publisher-place"/></else></choose><text variable="publisher"/></group></if></choose></macro><macro name="access"><choose><if variable="URL"><group delimiter=": "><text term="available at" text-case="capitalize-first"/><text variable="URL"/></group></if></choose></macro><macro name="accessed-date"><choose><if variable="URL"><group prefix="[" suffix="]" delimiter=" "><text term="cited" text-case="lowercase"/><date variable="accessed" form="text"/></group></if></choose></macro><macro name="container-title"><choose><if type="article-journal article-magazine chapter paper-conference article-newspaper review review-book entry-dictionary entry-encyclopedia" match="any"><group suffix="." delimiter=" "><choose><if type="article-journal review review-book" match="any"><text variable="container-title" form="short" strip-periods="true"/></if><else><text variable="container-title" strip-periods="true"/></else></choose><choose><if variable="URL"><text term="internet" prefix="[" suffix="]" text-case="capitalize-first"/></if></choose></group><text macro="edition" prefix=" "/></if><else-if type="bill legislation" match="any"><group delimiter=", "><group delimiter=". "><text variable="container-title"/><group delimiter=" "><text term="section" form="short" text-case="capitalize-first"/><text variable="section"/></group></group><text variable="number"/></group></else-if><else-if type="speech"><group delimiter=": " suffix=";"><group delimiter=" "><text variable="genre" text-case="capitalize-first"/><text term="presented at"/></group><text variable="event"/></group></else-if><else><group delimiter=", " suffix="."><choose><if variable="collection-title" match="none"><group delimiter=" "><label variable="volume" form="short" text-case="capitalize-first"/><text variable="volume"/></group></if></choose><text variable="container-title"/></group></else></choose></macro><macro name="title"><text variable="title"/><choose><if type="article-journal article-magazine chapter paper-conference article-newspaper review review-book entry-dictionary entry-encyclopedia" match="none"><choose><if variable="URL"><text term="internet" prefix=" [" suffix="]" text-case="capitalize-first"/></if></choose><text macro="edition" prefix=". "/></if></choose><choose><if type="thesis"><text variable="genre" prefix=" [" suffix="]"/></if></choose></macro><macro name="edition"><choose><if is-numeric="edition"><group delimiter=" "><number variable="edition" form="ordinal"/><text term="edition" form="short"/></group></if><else><text variable="edition" suffix="."/></else></choose></macro><macro name="date"><choose><if type="article-journal article-magazine article-newspaper review review-book" match="any"><group suffix=";" delimiter=" "><date variable="issued" form="text"/><text macro="accessed-date"/></group></if><else-if type="bill legislation" match="any"><group delimiter=", "><date variable="issued" delimiter=" "><date-part name="month" form="short" strip-periods="true"/><date-part name="day"/></date><date variable="issued"><date-part name="year"/></date></group></else-if><else-if type="report"><date variable="issued" delimiter=" "><date-part name="year"/><date-part name="month" form="short" strip-periods="true"/></date><text macro="accessed-date" prefix=" "/></else-if><else-if type="patent"><group suffix="."><group delimiter=", "><text variable="number"/><date variable="issued"><date-part name="year"/></date></group><text macro="accessed-date" prefix=" "/></group></else-if><else-if type="speech"><group delimiter="; "><group delimiter=" "><date variable="issued" delimiter=" "><date-part name="year"/><date-part name="month" form="short" strip-periods="true"/><date-part name="day"/></date><text macro="accessed-date"/></group><text variable="event-place"/></group></else-if><else><group suffix="."><date variable="issued"><date-part name="year"/></date><text macro="accessed-date" prefix=" "/></group></else></choose></macro><macro name="pages"><choose><if type="article-journal article-magazine article-newspaper review review-book" match="any"><text variable="page" prefix=":"/></if><else-if type="book" match="any"><text variable="number-of-pages" prefix=" "/><choose><if is-numeric="number-of-pages"><label variable="number-of-pages" form="short" prefix=" " plural="never"/></if></choose></else-if><else><group prefix=" " delimiter=" "><label variable="page" form="short" plural="never"/><text variable="page"/></group></else></choose></macro><macro name="journal-location"><choose><if type="article-journal article-magazine review review-book" match="any"><text variable="volume"/><text variable="issue" prefix="(" suffix=")"/></if></choose></macro><macro name="collection-details"><choose><if type="article-journal article-magazine article-newspaper review review-book" match="none"><choose><if variable="collection-title"><group delimiter=" " prefix="(" suffix=")"><names variable="collection-editor" suffix="."><name sort-separator=" " initialize-with="" name-as-sort-order="all" delimiter=", " delimiter-precedes-last="always"/><label form="long" prefix=", "/></names><group delimiter="; "><text variable="collection-title"/><group delimiter=" "><label variable="volume" form="short"/><text variable="volume"/></group></group></group></if></choose></if></choose></macro><macro name="report-details"><choose><if type="report"><text variable="number" prefix="Report No.: "/></if></choose></macro><citation collapse="citation-number"><sort><key variable="citation-number"/></sort><layout prefix="(" suffix=")" delimiter=","><text variable="citation-number"/></layout></citation><bibliography et-al-min="7" et-al-use-first="6" second-field-align="flush"><layout><text variable="citation-number" suffix=". "/><group delimiter=". " suffix=". "><text macro="author"/><text macro="title"/></group><group delimiter=" " suffix=". "><group delimiter=": "><text macro="chapter-marker"/><group delimiter=" "><text macro="editor"/><text macro="container-title"/></group></group><text macro="publisher"/><group><text macro="date"/><text macro="journal-location"/><text macro="pages"/></group></group><text macro="collection-details" suffix=". "/><text macro="report-details" suffix=". "/><text macro="access"/></layout></bibliography></style>',
  Cu = Js.plugins.config.get('@csl')
Cu.templates.add('vancouver', zD)
Cu.templates.add('harvard1', HD)
Cu.templates.add('mla', MD)
Cu.templates.add('chicago', UD)
const jD = XN(Js)
function es({ markdown: e, rehypeCitationOptions: t }) {
  return (
    Tn.useEffect(() => {
      AE()
        .use(wT)
        .use(LS)
        .use(T2, {})
        .use(jD, t)
        .use(FC)
        .process(e)
        .then((r) => {
          document.getElementById('results').innerHTML = r
        })
    }, [e, t]),
    $e.jsx('div', {
      children: $e.jsxs('div', {
        className: 'flex lg:space-x-12 flex-col lg:flex-row',
        children: [
          $e.jsxs('div', {
            className: 'mt-8 lg:max-w-[600px]',
            children: [
              $e.jsx('h2', { className: 'text-2xl mb-2', children: 'Markdown text' }),
              $e.jsx('div', {
                className:
                  'pb-4 font-mono text-sm overflow-auto whitespace-pre bg-gray-800 text-white rounded p-4',
                id: 'markdown',
                children: e,
              }),
              $e.jsx('h2', { className: 'text-2xl mt-4 mb-2', children: 'Settings' }),
              $e.jsx('div', {
                className: 'pb-4 bg-gray-200 whitespace-pre overflow-auto rounded p-4',
                id: 'markdown',
                children: JSON.stringify(t, null, 2),
              }),
            ],
          }),
          $e.jsxs('div', {
            className: 'mt-4 lg:mt-8',
            children: [
              $e.jsx('h2', { className: 'text-2xl mb-2', children: 'Result' }),
              $e.jsx('div', {
                className:
                  'prose pb-4 marker:text-black bg-blue-100 rounded p-4 prose-a:text-gray-800 hover:prose-a:text-gray-600 prose-a:no-underline',
                id: 'results',
                children: 'processing markdown...',
              }),
            ],
          }),
        ],
      }),
    })
  )
}
const qD = `## Welcome

Rehype plugin to nicely format citations in markdown
documents and insert bibliography in html format.

- Supports standard citations [@Nash1950{pp. iv, vi-xi, (xv)-(xvii)}];
- in-text citations, @Nash1951 [p. 33] says blah;
- and multiple citations [see @Nash1950 pp 12-13; @Nash1951]

Customizable CSL and locale.

### Bibliography
`,
  $D = `## Welcome

Rehype plugin to nicely format citations in markdown
documents and insert bibliography in html format.

- Supports standard citations [@Nash1950{pp. iv, vi-xi, (xv)-(xvii)}];
- in-text citations, @Nash1951 [p. 33] says blah;
- and multiple citations [see @Nash1950 pp 12-13; @Nash1951]

Customizable CSL and locale.
`,
  VD = `## Welcome

Choose from one of the multiple preconfigured CSLs[^1]
[^1]: apa, vancouver, harvard1, chicago, mla

or pass in a valid file path or url to the _csl_ argument.

Here's an example in ACM format:

- Supports standard citations [@Nash1950{pp. iv, vi-xi, (xv)-(xvii)}];
- You probably don't want in-text citation with a note style;
- and multiple citations [see @Nash1950 pp 12-13; @Nash1951]

### References
`,
  GD = `## Welcome

The plugin also works with Github formatted footnotes
from remarkgfm and automatically merges user content with citations.[^1]

[^1]: There's no guarantee it works with other footnote formats since
it searches for specific ids and hrefs added by GFM

Here's an example in Chicago fullnote style:

- Supports standard citations[@Nash1950{pp. iv, vi-xi, (xv)-(xvii)}];
- Avoid in-text citations for footnote citations;
- and multiple citations[see @Nash1950 pp 12-13; @Nash1951]

### References
`,
  XD = `## Welcome

Rehype plugin to nicely format citations in markdown
documents and insert bibliography in html format.

- Supports standard citations [@Nash1950{pp. iv, vi-xi, (xv)-(xvii)}];
- in-text citations, @Nash1951 [p. 33] says blah;
- and multiple citations [see @Nash1950 pp 12-13; @Nash1951]

The _link-citations_ option can be used to add a link from citations to the references sections.

This applies to numeric and author-date styles only.

Implementation might differ from Pandoc, but if you run into any problems please file an issue.

### Bibliography
`,
  ts = 'https://raw.githubusercontent.com/timlrx/rehype-citation/main/test/references-data.bib',
  YD =
    'https://raw.githubusercontent.com/citation-style-language/styles/master/acm-sig-proceedings.csl',
  WD =
    'https://raw.githubusercontent.com/citation-style-language/styles/master/chicago-fullnote-bibliography.csl',
  Ar = ['Default', 'Suppress Bibliography', 'Custom CSL', 'Footnote Style', 'Link Citations'],
  kd = Ar.map((e) => e.toLocaleLowerCase().replace(' ', '-'))
function QD() {
  Tn.useEffect(() => {
    const r = kd.find((i) => i === window.location.pathname.slice(1))
    t(r ? Ar[kd.indexOf(r)] : Ar[0])
  }, [])
  const [e, t] = Tn.useState()
  return $e.jsx($e.Fragment, {
    children: $e.jsxs('div', {
      className: 'mx-6 pt-12 lg:pl-12 mb-12',
      children: [
        $e.jsx('h1', { className: 'text-4xl font-bold', children: 'Rehype Citation' }),
        $e.jsx('div', {
          className: 'mt-8 space-x-4 space-y-2',
          children: Ar.map((r) =>
            $e.jsx(
              'button',
              {
                onClick: () => {
                  window.history.pushState({}, '', r.toLowerCase().replace(' ', '-')), t(r)
                },
                className: `${
                  e === r && 'bg-gradient-to-r from-purple-400 to-yellow-400'
                } px-4 py-2 text-sm font-bold bg-indigo-100 rounded`,
                children: r,
              },
              r
            )
          ),
        }),
        e === Ar[0] && $e.jsx(es, { markdown: qD, rehypeCitationOptions: { bibliography: ts } }),
        e === Ar[1] &&
          $e.jsx(es, {
            markdown: $D,
            rehypeCitationOptions: { bibliography: ts, suppressBibliography: !0 },
          }),
        e === Ar[2] &&
          $e.jsx(es, { markdown: VD, rehypeCitationOptions: { bibliography: ts, csl: YD } }),
        e === Ar[3] &&
          $e.jsx(es, { markdown: GD, rehypeCitationOptions: { bibliography: ts, csl: WD } }),
        e === Ar[4] &&
          $e.jsx(es, {
            markdown: XD,
            rehypeCitationOptions: { bibliography: ts, linkCitations: !0 },
          }),
      ],
    }),
  })
}
aE.render($e.jsx(Wy.StrictMode, { children: $e.jsx(QD, {}) }), document.getElementById('root'))
